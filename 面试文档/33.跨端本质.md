## [跨端技术的本质与现状](https://mp.weixin.qq.com/s/XO4LIvglk2wrMT-Vjd6rkA)
## 1. 主流方案
> 1. <font color="red">H5 hybrid 方案</font>： 浏览器本身就是一个跨端得实现方案。如果我们把浏览器嵌入APP中， 再将地址栏等内容隐藏， 是不是就能将我们得网页嵌入到原生得APP中了
> 2. 而整个嵌入APP得浏览器我们称之为`webview`
> 3. <font color="red">框架层+原生渲染</font>：最典型的是`react-native`，组件最终都会被渲染为原生组件
> 4. <font color="red">框架层+自渲染引擎</font>：最典型的是`flutter`，它并没有直接接用原生能力去渲染组件，而是利用了更底层的渲染能力，自己去渲染组件，这种方式，会比上述的方案的链路更短，性能也会更好
> 5. <font color="red">另类跨端</font>：如小程序

## React-native 实现分析
![](https://mmbiz.qpic.cn/mmbiz_png/3xDuJ3eiciblnSuuXtDd9YR5Dax7ibLusLoeNPxBxupC4I6vLOYuIt6lHOS26IMctA2BOnjG87lUcLgO1wB0jYKvQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
1. rn包括三个线程
> 1. native thread: 主要负责原生渲染和调用原生能力
> 2. js thread: JS线程用于解释和执行我们的JS代码
> 3. shadow thread: 要渲染到界面上一个很重要的步骤就是布局，我们需要知道每个组件应该渲染到什么位置，这个过程就是通过yoga去实现的，这是一个基于flexbox的跨平台布局引擎

2. 初始化流程
> 1. native 启动一个原生界面，比如android会起一个新的activity来承载rn，并做一些初始化的操作
> 2. 加载 js 引擎，运行 js 代码，此时的流程和 react 的启动流程就非常相似了，我们先简单观察调用栈
> 3. js 线程通知shadow thread。在react中，走到createInstance以后我们就可以直接调用createElement来创建真实结点了，但是在rn中我们没办法做到这一步，所以我们会通知native层让它来帮助我们创建一个对应的真实结点
> 4. shadow thread 计算布局，通知native Thread 创建原生组件。
> 5. native 在界面上渲染原生组件，呈现给用户。

3. 特点
> 1. native thread监听到了滚动事件，发送消息通知js thread
> 2. js thread 处理滚动事件，如果需要修改 state 需要经过一层js diff，拿到最终需要更新的结点
> 3. js thread 通知 shadow thread
> 4. shadow thread 通知 native 渲染
> 5. 当用户操作过快的时候，就会导致界面来不及更新，进而导致在快速滑动的时候会出现白屏、卡顿的现象。

## 从RN 看本质
