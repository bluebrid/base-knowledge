
## [前端性能监控指标](https://github.com/Godiswill/blog/issues/19)
![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0dvZGlzd2lsbC9ibG9nL21hc3Rlci8wOCVFNSU4OSU4RCVFNyVBQiVBRiVFNSVCNyVBNSVFNyVBOCU4QiVFNSU4QyU5Ni90aW1lc3RhbXAtZGlhZ3JhbS5qcGc?x-oss-process=image/format,png)
关键性指标：
1. firstbyte(首包时间) esponseStart - domainLookupStart
2. fpt(First paint time 首次渲染时间，白屏时间) responseEnd - fetchStart
3. tti(time to interact, 首次可以交互的时间) domInteractive - fetchStart 
4. ready（HTML加载完成时间，也就是Dom Ready 时间） domContentLoadedEventEnd - fetchStart
5. load (页面完成加载时间)
计算方法
```javascript
const t = performance.timing;
const pageloadtime = t.loadEventStart - t.navigationStart,
  dns = t.domainLookupEnd - t.domainLookupStart,
  tcp = t.connectEnd - t.connectStart,
  ttfb = t.responseStart - t.navigationStart;
```

```javascript
const pageNav = performance.getEntriesByType('navigation')[0];
```

### 数据上报
1. 一般考虑再页面卸载`unload`时准备上报， 这个时间点时不会干扰用户再当前页的操作
2. 但是如果上报时间很长，会影响用户跳转到下一页面的体验，可以使用`navigator.sendBeacon`
```javascript
window.addEventListener('unload', function() {
  // 注意 performance.getEntries 会取当前页所有资源包括页面本身的性能信息
  // 注意 数据体量问题
  let rumData = new FormData();
  rumData.append('entries', JSON.stringify(performance.getEntries()));

  // 是否支持
  if('sendBeacon' in navigator) {
    // Beacon 发起请求
    if(navigator.sendBeacon(endpoint, rumData)) {
      // sendBeacon 发送成功
    } else {
      // sendBeacon 发送失败! 使用 XHR or fetch 代替
    }
  } else {
    // sendBeacon 不支持! 使用 XHR or fetch 代替
  }
}, false);
```
3. 传统的做法，还有:
> 1. 在unload 中调用ajax 来发送数据
> 2. 传教一个长宽1px的img src 来发送请求
> 3. setTimeout(ajax, 0)放在异步中
但是上面`navigation.sendBeacon`都能解决

## [可视化性能分析](https://github.com/Godiswill/blog/issues/24)