## [深入浅出 npm & yarn & pnpm 包管理机制](https://mp.weixin.qq.com/s/X6eehnbs055Gmiw56Zs_DA)
1. NPM 问题
> 1. 嵌套的`node_module`结构， 会造成相同的依赖多次安装
> 2. 依赖地狱`dependency hell`:依赖增加，冗余包也会增加，占用大量的磁盘
> 3. NPM V3, 将嵌套依赖，改成了扁平的结构，但是还是存在如下问题：
> 3.1 幽灵依赖：也就是依赖在package.json 中没有定义，但是项目中依然能够引用对应的模块，而且不报错，如果某天，某个模块不在依赖对应的包，但是在我们的代码中还是依赖了对应的包，就会报错
> 3.2 不确定性： 不同的包，依赖相同包的不同版本， 会造成生产环境和开发环境的包其实不一样，造成线上代码无法运行的问题（<font color=red>两个不同的包A，B依赖同一个包C的不同的版本， 最终可能会造成C版本在线上的不一致，因为取决于安装的先后顺序</font>）
> 4. 依赖分身： 不同的包，依赖同一个包的不同的版本， 会造成依赖包的多次安装（<font color=red></font>）
> 5. NPM 安装包是<font color=red>串行的</font>,`yarn`是<font color=red>并行的</font>
2. Yarn
> 1. yarn 最大的贡献就是`yarn.lock`，记录了依赖，以及依赖的子版本， 以及获取地址与模块的完整性的hash
> 2. yarn 同样没有解决<font color=red>幽灵依赖</font>，<font color=red>依赖分身</font>的问题
> 3. yarn 提升了安装速度， 安装任务是按照<font color=red>并行操作</font>
3. PNPM
> 1. PNPM 定义为:快速，节省磁盘空间的包管理工具
> 2. 与NPM，yarn 的依赖提升和扁平化管理Node_module不同， pnpm 引入了一套依赖管理策略: <font color=red>内容寻址存储</font>
> 3. 将包安装在全局的<font color=red>store</font>中，依赖的每个版本都只会安装一次
> 4. 在引用`node_module`依赖时，会通过<font color=red>硬链接（hard lind）和 符号链接(symbolic link)</font>在全局的store找到这个文件
> 4.1 硬链接： 可以理解为<font color=red>文件副本</font>：它使得用户可以通过路径引用查找到全局store的源文件，这个副本不占用任何空间，pnpm会在全局store中存储硬链接地址
> 4.2 符号链接：可以理解为<font color=red>快捷方式</font>
> 5. 在node_module目录下，会多出`.pnpm`目录，并且是非扁平化结构
> 6. 解决问题：
> 6.1 非平铺结构，解决了<font color=red>幽灵依赖问题</font>（只有直接依赖才会平铺，子依赖不会提升）
> 6.2 全局管理包，同一个包只安排一次，解决了<font color=red>依赖分身问题</font>
> 7. 存在问题：
> 7.1 因为是通过<font color=red>依赖软连接</font>，对于不支持软连接的环境，则无法使用，存在<font color=red>系统兼容性问题</font>
> 7.2 因为是安装在全局store中， 给依赖打补丁，可能会存在问题， 影响其他的项目
## [字节的一个小问题 npm 和 yarn不一样吗](https://juejin.cn/post/7060844948316225572?share_token=c36973a3-1d1f-4f69-be6d-6adc8b4fad92)
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fbc0e4e27c14500a2a9e4fcf4757fae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1630:0:0:0.awebp?)
## npm
1. NPM 在2.0的版本的时候，依赖包是通过嵌套方式来进行处理（文件目录太长，可能会导致Window都不能删除文件）
2. 文件依赖，可能会存在大量的重复的安装
3. NPM3.x和yarn 采用的是扁平方式处理依赖
## yarn解决的问题
1. 之前的NPM版本， 没用package-lock.json机制，也就是不会进行<font size=5 color="red">版本锁定</font>，会出现很多问题,
2. <font size=5 color="red">采用模块扁平化的安装方式：</font> 将不同版本的依赖包,按照一定的策略，归结为单个版本;以避免创建多个版本造成工程的冗余(目前版本的npm也有相同的优化)
3.  <font size=5 color="red">网络性能更好：</font>yarn采用了<font color="red">请求排队的理念</font>,类似于并发池连接,能够更好的利用网络资源;同时也引入了一种安装失败的重试机制
4.  <font size=5 color="red">采用缓存机制,实现了离线模式</font>(目前的NPM也有类似的实现机制)
5.  <font size=5 color="red">相比于npm,Yarn另一个显著的区别就是yarn.lock的子依赖的版本不是固定的版本</font>

## yarn 的安装机制
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a25fa69736e4f0aacee1372476ece5c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1630:0:0:0.awebp?)

## [pnpm](https://juejin.cn/post/7098637533646422024?share_token=757bb462-b400-45bd-8342-e6235f96c782)
1. pnpm 运行起来非常的快
2. pnpm 采用一中巧妙的方式，利用<font color="red">硬链接和符号链接</font>，避免复制所有本地缓存源文件，这是yarn的最大的性能弱点之一。
3. pnpm 可以创建一个<font color=red>workspace</font>,将多个项目合并到一个项目中，一个workspace 的根目录下必须有<font color=red>pnpm-workspace.yaml</font>文件，常见的`pnpm-workspace.yaml`类似如下的配置，可以定义哪些文件或者文件夹应该包含于`workspace`中：
```yaml
packages:
  # all packages in subdirs of packages/ and components/
  - 'packages/**'
  - 'components/**'
  # exclude packages that are inside test directories
  - '!**/test/**'

```
Vue 的配置如下：
```yaml
packages:
  - 'packages/*'
```
4. workspace: 协议:
> 1. pnpm 支持`workspace:`协议，当使用这个协议的时候，pnpm 只会解析本地`workspace`中的包，
引用方式如下：
```
"@vue/reactivity": "workspace:*",
"@vue/runtime-core": "workspace:*",
"@vue/runtime-dom": "workspace:*",
```
<font >
当需要发布包时，例如使用 pnpm pack 或者 pnpm publish 命令时，将动态的把 workspace: 协议替换为真正的版本号

## [NPM 的安装机制](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22)
1. 发出`npm install`命令
2. 先在`node_module`目录中查找是否存在该模块
3. 如果存在则不重新安装
4. 如果不存在，则从`register`查询模块压缩包的网站
5. 下载压缩包，存在根目录的`.npm`目录下
6. 解压压缩包到当前目录的`node_module`目录
## NPM 运行机制
1. 安装Node之后， 会同时安装NPM， 安装目录`C:\Users\userName\AppData\Roaming\npm`,并且配置在系统`path`中
2. 首先会执行工程自身的`preinstall` Hooks
3. 确定首层依赖关系，也就是`dependencies`和`devDependencies`属性中直接指定的模块
4. 获取模块
   > 1. 先获取模块信息，包括其版本信息
   > 2. 从`Register`中获取模块实体（npm 会检查本地缓存，缓存有，就直接从缓存中获取，否则从远程Register 进行下载）
   > 3. 查找相互依赖的模块
5. 模块扁平化(dedupe)
   > 1. 在第四步，可能包括大量重复模块，会存在重复的下载过程
   > 2. `npm3`开始默认加入了一个`dedupe`的过程，它会遍历所有的节点， 逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有重复模块时，则将其丢弃。
6. 安装模块，也就是将下载的模块解压到工程项目的`node_modules`中，并且执行模块中的生命周期函数
7. 执行工程中的生命周期Hook（按照: install->postinstall->prepublish-> prepare顺序）

