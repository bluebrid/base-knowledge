## [字节的一个小问题 npm 和 yarn不一样吗](https://juejin.cn/post/7060844948316225572?share_token=c36973a3-1d1f-4f69-be6d-6adc8b4fad92)
![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4fbc0e4e27c14500a2a9e4fcf4757fae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1630:0:0:0.awebp?)
## npm
1. NPM 在2.0的版本的时候，依赖包是通过嵌套方式来进行处理（文件目录太长，可能会导致Window都不能删除文件）
2. 文件依赖，可能会存在大量的重复的安装
3. NPM3.x和yarn 采用的是扁平方式处理依赖
## yarn解决的问题
1. 之前的NPM版本， 没用package-lock.json机制，也就是不会进行<font size=5 color="red">版本锁定</font>，会出现很多问题,
2. <font size=5 color="red">采用模块扁平化的安装方式：</font> 将不同版本的依赖包,按照一定的策略，归结为单个版本;以避免创建多个版本造成工程的冗余(目前版本的npm也有相同的优化)
3.  <font size=5 color="red">网络性能更好：</font>yarn采用了<font color="red">请求排队的理念</font>,类似于并发池连接,能够更好的利用网络资源;同时也引入了一种安装失败的重试机制
4.  <font size=5 color="red">采用缓存机制,实现了离线模式</font>(目前的NPM也有类似的实现机制)
5.  <font size=5 color="red">相比于npm,Yarn另一个显著的区别就是yarn.lock的子依赖的版本不是固定的版本</font>

## yarn 的安装机制
![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a25fa69736e4f0aacee1372476ece5c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1630:0:0:0.awebp?)

## [pnpm](https://juejin.cn/post/7098637533646422024?share_token=757bb462-b400-45bd-8342-e6235f96c782)
1. pnpm 运行起来非常的快
2. pnpm 采用一中巧妙的方式，利用<font color="red">硬链接和符号链接</font>，避免复制所有本地缓存源文件，这是yarn的最大的性能弱点之一。
3. pnpm 可以创建一个<font color=red>workspace</font>,将多个项目合并到一个项目中，一个workspace 的根目录下必须有<font color=red>pnpm-workspace.yaml</font>文件，常见的`pnpm-workspace.yaml`类似如下的配置，可以定义哪些文件或者文件夹应该包含于`workspace`中：
```yaml
packages:
  # all packages in subdirs of packages/ and components/
  - 'packages/**'
  - 'components/**'
  # exclude packages that are inside test directories
  - '!**/test/**'

```
Vue 的配置如下：
```yaml
packages:
  - 'packages/*'
```
4. workspace: 协议:
> 1. pnpm 支持`workspace:`协议，当使用这个协议的时候，pnpm 只会解析本地`workspace`中的包，
引用方式如下：
```
"@vue/reactivity": "workspace:*",
"@vue/runtime-core": "workspace:*",
"@vue/runtime-dom": "workspace:*",
```
<font >
当需要发布包时，例如使用 pnpm pack 或者 pnpm publish 命令时，将动态的把 workspace: 协议替换为真正的版本号

## [NPM 的安装机制](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22)
1. 发出`npm install`命令
2. 先在`node_module`目录中查找是否存在该模块
3. 如果存在则不重新安装
4. 如果不存在，则从`register`查询模块压缩包的网站
5. 下载压缩包，存在根目录的`.npm`目录下
6. 解压压缩包到当前目录的`node_module`目录
## NPM 运行机制
1. 安装Node之后， 会同时安装NPM， 安装目录`C:\Users\userName\AppData\Roaming\npm`,并且配置在系统`path`中
2. 首先会执行工程自身的`preinstall` Hooks
3. 确定首层依赖关系，也就是`dependencies`和`devDependencies`属性中直接指定的模块
4. 获取模块
   > 1. 先获取模块信息，包括其版本信息
   > 2. 从`Register`中获取模块实体（npm 会检查本地缓存，缓存有，就直接从缓存中获取，否则从远程Register 进行下载）
   > 3. 查找相互依赖的模块
5. 模块扁平化(dedupe)
   > 1. 在第四步，可能包括大量重复模块，会存在重复的下载过程
   > 2. `npm3`开始默认加入了一个`dedupe`的过程，它会遍历所有的节点， 逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有重复模块时，则将其丢弃。
6. 安装模块，也就是将下载的模块解压到工程项目的`node_modules`中，并且执行模块中的生命周期函数
7. 执行工程中的生命周期Hook（按照: install->postinstall->prepublish-> prepare顺序）

