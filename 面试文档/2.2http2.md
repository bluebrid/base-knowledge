
<font size=5 color=red>启动Demo需要用https协议： https://localhost:3001</font>
## [HTTP2 详解](https://juejin.im/post/5b88a4f56fb9a01a0b31a67e)
   [解密HTTP/2与HTTP/3 的新特性](https://juejin.im/post/5d9abde7e51d4578110dc77f?utm_source=gold_browser_extension)
### HTTP1.1 存在问题
1. TCP连接限制

>对于浏览器同一个域名，**同时** 只能创建6-8个TCP连接(不同的浏览器不一样), 为了解决这个问题，出现了**域名分片**技术，也就是资源放在不同的域名下(比如二级域名)， 造成的新的问题是: DNS查询，三次握手，占用CPU等减速的问题，而且对于服务器来说，过多的连接也容易造成网络拥挤，交通堵塞的问题

2. 线头阻塞问题

> 所谓的线头阻塞，就是：基于每一个TCP连接只能处理一个请求，浏览器按照先进先出的原理处理请求，如果上一个响应没有及时返回，后续的所有的请求都会被阻塞。

3. 请求头部Header 过多问题

> 每一次的请求的请求头部信息不会变化太多，但是每次请求都会携带所有的请求头部信息

4. 为了尽量减少请求，我们需要做文件合并，雪碧图，资源内联等优化工作，但是这无疑造成了单个请求内容变大，延时变高的问题，而且内嵌资源不能有效使用缓存机制

5. 明文传输不安全

### HTTP2.0 的优势

1. 二进制分帧层
> 在http1.0的时候，数据都是明文传输，2.0 是二进制传输
2. 多路复用
> 1. 多路复用很好的解决了浏览器限制同一个域名下请求数量的问题，
> 2. 同个域名只需要占用一个 TCP 连接，使用一个连接<font color="red">并行发送多个请求和响应</font>,这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽所带来的问题。
并行交错地发送多个请求/响应，请求/响应之间互不影响。
> 3. <font color="red">HTTP/1.x 虽然引入了 keep-alive 长连接，但它每次请求必须等待上一次响应之后才能发起,**也就是串行**</font>
> 4. HTTP/1.x keep-alive 必须按照请求发送的顺序返回响应；HTTP/2 多路复用不按序响应
> 5.  HTTP/1.x keep-alive 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个 TCP 连接；HTTP/2 同域名下所有通信都在单个连接上完成
> 6. HTTP/1.x keep-alive 单个 TCP 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；HTTP/2 单个 TCP 同一时刻可以发送多个请求和响应
#### 与WebSocket 的区别
1. Websocket 是一个持久化协议， 而Http是非持久的协议
2. Http是通过Request 来界定的，也就是一个Request对应一个Response, 而且Response 是被动发送， 不能主动发送
3. 虽然Http1.1改进使用了keep-live, 但也只是说在一个http 连接(tcp/ip)连接，可以发送多个request
> 1. keep-live 只是说创建一个tcp链接，但是每次发送请求还是需要单独发送header 等信息
> 2. 服务端和客户端还要大量交换Http Header 信息， 信息交换得效率很低
> 3. Websocket 就是通过第一个http request 创建连接后， 之后数据连接都不在需要发送http Request . 


http2.0 怎么实现多路复用的？
1. 首先它引入了 <font color="red">帧（frame）和流（stream）</font>，因为 HTTP/1.x 是基于文本的，因为是文本，就导致了它必须是个整体，在传输是不可切割的，只能整体去传
2. 既然，HTTP/2 是基于二进制流的，它就可以把 HTTP 消息分解为独立的帧，交错发送，然后在另一端通过帧中的标识重新组装，这就是多路复用
3. <font color="red">这就实现了在同一个TCP连接中，同一时刻可以发送多个请求和响应，且不用按照顺序一一对应，即使某个请求任务耗时严重，也不会影响到其它连接的正常执行</font>
 
4. 服务器推送
> HTTP2还在一定程度上改变了传统的<font color="red">“请求-应答”</font>工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求HTML的时候就提前把可能会用到的JS、CSS文件发给客户端，减少等待的延迟，这被称为"服务器推送"（ Server Push，也叫 Cache push）
4. Header 压缩
5. 应用层的重置连接
6. 请求优先级设置
>  请求优先级设置： 在HTTP/2中，每个请求都可以带一个31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。
7. 流量控制
8. 提高了安全性
> http2.0 一般都是配合https 使用，所以安全性更高
 