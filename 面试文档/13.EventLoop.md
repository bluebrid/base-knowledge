https://github.com/Nealyang/PersonalBlog/issues/55
https://juejin.im/post/5d693d8b6fb9a06aca383488
https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
[从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理](https://segmentfault.com/a/1190000012925872)
[「前端进阶」从多线程到Event Loop全面梳理](https://juejin.im/post/5d5b4c2df265da03dd3d73e5)

我们都知道JS是**单线程**, 但是其实依靠**事件队列(Event loop)**的方式来实现异步回调的。

浏览器是一个**多进程**的， 其中包括**GPU进程**， **主进程**， **第三方插件进程**， **tab进程**， **渲染进程**

但是对于一个普通的前端用户来说，我们需要关注的是**渲染进程**，其实也就是**浏览器内核**
包括如下的线程：
1. GUI线程，主要负责渲染，布局，绘制，重绘，回流等，与JS线程是互斥的，防止渲染结果不可预期
2. JS引擎线程
4. 事件触发线程
5. 定时器线程
6. 网络请求线程

> JS 引擎线程和GUI渲染线程是<font size=5 color=red>互斥</font>的， 因为如果不是互斥，在GUI渲染的时候，JS又在操作DOM元素， 就会让页面混乱， 因为是互斥的，所以在在执行完成一个**宏任务**后，会在下一个宏任务执行之前去执行一个**GUI渲染进程**去对页面进行渲染绘制。

我们已经知道宏任务结束后，会执行渲染，然后执行下一个宏任务，
而微任务可以理解成在当前宏任务执行后立即执行的任务。
也就是说，当宏任务执行完，会在渲染前，将执行期间所产生的所有微任务都执行完。
Promise，process.nextTick等，属于微任务。
1. 执行一个宏任务（栈中没有就从事件队列中获取）
2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

## [NodeJS EventLoop](https://zhuanlan.zhihu.com/p/56151579)

![](https://pic4.zhimg.com/80/v2-97a12551238a057224c93e6ad35ac167_1440w.jpg)

1. timers阶段：  是处理setTimeout, setInterval中到时间的回调函数
2. poll阶段：轮询阶段， timers阶段外的所有的阶段都是在poll阶段处理的。 poll 阶段会一直重复的检查刚才的timers阶段是否有到时间的计时器，如果到时间的计时器， 则通过check 到达timer阶段，执行对应的回调函数，然后从timers队列中移除
3. check阶段： 只处理setImmediate
4. nextTick： 是进入每个阶段都会执行，也就是当前阶段结束后， 立即执行nextTick,然后进入下一个阶段
```js
setTimeout(() => {
    console.log('timeout')
    process.nextTick(() => {
        console.log('timeout next tick')
    })
})
setImmediate(() => {
    console.log('immediate')
})
process.nextTick(() => {
    console.log('next tick')
})
//next tick
//timeout
//timeout next tick
//immediate
```
**分析**
1. 上面的代码首先执行nodejs, 然后接着立即执行nextTick 
2. 然后进入timers阶段，打印出 timeout ,然后立即执行里面的nextTick,
3. 然后进入的check 阶段， 然后立即执行setImmeditae
