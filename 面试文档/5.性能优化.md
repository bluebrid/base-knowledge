[前端监控demo](https://github.com/LianjiaTech/fee)

## 浏览器工作原理
1. 浏览器会解析三个模块: Dom, CSS, JS
2. 下载HTML文件后， 回去解析HTML，生成Dom Tree
3. 遇到CSS脚本或者CSS文件， 会生成一个CSS Rule Tree
4. 如果在解析DOM的时候，遇到CSS脚本文件，不会阻塞DOM Tree的构建，但是会阻塞Render Tree的生成， 因为是需要将DOM tree和CSS rule Tree 合并成一个Render Tree
5. 如果遇到JS脚本和文件， 会阻塞DOM 树的解析， 因为JS会去操作Dom 和 CSS
6. 所以建议将JS文件放在最下面
7. 将Dom Tree 和 CSS rule tree 合并成一个Render tree
8. 生成render tree 后， 会去计算每一个DOM的具体位置和大小，也就是Layout(reflow)
9. Render tree 并不等同于Dom 树，因为在Render tree中不会显示header 和隐藏的元素
10. 调用操作系统的Native GUI的API绘制Render tree 到屏幕中

## 造成重排(reflow)和重绘(repaint)的原因
1. 增加，删除或者修改DOM节点
2. 移动DOM的位置，开始动画的时候
3. 修改CSS样式，改变DOM的大小，位置，或者用display:none 会造成**重排**， 如果修改CSS颜色或者设置visibility:hidden会造成**重绘**
4. 修改页面的默认字体
5. Resize 页面窗口，或者滚动的时候
6. 内容改变，如果输入框中写入内容
7. 激活伪类
8. 计算offsetwidth, offsetHeight,scroll,clientHeight,clientWidht,getComputeStyles..

## 如何减少重排和重绘
1. 尽量避免对Style的使用， 需要操作DOM的样式，最好用className,通过更新className 来批量更新样式
2. 尽量避免多次读取同一个元素， 读取一个元素后， 用变量保存，再次使用
3. 如果需要添加或者clone 元素，可以先把元素放在documentFragement中，存入内存，等操作完毕后，再appendChild到DOM元素中
4. 尽量少使用display:none, 可以使用visibility:hidden 来代替， 或者对需要频繁使用display 的元素，让其通过position: absolute/fixed 来脱离文档流在操作
5. 不要使用table布局，因为如果一个小的操作，都会造成整个table 的重排
6. 使用resize事件的时候，添加防抖和节流处理
7. 对动画和批量修改元素的时候，让其脱离文档里， 等修改完成后， 在将其放入文档流里面

## 性能优化的方向
1. 降低请求量
> 1. 合并资源： js 文件合并， CSS文件合并
> 2. 减少HTTP请求数，如果图片处理，雪碧图， 字体图标
> 3. 图片的懒加载
> 4. 启动gzip, minify文件
2. 加快请求速度
> 1. 预解析DNS pre-fetch, 
> 2. 减少域名数
> 3. CDN分发
> 4. http1.1 keep-alive， http2.0 协议升级
> 5. 利用preconnect 对tcp/ip 提前进行连接`<link rel="preconnect" href="//example.com">`
3. 缓存文件处理
> 1. 用PWA缓存请求结果
> 2. 浏览器进行缓存，强缓存: Expires, Cache-Control ,协商缓存: last-modify/if-modify-since, etag/if-none-match
> 3. localstorage, indexDB, 进行离线缓存
> 4. 服务器层面的缓存， 比如利用redis进行请求数据的缓存，减少DB的压力
4. 渲染层面处理
> 1. 尽快让首屏展示处理， 其中涉及到JS的文件的存放位置，以及图片的处理(图片懒加载)， 避免使用css表达式， 将css文件放在顶部，JS文件放在底部
> 2. 尽量少的减少重排和重绘
> 2.1 脱离文档流<font color=red>绝对定位，固定定位</font>，脱离文档流的元素进行重排，不会影响到其他的元素
> 2.2 图片渲染时，增加宽高属性，宽高固定后，图片不会根据内容动态改变高度，变不会触发重排
> 2.3 尽力使用CSS3动画，CSS3动画能最大程度减少重排和重绘
> 2.4 使用`will-change:transform`,将元素独立为一个单独的图层（<font color=red>定位，透明，transform, clip 都会产生对立图层</font>）
> 3. 服务端渲染(SSR 服务端直出)

## [图片优化](https://mp.weixin.qq.com/s/wJxj5QbOHwH9cKmqU5eSQw)

### 图片格式
1. jpeg: 适合颜色丰富的图，banner图片，<font color=red>不适合：图形文字，图标，不支持透明度</font>
2. png: 适合纯色，透明，图标，支持纯透明，半透明，<font color=red>不适合颜色丰富的图片，因为无损存储会导致储存提及大于jpeg</font>
3. gif: 适合动画，可以动的图标，支持纯透明但不支持半透明， <font color=red>不适合色彩丰富的图片</font>
4. <font color=red>埋点信息通常也会使用gif发送， 因为1x1px 的gif 图发送的网络请求比普通的get请求要小一些</font>
5. webp:支持透明和半透明，可以保证图片质量和较小的体积，但是只试合<font color=red>Chrome和移动端浏览器</font>
6. svg: 矢量格式，大小非常小，<font color=red>但渲染成本过高</font>，适合小且色彩单一的图标

### 图片优化
1. 减少图片资源的大小和尺寸，节约用户流量
2. 设置`alt=xxx`,属性， 图片无法显示，会显示`alt`内容
3. 图片懒加载
4. 不同的环境加载不同大小的图片，`srcset`与`sizes`的使用
5. 采用站位图，渐进式加载图片，<font color=red>站位图-> 模糊小图-> 真正清晰大图</font>
6. 小图采用`base64URL`,减少图片资源的请求
7. 采用雪碧图，减少请求数

## [SSR](https://zhuanlan.zhihu.com/p/90746589)
1. 优势
> 1. 首屏加载时间变快， 因为是HTML直出，浏览器可以直接解析该字符串显示在页面上
> 2. SEO更友好， 因为服务端直接输出到浏览器的是整个HTML字符串， 所以是的搜索引擎能抓取到真实的内容
2. 缺点：
> 1. SSR虽然能呈现页面更快，但是如果对应的UI框架(如React)没有加载成功， 页面是不能交互的
> 2. TTFB(Time To First Byte),即第一字节的时间变长
> 3. 会给服务端增加负载，由于SSR是Node端进行服务端进行页面的渲染， 
3. LCP(Largest Contentful Pain)
   > CSR:LCP=加载HTML+加载样式+加载JS+加载数据+Render
   
   > SSR:LCP=加载HTML+加载样式
4. 现在的SSR是指，同构渲染， 即： SSR和CSR渲染使用的是同一套页面模板/框架渲染，经过注水，将SSR 生成HTML转换未View得一部分
5. SSR需要考虑降级方案和怎么去减少服务器的压力， 比如说缓存。 
6. CSR的优势是： 前后端分离非常干净彻底， 部署非常简单，缺点是：SEO差， 首屏渲染非常慢

## [Chrome性能优化相关工具](https://mp.weixin.qq.com/s/wJxj5QbOHwH9cKmqU5eSQw)
   