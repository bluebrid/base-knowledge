# CodeBeautify

[webpack原理](https://segmentfault.com/a/1190000015088834)
[https://webpack.wuhaolin.cn/](深入浅出 Webpack)
[带你深度解锁Webpack系列(优化篇)](https://juejin.im/post/5e6cfdc85188254913107c1f#heading-1)
[从基础到实战 手摸手带你掌握新版Webpack4.0详解 一起读文档](https://juejin.im/post/5cb36a3ef265da03a1581d6d#heading-11)

## 基本概念
1. entry: 入口，Webpack 执行构建的第一步将从entry 开始，可以看做是输入
2. module: 模块， 在webpack里， 一切皆为模块， 一个模块对应一个文件， webpack 会从配置的entry 开始递归查找出所有的依赖模块
3. chunk : 代码块， 一个chunk由多个模块组合而成， 用与代码的合并和分割
4. loader: 模块转换器， 用于把模块原来的内容按照需求转换成新的内容(AST)
5. plugin: 扩展插件， 在webpack 的构建流程中， 会在特定的时机广播对应的事件， 插件可以监听这些事件，然后在特定的时机做对应的事情

## 流程概括
webpack 构建流程是一个串行过程， 从启动到结束会经历如下过程：
1. Webpack 的编译入口文件是base-knowledge\javascript\advance\tools\Webpack-debugger\lib\webpack\bin\webpack.js
2. 判断是否安装了`webpack-cli`或者`webpack-command`依赖包， 现在主要用的是`webpack-cli`
3. 请求`webpack-cli`包
```js
else if (installedClis.length === 1) {
	const path = require("path");
	
	const pkgPath = require.resolve(`../../${installedClis[0].package}/package.json`);
	// eslint-disable-next-line node/no-missing-require
	const pkg = require(pkgPath);
	// eslint-disable-next-line node/no-missing-require
	console.log('0.============================> 执行webpack-cli的package.json 中配置的bin:  "webpack-cli": "./bin/cli.js"')
	
	require(path.resolve(
		path.dirname(pkgPath),
		pkg.bin[installedClis[0].binName]
	));
}
```
3. 初始化参数（在：base-knowledge\javascript\advance\tools\Webpack-debugger\lib\webpack-cli\bin\cli.js）： 从配置文件和shell 中获取配置的参数，并合并参数，得到最终的参数配置
```js
yargs.parse(process.argv.slice(2), (err, argv, output) => {
  ...
  function processOptions(options) {}
  ...
})
```

2. 开始编译： 用上一步的获取到的配置参数初始化compiler对象， 加载所有配置的插件， 执行对象的run 方法开始编译
```js
	let compiler;
			try {
				console.log('1.============================> 执行webpack 函数去初始化webpack, 返回的是一个Compiler 对象')
				compiler = webpack(options);
			} catch (err) {
				if (err.name === "WebpackOptionsValidationError") {
					if (argv.color) console.error(`\u001b[1m\u001b[31m${err.message}\u001b[39m\u001b[22m`);
					else console.error(err.message);
					// eslint-disable-next-line no-process-exit
					process.exit(1);
				}

				throw err;
			}
```
2.1 执行配置的所有的pulgin,其实也就是去注册tapable里面注册对应的事件
```js
console.log('  1.4.============================> 遍历执行options.plugins')
		if (options.plugins && Array.isArray(options.plugins)) {
			for (const plugin of options.plugins) {
				if (typeof plugin === "function") {
					plugin.call(compiler, compiler);
				} else {
					plugin.apply(compiler);
				}
			}
		}
```
```js
class AsyncPlugin {
  constructor(){

  }
  apply(compiler){
    //先监听emit事件 编译完成后 文件内容输出到硬盘上是 触发此事件
    compiler.hooks.emit.tapAsync('AsyncPlugin',(compilation,callback)=>{
      setTimeout(()=>{
        console.log('文件将要写入硬盘')
        callback()
      },3000)
    })
  }
}
module.exports = AsyncPlugin
```
2.2 `compiler.hooks.emit` 是在`Compiler`（base-knowledge\javascript\advance\tools\Webpack-debugger\lib\webpack\lib\Compiler.js）对象中hooks 预制的对应的Hooks, [Hooks](https://webpack.docschina.org/api/compiler-hooks/)
```js
	this.hooks = {
			/** @type {SyncBailHook<Compilation>} */
			shouldEmit: new SyncBailHook(["compilation"]),
			/** @type {AsyncSeriesHook<Stats>} */
			done: new AsyncSeriesHook(["stats"]),
			/** @type {AsyncSeriesHook<>} */
			additionalPass: new AsyncSeriesHook([]),
			/** @type {AsyncSeriesHook<Compiler>} */
			beforeRun: new AsyncSeriesHook(["compiler"]),
			/** @type {AsyncSeriesHook<Compiler>} */
			run: new AsyncSeriesHook(["compiler"]),
			/** @type {AsyncSeriesHook<Compilation>} */
			emit: new AsyncSeriesHook(["compilation"]),
			/** @type {AsyncSeriesHook<Compilation>} */
			afterEmit: new AsyncSeriesHook(["compilation"]),

			/** @type {SyncHook<Compilation, CompilationParams>} */
			thisCompilation: new SyncHook(["compilation", "params"]),
			/** @type {SyncHook<Compilation, CompilationParams>} */
			compilation: new SyncHook(["compilation", "params"]),
			/** @type {SyncHook<NormalModuleFactory>} */
			normalModuleFactory: new SyncHook(["normalModuleFactory"]),
			/** @type {SyncHook<ContextModuleFactory>}  */
			contextModuleFactory: new SyncHook(["contextModulefactory"]),

			/** @type {AsyncSeriesHook<CompilationParams>} */
			beforeCompile: new AsyncSeriesHook(["params"]),
			/** @type {SyncHook<CompilationParams>} */
			compile: new SyncHook(["params"]),
			/** @type {AsyncParallelHook<Compilation>} */
			make: new AsyncParallelHook(["compilation"]),
			/** @type {AsyncSeriesHook<Compilation>} */
			afterCompile: new AsyncSeriesHook(["compilation"]),

			/** @type {AsyncSeriesHook<Compiler>} */
			watchRun: new AsyncSeriesHook(["compiler"]),
			/** @type {SyncHook<Error>} */
			failed: new SyncHook(["error"]),
			/** @type {SyncHook<string, string>} */
			invalid: new SyncHook(["filename", "changeTime"]),
			/** @type {SyncHook} */
			watchClose: new SyncHook([]),

			// TODO the following hooks are weirdly located here
			// TODO move them for webpack 5
			/** @type {SyncHook} */
			environment: new SyncHook([]),
			/** @type {SyncHook} */
			afterEnvironment: new SyncHook([]),
			/** @type {SyncHook<Compiler>} */
			afterPlugins: new SyncHook(["compiler"]),
			/** @type {SyncHook<Compiler>} */
			afterResolvers: new SyncHook(["compiler"]),
			/** @type {SyncBailHook<string, Entry>} */
			entryOption: new SyncBailHook(["context", "entry"])
		};
```
2.3 如`Compiler`对象中的`compile`方法：
```js
compile(callback) {
		const params = this.newCompilationParams();
		console.log('  2.4.============================> [生命钩子]compiler.compile 方法执行beforeCompile')
		this.hooks.beforeCompile.callAsync(params, err => {
			if (err) return callback(err);
			console.log('  2.5.============================> [生命钩子]compiler.compile 方法执行compile')
			this.hooks.compile.call(params);
			console.log('    2.5.1.============================> [生命钩子]创建compilation 对象')
			const compilation = this.newCompilation(params);
			console.log('  2.6.============================> [生命钩子]compiler.compile 方法执行make, 正式开始启动编译了')
			this.hooks.make.callAsync(compilation, err => {
				if (err) return callback(err);

				compilation.finish();
				console.log('  2.7.============================> compilation.seal, make 正式启动编译，编译完成后，执行seal 进行封装')
				compilation.seal(err => {
					if (err) return callback(err);
					console.log('  2.8.============================> [生命钩子]compiler.compile 方法执行afterCompile')
					this.hooks.afterCompile.callAsync(compilation, err => {
						if (err) return callback(err);

						return callback(null, compilation);
					});
				});
			});
		});
	}
```
> 1. class Compiler extends Tapable {
3. 确定入口： 根据配置参数中的entry 找出所有的入口文件
```js
console.log('  1.8.============================> 判断是否有watch 参数')
			if (firstOptions.watch || options.watch) {
				const watchOptions = firstOptions.watchOptions || firstOptions.watch || options.watch || {};
				if (watchOptions.stdin) {
					process.stdin.on("end", function(_) {
						process.exit(); // eslint-disable-line
					});
					process.stdin.resume();
				}
				console.log('  1.9.============================> 开始执行watch')
				compiler.watch(watchOptions, compilerCallback);
				if (outputOptions.infoVerbosity !== "none") console.error("\nwebpack is watching the files…\n");
			} else {
				console.log('2.============================> 调用compiler的run 方法去执行编译')
				compiler.run((err, stats) => {
					if (compiler.close) {
						compiler.close(err2 => {
							compilerCallback(err || err2, stats);
						});
					} else {
						compilerCallback(err, stats);
					}
				});
			}
```
```js
compile(callback) {
		const params = this.newCompilationParams();
		console.log('  2.4.============================> [生命钩子]compiler.compile 方法执行beforeCompile')
		this.hooks.beforeCompile.callAsync(params, err => {
			if (err) return callback(err);
			console.log('  2.5.============================> [生命钩子]compiler.compile 方法执行compile')
			this.hooks.compile.call(params);
			console.log('    2.5.1.============================> [生命钩子]创建compilation 对象')
			const compilation = this.newCompilation(params);
			console.log('  2.6.============================> [生命钩子]compiler.compile 方法执行make, 正式开始启动编译了')
			this.hooks.make.callAsync(compilation, err => {
				if (err) return callback(err);

				compilation.finish();
				console.log('  2.7.============================> compilation.seal, make 正式启动编译，编译完成后，执行seal 进行封装')
				compilation.seal(err => {
					if (err) return callback(err);
					console.log('  2.8.============================> [生命钩子]compiler.compile 方法执行afterCompile')
					this.hooks.afterCompile.callAsync(compilation, err => {
						if (err) return callback(err);

						return callback(null, compilation);
					});
				});
			});
		});
	}
```
3.1 在上面的`compile`方法， 会触发<font color=red>make</font>钩子，而插件<font color=red>SingleEntryPlugin</font>订阅了<font color=red>make</font>钩子，并执行了：`compilation.addEntry` 
```js
/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";
const SingleEntryDependency = require("./dependencies/SingleEntryDependency");

/** @typedef {import("./Compiler")} Compiler */

class SingleEntryPlugin {
	/**
	 * An entry plugin which will handle
	 * creation of the SingleEntryDependency
	 *
	 * @param {string} context context path
	 * @param {string} entry entry path
	 * @param {string} name entry key name
	 */
	constructor(context, entry, name) {
		this.context = context;
		this.entry = entry;
		this.name = name;
	}

	/**
	 * @param {Compiler} compiler the compiler instance
	 * @returns {void}
	 */
	apply(compiler) {
		console.log('    1.7.4.============================> SingleEntryPlugin插件注册了compilation 和make 两个钩子')
		compiler.hooks.compilation.tap(
			"SingleEntryPlugin",
			(compilation, { normalModuleFactory }) => {
				compilation.dependencyFactories.set(
					SingleEntryDependency,
					normalModuleFactory
				);
			}
		);

		compiler.hooks.make.tapAsync(
			"SingleEntryPlugin",
			(compilation, callback) => {
				const { entry, name, context } = this;

				const dep = SingleEntryPlugin.createDependency(entry, name);
				compilation.addEntry(context, dep, name, callback);
			}
		);
	}

	/**
	 * @param {string} entry entry request
	 * @param {string} name entry name
	 * @returns {SingleEntryDependency} the dependency
	 */
	static createDependency(entry, name) {
		const dep = new SingleEntryDependency(entry);
		dep.loc = { name };
		return dep;
	}
}

module.exports = SingleEntryPlugin;

```


4. 编译模块： 从入口文件出发， 调用所有配置的loader 对模块进行翻译，再找出该模块中依赖的模块，在递归本步骤，直到所有的入口文件的依赖文件都经过loader 处理
```js
doBuild(options, compilation, resolver, fs, callback) {
		const loaderContext = this.createLoaderContext(
			resolver,
			options,
			compilation,
			fs
		);

		runLoaders(
			{
				resource: this.resource,
				loaders: this.loaders,
				context: loaderContext,
				readResource: fs.readFile.bind(fs)
			},
			(err, result) => {
				if (result) {
					this.buildInfo.cacheable = result.cacheable;
					this.buildInfo.fileDependencies = new Set(result.fileDependencies);
					this.buildInfo.contextDependencies = new Set(
						result.contextDependencies
					);
				}

				if (err) {
					if (!(err instanceof Error)) {
						err = new NonErrorEmittedError(err);
					}
					const currentLoader = this.getCurrentLoader(loaderContext);
					const error = new ModuleBuildError(this, err, {
						from:
							currentLoader &&
							compilation.runtimeTemplate.requestShortener.shorten(
								currentLoader.loader
							)
					});
					return callback(error);
				}

				const resourceBuffer = result.resourceBuffer;
				const source = result.result[0];
				const sourceMap = result.result.length >= 1 ? result.result[1] : null;
				const extraInfo = result.result.length >= 2 ? result.result[2] : null;

				if (!Buffer.isBuffer(source) && typeof source !== "string") {
					const currentLoader = this.getCurrentLoader(loaderContext, 0);
					const err = new Error(
						`Final loader (${
							currentLoader
								? compilation.runtimeTemplate.requestShortener.shorten(
										currentLoader.loader
								  )
								: "unknown"
						}) didn't return a Buffer or String`
					);
					const error = new ModuleBuildError(this, err);
					return callback(error);
				}

				this._source = this.createSource(
					this.binary ? asBuffer(source) : asString(source),
					resourceBuffer,
					sourceMap
				);
				this._ast =
					typeof extraInfo === "object" &&
					extraInfo !== null &&
					extraInfo.webpackAST !== undefined
						? extraInfo.webpackAST
						: null;
				return callback();
			}
		);
	}
```
```js
// 迭代执行每一个Loader
function iteratePitchingLoaders(options, loaderContext, callback) {
	// abort after last loader
	if(loaderContext.loaderIndex >= loaderContext.loaders.length)
		return processResource(options, loaderContext, callback);

	var currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex];

	// iterate
	if(currentLoaderObject.pitchExecuted) {
		loaderContext.loaderIndex++;
		return iteratePitchingLoaders(options, loaderContext, callback);
	}

	// load loader module
	loadLoader(currentLoaderObject, function(err) {
		if(err) {
			loaderContext.cacheable(false);
			return callback(err);
		}
		var fn = currentLoaderObject.pitch;
		currentLoaderObject.pitchExecuted = true;
		if(!fn) return iteratePitchingLoaders(options, loaderContext, callback);

		runSyncOrAsync(
			fn,
			loaderContext, [loaderContext.remainingRequest, loaderContext.previousRequest, currentLoaderObject.data = {}],
			function(err) {
				if(err) return callback(err);
				var args = Array.prototype.slice.call(arguments, 1);
				if(args.length > 0) {
					loaderContext.loaderIndex--;
					iterateNormalLoaders(options, loaderContext, args, callback);
				} else {
					iteratePitchingLoaders(options, loaderContext, callback);
				}
			}
		);
	});
}
```

```js
// 加载每一个loader 
var LoaderLoadingError = require("./LoaderLoadingError");

module.exports = function loadLoader(loader, callback) {
	if(typeof System === "object" && typeof System.import === "function") {
		System.import(loader.path).catch(callback).then(function(module) {
			loader.normal = typeof module === "function" ? module : module.default;
			loader.pitch = module.pitch;
			loader.raw = module.raw;
			if(typeof loader.normal !== "function" && typeof loader.pitch !== "function") {
				return callback(new LoaderLoadingError(
					"Module '" + loader.path + "' is not a loader (must have normal or pitch function)"
				));
			}
			callback();
		});
	} else {
		try {
			var module = require(loader.path);
		} catch(e) {
			// it is possible for node to choke on a require if the FD descriptor
			// limit has been reached. give it a chance to recover.
			if(e instanceof Error && e.code === "EMFILE") {
				var retry = loadLoader.bind(null, loader, callback);
				if(typeof setImmediate === "function") {
					// node >= 0.9.0
					return setImmediate(retry);
				} else {
					// node < 0.9.0
					return process.nextTick(retry);
				}
			}
			return callback(e);
		}
		if(typeof module !== "function" && typeof module !== "object") {
			return callback(new LoaderLoadingError(
				"Module '" + loader.path + "' is not a loader (export function or es6 module)"
			));
		}
		loader.normal = typeof module === "function" ? module : module.default;
		loader.pitch = module.pitch;
		loader.raw = module.raw;
		if(typeof loader.normal !== "function" && typeof loader.pitch !== "function") {
			return callback(new LoaderLoadingError(
				"Module '" + loader.path + "' is not a loader (must have normal or pitch function)"
			));
		}
		callback();
	}
};
```
5. 完成模块的编译： 在经过第四步使用loader 翻译完成所有的模块后， 得到了每个模块被翻译后的最终内容以及他们的依赖关系
6. 输出资源： 根据入口文件和模块之间的依赖关系， 组装成一个个包含多个模块的chunk， 在把chunk 转换成一个单独的文件，加入到输出列表， 这步是可以修改输出内容的最后机会
7. 输出完成： 在确定输出内容后， 根据配置的输出的路径和文件名，把文件写入文件系统

## 流程总结
1. 初始化： 启动构建，读取和合并配置参数， 加载pluin, 实例化compiler对象
2. 编译阶段： 从entry 出发， 针对每个module串行调用对应的loader去编译内容， 再找到该模块的依赖模块进行相同的loader处理， 递归的进行处理
3. 输出阶段：对编译后的module 组成了chunk, 把chunk 转换成文件，输出到文件系统

## [webpack 编译优化](https://juejin.im/post/5e6cfdc85188254913107c1f#heading-11)
1. 合理设置mode 模式，Webpack 4 在默认情况下mode的值是production, 会进行tree-shaking 和 uglifyJS
2. 利用alias去缩小文件的搜索范围
3. 合理利用include 和exclude
4. 合理利用noParse, 也就是说去配置哪些库不需要依赖其他的库，如jQuery 就不会依赖其他的库，noParse:/jquery/
5. 利用extension去配置查找的文件后缀，优先级高的放在前面，extension:['*', 'j.s', '.json', '.vue']
6. 利用happyPack 去开启多进程进行loader的转换
7. 利用webpack-parallel-uglify-plugin 增强代码的压缩速度
8. 利用Dllplugin 和DllReferencePlugin 去分离第三方代码
9. 配置loader缓存，因为我们每次构建执行的时候都会把所有的文件都重复编译一遍，这样的工作是可以缓存下来的，大部分loader都提供了cache的配置项babel-loader?cacheDirectory=true
10. 如果loader没有配置loader , 可以用第三方的loader-cache插件
11. 利用webpack-bundle-analyzer 进行分析打包后的文件
12. 利用externals来配置哪些文件不需要打包到bundle中，但是又可以在代码中用import 的方法导入库， externals: {jquery: 'jQuery'}, 在代码中同样可以用import $ from 'jquery' 来导入脚本。
13. 关于tree-shaking, 有个坑，要想让他生效，生成的代码必须是ES6的代码模块， 则需要在.babelrc 文件中配置， modules: false.

## babel & AST
[Babel 插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md)
三个阶段：
1. 解析parse
> 接收代码并输出AST， 这个步骤分为：**词法解析**和**语法解析**
2. 转换transform
3. 生成generate
```javascript
module.exports = function ({ types: babelTypes }) {
    return {
        name: "deadly-simple-plugin-example",
        visitor: {
            Identifier: {
                enter(path, state) {
                    console.log("Entered!", path.node.name);
                },
                exit(path, state) {
                    console.log("Exited!");
                }
            },
            // Identifier(path, state) {
            //   if (path.node.name === 'bad') {
            //     path.node.name = 'good';
            //   }
            // },
            Literal(path, state) {
                path.node.value = false
            }
        }
    };
};
```

## [前端工程化](https://www.yuque.com/cuggz/interview/hx0sf2)
1. webpack： 是基于模块进行打包
2. gulp和grunt是基于任务运行的工具， 自动执行指定的任务， 就像流水线， NPM脚本可以替代打造任务
## webpack
1. [常见的loader](https://juejin.cn/post/7067051380803895310)
> 1. file-loader, url-loader, source-map-loader, image-loader, css-loader, less-loader, style-loader
> 2. loader 是从右到左执行
2. 常见的plugin
> 1. define-plugin, html-webpack-plugin, uglifyjs-webpack-plugin, bundle-analyzer, 
3. loader和plugin 的区别：
> 1. loader是在module.rules中配置， plugin 是单独配置的
4. webpack的构建流程
> 初始化参数(命令行+webpack.config.js) + 开始编译生成一个compiler文件-> 确定一个entry 入口-> 编译模块(从入口开始进行编译， 调用所配置的所有的loader 对模块进行翻译加工，再找出依赖的文件，递归进行翻译处理) -> 完成了编译 -> 输出资源

> webpack 在特定的时间点， 会广播出特定的事件，插件在监听到对应的事件，会执行对应的逻辑处理，并且插件可以调用webpack提供的API改变webpack的运行结果

5. webpack 热更新原理：（javascript\advance\axios\demo\config\webpackDevServer.config.js）
D:\projects\base-knowledge\javascript\advance\axios\demo\src\index.js

> 1. 配置 hot: true,
> 2.  hot 是用来这是热更新的， 需要配合(热更新就是我们在不刷新页面的情况下， 页面相应的值也会进行更新，其实就是重新生成了一个新的文件，
    // 然后通过Ajax请求对应的新的脚本， 然后在页面执行这个脚本, 如果不支持热更新， 则直接通过：window.location.reload();重新加载页面，进行页面的更新)：
    // 1. 在webpack.config.js 中配置插件：new webpack.HotModuleReplacementPlugin(),
    // 2. 需要在devServer中设置hot:true
    // 3. 需要在应用的Index.js 中配置：
    /**
     * if (module.hot) {
      // -------------------3、热更新操作
        // HotModuleReplacement.runtime.js 中定义了accept
        module.hot.accept(undefined, () => { // accept 第一个参数表示为undefined 表示这个本身的页面也会热更新
          // require("./index.js");
          //  renderWithHotReload(Router);
        });
      }
     */
    // hotOnly: true,


![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1615910527011-339c57ce-22b2-4660-bcb5-93a7c6ec113b.png?x-oss-process=image%2Fresize%2Cw_1574%2Climit_0)

### 整体流程
1. webpack 打包完成后， 会触发一个done 事件
2. webpack-dev-server 是一个plugin, 会监听done 事件
3. dev-server 在监听到done 后， 会利用websocket 广播 一个事件
4. 客户端的websocket 监听到事件后， 会判断事件类型，如果是OK， 就区获取最新的文件
5. 获取最新的文件，其实通过websocket 的 接口， 通过xmlHttpRequest Ajax去获取最新的文件
6. 获取到最新的文件， 给对应的html 创建一个新的<script>标签
7. 由于webpack 打包后的文件是一个立即执行函数， 它在加载完成后， 就立即去执行，从而实现了热更新了。

### webpack 怎么提高页面性能
1. 压缩代码，
2. 合并文件
4. 利用CDN，配置publicPach,
5. TreeShaking, 
6. Code Splitting ,将代码按照路由等维度，进行拆分， 进行异步加载，可以充分利用浏览器的缓存
7. 提取第三方的公共库，splitChunckPlugin , 充分利用浏览器的缓存
### webpack 怎么提高编译速度


## loader 
1. loader单一原则： 每个loader 只做单一一件事情，各个Loader完全独立
2. 链式调用：webpack,会按照顺序链式调用每个loader
3. 统一原则：遵循webpack指定的设计规则和结构，输入输出都为字符串，各个 Loader 完全独立，即插即用
4. Loader 和 Plugin的区别是： loader 只做一件事，也就是说loader 只针对某一个场景进行处理，如less-loader，只处理less文件，因为有配置test正则去匹配文件，但是plugin是针对整个流程执行的广泛任务。
```js
// AST三个步骤： parse->traverse(转换) -> generator（生成）
const parser = require('@babel/parser')
const traverse = require('@babel/traverse').default
const generator = require('@babel/generator').default
const t = require('@babel/types')
module.exports = function (source) {
    const ast = parser.parse(source, { sourceType: 'module' }) // (解析)将源代码解析成 AST
    traverse(ast, {
        CallExpression(path) {
            if (t.isMemberExpression(path.node.callee) && t.isIdentifier(path.node.callee.object, { name: "console" })) {
                path.remove()//(转换) 对AST节点进行递归遍历，生成一个便于操作、转换的path对象
            }
        }
    })
    const output = generator(ast, {}, source);//(生成) 将AST解码生成js代码
    return output.code
}
```
```js
const loaderUtils = require("loader-utils");
// D:\private\bluebrid\CodeBeautify\node_modules\loader-runner\lib\LoaderRunner.js
module.exports = function(content) {
    const options = loaderUtils.getOptions(this);
    // console.log('***options loader.1***', options)
    // console.log('***value loader.11***', this.data.value1)
    this.cacheable(false)
    return  `/**
    This a custom comments added by Ivan Fan.
    */` + content;
}
// module.exports.normal = (remaining, preceding, data) => {
//     console.log('***remaining loader.1***', remaining)
//     console.log('***preceding loader.1***', preceding)
//     // data会被挂在到当前loader的上下文this上在loaders之间传递
//     data.value1 = "test"
// }
// module.exports.raw = (remaining, preceding, data) => {
//     console.log('***remaining loader.1***', remaining)
//     console.log('***preceding loader.1***', preceding)
//     // data会被挂在到当前loader的上下文this上在loaders之间传递
//     data.value1 = "test"
// }
module.exports.pitch = (remaining, preceding, data) => {
    // console.log('***remaining loader.1***', remaining)
    // console.log('***preceding loader.1***', preceding)
    // data会被挂在到当前loader的上下文this上在loaders之间传递
    data.value1 = "test"
}

```
```js
const loaderUtils = require("loader-utils");
module.exports = function(content) {
    const options = loaderUtils.getOptions(this);
    //console.log('***options loader.2***', options)
    //console.log('***value loader.2***', this.data.value2)
    return content;
}
module.exports.pitch = (remaining, preceding, data) => {
    //console.log('***remaining loader.2***', remaining)
    //console.log('***preceding loader.2***', preceding)
    // data会被挂在到当前loader的上下文this上在loaders之间传递
    data.value2 = "test"
}

```

## plugin
```js
class AsyncPlugin {
  constructor(){

  }
  apply(compiler){
    //先监听emit事件 编译完成后 文件内容输出到硬盘上是 触发此事件
    compiler.hooks.emit.tapAsync('AsyncPlugin',(compilation,callback)=>{
      setTimeout(()=>{
        console.log('文件将要写入硬盘')
        callback()
      },3000)
    })
  }
}
module.exports = AsyncPlugin
```
```js
class DonePlugin {
  constructor(){

  }
  apply(compiler){
    compiler.hooks.done.tapAsync('DonePluginv',function(name,callback){
      console.log('全部编译完成')
      callback()
    })
  }
}
module.exports = DonePlugin
```

## [总结18个webpack插件，总会有你想要的](https://juejin.cn/post/6844904193589772301)
