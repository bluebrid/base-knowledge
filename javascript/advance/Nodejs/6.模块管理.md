## 模块化
1. CMD
> 1. CMD是一个通用模块定义规范；是SeaJs推广过程中对模块定义的规范化产出
> 2. CMD推崇依赖就近， 只有在用到某个模块的时候才回去require
2. AMD
> AMD 是运行在浏览器环境的一个**异步加载**模块的规范， 是RequireJS推广的规范
4. CommonJS
> 1. Commond 是服务端模块的规范，由Node推广使用
> 2. Commonjs 是有三个部分组成： 模块定义，模块标识，模块引用
> 3. Commonjs 是**同步加载**的, 没有并行机制
> 4. 使用方式
```javascript
const a = require('./koala');
module.exports = {
    a: "这是module.exports维护的a的值"
}
```
> 5. require 导出的是module.exports的指向的内存内容，而不是exports的。 
> 6. export是module.exports 的一个引用
```javascript
//koala.js
let a = '程序员成长指北';

console.log(module.exports); //能打印出结果为：{}
console.log(exports); //能打印出结果为：{}
// 一开始exports指向的就是module.exports的内存，如果直接通过exports 进行赋值，
//也就是将exports的内存的指向和module.exports的指向给断开了。
// 再次给exports.a进行赋值，其实module.exports的值是没有变更的
// 这里已经将exports 和module.exports的指向给断开了
exports = "一开始指向其他的内存"
console.log(module.exports)
exports.a = '程序员成长指北哦哦'; //这里辛苦劳作帮 module.exports 的内容给改成 {a : '程序员成长指北哦哦'}
console.log(module.exoprts)
exports = '指向其他内存区'; //这里把exports的指向指走

module.exports = {
    a: "这是module.exports维护的a的值"
}
/**
 * require导出的内容是module.exports的指向的内存块内容，并不是exports的。
 * 简而言之，
 * 区分他们之间的区别就是 exports 只是 module.exports的引用，辅助后者添加内容用的。
 * 用内存指向的方式更好理解。
 */
/*
1. 在node中每个文件模块都是一个如下的对象
function Module(id, parent) {
    this.id = id;
    this.exports = {};
    this.parent = parent;
    this.filename = null;
    this.loaded = false;
    this.children = [];
  }
  
  module.exports = Module;
  
  var module = new Module(filename, parent);
  2. 所有的模块都是 Module 的实例。可以看到，当前模块（module.js）也是 Module 的一个实例
 */
```