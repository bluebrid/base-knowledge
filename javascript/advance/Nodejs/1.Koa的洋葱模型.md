## Koa
Koa 的洋葱模型指的是以 **next()** 函数为分割点，先由**外到内**执行 Request 的逻辑，再由**内到外**执行 Response 的逻辑。通过洋葱模型，将多个中间件之间通信等变得更加可行和简单。其实现的原理并不是很复杂，主要是 compose 方法。

```javascript
const Koa = require('koa');
//Applications
const app = new Koa();
// 中间件1
app.use((ctx, next) => {
  console.log(1);
  next();
  console.log(2);
});
// 中间件 2 
app.use((ctx, next) => {
  console.log(3);
  next();
  console.log(4);
});
app.listen(9000, '0.0.0.0', () => {
    console.log(`Server is starting`);
});
```

```javascript
  use(fn) {
    if (typeof fn !== 'function') throw new TypeError('middleware must be a function!');
    if (isGeneratorFunction(fn)) {
      deprecate('Support for generators will be removed in v3. ' +
                'See the documentation for examples of how to convert old middleware ' +
                'https://github.com/koajs/koa/blob/master/docs/migration.md');
      fn = convert(fn);
    }
    debug('use %s', fn._name || fn.name || '-');
    this.middleware.push(fn);
    return this;
  }
```
![](https://pic1.zhimg.com/v2-e2e19352126f075152431ba52efbdba8_1440w.jpg?source=172ae18b)
![](https://pic4.zhimg.com/80/v2-99b874cf305bbfe6ecfcb2df1143dccb_720w.jpg)
![](https://pic3.zhimg.com/80/v2-95f4fcba6e7023f3f29d177922f60c0e_720w.jpg)

## [Koa & Express](https://www.imooc.com/article/302300)
1. <font color=red size=5>Express</font>: 使用的是普通的回调函数，一种线性的逻辑，在同一个线程上完成所有的HTTP请求
> 1. Express 不能容忍的是`callback`,特别是对错误捕获处理起来不友好，每一个回调都是一个新的`调用栈`，不能直接在callback 中捕获异常，需要在callback中捕获，然后一层层向外传递
2. <font color=red size=5>Koa2</font>: Koa使用的是一个`洋葱模型`，他的特点是`级联`，通过`await next()`控制调用`下游中间件`
> 1. 直到下游的中间件且堆栈执行完毕，最终在流回上游中间件
> 2. <font color=red>这种方式的有点特别是对日志记录<请求->响应时间>，错误处理支持都很完美</font>
> 3. <font color=red size=5>缺点：</font>因为Koa2是基于Promise实现的， 而Promise是一种链式调用，当多个then 链式调用， 你是<font color=red>没法提前中断</font>，要么继续向下传递，要么catch抛出一个错误
3. Express 中间件的实现是基于Callback回调函数同步的， <font color=red>它不会等待异步Promise完成</font>可以参考`1.js`（注释f3 中的 sleep()）观察结果
4. Koa的中间件机制中，使用的是`await /async`，以同步的方式来管理异步的方式，<font color=red>他则可以等待异步操作</font>

## 响应机制不一样
1. koa中数据响应是通过`ctx.body`进行设置，这里只是进行了设置，没有立即响应，而是在所有的中间件结束后，才做响应
```js
const handleResponse = () => respond(ctx);
fnMiddleware(ctx).then(handleResponse)

function respond(ctx) {
  ...
  res.end(body);
}
```
2. 这样做得好处是：<font color=red>这样做一个好处是我们在响应之前是有一些预留操作空间的</font>
```js
async function f1(ctx, next) {
  console.log('f1 start ->');
  await next();
  ctx.body += 'f1';
  console.log('f1 end <-');
}
async function f2(ctx, next) {
  console.log('f2 start ->');
  await next();
  ctx.body += 'f2 ';
  console.log('f2 end <-');
}
async function f3(ctx) {
  ctx.body = 'f3 '
  console.log('f3 service...');
}
fn().then(() => {
  console.log(ctx); // { body: 'f3 f2 f1' }
});

```
3. Express 中我们直接操作的是`res`对象， 直接通过`res.send()`后，立即响应
```js
function f2(req, res, next) {
  console.log('f2 start ->');
  next();
  res.send('f2 Hello World!') // 第二次执行
  console.log('f2 end <-');
}

async function f3(req, res) {
  console.log('f3 service...');
  res.send('f3 Hello World!') // 第一次执行
}

app.use(f2);
app.use(f3);
app.get('/', f3)
```
4. 上面进行了多次`send`操作，会报错`ERR_HTTP_HEADERS_SEND`