[人人都能读懂的react源码解析(大厂高薪必备)](https://xiaochen1024.com/article_item/600aca0cecf02e002e6db56c)
[图解 React 原理系列](https://github.com/7kms/react-illustration-series/tree/v17.0.1)
## Fiber 产生背景
![](https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIqnSvBHOnuOIY0B4DttcgibPrx1mRxEGc9M33DJgicRG5keaVxfB7eiawTrzkn30iakjJ50z0tz3eDCJg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
### 原因
1. React15 在render阶段的<font size=5 color="red">reconcile(协调)</font> 是不可以打断的
> reconcile就是构建workInProgress树的流程
2. 这个时候会进行大量的Dom的reconcile 会产生卡顿
3. 因为浏览器执行JS是单线程的， 这个时候将所有的事件都交给了JS执行

### react 16 方案
1. 16之后就有了scheduler进行时间片的调度，给每个task 一定的执行时间
2. 如果在对应的时间内没有执行完成， 也需要交出执行权给浏览器进行绘制和重排
3. 所以异步可中断的更新， 则需要一定的数据结构在**内存中**保存这个dom 的信息， 这个数据结构就是： <font size=5 color="red">Fiber(虚拟Dom)</font>
4. Fiber 首先要保存节点的信息， 如： tag, key , type. typeNode(节点信息)
5. Fiber 是一棵树， 需要保存 Child, sibling(兄弟节点) 
6. Fiber 需要来保存状态值信息， 
7. Fiber<font size=5 color="red">(双缓存)</font>， 也就是fiber首先会保存当前正式的Dom信息(current fiber),同时也会保存当前构建的fiber ,也就是workInProgress Fiber, 这两棵树通过（<font size=5 color="red">alertnate</font>） 相连
8. 在**Mount**时(第一次render), 会创建fiberRoot 和 RootFiber,然后跟进JSX创建的Fiber节点， 生成一个Current Fiber 树
9. 在**Update**时(更新) ，会根据最新的jsx 和current Fiber 进行diff算法， 生成一个WorkInProgress的Fiber树， 然后将fiberRoot的current 指向 WorkInprogress树， 这个时候的workInProgress树，就是current Fiber
```javascript
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) {
  //保存节点的信息
  this.tag = tag;//对应组件的类型
  this.key = key;//key属性
  this.elementType = null;//元素类型
  this.type = null;//func或者class
  this.stateNode = null;//真实dom节点

  //连接成fiber树
  this.return = null;//指向父节点
  this.child = null;//指向child
  this.sibling = null;//指向兄弟节点
  this.index = 0;

  this.ref = null;

  //用来计算state
  this.pendingProps = pendingProps;
  this.memoizedProps = null;
  this.updateQueue = null;
  this.memoizedState = null;
  this.dependencies = null;

  this.mode = mode;
    
	//effect相关
  this.effectTag = NoEffect;
  this.nextEffect = null;
  this.firstEffect = null;
  this.lastEffect = null;

  //优先级相关的属性
  this.lanes = NoLanes;
  this.childLanes = NoLanes;

  //current和workInProgress的指针
  this.alternate = null;
}
```
## [React Fiber架构浅析](https://mp.weixin.qq.com/s/GDYfwQyIKOjqfC_n-oDPzQ)
### 解决丢帧的方法
1. 一帧空闲时处理, 利用 <font color="red">RequestIdleCallback</font>处理任务。
  > window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队
2. 对高耗时的任务，进行分步骤处理
3. Web worker 貌似也可以解决上述问题，这里不做扩展。



## [深入理解 scheduler 原理](https://mp.weixin.qq.com/s/0vomFnPPNb27E76LBIQcsA)
1. React在不同的环境下， 实现requestHostCallback 等函数的时候，采用不同的方式
2. 在Node环境采用的是setTimeout,在浏览器环境下采用的是：`MessageChannel`(<font color="red">团队更希望控制调度的频率，根据任务的优先级不同，提高任务的处理速度，放弃本身对于浏览器帧的依赖</font>)
3. MessageChannel:接口允许我们创建一个新的消息通道，并通过它的两个MessagePort属性发送数据
```javascript
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = function (event) {
    isMessageEventScheduled = false;

    var prevScheduledCallback = scheduledHostCallback;
    var prevTimeoutTime = timeoutTime;
    scheduledHostCallback = null;
    timeoutTime = -1;

    var currentTime = getCurrentTime();

    var didTimeout = false;
    if (frameDeadline - currentTime <= 0) {
      // There's no time left in this idle period. Check if the callback has
      // a timeout and whether it's been exceeded.
      if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {
        // Exceeded the timeout. Invoke the callback even though there's no
        // time left.
        didTimeout = true;
      } else {
        // No timeout.
        if (!isAnimationFrameScheduled) {
          // Schedule another animation callback so we retry later.
          isAnimationFrameScheduled = true;
          requestAnimationFrameWithTimeout(animationTick);
        }
        // Exit without invoking the callback.
        scheduledHostCallback = prevScheduledCallback;
        timeoutTime = prevTimeoutTime;
        return;
      }
    }

    if (prevScheduledCallback !== null) {
      isFlushingHostCallback = true;
      try {
        prevScheduledCallback(didTimeout);
      } finally {
        isFlushingHostCallback = false;
      }
    }
  };
```

4. 调度的实现
> 1. 调度中心比较重要的函数在`SchedulerHostConfig.default.js`
```javascript
export let requestHostCallback;//请求及时回调 
export let cancelHostCallback;
export let requestHostTimeout;
export let cancelHostTimeout;
export let shouldYieldToHost;
export let requestPaint;
export let getCurrentTime;
export let forceFrameRate;
```
> 2. ScheduleCallback: 这个函数注册了一个任务并开始调度。
> 3. requestHostCallback： 调用任务
5. 可中断原理
> 1. task.callback 在执行的时候，自己判断是否已经超时，fiber 树每构建一个单元都会判断是否超时，如果超时，则退出循环，并返回回调，等待下次执行

## 调度实现的总结：
1. 有个任务队列queue,改队列存放了可以中断的任务
2. 通过`workLoop`对队列里取第一个任务`currentTask`,开始执行
> 1. 如果任务执行完成后， 还有连续的回调，则：`currentTask.callback=continuationTask`
> 否则移除已经完成的任务
> 改任务如果没用时间了，或者需要中断，则让出主线程
> 否则执行`currentTask.callback()`
> 更新`currentTask`,继续循环走起
3. 通过`requestAnimationFrame`计算一帧的空余时间
4. 使用`new MessageChannel()`执行任务
5. 