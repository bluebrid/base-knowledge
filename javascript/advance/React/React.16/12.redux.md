## [Redux](https://www.yuque.com/cuggz/interview/pgw8v4#a03a11ff2cec9e9af1df9a4ecc2009dc)
## 历史问题？
1. React 是一个<font color=red>单项数据流</font> 属性只能从父组件传递给子组件
2. Props不能通过子组件传递给父组件（props 传递回调函数的形式），而且兄弟组件不能传递
3. 项目越来越大的时候， 管理数据的事件越来越多， 回调函数也将越来越多
4. 管理不断变化的state 非常的困难
5. 状态的变更的跟踪也会变得非常困难，什么时候在哪里发生的变化
## Redux解决的问题
1. Redux 提供一个通关管理状态的store的存储仓库
2. 组件通过dispatch 将state直接传入store
3. 组件通过subscribe 从store 中获取state的变更
4. 所有的组件都能从store中获取所有需要的state
5. 他们也能从store获取state的改变

## 流程
1. 用户通过View 发起Action ,发出方调用`dispatch`方法
2. stroe调用`reducer`并且传入两个参数`type`和`state`,reducer会返回一个新的state
3. state 一旦发生变化，store就会调用监听函数，来更新view(当Reducers的更新完成以后会通过store的订阅来通知react component，组件把新的状态重新获取渲染)
## 原理
1. 将所有的mapStateToProps 和 mapDispatchToProps 封装到props中
1. 其中 mapDispatchToProps 会将所有的方法用dispatch 包裹如：
```javascript
      return function() {
          return dispatch(actionCreator.apply(this, arguments))
        }
        如: addTODO = function {
          return dispatch(addTODO.apply(this, arguments))
        }
        其中dispatch 就是store.dispatch 
        dispatch 会通知所有的订阅者， 而connectAdvanced组件在componentDidMount事件中对store进行了订阅， 
        其this.runUpdater()会调用setState, 然后就会重新render 所有的组件
         componentDidMount() {
          if (!shouldHandleStateChanges) return
          this.subscription.trySubscribe()
          this.runUpdater()
        }
```
```javascript
     const nextProps = sourceSelector(store.getState(), props)
      if (nextProps !== prevState.props || prevState.error) { // 利用shouldComponentUpdate 来判断是否需要更新组件
        return {
          shouldComponentUpdate: true,
          props: nextProps,
          error: null,
        }
      }
```