1. 函数组件比类组件的<font color="red">性能要高</font>，因为类组件会有一个实例化的阶段，而函数组件则是直接执行的函数，返回结果过即可
2. 为了性能，尽可能用函数组件
3. 函数组件不需要取维护一系列的生命周期，编写更简单
4. 函数组件，可以更小颗粒度的维护组件， 对于封装组件提供了很多的便利
5. 函数组件不能获取组件实例this
6. 函数组件没有状态， 需要通过useState 来进行组件状态的维护
7. 函数组件， 更便于做单元测试

## Hooks 
1. HOC
> 优点： 逻辑复用， 不影响被包裹组件的内部逻辑
> 缺点： HOC 传递给被包裹组件的Props容易和被包裹后的组件重名， 从而被覆盖

2. Render Props
> 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。
> 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅

3. Hooks
> 更好的状态复用（也就是代码逻辑的复用）
> Mixins弊端： 1. 难以追溯方法和属性到底在哪里定义的， 2. 重名覆盖，
> 使用直观；
> 解决hoc的prop 重名问题；
> 解决render props 因共享数据 而出现嵌套地狱的问题；
> 能在return之外使用数据的问题。
> 缺点:  Hook只能在组件顶层使用， 不能再逻辑分支中使用

## [【React深入】从Mixin到HOC再到Hook](https://mp.weixin.qq.com/s?__biz=Mzk0MDMwMzQyOA==&mid=2247490057&idx=1&sn=e7a9abb4df2fb7f7baf406dbb20d8313&source=41#wechat_redirect)

1. 使用HOC的动机
> 1. Mixin 可能会相互依赖， 相互耦合，不利于代码的维护
> 2. 不同的Mixin中的方法可能会相互冲突
> 3. Mixin非常多时，组件是可以感知的，只是还要为其做相关的处理，这样给代码走查滚雪球的复杂性
2. HOC解决的问题：
> 1. HOC就是一个没用副作用的纯函数， 各个HOC不会互相依赖组合
> 2. HOC也可能存在冲突， 我们可以通过在遵守预定的情况下避免这些行为
> 3. 高阶组件并不关系数据使用的方式和原因，而被包裹的组件也不关心数据来自何处， 高阶组件的增加不会为原组件增加负担
3. HOC的<font color="red">缺陷</font>
  > 1. HOC 需要在原组件上进行包裹或者嵌套， 如果大量使用HOC，将会长生非常多的嵌套，让调试变得非常复杂
  > 2. HOC 可以劫持`props`,在不遵守约定的情况下， 也可能造成冲突
4. Hooks 解决的问题
   > 1. Hooks 可以帮助你在不重写组件结构的情况下复用状态逻辑
   > 2. Hooks 可以让这些逻辑容易被测试
5. Hooks 应该注意的问题
   > 1. 只能在React函数式组件或自定义Hook中使用Hook
   > 2. 不要在循环，条件，或嵌套函数中使用Hook
   > 3. <font color="red">Hook 通过数组实现，每次`useState`都会改变下标，React需要利用调用顺序来正确更新响应的状态，如果`useState`被包裹在循环或者条件语句中， 那每次就可能引起调用顺序的错乱，从而造成意想不到错误</font>
   > 4. 我们可以通过`eslint`插件`eslint-plugin-react-hooks`来帮助我们避免这些问题

6. 使用Hook的动机
   > 1. 减少状态逻辑复用的风险（Mixin存在相互覆盖的风险）
   > 2. 避免地狱式嵌套的问题
   > 3. 让组件更容易理解
   > 4. 使用函数式组件替代Class组件
7. HOC的实际应用
   > 1. 日志埋点
   > 2. 权限控制等
   > 3. 双向绑定
   > 4. 表单校验
   > 5. Redux Connect 