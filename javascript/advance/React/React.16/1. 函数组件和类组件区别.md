1. 函数组件比类组件的<font color="red">性能要高</font>，因为类组件会有一个实例化的阶段，而函数组件则是直接执行的函数，返回结果过即可
2. 为了性能，尽可能用函数组件
3. 函数组件不需要取维护一系列的生命周期，编写更简单
4. 函数组件，可以更小颗粒度的维护组件， 对于封装组件提供了很多的便利
5. 函数组件不能获取组件实例this
6. 函数组件没有状态， 需要通过useState 来进行组件状态的维护
7. 函数组件， 更便于做单元测试

## Hooks 
1. HOC
> 优点： 逻辑复用， 不影响被包裹组件的内部逻辑
> 缺点： HOC 传递给被包裹组件的Props容易和被包裹后的组件重名， 从而被覆盖
```jsx
// hoc的定义
function withSubscription(WrappedComponent, selectData) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        data: selectData(DataSource, props)
      };
    }
    // 一些通用的逻辑处理
    render() {
      // ... 并使用新数据渲染被包装的组件! (Hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖 )
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };

// 使用
const BlogPostWithSubscription = withSubscription(BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id));
```
2. Render Props
> 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。
> 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅

3. Hooks
> 更好的状态复用（也就是代码逻辑的复用）
> Mixins弊端： 1. 难以追溯方法和属性到底在哪里定义的， 2. 重名覆盖，
> 使用直观；
> 解决hoc的prop 重名问题；
> 解决render props 因共享数据 而出现嵌套地狱的问题；
> 能在return之外使用数据的问题。
> 缺点:  Hook只能在组件顶层使用， 不能再逻辑分支中使用

## [【React深入】从Mixin到HOC再到Hook](https://mp.weixin.qq.com/s?__biz=Mzk0MDMwMzQyOA==&mid=2247490057&idx=1&sn=e7a9abb4df2fb7f7baf406dbb20d8313&source=41#wechat_redirect)

[React 代码共享最佳实践方式](https://juejin.cn/post/6961000054018539550?share_token=783dc303-772a-4cc7-99c5-bb7c506af558)
1. Mixin:
   > 1. <font color=red>其作用是为单继承创造一种类似多继承的效果</font>
   > 2. 实现原理：
   ```js
   const mixin = function (obj, mixins) {
   const newObj = obj
   newObj.prototype = Object.create(obj.prototype)

   for (let prop in mixins) {
      // 遍历mixins的属性
      if (mixins.hasOwnPrototype(prop)) {
         // 判断是否为mixin的自身属性
         newObj.prototype[prop] = mixins[prop]; // 赋值
      }
   }
   return newObj
   }; 
   ```
   > 3. React 使用方式：
   ```js
   const DefaultNameMixin = {
      getDefaultProps: function () {
         return {
            name: "Joy"
         }
      }
   }
   const ComponentOne = React.createClass({
      mixins: [DefaultNameMixin]
      render: function () {
         return <h2>Hello {this.props.name}</h2>
      }
   })
   ```
   > 4. 写好的mixin 可以重复的在其他的组件中使用
   > 5. <font color=red>mixins</font>是一个数组， 可以包含多个，并且一个mixin立马可以包含其他的mixin
   > 6. <font color=red size=5>缺点：</font>
   > 6.1 破坏原有组件的封装，可能需要取维护新的`state`和`props`等状态
   > 6.2 不同的mixin 里的命名不可知，非常容易发生冲突
   > 6.3 可能产生递归调用的问题，造成了项目复杂度和维护难度
   > 6.4 <font color=red>`mixin`会存在状态冲突，方法冲突，多个生命周期调用顺序都会存在问题</font>
2. 使用HOC的动机
   <font color=red>HOC 本质上是一个函数，她接受一个组件作为参数，返回一个新的组件</font>
> 1. Mixin 可能会相互依赖， 相互耦合，不利于代码的维护
> 2. 不同的Mixin中的方法可能会相互冲突
> 3. Mixin非常多时，组件是可以感知的，只是还要为其做相关的处理，这样给代码走查滚雪球的复杂性
1. HOC解决的问题：
> 1. HOC就是一个没用副作用的纯函数， 各个HOC不会互相依赖组合
> 2. HOC也可能存在冲突， 我们可以通过在遵守预定的情况下避免这些行为
> 3. 高阶组件并不关系数据使用的方式和原因，而被包裹的组件也不关心数据来自何处， 高阶组件的增加不会为原组件增加负担
3. HOC的<font color="red">缺陷</font>
  > 1. HOC 需要在原组件上进行包裹或者嵌套， 如果大量使用HOC，将会产生非常多的嵌套，让调试变得非常复杂
  > 2. HOC 可以劫持`props`,在不遵守约定的情况下， 也可能造成冲突
  > 3. <font color=red>当父子组件，有同名的props时，会导致父组件覆盖子组件props问题，不会报错，而且开发者感知性非常低</font>
  > 4. 每一个HOC 都会返回一个新的组件，从而产生很多无用的组件，同时加深了组件的层级，不利于排查问题
4. **Render Props**
   > <font color=red size=5>使用限制</font>
   > 1. 避免使用箭头函数， 造成性能影响
   > <font color=red size=5>优点</font>
   > 1. props 命名可以修改，不存在相互覆盖
   > 2. 清楚props 的来源
   > 3. 不会出现组件的多层嵌套
   > <font color=red size=5>缺点</font>
   > 1. 写法繁琐
   > 2. 无法在`return`语句外访问数据
   > 3. 容易产生函数回调嵌套
   ```jsx
      // DataProvider组件内部的渲染逻辑如下
   class DataProvider extends React.Components {
      state = {
      name: 'Tom'
   }

      render() {
      return (
         <div>
            <p>共享数据组件自己内部的渲染逻辑</p>
            { this.props.render(this.state) }
         </div>
      );
   }
   }

   // 调用方式 (这里有个render 方法)
   <DataProvider render={data => (
   <h1>Hello {data.name}</h1>
   )}/>

   ```
   ```jsx
   const MyComponent = () => {
      return (
         <Mouse>
            {({ x, y }) => (
            <Page>
               {({ x: pageX, y: pageY }) => (
                  <Connection>
                  {({ api }) => {
                     // yikes
                  }}
                  </Connection>
               )}
            </Page>
            )}
         </Mouse>
      )
   }

   ```
   ```jsx
   import { Modal, Button } from "antd"
      class MyModal extends React.Component {
      state = { on: false }

      toggle = () => {
         this.setState({
            on: !this.state.on
         })
      }

      renderButton = (props) => <Button {...props} onClick={this.toggle} />

      renderModal = ({ onOK, ...rest }) => (
         <Modal
            {...rest}
            visible={this.state.on}
            onOk={() => {
            onOK && onOK()
            this.toggle()
            }}
            onCancel={this.toggle}
         />
      )

      render() {
         return this.props.children({
            Button: this.renderButton,
            Modal: this.renderModal
         })
      }
      }

   ```
5. <font size=5 color=red>Hooks</font>
   > 1. React一直在致力于优化和完善组件的方式
   > 2. 从最开始的`class`组件再到后来的`function`组件
   > 3. `class`组件，给我们提供一个完整的生命周期和状态，但是写法笨重
   > 4. `class`组件， 必须需要实例化，才能使用，性能是会有影响的
   > 5. `函数组件`写法简洁轻便，但是限制必须时纯函数，不能包含状态，也不支持生命周期，因此`类组件`并不能被`函数组件` 取代
   > 6. <font color=red>而React团队，觉得组件的最佳写法应该时函数，而不是类，由此产生了`React Hooks`</font>
   > 7. React Hooks 设计的目的，就是加强版函数组件， 完全不用使用`类`, 就能写出一个全功能的组件

6. Hooks 解决的问题
   > 1. Hooks 可以帮助你在不重写组件结构的情况下复用状态逻辑
   > 2. Hooks 可以让这些逻辑容易被测试
   > 3. 更容易复用代码
   > 4. 清爽的代码风格
   > 5. 代码量更少
7. Hooks 应该注意的问题
   > 1. 只能在React函数式组件或自定义Hook中使用Hook
   > 2. 不要在循环，条件，或嵌套函数中使用Hook
   > 3. <font color="red">Hook 通过数组实现，每次`useState`都会改变下标，React需要利用调用顺序来正确更新响应的状态，如果`useState`被包裹在循环或者条件语句中， 那每次就可能引起调用顺序的错乱，从而造成意想不到错误</font>
   > 4. 我们可以通过`eslint`插件`eslint-plugin-react-hooks`来帮助我们避免这些问题
   > 5. <font color="red">状态不同步(函数独立运行，每个函数都有一份独立的作用域)</font>
   > 6. 需要更合理的使用`useEffect`
   > 7. 颗粒度小，对于复杂逻辑需要抽象出很多的`hook`

8. 使用Hook的动机
   > 1. 减少状态逻辑复用的风险（Mixin存在相互覆盖的风险）
   > 2. 避免地狱式嵌套的问题
   > 3. 让组件更容易理解
   > 4. 使用函数式组件替代Class组件
9.  HOC的实际应用
   > 1. 日志埋点
   > 2. 权限控制等
   > 3. 双向绑定
   > 4. 表单校验
   > 5. Redux Connect 