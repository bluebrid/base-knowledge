{
  "version": 3,
  "sources": ["../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/util/whitespace.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/util/location.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/base.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/comments.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/error-codes.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/error-message.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/error.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugins/estree.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/tokenizer/context.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/tokenizer/types.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/babel-helper-validator-identifier/src/identifier.ts", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/babel-helper-validator-identifier/src/keyword.ts", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/util/identifier.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/util/scopeflags.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/util/scope.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugins/flow/scope.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/tokenizer/state.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/tokenizer/index.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/util/class-scope.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/util/expression-scope.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/util/production-parameter.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/util.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/node.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugins/flow/index.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugins/jsx/xhtml.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugins/jsx/index.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugins/typescript/scope.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugins/typescript/index.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugins/placeholders.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugins/v8intrinsic.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/plugin-utils.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/options.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/lval.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/expression.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/statement.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/parser/index.js", "../../../node_modules/.pnpm/@babel+parser@7.16.4/node_modules/@babel/parser/src/index.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js", "../../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js", "../src/index.ts", "../../reactivity/src/operations.ts", "../../shared/src/makeMap.ts", "../../shared/src/patchFlags.ts", "../../shared/src/slotFlags.ts", "../../shared/src/globalsWhitelist.ts", "../../shared/src/codeframe.ts", "../../shared/src/domAttrConfig.ts", "../../shared/src/normalizeProp.ts", "../../shared/src/domTagConfig.ts", "../../shared/src/looseEqual.ts", "../../shared/src/toDisplayString.ts", "../../shared/src/index.ts", "../../reactivity/src/warning.ts", "../../reactivity/src/effectScope.ts", "../../reactivity/src/dep.ts", "../../reactivity/src/effect.ts", "../../reactivity/src/baseHandlers.ts", "../../reactivity/src/collectionHandlers.ts", "../../reactivity/src/reactive.ts", "../../reactivity/src/ref.ts", "../../reactivity/src/computed.ts", "../../runtime-core/src/warning.ts", "../../runtime-core/src/errorHandling.ts", "../../runtime-core/src/scheduler.ts", "../../runtime-core/src/hmr.ts", "../../runtime-core/src/devtools.ts", "../../runtime-core/src/compat/compatConfig.ts", "../../runtime-core/src/componentEmits.ts", "../../runtime-core/src/componentRenderContext.ts", "../../runtime-core/src/componentRenderUtils.ts", "../../runtime-core/src/apiInject.ts", "../../runtime-core/src/apiWatch.ts", "../../runtime-core/src/components/BaseTransition.ts", "../../runtime-core/src/apiDefineComponent.ts", "../../runtime-core/src/apiAsyncComponent.ts", "../../runtime-core/src/components/KeepAlive.ts", "../../runtime-core/src/apiLifecycle.ts", "../../runtime-core/src/componentOptions.ts", "../../runtime-core/src/componentProps.ts", "../../runtime-core/src/componentSlots.ts", "../../runtime-core/src/directives.ts", "../../runtime-core/src/apiCreateApp.ts", "../../runtime-core/src/rendererTemplateRef.ts", "../../runtime-core/src/hydration.ts", "../../runtime-core/src/profiling.ts", "../../runtime-core/src/renderer.ts", "../../runtime-core/src/components/Suspense.ts", "../../runtime-core/src/components/Teleport.ts", "../../runtime-core/src/helpers/resolveAssets.ts", "../../runtime-core/src/vnode.ts", "../../runtime-core/src/helpers/renderList.ts", "../../runtime-core/src/helpers/createSlots.ts", "../../runtime-core/src/helpers/renderSlot.ts", "../../runtime-core/src/helpers/toHandlers.ts", "../../runtime-core/src/componentPublicInstance.ts", "../../runtime-core/src/component.ts", "../../runtime-core/src/apiComputed.ts", "../../runtime-core/src/apiSetupHelpers.ts", "../../runtime-core/src/h.ts", "../../runtime-core/src/helpers/useSsrContext.ts", "../../runtime-core/src/customFormatter.ts", "../../runtime-core/src/helpers/withMemo.ts", "../../runtime-core/src/index.ts", "../../runtime-dom/src/nodeOps.ts", "../../runtime-dom/src/modules/class.ts", "../../runtime-dom/src/modules/style.ts", "../../runtime-dom/src/modules/attrs.ts", "../../runtime-dom/src/modules/props.ts", "../../runtime-dom/src/modules/events.ts", "../../runtime-dom/src/patchProp.ts", "../../runtime-dom/src/apiCustomElement.ts", "../../runtime-dom/src/helpers/useCssModule.ts", "../../runtime-dom/src/helpers/useCssVars.ts", "../../runtime-dom/src/components/Transition.ts", "../../runtime-dom/src/components/TransitionGroup.ts", "../../runtime-dom/src/directives/vModel.ts", "../../runtime-dom/src/directives/vOn.ts", "../../runtime-dom/src/directives/vShow.ts", "../../runtime-dom/src/index.ts", "../src/dev.ts", "../../compiler-core/src/errors.ts", "../../compiler-core/src/runtimeHelpers.ts", "../../compiler-core/src/ast.ts", "../../compiler-core/src/utils.ts", "../../compiler-core/src/compat/compatConfig.ts", "../../compiler-core/src/parse.ts", "../../compiler-core/src/transforms/hoistStatic.ts", "../../compiler-core/src/transform.ts", "../../compiler-core/src/codegen.ts", "../../../node_modules/.pnpm/estree-walker@2.0.2/node_modules/estree-walker/dist/esm/estree-walker.js", "../../compiler-core/src/babelUtils.ts", "../../compiler-core/src/validateExpression.ts", "../../compiler-core/src/transforms/transformExpression.ts", "../../compiler-core/src/transforms/vIf.ts", "../../compiler-core/src/transforms/vFor.ts", "../../compiler-core/src/transforms/vSlot.ts", "../../compiler-core/src/transforms/transformElement.ts", "../../compiler-core/src/transforms/transformSlotOutlet.ts", "../../compiler-core/src/transforms/vOn.ts", "../../compiler-core/src/transforms/vBind.ts", "../../compiler-core/src/transforms/transformText.ts", "../../compiler-core/src/transforms/vOnce.ts", "../../compiler-core/src/transforms/vModel.ts", "../../compiler-core/src/transforms/vMemo.ts", "../../compiler-core/src/compile.ts", "../../compiler-core/src/transforms/noopDirectiveTransform.ts", "../../compiler-dom/src/runtimeHelpers.ts", "../../compiler-dom/src/decodeHtmlBrowser.ts", "../../compiler-dom/src/parserOptions.ts", "../../compiler-dom/src/transforms/transformStyle.ts", "../../compiler-dom/src/errors.ts", "../../compiler-dom/src/transforms/vHtml.ts", "../../compiler-dom/src/transforms/vText.ts", "../../compiler-dom/src/transforms/vModel.ts", "../../compiler-dom/src/transforms/vOn.ts", "../../compiler-dom/src/transforms/vShow.ts", "../../compiler-dom/src/transforms/warnTransitionChildren.ts", "../../compiler-dom/src/transforms/ignoreSideEffectTags.ts", "../../compiler-dom/src/index.ts"],
  "sourcesContent": ["// @flow\n\nimport * as charCodes from \"charcodes\";\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\nexport const lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nexport const lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n// https://tc39.github.io/ecma262/#sec-line-terminators\nexport function isNewLine(code: number): boolean {\n  switch (code) {\n    case charCodes.lineFeed:\n    case charCodes.carriageReturn:\n    case charCodes.lineSeparator:\n    case charCodes.paragraphSeparator:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexport const skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nexport const skipWhiteSpaceInLine =\n  /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/y;\n\n// Skip whitespace and single-line comments, including /* no newline here */.\n// After this RegExp matches, its lastIndex points to a line terminator, or\n// the start of multi-line comment (which is effectively a line terminator),\n// or the end of string.\nexport const skipWhiteSpaceToLineBreak = new RegExp(\n  // Unfortunately JS doesn't support Perl's atomic /(?>pattern)/ or\n  // possessive quantifiers, so we use a trick to prevent backtracking\n  // when the look-ahead for line terminator fails.\n  \"(?=(\" +\n    // Capture the whitespace and comments that should be skipped inside\n    // a look-ahead assertion, and then re-match the group as a unit.\n    skipWhiteSpaceInLine.source +\n    \"))\\\\1\" +\n    // Look-ahead for either line terminator, start of multi-line comment,\n    // or end of string.\n    /(?=[\\n\\r\\u2028\\u2029]|\\/\\*(?!.*?\\*\\/)|$)/.source,\n  \"y\", // sticky\n);\n\n// https://tc39.github.io/ecma262/#sec-white-space\nexport function isWhitespace(code: number): boolean {\n  switch (code) {\n    case 0x0009: // CHARACTER TABULATION\n    case 0x000b: // LINE TABULATION\n    case 0x000c: // FORM FEED\n    case charCodes.space:\n    case charCodes.nonBreakingSpace:\n    case charCodes.oghamSpaceMark:\n    case 0x2000: // EN QUAD\n    case 0x2001: // EM QUAD\n    case 0x2002: // EN SPACE\n    case 0x2003: // EM SPACE\n    case 0x2004: // THREE-PER-EM SPACE\n    case 0x2005: // FOUR-PER-EM SPACE\n    case 0x2006: // SIX-PER-EM SPACE\n    case 0x2007: // FIGURE SPACE\n    case 0x2008: // PUNCTUATION SPACE\n    case 0x2009: // THIN SPACE\n    case 0x200a: // HAIR SPACE\n    case 0x202f: // NARROW NO-BREAK SPACE\n    case 0x205f: // MEDIUM MATHEMATICAL SPACE\n    case 0x3000: // IDEOGRAPHIC SPACE\n    case 0xfeff: // ZERO WIDTH NO-BREAK SPACE\n      return true;\n\n    default:\n      return false;\n  }\n}\n", "// @flow\n\nimport { lineBreakG } from \"./whitespace\";\n\nexport type Pos = {\n  start: number,\n};\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nexport class Position {\n  line: number;\n  column: number;\n\n  constructor(line: number, col: number) {\n    this.line = line;\n    this.column = col;\n  }\n}\n\nexport class SourceLocation {\n  start: Position;\n  end: Position;\n  filename: string;\n  identifierName: ?string;\n\n  constructor(start: Position, end?: Position) {\n    this.start = start;\n    // $FlowIgnore (may start as null, but initialized later)\n    this.end = end;\n  }\n}\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nexport function getLineInfo(input: string, offset: number): Position {\n  let line = 1;\n  let lineStart = 0;\n  let match;\n  lineBreakG.lastIndex = 0;\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\n    line++;\n    lineStart = lineBreakG.lastIndex;\n  }\n\n  return new Position(line, offset - lineStart);\n}\n", "// @flow\n\nimport type { Options } from \"../options\";\nimport type State from \"../tokenizer/state\";\nimport type { PluginsMap } from \"./index\";\nimport type ScopeHandler from \"../util/scope\";\nimport type ExpressionScopeHandler from \"../util/expression-scope\";\nimport type ClassScopeHandler from \"../util/class-scope\";\nimport type ProductionParameterHandler from \"../util/production-parameter\";\n\nexport default class BaseParser {\n  // Properties set by constructor in index.js\n  declare options: Options;\n  declare inModule: boolean;\n  declare scope: ScopeHandler<*>;\n  declare classScope: ClassScopeHandler;\n  declare prodParam: ProductionParameterHandler;\n  declare expressionScope: ExpressionScopeHandler;\n  declare plugins: PluginsMap;\n  declare filename: ?string;\n  // Names of exports store. `default` is stored as a name for both\n  // `export default foo;` and `export { foo as default };`.\n  declare exportedIdentifiers: Set<string>;\n  sawUnambiguousESM: boolean = false;\n  ambiguousScriptDifferentAst: boolean = false;\n\n  // Initialized by Tokenizer\n  declare state: State;\n  // input and length are not in state as they are constant and we do\n  // not want to ever copy them, which happens if state gets cloned\n  declare input: string;\n  declare length: number;\n\n  hasPlugin(name: string): boolean {\n    return this.plugins.has(name);\n  }\n\n  getPluginOption(plugin: string, name: string) {\n    // $FlowIssue\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\n  }\n}\n", "// @flow\n\n/*:: declare var invariant; */\n\nimport BaseParser from \"./base\";\nimport type { Comment, Node } from \"../types\";\nimport * as charCodes from \"charcodes\";\n\n/**\n * A whitespace token containing comments\n * @typedef CommentWhitespace\n * @type {object}\n * @property {number} start - the start of the whitespace token.\n * @property {number} end - the end of the whitespace token.\n * @property {Array<Comment>} comments - the containing comments\n * @property {Node | null} leadingNode - the immediately preceding AST node of the whitespace token\n * @property {Node | null} trailingNode - the immediately following AST node of the whitespace token\n * @property {Node | null} containingNode - the innermost AST node containing the whitespace\n *                                         with minimal size (|end - start|)\n */\nexport type CommentWhitespace = {\n  start: number,\n  end: number,\n  comments: Array<Comment>,\n  leadingNode: Node | null,\n  trailingNode: Node | null,\n  containingNode: Node | null,\n};\n\n/**\n * Merge comments with node's trailingComments or assign comments to be\n * trailingComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n *\n * @param {Node} node\n * @param {Array<Comment>} comments\n */\nfunction setTrailingComments(node: Node, comments: Array<Comment>) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\n\n/**\n * Merge comments with node's leadingComments or assign comments to be\n * leadingComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n *\n * @param {Node} node\n * @param {Array<Comment>} comments\n */\nfunction setLeadingComments(node: Node, comments: Array<Comment>) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\n\n/**\n * Merge comments with node's innerComments or assign comments to be\n * innerComments. New comments will be placed before old comments\n * because the commentStack is enumerated reversely.\n *\n * @param {Node} node\n * @param {Array<Comment>} comments\n */\nexport function setInnerComments(node: Node, comments: Array<Comment>) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\n\n/**\n * Given node and elements array, if elements has non-null element,\n * merge comments to its trailingComments, otherwise merge comments\n * to node's innerComments\n *\n * @param {Node} node\n * @param {Array<Node>} elements\n * @param {Array<Comment>} comments\n */\nfunction adjustInnerComments(\n  node: Node,\n  elements: Array<Node>,\n  commentWS: CommentWhitespace,\n) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\n\n/** @class CommentsParser */\nexport default class CommentsParser extends BaseParser {\n  addComment(comment: Comment): void {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.comments.push(comment);\n  }\n\n  /**\n   * Given a newly created AST node _n_, attach _n_ to a comment whitespace _w_ if applicable\n   * {@see {@link CommentWhitespace}}\n   *\n   * @param {Node} node\n   * @returns {void}\n   * @memberof CommentsParser\n   */\n  processComment(node: Node): void {\n    const { commentStack } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n\n    const { start: nodeStart } = node;\n    // invariant: for all 0 <= j <= i, let c = commentStack[j], c must satisfy c.end < node.end\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        // by definition of commentWhiteSpace, this implies commentWS.start > nodeStart\n        // so node can be a containingNode candidate. At this time we can finalize the comment\n        // whitespace, because\n        // 1) its leadingNode or trailingNode, if exists, will not change\n        // 2) its containingNode have been assigned and will not change because it is the\n        //    innermost minimal-sized AST node\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        // stop the loop when commentEnd <= nodeStart\n        break;\n      }\n    }\n  }\n\n  /**\n   * Assign the comments of comment whitespaces to related AST nodes.\n   * Also adjust innerComments following trailing comma.\n   *\n   * @memberof CommentsParser\n   */\n  finalizeComment(commentWS: CommentWhitespace) {\n    const { comments } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      /*:: invariant(commentWS.containingNode !== null) */\n      const { containingNode: node, start: commentStart } = commentWS;\n      if (this.input.charCodeAt(commentStart - 1) === charCodes.comma) {\n        // If a commentWhitespace follows a comma and the containingNode allows\n        // list structures with trailing comma, merge it to the trailingComment\n        // of the last non-null list element\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n          case \"RecordExpression\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n          case \"TupleExpression\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default: {\n            setInnerComments(node, comments);\n          }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n\n  /**\n   * Drains remaning commentStack and applies finalizeComment\n   * to each comment whitespace. Used only in parseExpression\n   * where the top level AST node is _not_ Program\n   * {@see {@link CommentsParser#finalizeComment}}\n   *\n   * @memberof CommentsParser\n   */\n  finalizeRemainingComments() {\n    const { commentStack } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n\n  /**\n   * Reset previous node trailing comments. Used in object / class\n   * property parsing. We parse `async`, `static`, `set` and `get`\n   * as an identifier but may reinterepret it into an async/static/accessor\n   * method later. In this case the identifier is not part of the AST and we\n   * should sync the knowledge to commentStacks\n   *\n   * For example, when parsing */\n  // async /* 1 */ function f() {}\n  /*\n   * the comment whitespace \"* 1 *\" has leading node Identifier(async). When\n   * we see the function token, we create a Function node and mark \"* 1 *\" as\n   * inner comments. So \"* 1 *\" should be detached from the Identifier node.\n   *\n   * @param {N.Node} node the last finished AST node _before_ current token\n   * @returns\n   * @memberof CommentsParser\n   */\n  resetPreviousNodeTrailingComments(node: Node) {\n    const { commentStack } = this.state;\n    const { length } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n\n  /**\n   * Attach a node to the comment whitespaces right before/after\n   * the given range.\n   *\n   * This is used to properly attach comments around parenthesized\n   * expressions as leading/trailing comments of the inner expression.\n   *\n   * @param {Node} node\n   * @param {number} start\n   * @param {number} end\n   */\n  takeSurroundingComments(node: Node, start: number, end: number) {\n    const { commentStack } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\n", "// @flow\n\nexport const ErrorCodes = Object.freeze({\n  SyntaxError: \"BABEL_PARSER_SYNTAX_ERROR\",\n  SourceTypeModuleError: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\",\n});\n\nexport type ErrorCode = $Values<typeof ErrorCodes>;\n", "// @flow\n\nimport { makeErrorTemplates, ErrorCodes } from \"./error\";\n\n/* eslint sort-keys: \"error\" */\n\n/**\n * @module parser/error-message\n */\n\n// The Errors key follows https://cs.chromium.org/chromium/src/v8/src/common/message-template.h unless it does not exist\nexport const ErrorMessages = makeErrorTemplates(\n  {\n    AccessorIsGenerator: \"A %0ter cannot be a generator.\",\n    ArgumentsInClass:\n      \"'arguments' is only allowed in functions and class methods.\",\n    AsyncFunctionInSingleStatementContext:\n      \"Async functions can only be declared at the top level or inside a block.\",\n    AwaitBindingIdentifier:\n      \"Can not use 'await' as identifier inside an async function.\",\n    AwaitBindingIdentifierInStaticBlock:\n      \"Can not use 'await' as identifier inside a static block.\",\n    AwaitExpressionFormalParameter:\n      \"'await' is not allowed in async function parameters.\",\n    AwaitNotInAsyncContext:\n      \"'await' is only allowed within async functions and at the top levels of modules.\",\n    AwaitNotInAsyncFunction: \"'await' is only allowed within async functions.\",\n    BadGetterArity: \"A 'get' accesor must not have any formal parameters.\",\n    BadSetterArity: \"A 'set' accesor must have exactly one formal parameter.\",\n    BadSetterRestParameter:\n      \"A 'set' accesor function argument must not be a rest parameter.\",\n    ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n    ConstructorClassPrivateField:\n      \"Classes may not have a private field named '#constructor'.\",\n    ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n    ConstructorIsAsync: \"Constructor can't be an async function.\",\n    ConstructorIsGenerator: \"Constructor can't be a generator.\",\n    DeclarationMissingInitializer: \"'%0' require an initialization value.\",\n    DecoratorBeforeExport:\n      \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.\",\n    DecoratorConstructor:\n      \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n    DecoratorExportClass:\n      \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n    DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n    DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n    DeletePrivateField: \"Deleting a private field is not allowed.\",\n    DestructureNamedImport:\n      \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n    DuplicateConstructor: \"Duplicate constructor in the same class.\",\n    DuplicateDefaultExport: \"Only one default export allowed per module.\",\n    DuplicateExport:\n      \"`%0` has already been exported. Exported identifiers must be unique.\",\n    DuplicateProto: \"Redefinition of __proto__ property.\",\n    DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n    ElementAfterRest: \"Rest element must be last element.\",\n    EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n    ExportBindingIsString:\n      \"A string literal cannot be used as an exported binding without `from`.\\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?\",\n    ExportDefaultFromAsIdentifier:\n      \"'from' is not allowed as an identifier after 'export default'.\",\n    ForInOfLoopInitializer:\n      \"'%0' loop variable declaration may not have an initializer.\",\n    ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n    ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n    GeneratorInSingleStatementContext:\n      \"Generators can only be declared at the top level or inside a block.\",\n    IllegalBreakContinue: \"Unsyntactic %0.\",\n    IllegalLanguageModeDirective:\n      \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n    IllegalReturn: \"'return' outside of function.\",\n    ImportBindingIsString:\n      'A string literal cannot be used as an imported binding.\\n- Did you mean `import { \"%0\" as foo }`?',\n    ImportCallArgumentTrailingComma:\n      \"Trailing comma is disallowed inside import(...) arguments.\",\n    ImportCallArity: \"`import()` requires exactly %0.\",\n    ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n    ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n    InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n    InvalidCodePoint: \"Code point out of bounds.\",\n    InvalidDecimal: \"Invalid decimal.\",\n    InvalidDigit: \"Expected number in radix %0.\",\n    InvalidEscapeSequence: \"Bad character escape sequence.\",\n    InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n    InvalidEscapedReservedWord: \"Escape sequence in keyword %0.\",\n    InvalidIdentifier: \"Invalid identifier %0.\",\n    InvalidLhs: \"Invalid left-hand side in %0.\",\n    InvalidLhsBinding: \"Binding invalid left-hand side in %0.\",\n    InvalidNumber: \"Invalid number.\",\n    InvalidOrMissingExponent:\n      \"Floating-point numbers require a valid exponent after the 'e'.\",\n    InvalidOrUnexpectedToken: \"Unexpected character '%0'.\",\n    InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n    InvalidPrivateFieldResolution: \"Private name #%0 is not defined.\",\n    InvalidPropertyBindingPattern: \"Binding member expression.\",\n    InvalidRecordProperty:\n      \"Only properties and spread elements are allowed in record definitions.\",\n    InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n    LabelRedeclaration: \"Label '%0' is already declared.\",\n    LetInLexicalBinding:\n      \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n    LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n    MalformedRegExpFlags: \"Invalid regular expression flag.\",\n    MissingClassName: \"A class name is required.\",\n    MissingEqInAssignment:\n      \"Only '=' operator can be used for specifying default value.\",\n    MissingSemicolon: \"Missing semicolon.\",\n    MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n    MixingCoalesceWithLogical:\n      \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n    ModuleAttributeDifferentFromType:\n      \"The only accepted module attribute is `type`.\",\n    ModuleAttributeInvalidValue:\n      \"Only string literals are allowed as module attribute values.\",\n    ModuleAttributesWithDuplicateKeys:\n      'Duplicate key \"%0\" is not allowed in module attributes.',\n    ModuleExportNameHasLoneSurrogate:\n      \"An export name cannot include a lone surrogate, found '\\\\u%0'.\",\n    ModuleExportUndefined: \"Export '%0' is not defined.\",\n    MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n    NewlineAfterThrow: \"Illegal newline after throw.\",\n    NoCatchOrFinally: \"Missing catch or finally clause.\",\n    NumberIdentifier: \"Identifier directly after number.\",\n    NumericSeparatorInEscapeSequence:\n      \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n    ObsoleteAwaitStar:\n      \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n    OptionalChainingNoNew:\n      \"Constructors in/after an Optional Chain are not allowed.\",\n    OptionalChainingNoTemplate:\n      \"Tagged Template Literals are not allowed in optionalChain.\",\n    OverrideOnConstructor:\n      \"'override' modifier cannot appear on a constructor declaration.\",\n    ParamDupe: \"Argument name clash.\",\n    PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n    PatternHasMethod: \"Object pattern can't contain methods.\",\n    // This error is only used by the smart-mix proposal\n    PipeBodyIsTighter:\n      \"Unexpected %0 after pipeline body; any %0 expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n    PipeTopicRequiresHackPipes:\n      'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n    PipeTopicUnbound:\n      \"Topic reference is unbound; it must be inside a pipe body.\",\n    PipeTopicUnconfiguredToken:\n      'Invalid topic token %0. In order to use %0 as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"%0\" }.',\n    PipeTopicUnused:\n      \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n    PipeUnparenthesizedBody:\n      \"Hack-style pipe body cannot be an unparenthesized %0 expression; please wrap it in parentheses.\",\n\n    // Messages whose codes start with \u201CPipeline\u201D or \u201CPrimaryTopic\u201D\n    // are retained for backwards compatibility\n    // with the deprecated smart-mix pipe operator proposal plugin.\n    // They are subject to removal in a future major version.\n    PipelineBodyNoArrow:\n      'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n    PipelineBodySequenceExpression:\n      \"Pipeline body may not be a comma-separated sequence expression.\",\n    PipelineHeadSequenceExpression:\n      \"Pipeline head should not be a comma-separated sequence expression.\",\n    PipelineTopicUnused:\n      \"Pipeline is in topic style but does not use topic reference.\",\n    PrimaryTopicNotAllowed:\n      \"Topic reference was used in a lexical context without topic binding.\",\n    PrimaryTopicRequiresSmartPipeline:\n      'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n\n    PrivateInExpectedIn:\n      \"Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).\",\n    PrivateNameRedeclaration: \"Duplicate private name #%0.\",\n    RecordExpressionBarIncorrectEndSyntaxType:\n      \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n    RecordExpressionBarIncorrectStartSyntaxType:\n      \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n    RecordExpressionHashIncorrectStartSyntaxType:\n      \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n    RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n    RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n    SloppyFunction:\n      \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n    StaticPrototype: \"Classes may not have static property named prototype.\",\n    StrictDelete: \"Deleting local variable in strict mode.\",\n    StrictEvalArguments: \"Assigning to '%0' in strict mode.\",\n    StrictEvalArgumentsBinding: \"Binding '%0' in strict mode.\",\n    StrictFunction:\n      \"In strict mode code, functions can only be declared at top level or inside a block.\",\n    StrictNumericEscape:\n      \"The only valid numeric escape in strict mode is '\\\\0'.\",\n    StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n    StrictWith: \"'with' in strict mode.\",\n    SuperNotAllowed:\n      \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n    SuperPrivateField: \"Private fields can't be accessed on super.\",\n    TrailingDecorator: \"Decorators must be attached to a class element.\",\n    TupleExpressionBarIncorrectEndSyntaxType:\n      \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n    TupleExpressionBarIncorrectStartSyntaxType:\n      \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n    TupleExpressionHashIncorrectStartSyntaxType:\n      \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n    UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n    UnexpectedAwaitAfterPipelineBody:\n      'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n    UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n    UnexpectedImportExport:\n      \"'import' and 'export' may only appear at the top level.\",\n    UnexpectedKeyword: \"Unexpected keyword '%0'.\",\n    UnexpectedLeadingDecorator:\n      \"Leading decorators must be attached to a class declaration.\",\n    UnexpectedLexicalDeclaration:\n      \"Lexical declaration cannot appear in a single-statement context.\",\n    UnexpectedNewTarget:\n      \"`new.target` can only be used in functions or class properties.\",\n    UnexpectedNumericSeparator:\n      \"A numeric separator is only allowed between two digits.\",\n    UnexpectedPrivateField:\n      \"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",\n    UnexpectedReservedWord: \"Unexpected reserved word '%0'.\",\n    UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n    UnexpectedToken: \"Unexpected token '%0'.\",\n    UnexpectedTokenUnaryExponentiation:\n      \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n    UnsupportedBind: \"Binding should be performed on object property.\",\n    UnsupportedDecoratorExport:\n      \"A decorated export must export a class declaration.\",\n    UnsupportedDefaultExport:\n      \"Only expressions, functions or classes are allowed as the `default` export.\",\n    UnsupportedImport:\n      \"`import` can only be used in `import()` or `import.meta`.\",\n    UnsupportedMetaProperty: \"The only valid meta property for %0 is %0.%1.\",\n    UnsupportedParameterDecorator:\n      \"Decorators cannot be used to decorate parameters.\",\n    UnsupportedPropertyDecorator:\n      \"Decorators cannot be used to decorate object literal properties.\",\n    UnsupportedSuper:\n      \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n    UnterminatedComment: \"Unterminated comment.\",\n    UnterminatedRegExp: \"Unterminated regular expression.\",\n    UnterminatedString: \"Unterminated string constant.\",\n    UnterminatedTemplate: \"Unterminated template.\",\n    VarRedeclaration: \"Identifier '%0' has already been declared.\",\n    YieldBindingIdentifier:\n      \"Can not use 'yield' as identifier inside a generator.\",\n    YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n    ZeroDigitNumericSeparator:\n      \"Numeric separator can not be used after leading 0.\",\n  },\n  /* code */ ErrorCodes.SyntaxError,\n);\n\nexport const SourceTypeModuleErrorMessages = makeErrorTemplates(\n  {\n    ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: \"module\"'`,\n    ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n  },\n  /* code */ ErrorCodes.SourceTypeModuleError,\n);\n", "// @flow\n/* eslint sort-keys: \"error\" */\nimport { getLineInfo, type Position } from \"../util/location\";\nimport CommentsParser from \"./comments\";\nimport { type ErrorCode, ErrorCodes } from \"./error-codes\";\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\ntype ErrorContext = {\n  pos: number,\n  loc: Position,\n  missingPlugin?: Array<string>,\n  code?: string,\n  reasonCode?: String,\n};\nexport type ParsingError = SyntaxError & ErrorContext;\n\nexport type ErrorTemplate = {\n  code: ErrorCode,\n  template: string,\n  reasonCode: string,\n};\nexport type ErrorTemplates = {\n  [key: string]: ErrorTemplate,\n};\n\ntype SyntaxPlugin = \"flow\" | \"typescript\" | \"jsx\" | typeof undefined;\n\nfunction keepReasonCodeCompat(reasonCode: string, syntaxPlugin: SyntaxPlugin) {\n  if (!process.env.BABEL_8_BREAKING) {\n    // For consistency in TypeScript and Flow error codes\n    if (syntaxPlugin === \"flow\" && reasonCode === \"PatternIsOptional\") {\n      return \"OptionalBindingPattern\";\n    }\n  }\n  return reasonCode;\n}\n\nexport function makeErrorTemplates(\n  messages: {\n    [key: string]: string,\n  },\n  code: ErrorCode,\n  syntaxPlugin?: SyntaxPlugin,\n): ErrorTemplates {\n  const templates: ErrorTemplates = {};\n  Object.keys(messages).forEach(reasonCode => {\n    templates[reasonCode] = Object.freeze({\n      code,\n      reasonCode: keepReasonCodeCompat(reasonCode, syntaxPlugin),\n      template: messages[reasonCode],\n    });\n  });\n  return Object.freeze(templates);\n}\n\nexport { ErrorCodes };\nexport {\n  ErrorMessages as Errors,\n  SourceTypeModuleErrorMessages as SourceTypeModuleErrors,\n} from \"./error-message\";\n\nexport type raiseFunction = (number, ErrorTemplate, ...any) => void;\n\nexport default class ParserError extends CommentsParser {\n  // Forward-declaration: defined in tokenizer/index.js\n  /*::\n  +isLookahead: boolean;\n  */\n\n  getLocationForPosition(pos: number): Position {\n    let loc;\n    if (pos === this.state.start) loc = this.state.startLoc;\n    else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;\n    else if (pos === this.state.end) loc = this.state.endLoc;\n    else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;\n    else loc = getLineInfo(this.input, pos);\n\n    return loc;\n  }\n\n  raise(\n    pos: number,\n    { code, reasonCode, template }: ErrorTemplate,\n    ...params: any\n  ): Error | empty {\n    return this.raiseWithData(pos, { code, reasonCode }, template, ...params);\n  }\n\n  /**\n   * Raise a parsing error on given position pos. If errorRecovery is true,\n   * it will first search current errors and overwrite the error thrown on the exact\n   * position before with the new error message. If errorRecovery is false, it\n   * fallbacks to `raise`.\n   *\n   * @param {number} pos\n   * @param {string} errorTemplate\n   * @param {...any} params\n   * @returns {(Error | empty)}\n   * @memberof ParserError\n   */\n  raiseOverwrite(\n    pos: number,\n    { code, template }: ErrorTemplate,\n    ...params: any\n  ): Error | empty {\n    const loc = this.getLocationForPosition(pos);\n    const message =\n      template.replace(/%(\\d+)/g, (_, i: number) => params[i]) +\n      ` (${loc.line}:${loc.column})`;\n    if (this.options.errorRecovery) {\n      const errors = this.state.errors;\n      for (let i = errors.length - 1; i >= 0; i--) {\n        const error = errors[i];\n        if (error.pos === pos) {\n          return Object.assign(error, { message });\n        } else if (error.pos < pos) {\n          break;\n        }\n      }\n    }\n    return this._raise({ code, loc, pos }, message);\n  }\n\n  raiseWithData(\n    pos: number,\n    data?: {\n      missingPlugin?: Array<string>,\n      code?: string,\n    },\n    errorTemplate: string,\n    ...params: any\n  ): Error | empty {\n    const loc = this.getLocationForPosition(pos);\n    const message =\n      errorTemplate.replace(/%(\\d+)/g, (_, i: number) => params[i]) +\n      ` (${loc.line}:${loc.column})`;\n    return this._raise(Object.assign(({ loc, pos }: Object), data), message);\n  }\n\n  _raise(errorContext: ErrorContext, message: string): Error | empty {\n    // $FlowIgnore\n    const err: SyntaxError & ErrorContext = new SyntaxError(message);\n    Object.assign(err, errorContext);\n    if (this.options.errorRecovery) {\n      if (!this.isLookahead) this.state.errors.push(err);\n      return err;\n    } else {\n      throw err;\n    }\n  }\n}\n", "// @flow\n\nimport { type TokenType } from \"../tokenizer/types\";\nimport type Parser from \"../parser\";\nimport type { ExpressionErrors } from \"../parser/util\";\nimport * as N from \"../types\";\nimport type { Position } from \"../util/location\";\nimport { Errors } from \"../parser/error\";\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    parseRegExpLiteral({ pattern, flags }): N.Node {\n      let regex = null;\n      try {\n        regex = new RegExp(pattern, flags);\n      } catch (e) {\n        // In environments that don't support these flags value will\n        // be null as the regex can't be represented natively.\n      }\n      const node = this.estreeParseLiteral<N.EstreeRegExpLiteral>(regex);\n      node.regex = { pattern, flags };\n\n      return node;\n    }\n\n    parseBigIntLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/es2020.md#bigintliteral\n      let bigInt;\n      try {\n        // $FlowIgnore\n        bigInt = BigInt(value);\n      } catch {\n        bigInt = null;\n      }\n      const node = this.estreeParseLiteral<N.EstreeBigIntLiteral>(bigInt);\n      node.bigint = String(node.value || value);\n\n      return node;\n    }\n\n    parseDecimalLiteral(value: any): N.Node {\n      // https://github.com/estree/estree/blob/master/experimental/decimal.md\n      // todo: use BigDecimal when node supports it.\n      const decimal = null;\n      const node = this.estreeParseLiteral(decimal);\n      node.decimal = String(node.value || value);\n\n      return node;\n    }\n\n    estreeParseLiteral<T: N.Node>(value: any) {\n      return this.parseLiteral<T>(value, \"Literal\");\n    }\n\n    parseStringLiteral(value: any): N.Node {\n      return this.estreeParseLiteral(value);\n    }\n\n    parseNumericLiteral(value: any): any {\n      return this.estreeParseLiteral(value);\n    }\n\n    parseNullLiteral(): N.Node {\n      return this.estreeParseLiteral(null);\n    }\n\n    parseBooleanLiteral(value: boolean): N.BooleanLiteral {\n      return this.estreeParseLiteral(value);\n    }\n\n    directiveToStmt(directive: N.Directive): N.ExpressionStatement {\n      const directiveLiteral = directive.value;\n\n      const stmt = this.startNodeAt(directive.start, directive.loc.start);\n      const expression = this.startNodeAt(\n        directiveLiteral.start,\n        directiveLiteral.loc.start,\n      );\n\n      expression.value = directiveLiteral.extra.expressionValue;\n      expression.raw = directiveLiteral.extra.raw;\n\n      stmt.expression = this.finishNodeAt(\n        expression,\n        \"Literal\",\n        directiveLiteral.end,\n        directiveLiteral.loc.end,\n      );\n      stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n\n      return this.finishNodeAt(\n        stmt,\n        \"ExpressionStatement\",\n        directive.end,\n        directive.loc.end,\n      );\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    initFunction(\n      node: N.BodilessFunctionOrMethodBase,\n      isAsync: ?boolean,\n    ): void {\n      super.initFunction(node, isAsync);\n      node.expression = false;\n    }\n\n    checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n      if (node != null && this.isObjectProperty(node)) {\n        this.checkDeclaration(((node: any): N.EstreeProperty).value);\n      } else {\n        super.checkDeclaration(node);\n      }\n    }\n\n    getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n      return ((method: any): N.EstreeProperty | N.EstreeMethodDefinition).value\n        .params;\n    }\n\n    isValidDirective(stmt: N.Statement): boolean {\n      return (\n        stmt.type === \"ExpressionStatement\" &&\n        stmt.expression.type === \"Literal\" &&\n        typeof stmt.expression.value === \"string\" &&\n        !stmt.expression.extra?.parenthesized\n      );\n    }\n\n    parseBlockBody(\n      node: N.BlockStatementLike,\n      ...args: [?boolean, boolean, TokenType, void | (boolean => void)]\n    ): void {\n      super.parseBlockBody(node, ...args);\n\n      const directiveStatements = node.directives.map(d =>\n        this.directiveToStmt(d),\n      );\n      node.body = directiveStatements.concat(node.body);\n      // $FlowIgnore - directives isn't optional in the type definition\n      delete node.directives;\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      );\n      if (method.typeParameters) {\n        // $FlowIgnore\n        method.value.typeParameters = method.typeParameters;\n        delete method.typeParameters;\n      }\n      classBody.body.push(method);\n    }\n\n    parsePrivateName(): any {\n      const node = super.parsePrivateName();\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return node;\n        }\n      }\n      return this.convertPrivateNameToPrivateIdentifier(node);\n    }\n\n    convertPrivateNameToPrivateIdentifier(\n      node: N.PrivateName,\n    ): N.EstreePrivateIdentifier {\n      const name = super.getPrivateNameSV(node);\n      node = (node: any);\n      delete node.id;\n      node.name = name;\n      node.type = \"PrivateIdentifier\";\n      return node;\n    }\n\n    isPrivateName(node: N.Node): boolean {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.isPrivateName(node);\n        }\n      }\n      return node.type === \"PrivateIdentifier\";\n    }\n\n    getPrivateNameSV(node: N.Node): string {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return super.getPrivateNameSV(node);\n        }\n      }\n      return node.name;\n    }\n\n    parseLiteral<T: N.Node>(value: any, type: $ElementType<T, \"type\">): T {\n      const node = super.parseLiteral<T>(value, type);\n      node.raw = node.extra.raw;\n      delete node.extra;\n\n      return node;\n    }\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpression: ?boolean,\n      isMethod?: boolean = false,\n    ): void {\n      super.parseFunctionBody(node, allowExpression, isMethod);\n      node.expression = node.body.type !== \"BlockStatement\";\n    }\n\n    parseMethod<T: N.MethodLike>(\n      node: T,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowDirectSuper: boolean,\n      type: string,\n      inClassScope: boolean = false,\n    ): T {\n      let funcNode = this.startNode();\n      funcNode.kind = node.kind; // provide kind, so super method correctly sets state\n      funcNode = super.parseMethod(\n        funcNode,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowDirectSuper,\n        type,\n        inClassScope,\n      );\n      funcNode.type = \"FunctionExpression\";\n      delete funcNode.kind;\n      // $FlowIgnore\n      node.value = funcNode;\n      if (type === \"ClassPrivateMethod\") {\n        // $FlowIgnore\n        node.computed = false;\n      }\n      type = \"MethodDefinition\";\n      return this.finishNode(node, type);\n    }\n\n    parseClassProperty(...args: [N.ClassProperty]): any {\n      const propertyNode = (super.parseClassProperty(...args): any);\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return (propertyNode: N.EstreePropertyDefinition);\n        }\n      }\n      propertyNode.type = \"PropertyDefinition\";\n      return (propertyNode: N.EstreePropertyDefinition);\n    }\n\n    parseClassPrivateProperty(...args: [N.ClassPrivateProperty]): any {\n      const propertyNode = (super.parseClassPrivateProperty(...args): any);\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n          return (propertyNode: N.EstreePropertyDefinition);\n        }\n      }\n      propertyNode.type = \"PropertyDefinition\";\n      propertyNode.computed = false;\n      return (propertyNode: N.EstreePropertyDefinition);\n    }\n\n    parseObjectMethod(\n      prop: N.ObjectMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n    ): ?N.ObjectMethod {\n      const node: N.EstreeProperty = (super.parseObjectMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ): any);\n\n      if (node) {\n        node.type = \"Property\";\n        if (((node: any): N.ClassMethod).kind === \"method\") node.kind = \"init\";\n        node.shorthand = false;\n      }\n\n      return (node: any);\n    }\n\n    parseObjectProperty(\n      prop: N.ObjectProperty,\n      startPos: ?number,\n      startLoc: ?Position,\n      isPattern: boolean,\n      refExpressionErrors: ?ExpressionErrors,\n    ): ?N.ObjectProperty {\n      const node: N.EstreeProperty = (super.parseObjectProperty(\n        prop,\n        startPos,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      ): any);\n\n      if (node) {\n        node.kind = \"init\";\n        node.type = \"Property\";\n      }\n\n      return (node: any);\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node != null && this.isObjectProperty(node)) {\n        return this.isAssignable(node.value, isBinding);\n      }\n      return super.isAssignable(node, isBinding);\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): N.Node {\n      if (node != null && this.isObjectProperty(node)) {\n        this.toAssignable(node.value, isLHS);\n\n        return node;\n      }\n\n      return super.toAssignable(node, isLHS);\n    }\n\n    toAssignableObjectExpressionProp(prop: N.Node, ...args) {\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        this.raise(prop.key.start, Errors.PatternHasAccessor);\n      } else if (prop.method) {\n        this.raise(prop.key.start, Errors.PatternHasMethod);\n      } else {\n        super.toAssignableObjectExpressionProp(prop, ...args);\n      }\n    }\n\n    finishCallExpression<T: N.CallExpression | N.OptionalCallExpression>(\n      node: T,\n      optional: boolean,\n    ): N.Expression {\n      super.finishCallExpression(node, optional);\n\n      if (node.callee.type === \"Import\") {\n        ((node: N.Node): N.EstreeImportExpression).type = \"ImportExpression\";\n        ((node: N.Node): N.EstreeImportExpression).source = node.arguments[0];\n        if (this.hasPlugin(\"importAssertions\")) {\n          ((node: N.Node): N.EstreeImportExpression).attributes =\n            node.arguments[1] ?? null;\n        }\n        // $FlowIgnore - arguments isn't optional in the type definition\n        delete node.arguments;\n        // $FlowIgnore - callee isn't optional in the type definition\n        delete node.callee;\n      }\n\n      return node;\n    }\n\n    toReferencedArguments(\n      node:\n        | N.CallExpression\n        | N.OptionalCallExpression\n        | N.EstreeImportExpression,\n      /* isParenthesizedExpr?: boolean, */\n    ) {\n      // ImportExpressions do not have an arguments array.\n      if (node.type === \"ImportExpression\") {\n        return;\n      }\n\n      super.toReferencedArguments(node);\n    }\n\n    parseExport(node: N.Node) {\n      super.parseExport(node);\n\n      switch (node.type) {\n        case \"ExportAllDeclaration\":\n          node.exported = null;\n          break;\n\n        case \"ExportNamedDeclaration\":\n          if (\n            node.specifiers.length === 1 &&\n            node.specifiers[0].type === \"ExportNamespaceSpecifier\"\n          ) {\n            node.type = \"ExportAllDeclaration\";\n            node.exported = node.specifiers[0].exported;\n            delete node.specifiers;\n          }\n\n          break;\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls: ?boolean,\n      state: N.ParseSubscriptState,\n    ) {\n      const node = super.parseSubscript(\n        base,\n        startPos,\n        startLoc,\n        noCalls,\n        state,\n      );\n\n      if (state.optionalChainMember) {\n        // https://github.com/estree/estree/blob/master/es2020.md#chainexpression\n        if (\n          node.type === \"OptionalMemberExpression\" ||\n          node.type === \"OptionalCallExpression\"\n        ) {\n          node.type = node.type.substring(8); // strip Optional prefix\n        }\n        if (state.stop) {\n          const chain = this.startNodeAtNode(node);\n          chain.expression = node;\n          return this.finishNode(chain, \"ChainExpression\");\n        }\n      } else if (\n        node.type === \"MemberExpression\" ||\n        node.type === \"CallExpression\"\n      ) {\n        node.optional = false;\n      }\n\n      return node;\n    }\n\n    hasPropertyAsPrivateName(node: N.Node): boolean {\n      if (node.type === \"ChainExpression\") {\n        node = node.expression;\n      }\n      return super.hasPropertyAsPrivateName(node);\n    }\n\n    isOptionalChain(node: N.Node): boolean {\n      return node.type === \"ChainExpression\";\n    }\n\n    isObjectProperty(node: N.Node): boolean {\n      return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n    }\n\n    isObjectMethod(node: N.Node): boolean {\n      return node.method || node.kind === \"get\" || node.kind === \"set\";\n    }\n  };\n", "// @flow\n\n// The token context is used to track whether the apostrophe \"`\"\n// starts or ends a string template\n\nexport class TokContext {\n  constructor(token: string, preserveSpace?: boolean) {\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n\n  token: string;\n  preserveSpace: boolean;\n}\n\nexport const types: {\n  [key: string]: TokContext,\n} = {\n  brace: new TokContext(\"{\"),\n  template: new TokContext(\"`\", true),\n};\n", "// @flow\nimport { types as tc, type TokContext } from \"./context\";\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between 1) binary\n// expression (<) and JSX Tag start (<name>); 2) object literal and JSX\n// texts. It is set on the `updateContext` function in the JSX plugin.\n\n// The `startsExpr` property is used to determine whether an expression\n// may be the \u201Cargument\u201D subexpression of a `yield` expression or\n// `yield` statement. It is set on all token types that may be at the\n// start of a subexpression.\n\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\n\ntype TokenOptions = {\n  keyword?: string,\n  beforeExpr?: boolean,\n  startsExpr?: boolean,\n  rightAssociative?: boolean,\n  isLoop?: boolean,\n  isAssign?: boolean,\n  prefix?: boolean,\n  postfix?: boolean,\n  binop?: ?number,\n};\n\n// Internally the tokenizer stores token as a number\nexport opaque type TokenType = number;\n\n// The `ExportedTokenType` is exported via `tokTypes` and accessible\n// when `tokens: true` is enabled. Unlike internal token type, it provides\n// metadata of the tokens.\nexport class ExportedTokenType {\n  label: string;\n  keyword: ?string;\n  beforeExpr: boolean;\n  startsExpr: boolean;\n  rightAssociative: boolean;\n  isLoop: boolean;\n  isAssign: boolean;\n  prefix: boolean;\n  postfix: boolean;\n  binop: ?number;\n  // todo(Babel 8): remove updateContext from exposed token layout\n  declare updateContext: ?(context: Array<TokContext>) => void;\n\n  constructor(label: string, conf: TokenOptions = {}) {\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    if (!process.env.BABEL_8_BREAKING) {\n      this.updateContext = null;\n    }\n  }\n}\n\n// A map from keyword/keyword-like string value to the token type\nexport const keywords = new Map<string, TokenType>();\n\nfunction createKeyword(name: string, options: TokenOptions = {}): TokenType {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name: string, binop: number) {\n  return createToken(name, { beforeExpr, binop });\n}\n\nlet tokenTypeCounter = -1;\nexport const tokenTypes: ExportedTokenType[] = [];\nconst tokenLabels: string[] = [];\nconst tokenBinops: number[] = [];\nconst tokenBeforeExprs: boolean[] = [];\nconst tokenStartsExprs: boolean[] = [];\nconst tokenPrefixes: boolean[] = [];\n\nfunction createToken(name: string, options: TokenOptions = {}): TokenType {\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push(options.binop ?? -1);\n  tokenBeforeExprs.push(options.beforeExpr ?? false);\n  tokenStartsExprs.push(options.startsExpr ?? false);\n  tokenPrefixes.push(options.prefix ?? false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n\n  return tokenTypeCounter;\n}\n\nfunction createKeywordLike(\n  name: string,\n  options: TokenOptions = {},\n): TokenType {\n  ++tokenTypeCounter;\n  keywords.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push(options.binop ?? -1);\n  tokenBeforeExprs.push(options.beforeExpr ?? false);\n  tokenStartsExprs.push(options.startsExpr ?? false);\n  tokenPrefixes.push(options.prefix ?? false);\n  // In the exported token type, we set the label as \"name\" for backward compatibility with Babel 7\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n\n  return tokenTypeCounter;\n}\n\n// For performance the token type helpers depend on the following declarations order.\n// When adding new token types, please also check if the token helpers need update.\n\nexport const tt: { [name: string]: TokenType } = {\n  // Punctuation token types.\n  bracketL: createToken(\"[\", { beforeExpr, startsExpr }),\n  bracketHashL: createToken(\"#[\", { beforeExpr, startsExpr }),\n  bracketBarL: createToken(\"[|\", { beforeExpr, startsExpr }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", { beforeExpr, startsExpr }),\n  braceBarL: createToken(\"{|\", { beforeExpr, startsExpr }),\n  braceHashL: createToken(\"#{\", { beforeExpr, startsExpr }),\n  braceR: createToken(\"}\", { beforeExpr }),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", { beforeExpr, startsExpr }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", { beforeExpr }),\n  semi: createToken(\";\", { beforeExpr }),\n  colon: createToken(\":\", { beforeExpr }),\n  doubleColon: createToken(\"::\", { beforeExpr }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", { beforeExpr }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", { beforeExpr }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", { beforeExpr }),\n  backQuote: createToken(\"`\", { startsExpr }),\n  dollarBraceL: createToken(\"${\", { beforeExpr, startsExpr }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", { startsExpr }),\n\n  // Special hashbang token.\n  interpreterDirective: createToken(\"#!...\"),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  // start: isAssign\n  eq: createToken(\"=\", { beforeExpr, isAssign }),\n  assign: createToken(\"_=\", { beforeExpr, isAssign }),\n  slashAssign: createToken(\"_=\", { beforeExpr, isAssign }),\n  // These are only needed to support % and ^ as a Hack-pipe topic token. When the\n  // proposal settles on a token, the others can be merged with tt.assign.\n  xorAssign: createToken(\"_=\", { beforeExpr, isAssign }),\n  moduloAssign: createToken(\"_=\", { beforeExpr, isAssign }),\n  // end: isAssign\n\n  incDec: createToken(\"++/--\", { prefix, postfix, startsExpr }),\n  bang: createToken(\"!\", { beforeExpr, prefix, startsExpr }),\n  tilde: createToken(\"~\", { beforeExpr, prefix, startsExpr }),\n  // start: isBinop\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", { beforeExpr, binop: 9, prefix, startsExpr }),\n  // startsExpr: required by v8intrinsic plugin\n  modulo: createToken(\"%\", { binop: 10, startsExpr }),\n  // unset `beforeExpr` as it can be `function *`\n  star: createToken(\"*\", { binop: 10 }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true,\n  }),\n\n  // Keywords\n  // Don't forget to update packages/babel-helper-validator-identifier/src/keyword.js\n  // when new keywords are added\n  // start: isLiteralPropertyName\n  // start: isKeyword\n  _in: createKeyword(\"in\", { beforeExpr, binop: 7 }),\n  _instanceof: createKeyword(\"instanceof\", { beforeExpr, binop: 7 }),\n  // end: isBinop\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", { beforeExpr }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", { beforeExpr }),\n  _else: createKeyword(\"else\", { beforeExpr }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", { startsExpr }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", { beforeExpr }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", { beforeExpr, prefix, startsExpr }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", { beforeExpr, startsExpr }),\n  _this: createKeyword(\"this\", { startsExpr }),\n  _super: createKeyword(\"super\", { startsExpr }),\n  _class: createKeyword(\"class\", { startsExpr }),\n  _extends: createKeyword(\"extends\", { beforeExpr }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", { startsExpr }),\n  _null: createKeyword(\"null\", { startsExpr }),\n  _true: createKeyword(\"true\", { startsExpr }),\n  _false: createKeyword(\"false\", { startsExpr }),\n  _typeof: createKeyword(\"typeof\", { beforeExpr, prefix, startsExpr }),\n  _void: createKeyword(\"void\", { beforeExpr, prefix, startsExpr }),\n  _delete: createKeyword(\"delete\", { beforeExpr, prefix, startsExpr }),\n  // start: isLoop\n  _do: createKeyword(\"do\", { isLoop, beforeExpr }),\n  _for: createKeyword(\"for\", { isLoop }),\n  _while: createKeyword(\"while\", { isLoop }),\n  // end: isLoop\n  // end: isKeyword\n\n  // Primary literals\n  // start: isIdentifier\n  _as: createKeywordLike(\"as\", { startsExpr }),\n  _assert: createKeywordLike(\"assert\", { startsExpr }),\n  _async: createKeywordLike(\"async\", { startsExpr }),\n  _await: createKeywordLike(\"await\", { startsExpr }),\n  _from: createKeywordLike(\"from\", { startsExpr }),\n  _get: createKeywordLike(\"get\", { startsExpr }),\n  _let: createKeywordLike(\"let\", { startsExpr }),\n  _meta: createKeywordLike(\"meta\", { startsExpr }),\n  _of: createKeywordLike(\"of\", { startsExpr }),\n  _sent: createKeywordLike(\"sent\", { startsExpr }),\n  _set: createKeywordLike(\"set\", { startsExpr }),\n  _static: createKeywordLike(\"static\", { startsExpr }),\n  _yield: createKeywordLike(\"yield\", { startsExpr }),\n\n  // Flow and TypeScript Keywordlike\n  _asserts: createKeywordLike(\"asserts\", { startsExpr }),\n  _checks: createKeywordLike(\"checks\", { startsExpr }),\n  _exports: createKeywordLike(\"exports\", { startsExpr }),\n  _global: createKeywordLike(\"global\", { startsExpr }),\n  _implements: createKeywordLike(\"implements\", { startsExpr }),\n  _intrinsic: createKeywordLike(\"intrinsic\", { startsExpr }),\n  _infer: createKeywordLike(\"infer\", { startsExpr }),\n  _is: createKeywordLike(\"is\", { startsExpr }),\n  _mixins: createKeywordLike(\"mixins\", { startsExpr }),\n  _proto: createKeywordLike(\"proto\", { startsExpr }),\n  _require: createKeywordLike(\"require\", { startsExpr }),\n  // start: isTSTypeOperator\n  _keyof: createKeywordLike(\"keyof\", { startsExpr }),\n  _readonly: createKeywordLike(\"readonly\", { startsExpr }),\n  _unique: createKeywordLike(\"unique\", { startsExpr }),\n  // end: isTSTypeOperator\n  // start: isTSDeclarationStart\n  _abstract: createKeywordLike(\"abstract\", { startsExpr }),\n  _declare: createKeywordLike(\"declare\", { startsExpr }),\n  _enum: createKeywordLike(\"enum\", { startsExpr }),\n  _module: createKeywordLike(\"module\", { startsExpr }),\n  _namespace: createKeywordLike(\"namespace\", { startsExpr }),\n  // start: isFlowInterfaceOrTypeOrOpaque\n  _interface: createKeywordLike(\"interface\", { startsExpr }),\n  _type: createKeywordLike(\"type\", { startsExpr }),\n  // end: isTSDeclarationStart\n  _opaque: createKeywordLike(\"opaque\", { startsExpr }),\n  // end: isFlowInterfaceOrTypeOrOpaque\n  name: createToken(\"name\", { startsExpr }),\n  // end: isIdentifier\n\n  string: createToken(\"string\", { startsExpr }),\n  num: createToken(\"num\", { startsExpr }),\n  bigint: createToken(\"bigint\", { startsExpr }),\n  decimal: createToken(\"decimal\", { startsExpr }),\n  // end: isLiteralPropertyName\n  regexp: createToken(\"regexp\", { startsExpr }),\n  privateName: createToken(\"#name\", { startsExpr }),\n  eof: createToken(\"eof\"),\n\n  // jsx plugin\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", { beforeExpr: true }),\n  jsxTagStart: createToken(\"jsxTagStart\", { startsExpr: true }),\n  jsxTagEnd: createToken(\"jsxTagEnd\"),\n\n  // placeholder plugin\n  placeholder: createToken(\"%%\", { startsExpr: true }),\n};\n\nexport function tokenIsIdentifier(token: TokenType): boolean {\n  return token >= tt._as && token <= tt.name;\n}\n\nexport function tokenKeywordOrIdentifierIsKeyword(token: TokenType): boolean {\n  // we can remove the token >= tt._in check when we\n  // know a token is either keyword or identifier\n  return token <= tt._while;\n}\n\nexport function tokenIsKeywordOrIdentifier(token: TokenType): boolean {\n  return token >= tt._in && token <= tt.name;\n}\n\nexport function tokenIsLiteralPropertyName(token: TokenType): boolean {\n  return token >= tt._in && token <= tt.decimal;\n}\n\nexport function tokenComesBeforeExpression(token: TokenType): boolean {\n  return tokenBeforeExprs[token];\n}\n\nexport function tokenCanStartExpression(token: TokenType): boolean {\n  return tokenStartsExprs[token];\n}\n\nexport function tokenIsAssignment(token: TokenType): boolean {\n  return token >= tt.eq && token <= tt.moduloAssign;\n}\n\nexport function tokenIsFlowInterfaceOrTypeOrOpaque(token: TokenType): boolean {\n  return token >= tt._interface && token <= tt._opaque;\n}\n\nexport function tokenIsLoop(token: TokenType): boolean {\n  return token >= tt._do && token <= tt._while;\n}\n\nexport function tokenIsKeyword(token: TokenType): boolean {\n  return token >= tt._in && token <= tt._while;\n}\n\nexport function tokenIsOperator(token: TokenType): boolean {\n  return token >= tt.pipeline && token <= tt._instanceof;\n}\n\nexport function tokenIsPostfix(token: TokenType): boolean {\n  return token === tt.incDec;\n}\n\nexport function tokenIsPrefix(token: TokenType): boolean {\n  return tokenPrefixes[token];\n}\n\nexport function tokenIsTSTypeOperator(token: TokenType): boolean {\n  return token >= tt._keyof && token <= tt._unique;\n}\n\nexport function tokenIsTSDeclarationStart(token: TokenType): boolean {\n  return token >= tt._abstract && token <= tt._type;\n}\n\nexport function tokenLabelName(token: TokenType): string {\n  return tokenLabels[token];\n}\n\nexport function tokenOperatorPrecedence(token: TokenType): number {\n  return tokenBinops[token];\n}\n\nexport function tokenIsRightAssociative(token: TokenType): boolean {\n  return token === tt.exponent;\n}\n\nexport function getExportedToken(token: TokenType): ExportedTokenType {\n  return tokenTypes[token];\n}\n\nexport function isTokenType(obj: any): boolean {\n  return typeof obj === \"number\";\n}\n\nif (!process.env.BABEL_8_BREAKING) {\n  tokenTypes[tt.braceR].updateContext = context => {\n    context.pop();\n  };\n\n  tokenTypes[tt.braceL].updateContext =\n    tokenTypes[tt.braceHashL].updateContext =\n    tokenTypes[tt.dollarBraceL].updateContext =\n      context => {\n        context.push(tc.brace);\n      };\n\n  tokenTypes[tt.backQuote].updateContext = context => {\n    if (context[context.length - 1] === tc.template) {\n      context.pop();\n    } else {\n      context.push(tc.template);\n    }\n  };\n\n  tokenTypes[tt.jsxTagStart].updateContext = context => {\n    context.push(tc.j_expr, tc.j_oTag);\n  };\n}\n", "import * as charCodes from \"charcodes\";\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point between 0x80 and 0xffff.\n// Generated by `scripts/generate-identifier-regex.js`.\n\n/* prettier-ignore */\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ca\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7d9\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n/* prettier-ignore */\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0898-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nconst nonASCIIidentifierStart = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + \"]\",\n);\nconst nonASCIIidentifier = new RegExp(\n  \"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\",\n);\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset-encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by `scripts/generate-identifier-regex.js`.\n/* prettier-ignore */\nconst astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,13,10,2,14,2,6,2,1,2,10,2,14,2,6,2,1,68,310,10,21,11,7,25,5,2,41,2,8,70,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,349,41,7,1,79,28,11,0,9,21,43,17,47,20,28,22,13,52,58,1,3,0,14,44,33,24,27,35,30,0,3,0,9,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,2,31,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,38,6,186,43,117,63,32,7,3,0,3,7,2,1,2,23,16,0,2,0,95,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,19,72,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,190,0,80,921,103,110,18,195,2637,96,16,1070,4050,582,8634,568,8,30,18,78,18,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,1237,43,8,8936,3,2,6,2,1,2,290,46,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,1845,30,482,44,11,6,17,0,322,29,19,43,1269,6,2,3,2,1,2,14,2,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42719,33,4152,8,221,3,5761,15,7472,3104,541,1507,4938];\n/* prettier-ignore */\nconst astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,370,1,154,10,50,3,123,2,54,14,32,10,3,1,11,3,46,10,8,0,46,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,2,11,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,71,5,2,1,3,3,2,0,2,1,13,9,120,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,87,9,39,4,60,6,26,9,1014,0,2,54,8,3,82,0,12,1,19628,1,4706,45,3,22,543,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,357,0,62,13,1495,6,110,6,6,9,4759,9,787719,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code: number, set: readonly number[]): boolean {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\n\n// Test whether a given character code starts an identifier.\n\nexport function isIdentifierStart(code: number): boolean {\n  if (code < charCodes.uppercaseA) return code === charCodes.dollarSign;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return (\n      code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n    );\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nexport function isIdentifierChar(code: number): boolean {\n  if (code < charCodes.digit0) return code === charCodes.dollarSign;\n  if (code < charCodes.colon) return true;\n  if (code < charCodes.uppercaseA) return false;\n  if (code <= charCodes.uppercaseZ) return true;\n  if (code < charCodes.lowercaseA) return code === charCodes.underscore;\n  if (code <= charCodes.lowercaseZ) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return (\n    isInAstralSet(code, astralIdentifierStartCodes) ||\n    isInAstralSet(code, astralIdentifierCodes)\n  );\n}\n\n// Test whether a given string is a valid identifier name\n\nexport function isIdentifierName(name: string): boolean {\n  let isFirst = true;\n  for (let i = 0; i < name.length; i++) {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `name` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = name.charCodeAt(i);\n    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n      const trail = name.charCodeAt(++i);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    if (isFirst) {\n      isFirst = false;\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n  return !isFirst;\n}\n", "const reservedWords = {\n  keyword: [\n    \"break\",\n    \"case\",\n    \"catch\",\n    \"continue\",\n    \"debugger\",\n    \"default\",\n    \"do\",\n    \"else\",\n    \"finally\",\n    \"for\",\n    \"function\",\n    \"if\",\n    \"return\",\n    \"switch\",\n    \"throw\",\n    \"try\",\n    \"var\",\n    \"const\",\n    \"while\",\n    \"with\",\n    \"new\",\n    \"this\",\n    \"super\",\n    \"class\",\n    \"extends\",\n    \"export\",\n    \"import\",\n    \"null\",\n    \"true\",\n    \"false\",\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"void\",\n    \"delete\",\n  ],\n  strict: [\n    \"implements\",\n    \"interface\",\n    \"let\",\n    \"package\",\n    \"private\",\n    \"protected\",\n    \"public\",\n    \"static\",\n    \"yield\",\n  ],\n  strictBind: [\"eval\", \"arguments\"],\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\n\n/**\n * Checks if word is a reserved word in non-strict mode\n */\nexport function isReservedWord(word: string, inModule: boolean): boolean {\n  return (inModule && word === \"await\") || word === \"enum\";\n}\n\n/**\n * Checks if word is a reserved word in non-binding strict mode\n *\n * Includes non-strict reserved words\n */\nexport function isStrictReservedWord(word: string, inModule: boolean): boolean {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode, but it is allowed as\n * a normal identifier.\n */\nexport function isStrictBindOnlyReservedWord(word: string): boolean {\n  return reservedWordsStrictBindSet.has(word);\n}\n\n/**\n * Checks if word is a reserved word in binding strict mode\n *\n * Includes non-strict reserved words and non-binding strict reserved words\n */\nexport function isStrictBindReservedWord(\n  word: string,\n  inModule: boolean,\n): boolean {\n  return (\n    isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word)\n  );\n}\n\nexport function isKeyword(word: string): boolean {\n  return keywords.has(word);\n}\n", "/* eslint max-len: 0 */\n\n// @flow\n\nimport * as charCodes from \"charcodes\";\n\nexport {\n  isIdentifierStart,\n  isIdentifierChar,\n  isReservedWord,\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\nexport const keywordRelationalOperator = /^in(stanceof)?$/;\n\n// Test whether a current state character code and next character code is @\n\nexport function isIteratorStart(current: number, next: number): boolean {\n  return current === charCodes.atSign && next === charCodes.atSign;\n}\n\n// This is the comprehensive set of JavaScript reserved words\n// If a word is in this set, it could be a reserved word,\n// depending on sourceType/strictMode/binding info. In other words\n// if a word is not in this set, it is not a reserved word under\n// any circumstance.\nconst reservedWordLikeSet = new Set([\n  \"break\",\n  \"case\",\n  \"catch\",\n  \"continue\",\n  \"debugger\",\n  \"default\",\n  \"do\",\n  \"else\",\n  \"finally\",\n  \"for\",\n  \"function\",\n  \"if\",\n  \"return\",\n  \"switch\",\n  \"throw\",\n  \"try\",\n  \"var\",\n  \"const\",\n  \"while\",\n  \"with\",\n  \"new\",\n  \"this\",\n  \"super\",\n  \"class\",\n  \"extends\",\n  \"export\",\n  \"import\",\n  \"null\",\n  \"true\",\n  \"false\",\n  \"in\",\n  \"instanceof\",\n  \"typeof\",\n  \"void\",\n  \"delete\",\n  // strict\n  \"implements\",\n  \"interface\",\n  \"let\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"static\",\n  \"yield\",\n  // strictBind\n  \"eval\",\n  \"arguments\",\n  // reservedWorkLike\n  \"enum\",\n  \"await\",\n]);\n\nexport function canBeReservedWord(word: string): boolean {\n  return reservedWordLikeSet.has(word);\n}\n", "// @flow\n\n// Each scope gets a bitset that may contain these flags\n// prettier-ignore\nexport const SCOPE_OTHER        = 0b000000000,\n             SCOPE_PROGRAM      = 0b000000001,\n             SCOPE_FUNCTION     = 0b000000010,\n             SCOPE_ARROW        = 0b000000100,\n             SCOPE_SIMPLE_CATCH = 0b000001000,\n             SCOPE_SUPER        = 0b000010000,\n             SCOPE_DIRECT_SUPER = 0b000100000,\n             SCOPE_CLASS        = 0b001000000,\n             SCOPE_STATIC_BLOCK = 0b010000000,\n             SCOPE_TS_MODULE    = 0b100000000,\n             SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\n\nexport type ScopeFlags =\n  | typeof SCOPE_OTHER\n  | typeof SCOPE_PROGRAM\n  | typeof SCOPE_FUNCTION\n  | typeof SCOPE_VAR\n  | typeof SCOPE_ARROW\n  | typeof SCOPE_SIMPLE_CATCH\n  | typeof SCOPE_SUPER\n  | typeof SCOPE_DIRECT_SUPER\n  | typeof SCOPE_CLASS\n  | typeof SCOPE_STATIC_BLOCK;\n\n// These flags are meant to be _only_ used inside the Scope class (or subclasses).\n// prettier-ignore\nexport const BIND_KIND_VALUE            = 0b000000_0000_01,\n             BIND_KIND_TYPE             = 0b000000_0000_10,\n             // Used in checkLVal and declareName to determine the type of a binding\n             BIND_SCOPE_VAR             = 0b000000_0001_00, // Var-style binding\n             BIND_SCOPE_LEXICAL         = 0b000000_0010_00, // Let- or const-style binding\n             BIND_SCOPE_FUNCTION        = 0b000000_0100_00, // Function declaration\n             BIND_SCOPE_OUTSIDE         = 0b000000_1000_00, // Special case for function names as\n                                                   // bound inside the function\n             // Misc flags\n             BIND_FLAGS_NONE            = 0b000001_0000_00,\n             BIND_FLAGS_CLASS           = 0b000010_0000_00,\n             BIND_FLAGS_TS_ENUM         = 0b000100_0000_00,\n             BIND_FLAGS_TS_CONST_ENUM   = 0b001000_0000_00,\n             BIND_FLAGS_TS_EXPORT_ONLY  = 0b010000_0000_00,\n             BIND_FLAGS_FLOW_DECLARE_FN = 0b100000_0000_00;\n\n// These flags are meant to be _only_ used by Scope consumers\n// prettier-ignore\n/*                              =    is value?    |    is type?    |      scope          |    misc flags    */\nexport const BIND_CLASS         = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_CLASS  ,\n             BIND_LEXICAL       = BIND_KIND_VALUE | 0              | BIND_SCOPE_LEXICAL  | 0                 ,\n             BIND_VAR           = BIND_KIND_VALUE | 0              | BIND_SCOPE_VAR      | 0                 ,\n             BIND_FUNCTION      = BIND_KIND_VALUE | 0              | BIND_SCOPE_FUNCTION | 0                 ,\n             BIND_TS_INTERFACE  = 0               | BIND_KIND_TYPE | 0                   | BIND_FLAGS_CLASS  ,\n             BIND_TS_TYPE       = 0               | BIND_KIND_TYPE | 0                   | 0                 ,\n             BIND_TS_ENUM       = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL  | BIND_FLAGS_TS_ENUM,\n             BIND_TS_AMBIENT    = 0               | 0              | 0            | BIND_FLAGS_TS_EXPORT_ONLY,\n             // These bindings don't introduce anything in the scope. They are used for assignments and\n             // function expressions IDs.\n             BIND_NONE          = 0               | 0              | 0                   | BIND_FLAGS_NONE   ,\n             BIND_OUTSIDE       = BIND_KIND_VALUE | 0              | 0                   | BIND_FLAGS_NONE   ,\n\n             BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n             BIND_TS_NAMESPACE  = 0               | 0              | 0            | BIND_FLAGS_TS_EXPORT_ONLY,\n\n             BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;\n\nexport type BindingTypes =\n  | typeof BIND_NONE\n  | typeof BIND_OUTSIDE\n  | typeof BIND_VAR\n  | typeof BIND_LEXICAL\n  | typeof BIND_CLASS\n  | typeof BIND_FUNCTION\n  | typeof BIND_TS_INTERFACE\n  | typeof BIND_TS_TYPE\n  | typeof BIND_TS_ENUM\n  | typeof BIND_TS_AMBIENT\n  | typeof BIND_TS_NAMESPACE;\n\n// prettier-ignore\nexport const CLASS_ELEMENT_FLAG_STATIC = 0b1_00,\n             CLASS_ELEMENT_KIND_GETTER = 0b0_10,\n             CLASS_ELEMENT_KIND_SETTER = 0b0_01,\n             CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\n\n// prettier-ignore\nexport const CLASS_ELEMENT_STATIC_GETTER   = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n             CLASS_ELEMENT_STATIC_SETTER   = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n             CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n             CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n             CLASS_ELEMENT_OTHER           = 0;\n\nexport type ClassElementTypes =\n  | typeof CLASS_ELEMENT_STATIC_GETTER\n  | typeof CLASS_ELEMENT_STATIC_SETTER\n  | typeof CLASS_ELEMENT_INSTANCE_GETTER\n  | typeof CLASS_ELEMENT_INSTANCE_SETTER\n  | typeof CLASS_ELEMENT_OTHER;\n", "// @flow\nimport {\n  SCOPE_ARROW,\n  SCOPE_DIRECT_SUPER,\n  SCOPE_FUNCTION,\n  SCOPE_SIMPLE_CATCH,\n  SCOPE_SUPER,\n  SCOPE_PROGRAM,\n  SCOPE_VAR,\n  SCOPE_CLASS,\n  SCOPE_STATIC_BLOCK,\n  BIND_SCOPE_FUNCTION,\n  BIND_SCOPE_VAR,\n  BIND_SCOPE_LEXICAL,\n  BIND_KIND_VALUE,\n  type ScopeFlags,\n  type BindingTypes,\n} from \"./scopeflags\";\nimport * as N from \"../types\";\nimport { Errors, type raiseFunction } from \"../parser/error\";\n\n// Start an AST node, attaching a start offset.\nexport class Scope {\n  declare flags: ScopeFlags;\n  // A set of var-declared names in the current lexical scope\n  var: Set<string> = new Set();\n  // A set of lexically-declared names in the current lexical scope\n  lexical: Set<string> = new Set();\n  // A set of lexically-declared FunctionDeclaration names in the current lexical scope\n  functions: Set<string> = new Set();\n\n  constructor(flags: ScopeFlags) {\n    this.flags = flags;\n  }\n}\n\n// The functions in this module keep track of declared variables in the\n// current scope in order to detect duplicate variable names.\nexport default class ScopeHandler<IScope: Scope = Scope> {\n  scopeStack: Array<IScope> = [];\n  declare raise: raiseFunction;\n  declare inModule: boolean;\n  undefinedExports: Map<string, number> = new Map();\n  undefinedPrivateNames: Map<string, number> = new Map();\n\n  constructor(raise: raiseFunction, inModule: boolean) {\n    this.raise = raise;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & SCOPE_STATIC_BLOCK) {\n        return true;\n      }\n      if (flags & (SCOPE_VAR | SCOPE_CLASS)) {\n        // function body, module body, class property initializers\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags: ScopeFlags): Scope {\n    return new Scope(flags);\n  }\n  // This method will be overwritten by subclasses\n  /*:: +createScope: (flags: ScopeFlags) => IScope; */\n\n  enter(flags: ScopeFlags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  treatFunctionsAsVarInScope(scope: IScope): boolean {\n    return !!(\n      scope.flags & SCOPE_FUNCTION ||\n      (!this.inModule && scope.flags & SCOPE_PROGRAM)\n    );\n  }\n\n  declareName(name: string, bindingType: BindingTypes, pos: number) {\n    let scope = this.currentScope();\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.add(name);\n      } else {\n        scope.lexical.add(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        scope.var.add(name);\n        this.maybeExportDefined(scope, name);\n\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope: IScope, name: string) {\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingTypes,\n    pos: number,\n  ) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.raise(pos, Errors.VarRedeclaration, name);\n    }\n  }\n\n  isRedeclaredInScope(\n    scope: IScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return (\n        scope.lexical.has(name) ||\n        scope.functions.has(name) ||\n        scope.var.has(name)\n      );\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return (\n        scope.lexical.has(name) ||\n        (!this.treatFunctionsAsVarInScope(scope) && scope.var.has(name))\n      );\n    }\n\n    return (\n      (scope.lexical.has(name) &&\n        !(\n          scope.flags & SCOPE_SIMPLE_CATCH &&\n          scope.lexical.values().next().value === name\n        )) ||\n      (!this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name))\n    );\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    const { name } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (\n      !topLevelScope.lexical.has(name) &&\n      !topLevelScope.var.has(name) &&\n      // In strict mode, scope.functions will always be empty.\n      // Modules are strict by default, but the `scriptMode` option\n      // can overwrite this behavior.\n      !topLevelScope.functions.has(name)\n    ) {\n      this.undefinedExports.set(name, id.start);\n    }\n  }\n\n  currentScope(): IScope {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  // $FlowIgnore\n  currentVarScopeFlags(): ScopeFlags {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & SCOPE_VAR) {\n        return flags;\n      }\n    }\n  }\n\n  // Could be useful for `arguments`, `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  // $FlowIgnore\n  currentThisScopeFlags(): ScopeFlags {\n    for (let i = this.scopeStack.length - 1; ; i--) {\n      const { flags } = this.scopeStack[i];\n      if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {\n        return flags;\n      }\n    }\n  }\n}\n", "// @flow\n\nimport ScopeHandler, { Scope } from \"../../util/scope\";\nimport {\n  BIND_FLAGS_FLOW_DECLARE_FN,\n  type ScopeFlags,\n  type BindingTypes,\n} from \"../../util/scopeflags\";\nimport * as N from \"../../types\";\n\n// Reference implementation: https://github.com/facebook/flow/blob/23aeb2a2ef6eb4241ce178fde5d8f17c5f747fb5/src/typing/env.ml#L536-L584\nclass FlowScope extends Scope {\n  // declare function foo(): type;\n  declareFunctions: Set<string> = new Set();\n}\n\nexport default class FlowScopeHandler extends ScopeHandler<FlowScope> {\n  createScope(flags: ScopeFlags): FlowScope {\n    return new FlowScope(flags);\n  }\n\n  declareName(name: string, bindingType: BindingTypes, pos: number) {\n    const scope = this.currentScope();\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n  }\n\n  isRedeclaredInScope(\n    scope: FlowScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (super.isRedeclaredInScope(...arguments)) return true;\n\n    if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {\n      return (\n        !scope.declareFunctions.has(name) &&\n        (scope.lexical.has(name) || scope.functions.has(name))\n      );\n    }\n\n    return false;\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\n", "// @flow\n\nimport type { Options } from \"../options\";\nimport * as N from \"../types\";\nimport type { CommentWhitespace } from \"../parser/comments\";\nimport { Position } from \"../util/location\";\n\nimport { types as ct, type TokContext } from \"./context\";\nimport { tt, type TokenType } from \"./types\";\nimport type { ParsingError, ErrorTemplate } from \"../parser/error\";\n\ntype TopicContextState = {\n  // When a topic binding has been currently established,\n  // then this is 1. Otherwise, it is 0. This is forwards compatible\n  // with a future plugin for multiple lexical topics.\n  maxNumOfResolvableTopics: number,\n\n  // When a topic binding has been currently established, and if that binding\n  // has been used as a topic reference `#`, then this is 0. Otherwise, it is\n  // `null`. This is forwards compatible with a future plugin for multiple\n  // lexical topics.\n  maxTopicIndex: null | 0,\n};\n\nexport default class State {\n  strict: boolean;\n  curLine: number;\n  lineStart: number;\n\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  startLoc: Position;\n  endLoc: Position;\n\n  init({ strictMode, sourceType, startLine, startColumn }: Options): void {\n    this.strict =\n      strictMode === false\n        ? false\n        : strictMode === true\n        ? true\n        : sourceType === \"module\";\n\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn);\n  }\n\n  errors: ParsingError[] = [];\n\n  // Used to signify the start of a potential arrow function\n  potentialArrowAt: number = -1;\n\n  // Used to signify the start of an expression which looks like a\n  // typed arrow function, but it isn't\n  // e.g. a ? (b) : c => d\n  //          ^\n  noArrowAt: number[] = [];\n\n  // Used to signify the start of an expression whose params, if it looks like\n  // an arrow function, shouldn't be converted to assignable nodes.\n  // This is used to defer the validation of typed arrow functions inside\n  // conditional expressions.\n  // e.g. a ? (b) : c => d\n  //          ^\n  noArrowParamsConversionAt: number[] = [];\n\n  // Flags to track\n  maybeInArrowParameters: boolean = false;\n  inType: boolean = false;\n  noAnonFunctionType: boolean = false;\n  hasFlowComment: boolean = false;\n  isAmbientContext: boolean = false;\n  inAbstractClass: boolean = false;\n\n  // For the Hack-style pipelines plugin\n  topicContext: TopicContextState = {\n    maxNumOfResolvableTopics: 0,\n    maxTopicIndex: null,\n  };\n\n  // For the F#-style pipelines plugin\n  soloAwait: boolean = false;\n  inFSharpPipelineDirectBody: boolean = false;\n\n  // Labels in scope.\n  labels: Array<{\n    kind: ?(\"loop\" | \"switch\"),\n    name?: ?string,\n    statementStart?: number,\n  }> = [];\n\n  // Leading decorators. Last element of the stack represents the decorators in current context.\n  // Supports nesting of decorators, e.g. @foo(@bar class inner {}) class outer {}\n  // where @foo belongs to the outer class and @bar to the inner\n  decoratorStack: Array<Array<N.Decorator>> = [[]];\n\n  // Comment store for Program.comments\n  comments: Array<N.Comment> = [];\n\n  // Comment attachment store\n  commentStack: Array<CommentWhitespace> = [];\n\n  // The current position of the tokenizer in the input.\n  pos: number = 0;\n\n  // Properties of the current token:\n  // Its type\n  type: TokenType = tt.eof;\n\n  // For tokens that include more information than their type, the value\n  value: any = null;\n\n  // Its start and end offset\n  start: number = 0;\n  end: number = 0;\n\n  // Position information for the previous token\n  // $FlowIgnore this is initialized when generating the second token.\n  lastTokEndLoc: Position = null;\n  // $FlowIgnore this is initialized when generating the second token.\n  lastTokStartLoc: Position = null;\n  lastTokStart: number = 0;\n  lastTokEnd: number = 0;\n\n  // The context stack is used to track whether the apostrophe \"`\" starts\n  // or ends a string template\n  context: Array<TokContext> = [ct.brace];\n  // Used to track whether a JSX element is allowed to form\n  canStartJSXElement: boolean = true;\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  containsEsc: boolean = false;\n\n  // This property is used to track the following errors\n  // - StrictNumericEscape\n  // - StrictOctalLiteral\n  //\n  // in a literal that occurs prior to/immediately after a \"use strict\" directive.\n\n  // todo(JLHwung): set strictErrors to null and avoid recording string errors\n  // after a non-directive is parsed\n  strictErrors: Map<number, ErrorTemplate> = new Map();\n\n  // Tokens length in token store\n  tokensLength: number = 0;\n\n  curPosition(): Position {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n\n  clone(skipArrays?: boolean): State {\n    const state = new State();\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      // $FlowIgnore\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      // $FlowIgnore\n      state[key] = val;\n    }\n\n    return state;\n  }\n}\n\nexport type LookaheadState = {\n  pos: number,\n  value: any,\n  type: TokenType,\n  start: number,\n  end: number,\n  /* Used only in readToken_mult_modulo */\n  inType: boolean,\n};\n", "// @flow\n\n/*:: declare var invariant; */\n\nimport type { Options } from \"../options\";\nimport * as N from \"../types\";\nimport * as charCodes from \"charcodes\";\nimport { isIdentifierStart, isIdentifierChar } from \"../util/identifier\";\nimport {\n  tokenIsKeyword,\n  tokenLabelName,\n  tt,\n  keywords as keywordTypes,\n  type TokenType,\n} from \"./types\";\nimport { type TokContext, types as ct } from \"./context\";\nimport ParserErrors, { Errors, type ErrorTemplate } from \"../parser/error\";\nimport { SourceLocation } from \"../util/location\";\nimport {\n  lineBreakG,\n  isNewLine,\n  isWhitespace,\n  skipWhiteSpace,\n} from \"../util/whitespace\";\nimport State from \"./state\";\nimport type { LookaheadState } from \"./state\";\n\nconst VALID_REGEX_FLAGS = new Set([\n  charCodes.lowercaseG,\n  charCodes.lowercaseM,\n  charCodes.lowercaseS,\n  charCodes.lowercaseI,\n  charCodes.lowercaseY,\n  charCodes.lowercaseU,\n  charCodes.lowercaseD,\n]);\n\n// The following character codes are forbidden from being\n// an immediate sibling of NumericLiteralSeparator _\n\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: [\n    charCodes.dot,\n    charCodes.uppercaseB,\n    charCodes.uppercaseE,\n    charCodes.uppercaseO,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseB,\n    charCodes.lowercaseE,\n    charCodes.lowercaseO,\n  ],\n  hex: [\n    charCodes.dot,\n    charCodes.uppercaseX,\n    charCodes.underscore, // multiple separators are not allowed\n    charCodes.lowercaseX,\n  ],\n};\n\nconst allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [\n  // 0 - 1\n  charCodes.digit0,\n  charCodes.digit1,\n];\nallowedNumericSeparatorSiblings.oct = [\n  // 0 - 7\n  ...allowedNumericSeparatorSiblings.bin,\n\n  charCodes.digit2,\n  charCodes.digit3,\n  charCodes.digit4,\n  charCodes.digit5,\n  charCodes.digit6,\n  charCodes.digit7,\n];\nallowedNumericSeparatorSiblings.dec = [\n  // 0 - 9\n  ...allowedNumericSeparatorSiblings.oct,\n\n  charCodes.digit8,\n  charCodes.digit9,\n];\n\nallowedNumericSeparatorSiblings.hex = [\n  // 0 - 9, A - F, a - f,\n  ...allowedNumericSeparatorSiblings.dec,\n\n  charCodes.uppercaseA,\n  charCodes.uppercaseB,\n  charCodes.uppercaseC,\n  charCodes.uppercaseD,\n  charCodes.uppercaseE,\n  charCodes.uppercaseF,\n\n  charCodes.lowercaseA,\n  charCodes.lowercaseB,\n  charCodes.lowercaseC,\n  charCodes.lowercaseD,\n  charCodes.lowercaseE,\n  charCodes.lowercaseF,\n];\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nexport class Token {\n  constructor(state: State) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n  declare type: TokenType;\n  declare value: any;\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n}\n\n// ## Tokenizer\n\nexport default class Tokenizer extends ParserErrors {\n  // Forward-declarations\n  // parser/util.js\n  /*::\n  +hasPrecedingLineBreak: () => boolean;\n  +unexpected: (pos?: ?number, messageOrType?: ErrorTemplate | TokenType) => empty;\n  +expectPlugin: (name: string, pos?: ?number) => true;\n  */\n\n  isLookahead: boolean;\n\n  // Token store.\n  tokens: Array<Token | N.Comment> = [];\n\n  constructor(options: Options, input: string) {\n    super();\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token: Token | N.Comment) {\n    // Pop out invalid tokens trapped by try-catch parsing.\n    // Those parsing branches are mainly created by typescript and flow plugins.\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  // Move to the next token\n\n  next(): void {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  // TODO\n\n  eat(type: TokenType): boolean {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Whether current token matches given type\n   *\n   * @param {TokenType} type\n   * @returns {boolean}\n   * @memberof Tokenizer\n   */\n  match(type: TokenType): boolean {\n    return this.state.type === type;\n  }\n\n  /**\n   * Create a LookaheadState from current parser state\n   *\n   * @param {State} state\n   * @returns {LookaheadState}\n   * @memberof Tokenizer\n   */\n  createLookaheadState(state: State): LookaheadState {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      lastTokEnd: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n    };\n  }\n\n  /**\n   * lookahead peeks the next token, skipping changes to token context and\n   * comment stack. For performance it returns a limited LookaheadState\n   * instead of full parser state.\n   *\n   * The { column, line } Loc info is not included in lookahead since such usage\n   * is rare. Although it may return other location properties e.g. `curLine` and\n   * `lineStart`, these properties are not listed in the LookaheadState interface\n   * and thus the returned value is _NOT_ reliable.\n   *\n   * The tokenizer should make best efforts to avoid using any parser state\n   * other than those defined in LookaheadState\n   *\n   * @returns {LookaheadState}\n   * @memberof Tokenizer\n   */\n  lookahead(): LookaheadState {\n    const old = this.state;\n    // For performance we use a simpified tokenizer state structure\n    // $FlowIgnore\n    this.state = this.createLookaheadState(old);\n\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart(): number {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n\n  nextTokenStartSince(pos: number): number {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n\n  lookaheadCharCode(): number {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  codePointAtPos(pos: number): number {\n    // The implementation is based on\n    // https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins/builtins-string-gen.cc;l=1455;drc=221e331b49dfefadbc6fa40b0c68e6f97606d0b3;bpv=0;bpt=1\n    // We reimplement `codePointAt` because `codePointAt` is a V8 builtin which is not inlined by TurboFan (as of M91)\n    // since `input` is mostly ASCII, an inlined `charCodeAt` wins here\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  setStrict(strict: boolean): void {\n    this.state.strict = strict;\n    if (strict) {\n      // Throw an error for any string decimal escape found before/immediately\n      // after a \"use strict\" directive. Strict mode will be set at parse\n      // time for any literals that occur after the next node of the strict\n      // directive.\n      this.state.strictErrors.forEach((message, pos) =>\n        /* eslint-disable @babel/development-internal/dry-error-messages */\n        this.raise(pos, message),\n      );\n      this.state.strictErrors.clear();\n    }\n  }\n\n  curContext(): TokContext {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  nextToken(): void {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(tt.eof);\n      return;\n    }\n\n    if (curContext === ct.template) {\n      this.readTmplToken();\n    } else {\n      this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n    }\n  }\n\n  skipBlockComment(): N.CommentBlock | void {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", start + 2);\n    if (end === -1) throw this.raise(start, Errors.UnterminatedComment);\n\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n    /*:: invariant(startLoc) */\n\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start,\n      end: end + 2,\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  skipLineComment(startSkip: number): N.CommentLine | void {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt((this.state.pos += startSkip));\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    // If we are doing a lookahead right now we need to advance the position (above code)\n    // but we do not want to push the comment to the state.\n    if (this.isLookahead) return;\n    /*:: invariant(startLoc) */\n\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start,\n      end,\n      loc: new SourceLocation(startLoc, this.state.curPosition()),\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  skipSpace(): void {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case charCodes.space:\n        case charCodes.nonBreakingSpace:\n        case charCodes.tab:\n          ++this.state.pos;\n          break;\n        case charCodes.carriageReturn:\n          if (\n            this.input.charCodeAt(this.state.pos + 1) === charCodes.lineFeed\n          ) {\n            ++this.state.pos;\n          }\n        // fall through\n        case charCodes.lineFeed:\n        case charCodes.lineSeparator:\n        case charCodes.paragraphSeparator:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case charCodes.slash:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case charCodes.asterisk: {\n              const comment = this.skipBlockComment();\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n              break;\n            }\n\n            case charCodes.slash: {\n              const comment = this.skipLineComment(2);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n              break;\n            }\n\n            default:\n              break loop;\n          }\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === charCodes.dash && !this.inModule) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.dash &&\n              this.input.charCodeAt(pos + 2) === charCodes.greaterThan &&\n              (spaceStart === 0 || this.state.lineStart > spaceStart)\n            ) {\n              // A `-->` line comment\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === charCodes.lessThan && !this.inModule) {\n            const pos = this.state.pos;\n            if (\n              this.input.charCodeAt(pos + 1) === charCodes.exclamationMark &&\n              this.input.charCodeAt(pos + 2) === charCodes.dash &&\n              this.input.charCodeAt(pos + 3) === charCodes.dash\n            ) {\n              // `<!--`, an XML-style comment that should be interpreted as a line comment\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const CommentWhitespace = {\n        start: spaceStart,\n        end,\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null,\n      };\n      this.state.commentStack.push(CommentWhitespace);\n    }\n  }\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `canStartJSXElement`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  finishToken(type: TokenType, val: any): void {\n    this.state.end = this.state.pos;\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n\n    if (!this.isLookahead) {\n      this.state.endLoc = this.state.curPosition();\n      this.updateContext(prevType);\n    }\n  }\n\n  replaceToken(type: TokenType): void {\n    this.state.type = type;\n    // the prevType of updateContext is required\n    // only when the new type is tt.slash/tt.jsxTagEnd\n    // $FlowIgnore\n    this.updateContext();\n  }\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n\n  // number sign is \"#\"\n  readToken_numberSign(): void {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      throw this.raise(this.state.pos, Errors.UnexpectedDigitAfterHash);\n    }\n\n    if (\n      next === charCodes.leftCurlyBrace ||\n      (next === charCodes.leftSquareBracket && this.hasPlugin(\"recordAndTuple\"))\n    ) {\n      // When we see `#{`, it is likely to be a hash record.\n      // However we don't yell at `#[` since users may intend to use \"computed private fields\",\n      // which is not allowed in the spec. Throwing expecting recordAndTuple is\n      // misleading\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(\n          this.state.pos,\n          next === charCodes.leftCurlyBrace\n            ? Errors.RecordExpressionHashIncorrectStartSyntaxType\n            : Errors.TupleExpressionHashIncorrectStartSyntaxType,\n        );\n      }\n\n      this.state.pos += 2;\n      if (next === charCodes.leftCurlyBrace) {\n        // #{\n        this.finishToken(tt.braceHashL);\n      } else {\n        // #[\n        this.finishToken(tt.bracketHashL);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1(next));\n    } else if (next === charCodes.backslash) {\n      ++this.state.pos;\n      this.finishToken(tt.privateName, this.readWord1());\n    } else {\n      this.finishOp(tt.hash, 1);\n    }\n  }\n\n  readToken_dot(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= charCodes.digit0 && next <= charCodes.digit9) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (\n      next === charCodes.dot &&\n      this.input.charCodeAt(this.state.pos + 2) === charCodes.dot\n    ) {\n      this.state.pos += 3;\n      this.finishToken(tt.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.dot);\n    }\n  }\n\n  readToken_slash(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.slashAssign, 2);\n    } else {\n      this.finishOp(tt.slash, 1);\n    }\n  }\n\n  readToken_interpreter(): boolean {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== charCodes.exclamationMark) return false;\n\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n\n    this.finishToken(tt.interpreterDirective, value);\n\n    return true;\n  }\n\n  readToken_mult_modulo(code: number): void {\n    // '%' or '*'\n    let type = code === charCodes.asterisk ? tt.star : tt.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n\n    // Exponentiation operator '**'\n    if (code === charCodes.asterisk && next === charCodes.asterisk) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = tt.exponent;\n    }\n\n    // '%=' or '*='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      width++;\n      // `tt.moduloAssign` is only needed to support % as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      type = code === charCodes.percentSign ? tt.moduloAssign : tt.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code: number): void {\n    // '||' '&&' '||=' '&&='\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n      } else {\n        this.finishOp(\n          code === charCodes.verticalBar ? tt.logicalOR : tt.logicalAND,\n          2,\n        );\n      }\n      return;\n    }\n\n    if (code === charCodes.verticalBar) {\n      // '|>'\n      if (next === charCodes.greaterThan) {\n        this.finishOp(tt.pipeline, 2);\n        return;\n      }\n      // '|}'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(\n            this.state.pos,\n            Errors.RecordExpressionBarIncorrectEndSyntaxType,\n          );\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.braceBarR);\n        return;\n      }\n\n      // '|]'\n      if (\n        this.hasPlugin(\"recordAndTuple\") &&\n        next === charCodes.rightSquareBracket\n      ) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(\n            this.state.pos,\n            Errors.TupleExpressionBarIncorrectEndSyntaxType,\n          );\n        }\n        this.state.pos += 2;\n        this.finishToken(tt.bracketBarR);\n        return;\n      }\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n      return;\n    }\n\n    this.finishOp(\n      code === charCodes.verticalBar ? tt.bitwiseOR : tt.bitwiseAND,\n      1,\n    );\n  }\n\n  readToken_caret(): void {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    // '^='\n    if (next === charCodes.equalsTo && !this.state.inType) {\n      // `tt.xorAssign` is only needed to support ^ as a Hack-pipe topic token.\n      // If the proposal ends up choosing a different token,\n      // it can be merged with tt.assign.\n      this.finishOp(tt.xorAssign, 2);\n    }\n    // '^'\n    else {\n      this.finishOp(tt.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_plus_min(code: number): void {\n    // '+-'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      this.finishOp(tt.incDec, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      this.finishOp(tt.assign, 2);\n    } else {\n      this.finishOp(tt.plusMin, 1);\n    }\n  }\n\n  readToken_lt(): void {\n    // '<'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.lessThan) {\n      if (this.input.charCodeAt(pos + 2) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, 3);\n        return;\n      }\n      this.finishOp(tt.bitShift, 2);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.lt, 1);\n  }\n\n  readToken_gt(): void {\n    // '>'\n    const { pos } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n\n    if (next === charCodes.greaterThan) {\n      const size =\n        this.input.charCodeAt(pos + 2) === charCodes.greaterThan ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === charCodes.equalsTo) {\n        this.finishOp(tt.assign, size + 1);\n        return;\n      }\n      this.finishOp(tt.bitShift, size);\n      return;\n    }\n\n    if (next === charCodes.equalsTo) {\n      // <= | >=\n      this.finishOp(tt.relational, 2);\n      return;\n    }\n\n    this.finishOp(tt.gt, 1);\n  }\n\n  readToken_eq_excl(code: number): void {\n    // '=!'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === charCodes.equalsTo) {\n      this.finishOp(\n        tt.equality,\n        this.input.charCodeAt(this.state.pos + 2) === charCodes.equalsTo\n          ? 3\n          : 2,\n      );\n      return;\n    }\n    if (code === charCodes.equalsTo && next === charCodes.greaterThan) {\n      // '=>'\n      this.state.pos += 2;\n      this.finishToken(tt.arrow);\n      return;\n    }\n    this.finishOp(code === charCodes.equalsTo ? tt.eq : tt.bang, 1);\n  }\n\n  readToken_question(): void {\n    // '?'\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === charCodes.questionMark) {\n      if (next2 === charCodes.equalsTo) {\n        // '??='\n        this.finishOp(tt.assign, 3);\n      } else {\n        // '??'\n        this.finishOp(tt.nullishCoalescing, 2);\n      }\n    } else if (\n      next === charCodes.dot &&\n      !(next2 >= charCodes.digit0 && next2 <= charCodes.digit9)\n    ) {\n      // '.' not followed by a number\n      this.state.pos += 2;\n      this.finishToken(tt.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(tt.question);\n    }\n  }\n\n  getTokenFromCode(code: number): void {\n    switch (code) {\n      // The interpretation of a dot depends on whether it is followed\n      // by a digit or another two dots.\n\n      case charCodes.dot:\n        this.readToken_dot();\n        return;\n\n      // Punctuation tokens.\n      case charCodes.leftParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenL);\n        return;\n      case charCodes.rightParenthesis:\n        ++this.state.pos;\n        this.finishToken(tt.parenR);\n        return;\n      case charCodes.semicolon:\n        ++this.state.pos;\n        this.finishToken(tt.semi);\n        return;\n      case charCodes.comma:\n        ++this.state.pos;\n        this.finishToken(tt.comma);\n        return;\n      case charCodes.leftSquareBracket:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              this.state.pos,\n              Errors.TupleExpressionBarIncorrectStartSyntaxType,\n            );\n          }\n\n          // [|\n          this.state.pos += 2;\n          this.finishToken(tt.bracketBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.bracketL);\n        }\n        return;\n      case charCodes.rightSquareBracket:\n        ++this.state.pos;\n        this.finishToken(tt.bracketR);\n        return;\n      case charCodes.leftCurlyBrace:\n        if (\n          this.hasPlugin(\"recordAndTuple\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.verticalBar\n        ) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(\n              this.state.pos,\n              Errors.RecordExpressionBarIncorrectStartSyntaxType,\n            );\n          }\n\n          // {|\n          this.state.pos += 2;\n          this.finishToken(tt.braceBarL);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.braceL);\n        }\n        return;\n      case charCodes.rightCurlyBrace:\n        ++this.state.pos;\n        this.finishToken(tt.braceR);\n        return;\n\n      case charCodes.colon:\n        if (\n          this.hasPlugin(\"functionBind\") &&\n          this.input.charCodeAt(this.state.pos + 1) === charCodes.colon\n        ) {\n          this.finishOp(tt.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(tt.colon);\n        }\n        return;\n\n      case charCodes.questionMark:\n        this.readToken_question();\n        return;\n\n      case charCodes.graveAccent:\n        ++this.state.pos;\n        this.finishToken(tt.backQuote);\n        return;\n\n      case charCodes.digit0: {\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        // '0x', '0X' - hex number\n        if (next === charCodes.lowercaseX || next === charCodes.uppercaseX) {\n          this.readRadixNumber(16);\n          return;\n        }\n        // '0o', '0O' - octal number\n        if (next === charCodes.lowercaseO || next === charCodes.uppercaseO) {\n          this.readRadixNumber(8);\n          return;\n        }\n        // '0b', '0B' - binary number\n        if (next === charCodes.lowercaseB || next === charCodes.uppercaseB) {\n          this.readRadixNumber(2);\n          return;\n        }\n      }\n      // Anything else beginning with a digit is an integer, octal\n      // number, or float. (fall through)\n      case charCodes.digit1:\n      case charCodes.digit2:\n      case charCodes.digit3:\n      case charCodes.digit4:\n      case charCodes.digit5:\n      case charCodes.digit6:\n      case charCodes.digit7:\n      case charCodes.digit8:\n      case charCodes.digit9:\n        this.readNumber(false);\n        return;\n\n      // Quotes produce strings.\n      case charCodes.quotationMark:\n      case charCodes.apostrophe:\n        this.readString(code);\n        return;\n\n      // Operators are parsed inline in tiny state machines. '=' (charCodes.equalsTo) is\n      // often referred to. `finishOp` simply skips the amount of\n      // characters it is given as second argument, and returns a token\n      // of the type given by its first argument.\n\n      case charCodes.slash:\n        this.readToken_slash();\n        return;\n\n      case charCodes.percentSign:\n      case charCodes.asterisk:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case charCodes.verticalBar:\n      case charCodes.ampersand:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case charCodes.caret:\n        this.readToken_caret();\n        return;\n\n      case charCodes.plusSign:\n      case charCodes.dash:\n        this.readToken_plus_min(code);\n        return;\n\n      case charCodes.lessThan:\n        this.readToken_lt();\n        return;\n\n      case charCodes.greaterThan:\n        this.readToken_gt();\n        return;\n\n      case charCodes.equalsTo:\n      case charCodes.exclamationMark:\n        this.readToken_eq_excl(code);\n        return;\n\n      case charCodes.tilde:\n        this.finishOp(tt.tilde, 1);\n        return;\n\n      case charCodes.atSign:\n        ++this.state.pos;\n        this.finishToken(tt.at);\n        return;\n\n      case charCodes.numberSign:\n        this.readToken_numberSign();\n        return;\n\n      case charCodes.backslash:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n\n    throw this.raise(\n      this.state.pos,\n      Errors.InvalidOrUnexpectedToken,\n      String.fromCodePoint(code),\n    );\n  }\n\n  finishOp(type: TokenType, size: number): void {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp(): void {\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let { pos } = this.state;\n    for (; ; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(start, Errors.UnterminatedRegExp);\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(start, Errors.UnterminatedRegExp);\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === charCodes.leftSquareBracket) {\n          inClass = true;\n        } else if (ch === charCodes.rightSquareBracket && inClass) {\n          inClass = false;\n        } else if (ch === charCodes.slash && !inClass) {\n          break;\n        }\n        escaped = ch === charCodes.backslash;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n\n    let mods = \"\";\n\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      // It doesn't matter if cp > 0xffff, the loop will either throw or break because we check on cp\n      const char = String.fromCharCode(cp);\n\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (mods.includes(char)) {\n          this.raise(pos + 1, Errors.DuplicateRegExpFlags);\n        }\n      } else if (isIdentifierChar(cp) || cp === charCodes.backslash) {\n        this.raise(pos + 1, Errors.MalformedRegExpFlags);\n      } else {\n        break;\n      }\n\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n\n    this.finishToken(tt.regexp, {\n      pattern: content,\n      flags: mods,\n    });\n  }\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n  // When `forceLen` is `true`, it means that we already know that in case\n  // of a malformed number we have to skip `len` characters anyway, instead\n  // of bailing out early. For example, in \"\\u{123Z}\" we want to read up to }\n  // anyway, while in \"\\u00Z\" we will stop at Z instead of consuming four\n  // characters (and thus the closing quote).\n\n  readInt(\n    radix: number,\n    len?: number,\n    forceLen?: boolean,\n    allowNumSeparator: boolean = true,\n  ): number | null {\n    const start = this.state.pos;\n    const forbiddenSiblings =\n      radix === 16\n        ? forbiddenNumericSeparatorSiblings.hex\n        : forbiddenNumericSeparatorSiblings.decBinOct;\n    const allowedSiblings =\n      radix === 16\n        ? allowedNumericSeparatorSiblings.hex\n        : radix === 10\n        ? allowedNumericSeparatorSiblings.dec\n        : radix === 8\n        ? allowedNumericSeparatorSiblings.oct\n        : allowedNumericSeparatorSiblings.bin;\n\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (code === charCodes.underscore) {\n        const prev = this.input.charCodeAt(this.state.pos - 1);\n        const next = this.input.charCodeAt(this.state.pos + 1);\n        if (allowedSiblings.indexOf(next) === -1) {\n          this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);\n        } else if (\n          forbiddenSiblings.indexOf(prev) > -1 ||\n          forbiddenSiblings.indexOf(next) > -1 ||\n          Number.isNaN(next)\n        ) {\n          this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);\n        }\n\n        if (!allowNumSeparator) {\n          this.raise(this.state.pos, Errors.NumericSeparatorInEscapeSequence);\n        }\n\n        // Ignore this _ character\n        ++this.state.pos;\n        continue;\n      }\n\n      if (code >= charCodes.lowercaseA) {\n        val = code - charCodes.lowercaseA + charCodes.lineFeed;\n      } else if (code >= charCodes.uppercaseA) {\n        val = code - charCodes.uppercaseA + charCodes.lineFeed;\n      } else if (charCodes.isDigit(code)) {\n        val = code - charCodes.digit0; // 0-9\n      } else {\n        val = Infinity;\n      }\n      if (val >= radix) {\n        // If we are in \"errorRecovery\" mode and we found a digit which is too big,\n        // don't break the loop.\n\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(this.state.start + i + 2, Errors.InvalidDigit, radix);\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n    if (\n      this.state.pos === start ||\n      (len != null && this.state.pos - start !== len) ||\n      invalid\n    ) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix: number): void {\n    const start = this.state.pos;\n    let isBigInt = false;\n\n    this.state.pos += 2; // 0x\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(this.state.start + 2, Errors.InvalidDigit, radix);\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === charCodes.lowercaseN) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === charCodes.lowercaseM) {\n      throw this.raise(start, Errors.InvalidDecimal);\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(this.state.pos, Errors.NumberIdentifier);\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    this.finishToken(tt.num, val);\n  }\n\n  // Read an integer, octal integer, or floating-point number.\n\n  readNumber(startsWithDot: boolean): void {\n    const start = this.state.pos;\n    let isFloat = false;\n    let isBigInt = false;\n    let isDecimal = false;\n    let hasExponent = false;\n    let isOctal = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, Errors.InvalidNumber);\n    }\n    const hasLeadingZero =\n      this.state.pos - start >= 2 &&\n      this.input.charCodeAt(start) === charCodes.digit0;\n\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(start, Errors.StrictOctalLiteral);\n      if (!this.state.strict) {\n        // disallow numeric separators in non octal decimals and legacy octal likes\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(underscorePos + start, Errors.ZeroDigitNumericSeparator);\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === charCodes.dot && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (\n      (next === charCodes.uppercaseE || next === charCodes.lowercaseE) &&\n      !isOctal\n    ) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === charCodes.plusSign || next === charCodes.dash) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(start, Errors.InvalidOrMissingExponent);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (next === charCodes.lowercaseN) {\n      // disallow floats, legacy octal syntax and non octal decimals\n      // new style octal (\"0o\") is handled in this.readRadixNumber\n      if (isFloat || hasLeadingZero) {\n        this.raise(start, Errors.InvalidBigIntLiteral);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (next === charCodes.lowercaseM) {\n      this.expectPlugin(\"decimal\", this.state.pos);\n      if (hasExponent || hasLeadingZero) {\n        this.raise(start, Errors.InvalidDecimal);\n      }\n      ++this.state.pos;\n      isDecimal = true;\n    }\n\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(this.state.pos, Errors.NumberIdentifier);\n    }\n\n    // remove \"_\" for numeric literal separator, and trailing `m` or `n`\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(tt.bigint, str);\n      return;\n    }\n\n    if (isDecimal) {\n      this.finishToken(tt.decimal, str);\n      return;\n    }\n\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(tt.num, val);\n  }\n\n  // Read a string value, interpreting backslash-escapes.\n\n  readCodePoint(throwOnInvalid: boolean): number | null {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === charCodes.leftCurlyBrace) {\n      const codePos = ++this.state.pos;\n      code = this.readHexChar(\n        this.input.indexOf(\"}\", this.state.pos) - this.state.pos,\n        true,\n        throwOnInvalid,\n      );\n      ++this.state.pos;\n      if (code !== null && code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, Errors.InvalidCodePoint);\n        } else {\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n    return code;\n  }\n\n  readString(quote: number): void {\n    let out = \"\",\n      chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === charCodes.backslash) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        // $FlowFixMe\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (\n        ch === charCodes.lineSeparator ||\n        ch === charCodes.paragraphSeparator\n      ) {\n        ++this.state.pos;\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(tt.string, out);\n  }\n\n  // Reads template string tokens.\n\n  readTmplToken(): void {\n    let out = \"\",\n      chunkStart = this.state.pos,\n      containsInvalid = false;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedTemplate);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (\n        ch === charCodes.graveAccent ||\n        (ch === charCodes.dollarSign &&\n          this.input.charCodeAt(this.state.pos + 1) ===\n            charCodes.leftCurlyBrace)\n      ) {\n        if (this.state.pos === this.state.start && this.match(tt.template)) {\n          if (ch === charCodes.dollarSign) {\n            this.state.pos += 2;\n            this.finishToken(tt.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(tt.backQuote);\n            return;\n          }\n        }\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(tt.template, containsInvalid ? null : out);\n        return;\n      }\n      if (ch === charCodes.backslash) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n        switch (ch) {\n          case charCodes.carriageReturn:\n            if (this.input.charCodeAt(this.state.pos) === charCodes.lineFeed) {\n              ++this.state.pos;\n            }\n          // fall through\n          case charCodes.lineFeed:\n            out += \"\\n\";\n            break;\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  recordStrictModeErrors(pos: number, message: ErrorTemplate) {\n    if (this.state.strict && !this.state.strictErrors.has(pos)) {\n      this.raise(pos, message);\n    } else {\n      this.state.strictErrors.set(pos, message);\n    }\n  }\n\n  // Used to read escaped characters\n  readEscapedChar(inTemplate: boolean): string | null {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n    switch (ch) {\n      case charCodes.lowercaseN:\n        return \"\\n\";\n      case charCodes.lowercaseR:\n        return \"\\r\";\n      case charCodes.lowercaseX: {\n        const code = this.readHexChar(2, false, throwOnInvalid);\n        return code === null ? null : String.fromCharCode(code);\n      }\n      case charCodes.lowercaseU: {\n        const code = this.readCodePoint(throwOnInvalid);\n        return code === null ? null : String.fromCodePoint(code);\n      }\n      case charCodes.lowercaseT:\n        return \"\\t\";\n      case charCodes.lowercaseB:\n        return \"\\b\";\n      case charCodes.lowercaseV:\n        return \"\\u000b\";\n      case charCodes.lowercaseF:\n        return \"\\f\";\n      case charCodes.carriageReturn:\n        if (this.input.charCodeAt(this.state.pos) === charCodes.lineFeed) {\n          ++this.state.pos;\n        }\n      // fall through\n      case charCodes.lineFeed:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n      // fall through\n      case charCodes.lineSeparator:\n      case charCodes.paragraphSeparator:\n        return \"\";\n      case charCodes.digit8:\n      case charCodes.digit9:\n        if (inTemplate) {\n          return null;\n        } else {\n          this.recordStrictModeErrors(\n            this.state.pos - 1,\n            Errors.StrictNumericEscape,\n          );\n        }\n      // fall through\n      default:\n        if (ch >= charCodes.digit0 && ch <= charCodes.digit7) {\n          const codePos = this.state.pos - 1;\n          const match = this.input\n            .substr(this.state.pos - 1, 3)\n            .match(/^[0-7]+/);\n\n          // This is never null, because of the if condition above.\n          /*:: invariant(match !== null) */\n          let octalStr = match[0];\n\n          let octal = parseInt(octalStr, 8);\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n          if (\n            octalStr !== \"0\" ||\n            next === charCodes.digit8 ||\n            next === charCodes.digit9\n          ) {\n            if (inTemplate) {\n              return null;\n            } else {\n              this.recordStrictModeErrors(codePos, Errors.StrictNumericEscape);\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  // Used to read character escape sequences ('\\x', '\\u').\n\n  readHexChar(\n    len: number,\n    forceLen: boolean,\n    throwOnInvalid: boolean,\n  ): number | null {\n    const codePos = this.state.pos;\n    const n = this.readInt(16, len, forceLen, false);\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, Errors.InvalidEscapeSequence);\n      } else {\n        this.state.pos = codePos - 1;\n      }\n    }\n    return n;\n  }\n\n  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n  //\n  // When `firstCode` is given, it assumes it is always an identifier start and\n  // will skip reading start position again\n\n  readWord1(firstCode: number | void): string {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === charCodes.backslash) {\n        this.state.containsEsc = true;\n\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.pos;\n        const identifierCheck =\n          this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== charCodes.lowercaseU) {\n          this.raise(this.state.pos, Errors.MissingUnicodeEscape);\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(escStart, Errors.EscapedCharNotAnIdentifier);\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  readWord(firstCode: number | void): void {\n    const word = this.readWord1(firstCode);\n    const type = keywordTypes.get(word);\n    if (type !== undefined) {\n      // We don't use word as state.value here because word is a dynamic string\n      // while token label is a shared constant string\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(tt.name, word);\n    }\n  }\n\n  checkKeywordEscapes(): void {\n    const { type } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(\n        this.state.start,\n        Errors.InvalidEscapedReservedWord,\n        tokenLabelName(type),\n      );\n    }\n  }\n\n  // the prevType is required by the jsx plugin\n  // eslint-disable-next-line no-unused-vars\n  updateContext(prevType: TokenType): void {\n    // Token-specific context update code\n    // Note that we should avoid accessing `this.prodParam` in context update,\n    // because it is executed immediately when last token is consumed, which may be\n    // before `this.prodParam` is updated. e.g.\n    // ```\n    // function *g() { () => yield / 2 }\n    // ```\n    // When `=>` is eaten, the context update of `yield` is executed, however,\n    // `this.prodParam` still has `[Yield]` production because it is not yet updated\n    const { context, type } = this.state;\n    switch (type) {\n      case tt.braceR:\n        context.pop();\n        break;\n      // we don't need to update context for tt.braceBarL because we do not pop context for tt.braceBarR\n      // ideally only dollarBraceL \"${\" needs a non-template context\n      // in order to indicate that the last \"`\" in `${`\" starts a new string template\n      // inside a template element within outer string template.\n      // but when we popped such context in `}`, we lost track of whether this\n      // `}` matches a `${` or other tokens matching `}`, so we have to push\n      // such context in every token that `}` will match.\n      case tt.braceL:\n      case tt.braceHashL:\n      case tt.dollarBraceL:\n        context.push(ct.brace);\n        break;\n      case tt.backQuote:\n        if (context[context.length - 1] === ct.template) {\n          context.pop();\n        } else {\n          context.push(ct.template);\n        }\n        break;\n      default:\n        break;\n    }\n  }\n}\n", "// @flow\n\nimport {\n  CLASS_ELEMENT_KIND_ACCESSOR,\n  CLASS_ELEMENT_FLAG_STATIC,\n  type ClassElementTypes,\n} from \"./scopeflags\";\nimport { Errors, type raiseFunction } from \"../parser/error\";\n\nexport class ClassScope {\n  // A list of private named declared in the current class\n  privateNames: Set<string> = new Set();\n\n  // A list of private getters of setters without their counterpart\n  loneAccessors: Map<string, ClassElementTypes> = new Map();\n\n  // A list of private names used before being defined, mapping to\n  // their position.\n  undefinedPrivateNames: Map<string, number> = new Map();\n}\n\nexport default class ClassScopeHandler {\n  stack: Array<ClassScope> = [];\n  declare raise: raiseFunction;\n  undefinedPrivateNames: Map<string, number> = new Map();\n\n  constructor(raise: raiseFunction) {\n    this.raise = raise;\n  }\n\n  current(): ClassScope {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n\n    // Migrate the usage of not yet defined private names to the outer\n    // class scope, or raise an error if we reached the top-level scope.\n\n    const current = this.current();\n\n    // Array.from is needed because this is compiled to an array-like for loop\n    for (const [name, pos] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, pos);\n        }\n      } else {\n        this.raise(pos, Errors.InvalidPrivateFieldResolution, name);\n      }\n    }\n  }\n\n  declarePrivateName(\n    name: string,\n    elementType: ClassElementTypes,\n    pos: number,\n  ) {\n    const classScope = this.current();\n    let redefined = classScope.privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && classScope.loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n\n        // The private name can be duplicated only if it is used by\n        // two accessors with different kind (get and set), and if\n        // they have the same placement (static or not).\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n\n        if (!redefined) classScope.loneAccessors.delete(name);\n      } else if (!redefined) {\n        classScope.loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.raise(pos, Errors.PrivateNameRedeclaration, name);\n    }\n\n    classScope.privateNames.add(name);\n    classScope.undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name: string, pos: number) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, pos);\n    } else {\n      // top-level\n      this.raise(pos, Errors.InvalidPrivateFieldResolution, name);\n    }\n  }\n}\n", "// @flow\n\nimport type { ErrorTemplate, raiseFunction } from \"../parser/error\";\n\n/*:: declare var invariant; */\n/**\n * @module util/expression-scope\n\nExpressionScope is used to track declaration errors in these ambiguous patterns:\n\n- CoverParenthesizedExpressionAndArrowParameterList\n  e.g. we don't know if `({ x })` is an parenthesized expression or an\n  arrow function parameters until we see an `=>` after `)`.\n\n- CoverCallExpressionAndAsyncArrowHead\n   e.g. we don't know if `async({ x })` is a call expression or an async arrow\n   function parameters until we see an `=>` after `)`\n\nThe following declaration errors (@see parser/error-message) will be recorded in\nsome expression scopes and thrown later when we know what the ambigous pattern is\n\n- AwaitBindingIdentifier\n- AwaitExpressionFormalParameter\n- YieldInParameter\n- InvalidParenthesizedAssignment when parenthesized is an identifier\n\nThere are four different expression scope\n- Expression\n  A general scope that represents program / function body / static block. No errors\n  will be recorded nor thrown in this scope.\n\n- MaybeArrowParameterDeclaration\n  A scope that represents ambiguous arrow head e.g. `(x)`. Errors will be recorded\n  alongside parent scopes and thrown when `ExpressionScopeHandler#validateAsPattern`\n  is called.\n\n- MaybeAsyncArrowParameterDeclaration\n  A scope that represents ambiguous async arrow head e.g. `async(x)`. Errors will\n  be recorded alongside parent scopes and thrown when\n  `ExpressionScopeHandler#validateAsPattern` is called.\n\n- ParameterDeclaration\n  A scope that represents unambiguous function parameters `function(x)`. Errors\n  recorded in this scope will be thrown immediately. No errors will be recorded in\n  this scope.\n\n// @see {@link https://docs.google.com/document/d/1FAvEp9EUK-G8kHfDIEo_385Hs2SUBCYbJ5H-NnLvq8M|V8 Expression Scope design docs}\n */\n\nconst kExpression = 0,\n  kMaybeArrowParameterDeclaration = 1,\n  kMaybeAsyncArrowParameterDeclaration = 2,\n  kParameterDeclaration = 3;\n\ntype ExpressionScopeType = 0 | 1 | 2 | 3;\n\nclass ExpressionScope {\n  type: ExpressionScopeType;\n\n  constructor(type: ExpressionScopeType = kExpression) {\n    this.type = type;\n  }\n\n  canBeArrowParameterDeclaration() {\n    return (\n      this.type === kMaybeAsyncArrowParameterDeclaration ||\n      this.type === kMaybeArrowParameterDeclaration\n    );\n  }\n\n  isCertainlyParameterDeclaration() {\n    return this.type === kParameterDeclaration;\n  }\n}\n\nclass ArrowHeadParsingScope extends ExpressionScope {\n  errors: Map</* pos */ number, /* message */ ErrorTemplate> = new Map();\n  constructor(type: 1 | 2) {\n    super(type);\n  }\n  recordDeclarationError(pos: number, template: ErrorTemplate) {\n    this.errors.set(pos, template);\n  }\n  clearDeclarationError(pos: number) {\n    this.errors.delete(pos);\n  }\n  iterateErrors(iterator: (template: ErrorTemplate, pos: number) => void) {\n    this.errors.forEach(iterator);\n  }\n}\n\nexport default class ExpressionScopeHandler {\n  stack: Array<ExpressionScope> = [new ExpressionScope()];\n  declare raise: raiseFunction;\n  constructor(raise: raiseFunction) {\n    this.raise = raise;\n  }\n  enter(scope: ExpressionScope) {\n    this.stack.push(scope);\n  }\n\n  exit() {\n    this.stack.pop();\n  }\n\n  /**\n   * Record likely parameter initializer errors\n   *\n   * When current scope is a ParameterDeclaration, the error will be thrown immediately,\n   * otherwise it will be recorded to any ancestry MaybeArrowParameterDeclaration and\n   * MaybeAsyncArrowParameterDeclaration scope until an Expression scope is seen.\n   * @param {number} pos Error position\n   * @param {ErrorTemplate} template Error template\n   * @memberof ExpressionScopeHandler\n   */\n  recordParameterInitializerError(pos: number, template: ErrorTemplate): void {\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        /*:: invariant(scope instanceof ArrowHeadParsingScope) */\n        scope.recordDeclarationError(pos, template);\n      } else {\n        /*:: invariant(scope.type == kExpression) */\n        // Type-Expression is the boundary where initializer error can populate to\n        return;\n      }\n      scope = stack[--i];\n    }\n    /* eslint-disable @babel/development-internal/dry-error-messages */\n    this.raise(pos, template);\n  }\n\n  /**\n   * Record parenthesized identifier errors\n   *\n   * A parenthesized identifier in LHS can be ambiguous because the assignment\n   * can be transformed to an assignable later, but not vice versa:\n   * For example, in `([(a) = []] = []) => {}`, we think `(a) = []` is an LHS in `[(a) = []]`,\n   * an LHS within `[(a) = []] = []`. However the LHS chain is then transformed by toAssignable,\n   * and we should throw assignment `(a)`, which is only valid in LHS. Hence we record the\n   * location of parenthesized `(a)` to current scope if it is one of MaybeArrowParameterDeclaration\n   * and MaybeAsyncArrowParameterDeclaration\n   *\n   * Unlike `recordParameterInitializerError`, we don't record to ancestry scope because we\n   * validate arrow head parsing scope before exit, and then the LHS will be unambiguous:\n   * For example, in `( x = ( [(a) = []] = [] ) ) => {}`, we should not record `(a)` in `( x = ... ) =>`\n   * arrow scope because when we finish parsing `( [(a) = []] = [] )`, it is an unambiguous assignment\n   * expression and can not be cast to pattern\n   * @param {number} pos\n   * @param {ErrorTemplate} template\n   * @returns {void}\n   * @memberof ExpressionScopeHandler\n   */\n  recordParenthesizedIdentifierError(\n    pos: number,\n    template: ErrorTemplate,\n  ): void {\n    const { stack } = this;\n    const scope: ExpressionScope = stack[stack.length - 1];\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.raise(pos, template);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      /*:: invariant(scope instanceof ArrowHeadParsingScope) */\n      scope.recordDeclarationError(pos, template);\n    } else {\n      return;\n    }\n  }\n\n  /**\n   * Record likely async arrow parameter errors\n   *\n   * Errors will be recorded to any ancestry MaybeAsyncArrowParameterDeclaration\n   * scope until an Expression scope is seen.\n   * @param {number} pos\n   * @param {ErrorTemplate} template\n   * @memberof ExpressionScopeHandler\n   */\n  recordAsyncArrowParametersError(pos: number, template: ErrorTemplate): void {\n    const { stack } = this;\n    let i = stack.length - 1;\n    let scope: ExpressionScope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === kMaybeAsyncArrowParameterDeclaration) {\n        /*:: invariant(scope instanceof ArrowHeadParsingScope) */\n        scope.recordDeclarationError(pos, template);\n      }\n      scope = stack[--i];\n    }\n  }\n\n  validateAsPattern(): void {\n    const { stack } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    /*:: invariant(currentScope instanceof ArrowHeadParsingScope) */\n    currentScope.iterateErrors((template, pos) => {\n      /* eslint-disable @babel/development-internal/dry-error-messages */\n      this.raise(pos, template);\n      // iterate from parent scope\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        /*:: invariant(scope instanceof ArrowHeadParsingScope) */\n        scope.clearDeclarationError(pos);\n        scope = stack[--i];\n      }\n    });\n  }\n}\n\nexport function newParameterDeclarationScope() {\n  return new ExpressionScope(kParameterDeclaration);\n}\n\nexport function newArrowHeadScope() {\n  return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);\n}\n\nexport function newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);\n}\n\nexport function newExpressionScope() {\n  return new ExpressionScope();\n}\n", "// @flow\nexport const PARAM = 0b0000, // Initial Parameter flags\n  PARAM_YIELD = 0b0001, // track [Yield] production parameter\n  PARAM_AWAIT = 0b0010, // track [Await] production parameter\n  PARAM_RETURN = 0b0100, // track [Return] production parameter\n  PARAM_IN = 0b1000; // track [In] production parameter\n\n// ProductionParameterHandler is a stack fashioned production parameter tracker\n// https://tc39.es/ecma262/#sec-grammar-notation\n// The tracked parameters are defined above.\n//\n// Whenever [+Await]/[+Yield] appears in the right-hand sides of a production,\n// we must enter a new tracking stack. For example when parsing\n//\n// AsyncFunctionDeclaration [Yield, Await]:\n//   async [no LineTerminator here] function BindingIdentifier[?Yield, ?Await]\n//     ( FormalParameters[~Yield, +Await] ) { AsyncFunctionBody }\n//\n// we must follow such process:\n//\n// 1. parse async keyword\n// 2. parse function keyword\n// 3. parse bindingIdentifier <= inherit current parameters: [?Await]\n// 4. enter new stack with (PARAM_AWAIT)\n// 5. parse formal parameters <= must have [Await] parameter [+Await]\n// 6. parse function body\n// 7. exit current stack\n\nexport type ParamKind =\n  | typeof PARAM\n  | typeof PARAM_AWAIT\n  | typeof PARAM_IN\n  | typeof PARAM_RETURN\n  | typeof PARAM_YIELD;\n\nexport default class ProductionParameterHandler {\n  stacks: Array<ParamKind> = [];\n  enter(flags: ParamKind) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags(): ParamKind {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait(): boolean {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield(): boolean {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn(): boolean {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n  get hasIn(): boolean {\n    return (this.currentFlags() & PARAM_IN) > 0;\n  }\n}\n\nexport function functionFlags(\n  isAsync: boolean,\n  isGenerator: boolean,\n): ParamKind {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n", "// @flow\n\nimport {\n  isTokenType,\n  tokenIsLiteralPropertyName,\n  tokenLabelName,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types\";\nimport Tokenizer from \"../tokenizer\";\nimport State from \"../tokenizer/state\";\nimport type { Node } from \"../types\";\nimport { lineBreak, skipWhiteSpaceToLineBreak } from \"../util/whitespace\";\nimport { isIdentifierChar } from \"../util/identifier\";\nimport ClassScopeHandler from \"../util/class-scope\";\nimport ExpressionScopeHandler from \"../util/expression-scope\";\nimport { SCOPE_PROGRAM } from \"../util/scopeflags\";\nimport ProductionParameterHandler, {\n  PARAM_AWAIT,\n  PARAM,\n} from \"../util/production-parameter\";\nimport { Errors, type ErrorTemplate, ErrorCodes } from \"./error\";\nimport type { ParsingError } from \"./error\";\n/*::\nimport type ScopeHandler from \"../util/scope\";\n*/\n\ntype TryParse<Node, Error, Thrown, Aborted, FailState> = {\n  node: Node,\n  error: Error,\n  thrown: Thrown,\n  aborted: Aborted,\n  failState: FailState,\n};\n\n// ## Parser utilities\n\nexport default class UtilParser extends Tokenizer {\n  // Forward-declaration: defined in parser/index.js\n  /*::\n  +getScopeHandler: () => Class<ScopeHandler<*>>;\n  */\n\n  // TODO\n\n  addExtra(node: Node, key: string, val: any): void {\n    if (!node) return;\n\n    const extra = (node.extra = node.extra || {});\n    extra[key] = val;\n  }\n\n  // Tests whether parsed token is a contextual keyword.\n\n  isContextual(token: TokenType): boolean {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart: number, name: string): boolean {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(\n        isIdentifierChar(nextCh) ||\n        // check if `nextCh is between 0xd800 - 0xdbff,\n        // if `nextCh` is NaN, `NaN & 0xfc00` is 0, the function\n        // returns true\n        (nextCh & 0xfc00) === 0xd800\n      );\n    }\n    return false;\n  }\n\n  isLookaheadContextual(name: string): boolean {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  // Consumes contextual keyword if possible.\n\n  eatContextual(token: TokenType): boolean {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n\n  // Asserts that following token is given contextual keyword.\n\n  expectContextual(token: TokenType, template?: ErrorTemplate): void {\n    if (!this.eatContextual(token)) this.unexpected(null, template);\n  }\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  canInsertSemicolon(): boolean {\n    return (\n      this.match(tt.eof) ||\n      this.match(tt.braceR) ||\n      this.hasPrecedingLineBreak()\n    );\n  }\n\n  hasPrecedingLineBreak(): boolean {\n    return lineBreak.test(\n      this.input.slice(this.state.lastTokEnd, this.state.start),\n    );\n  }\n\n  hasFollowingLineBreak(): boolean {\n    skipWhiteSpaceToLineBreak.lastIndex = this.state.end;\n    return skipWhiteSpaceToLineBreak.test(this.input);\n  }\n\n  // TODO\n\n  isLineTerminator(): boolean {\n    return this.eat(tt.semi) || this.canInsertSemicolon();\n  }\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  semicolon(allowAsi: boolean = true): void {\n    if (allowAsi ? this.isLineTerminator() : this.eat(tt.semi)) return;\n    this.raise(this.state.lastTokEnd, Errors.MissingSemicolon);\n  }\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error at given pos.\n\n  expect(type: TokenType, pos?: ?number): void {\n    this.eat(type) || this.unexpected(pos, type);\n  }\n\n  // Throws if the current token and the prev one are separated by a space.\n  assertNoSpace(message: string = \"Unexpected space.\"): void {\n    if (this.state.start > this.state.lastTokEnd) {\n      /* eslint-disable @babel/development-internal/dry-error-messages */\n      this.raise(this.state.lastTokEnd, {\n        code: ErrorCodes.SyntaxError,\n        reasonCode: \"UnexpectedSpace\",\n        template: message,\n      });\n      /* eslint-enable @babel/development-internal/dry-error-messages */\n    }\n  }\n\n  // Raise an unexpected token error. Can take the expected token type\n  // instead of a message string.\n\n  unexpected(\n    pos: ?number,\n    messageOrType: ErrorTemplate | TokenType = {\n      code: ErrorCodes.SyntaxError,\n      reasonCode: \"UnexpectedToken\",\n      template: \"Unexpected token\",\n    },\n  ): empty {\n    if (isTokenType(messageOrType)) {\n      messageOrType = {\n        code: ErrorCodes.SyntaxError,\n        reasonCode: \"UnexpectedToken\",\n        template: `Unexpected token, expected \"${tokenLabelName(\n          // $FlowIgnore: Flow does not support assertion signature and TokenType is opaque\n          messageOrType,\n        )}\"`,\n      };\n    }\n\n    /* eslint-disable @babel/development-internal/dry-error-messages */\n    // $FlowIgnore: Flow does not support assertion signature and TokenType is opaque\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n    /* eslint-enable @babel/development-internal/dry-error-messages */\n  }\n\n  expectPlugin(name: string, pos?: ?number): true {\n    if (!this.hasPlugin(name)) {\n      throw this.raiseWithData(\n        pos != null ? pos : this.state.start,\n        { missingPlugin: [name] },\n        `This experimental syntax requires enabling the parser plugin: '${name}'`,\n      );\n    }\n\n    return true;\n  }\n\n  expectOnePlugin(names: Array<string>, pos?: ?number): void {\n    if (!names.some(n => this.hasPlugin(n))) {\n      throw this.raiseWithData(\n        pos != null ? pos : this.state.start,\n        { missingPlugin: names },\n        `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\n          \", \",\n        )}'`,\n      );\n    }\n  }\n\n  // tryParse will clone parser state.\n  // It is expensive and should be used with cautions\n  tryParse<T: Node | $ReadOnlyArray<Node>>(\n    fn: (abort: (node?: T) => empty) => T,\n    oldState: State = this.state.clone(),\n  ):\n    | TryParse<T, null, false, false, null>\n    | TryParse<T | null, ParsingError, boolean, false, State>\n    | TryParse<T | null, null, false, true, State> {\n    const abortSignal: { node: T | null } = { node: null };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        // tokensLength should be preserved during error recovery mode\n        // since the parser does not halt and will instead parse the\n        // remaining tokens\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: (failState.errors[oldState.errors.length]: ParsingError),\n          thrown: false,\n          aborted: false,\n          failState,\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null,\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return { node: null, error, thrown: true, aborted: false, failState };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState,\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(\n    refExpressionErrors: ?ExpressionErrors,\n    andThrow: boolean,\n  ) {\n    if (!refExpressionErrors) return false;\n    const { shorthandAssign, doubleProto, optionalParameters } =\n      refExpressionErrors;\n    // shorthandAssign >= 0 || doubleProto >= 0 || optionalParameters >= 0\n    const hasErrors = shorthandAssign + doubleProto + optionalParameters > -3;\n    if (!andThrow) {\n      return hasErrors;\n    } else if (hasErrors) {\n      if (shorthandAssign >= 0) {\n        this.unexpected(shorthandAssign);\n      }\n      if (doubleProto >= 0) {\n        this.raise(doubleProto, Errors.DuplicateProto);\n      }\n      if (optionalParameters >= 0) {\n        this.unexpected(optionalParameters);\n      }\n    }\n  }\n\n  /**\n   * Test if current token is a literal property name\n   * https://tc39.es/ecma262/#prod-LiteralPropertyName\n   * LiteralPropertyName:\n   *   IdentifierName\n   *   StringLiteral\n   *   NumericLiteral\n   *   BigIntLiteral\n   */\n  isLiteralPropertyName(): boolean {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n\n  /*\n   * Test if given node is a PrivateName\n   * will be overridden in ESTree plugin\n   */\n  isPrivateName(node: Node): boolean {\n    return node.type === \"PrivateName\";\n  }\n\n  /*\n   * Return the string value of a given private name\n   * WITHOUT `#`\n   * @see {@link https://tc39.es/ecma262/#sec-static-semantics-stringvalue}\n   */\n  getPrivateNameSV(node: Node): string {\n    return node.id.name;\n  }\n\n  /*\n   * Return whether the given node is a member/optional chain that\n   * contains a private name as its property\n   * It is overridden in ESTree plugin\n   */\n  hasPropertyAsPrivateName(node: Node): boolean {\n    return (\n      (node.type === \"MemberExpression\" ||\n        node.type === \"OptionalMemberExpression\") &&\n      this.isPrivateName(node.property)\n    );\n  }\n\n  isOptionalChain(node: Node): boolean {\n    return (\n      node.type === \"OptionalMemberExpression\" ||\n      node.type === \"OptionalCallExpression\"\n    );\n  }\n\n  isObjectProperty(node: Node): boolean {\n    return node.type === \"ObjectProperty\";\n  }\n\n  isObjectMethod(node: Node): boolean {\n    return node.type === \"ObjectMethod\";\n  }\n\n  initializeScopes(\n    inModule: boolean = this.options.sourceType === \"module\",\n  ): () => void {\n    // Initialize state\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n\n    // initialize scopes\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\n\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this.raise.bind(this));\n\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));\n\n    return () => {\n      // Revert state\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n\n      // Revert scopes\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n\n  enterInitialScopes() {\n    let paramFlags = PARAM;\n    if (this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n  }\n}\n\n/**\n * The ExpressionErrors is a context struct used to track ambiguous patterns\n * When we are sure the parsed pattern is a RHS, which means it is not a pattern,\n * we will throw on this position on invalid assign syntax, otherwise it will be reset to -1\n *\n * Types of ExpressionErrors:\n *\n * - **shorthandAssign**: track initializer `=` position\n * - **doubleProto**: track the duplicate `__proto__` key position\n * - **optionalParameters**: track the optional paramter (`?`).\n * It's only used by typescript and flow plugins\n */\nexport class ExpressionErrors {\n  shorthandAssign = -1;\n  doubleProto = -1;\n  optionalParameters = -1;\n}\n", "// @flow\n\nimport type Parser from \"./index\";\nimport UtilParser from \"./util\";\nimport { SourceLocation, type Position } from \"../util/location\";\nimport type { Comment, Node as NodeType, NodeBase } from \"../types\";\n\n// Start an AST node, attaching a start offset.\n\nclass Node implements NodeBase {\n  constructor(parser: Parser, pos: number, loc: Position) {\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser?.options.ranges) this.range = [pos, 0];\n    if (parser?.filename) this.loc.filename = parser.filename;\n  }\n\n  type: string = \"\";\n  declare start: number;\n  declare end: number;\n  declare loc: SourceLocation;\n  declare range: [number, number];\n  declare leadingComments: Array<Comment>;\n  declare trailingComments: Array<Comment>;\n  declare innerComments: Array<Comment>;\n  declare extra: { [key: string]: any };\n}\nconst NodePrototype = Node.prototype;\n\nif (!process.env.BABEL_8_BREAKING) {\n  // $FlowIgnore\n  NodePrototype.__clone = function (): Node {\n    // $FlowIgnore\n    const newNode: any = new Node();\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      // Do not clone comments that are already attached to the node\n      if (\n        key !== \"leadingComments\" &&\n        key !== \"trailingComments\" &&\n        key !== \"innerComments\"\n      ) {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  };\n}\n\nfunction clonePlaceholder(node: any): any {\n  return cloneIdentifier(node);\n}\n\nexport function cloneIdentifier(node: any): any {\n  // We don't need to clone `typeAnnotations` and `optional`: because\n  // cloneIdentifier is only used in object shorthand and named import/export.\n  // Neither of them allow type annotations after the identifier or optional identifier\n  const { type, start, end, loc, range, extra, name } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === \"Placeholder\") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\n\nexport function cloneStringLiteral(node: any): any {\n  const { type, start, end, loc, range, extra } = node;\n  if (type === \"Placeholder\") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = \"StringLiteral\";\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.value = node.value;\n  return cloned;\n}\n\nexport class NodeUtils extends UtilParser {\n  startNode<T: NodeType>(): T {\n    // $FlowIgnore\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt<T: NodeType>(pos: number, loc: Position): T {\n    // $FlowIgnore\n    return new Node(this, pos, loc);\n  }\n\n  /** Start a new node with a previous node's location. */\n  startNodeAtNode<T: NodeType>(type: NodeType): T {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  finishNode<T: NodeType>(node: T, type: string): T {\n    return this.finishNodeAt(\n      node,\n      type,\n      this.state.lastTokEnd,\n      this.state.lastTokEndLoc,\n    );\n  }\n\n  // Finish node at given position\n\n  finishNodeAt<T: NodeType>(\n    node: T,\n    type: string,\n    pos: number,\n    loc: Position,\n  ): T {\n    if (process.env.NODE_ENV !== \"production\" && node.end > 0) {\n      throw new Error(\n        \"Do not call finishNode*() twice on the same node.\" +\n          \" Instead use resetEndLocation() or change type directly.\",\n      );\n    }\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    if (this.options.attachComment) this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node: NodeBase, start: number, startLoc: Position): void {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(\n    node: NodeBase,\n    end?: number = this.state.lastTokEnd,\n    endLoc?: Position = this.state.lastTokEndLoc,\n  ): void {\n    node.end = end;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = end;\n  }\n\n  /**\n   * Reset the start location of node to the start location of locationNode\n   */\n  resetStartLocationFromNode(node: NodeBase, locationNode: NodeBase): void {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n}\n", "// @flow\n\n/*:: declare var invariant; */\n\n// Error messages are colocated with the plugin.\n/* eslint-disable @babel/development-internal/dry-error-messages */\n\nimport type Parser from \"../../parser\";\nimport {\n  tokenIsIdentifier,\n  tokenIsKeyword,\n  tokenIsKeywordOrIdentifier,\n  tokenIsLiteralPropertyName,\n  tokenLabelName,\n  tt,\n  type TokenType,\n  tokenIsFlowInterfaceOrTypeOrOpaque,\n} from \"../../tokenizer/types\";\nimport * as N from \"../../types\";\nimport type { Position } from \"../../util/location\";\nimport { types as tc } from \"../../tokenizer/context\";\nimport * as charCodes from \"charcodes\";\nimport { isIteratorStart } from \"../../util/identifier\";\nimport FlowScopeHandler from \"./scope\";\nimport {\n  type BindingTypes,\n  BIND_LEXICAL,\n  BIND_VAR,\n  BIND_FUNCTION,\n  BIND_FLOW_DECLARE_FN,\n  SCOPE_ARROW,\n  SCOPE_FUNCTION,\n  SCOPE_OTHER,\n} from \"../../util/scopeflags\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport { Errors, makeErrorTemplates, ErrorCodes } from \"../../parser/error\";\nimport { cloneIdentifier } from \"../../parser/node\";\n\nconst reservedTypes = new Set([\n  \"_\",\n  \"any\",\n  \"bool\",\n  \"boolean\",\n  \"empty\",\n  \"extends\",\n  \"false\",\n  \"interface\",\n  \"mixed\",\n  \"null\",\n  \"number\",\n  \"static\",\n  \"string\",\n  \"true\",\n  \"typeof\",\n  \"void\",\n]);\n\n/* eslint sort-keys: \"error\" */\n// The Errors key follows https://github.com/facebook/flow/blob/master/src/parser/parse_error.ml unless it does not exist\nconst FlowErrors = makeErrorTemplates(\n  {\n    AmbiguousConditionalArrow:\n      \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n    AmbiguousDeclareModuleKind:\n      \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n    AssignReservedType: \"Cannot overwrite reserved type %0.\",\n    DeclareClassElement:\n      \"The `declare` modifier can only appear on class fields.\",\n    DeclareClassFieldInitializer:\n      \"Initializers are not allowed in fields with the `declare` modifier.\",\n    DuplicateDeclareModuleExports:\n      \"Duplicate `declare module.exports` statement.\",\n    EnumBooleanMemberNotInitialized:\n      \"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",\n    EnumDuplicateMemberName:\n      \"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",\n    EnumInconsistentMemberValues:\n      \"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",\n    EnumInvalidExplicitType:\n      \"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n    EnumInvalidExplicitTypeUnknownSupplied:\n      \"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n    EnumInvalidMemberInitializerPrimaryType:\n      \"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",\n    EnumInvalidMemberInitializerSymbolType:\n      \"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",\n    EnumInvalidMemberInitializerUnknownType:\n      \"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",\n    EnumInvalidMemberName:\n      \"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",\n    EnumNumberMemberNotInitialized:\n      \"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",\n    EnumStringMemberInconsistentlyInitailized:\n      \"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",\n    GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n    ImportTypeShorthandOnlyInPureImport:\n      \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n    InexactInsideExact:\n      \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n    InexactInsideNonObject:\n      \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n    InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n    InvalidNonTypeImportInDeclareModule:\n      \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n    MissingTypeParamDefault:\n      \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n    NestedDeclareModule:\n      \"`declare module` cannot be used inside another `declare module`.\",\n    NestedFlowComment:\n      \"Cannot have a flow comment inside another flow comment.\",\n    PatternIsOptional:\n      \"A binding pattern parameter cannot be optional in an implementation signature.\",\n    SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n    SpreadVariance: \"Spread properties cannot have variance.\",\n    ThisParamAnnotationRequired:\n      \"A type annotation is required for the `this` parameter.\",\n    ThisParamBannedInConstructor:\n      \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n    ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n    ThisParamMustBeFirst:\n      \"The `this` parameter must be the first function parameter.\",\n    ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n    TypeBeforeInitializer:\n      \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n    TypeCastInPattern:\n      \"The type cast expression is expected to be wrapped with parenthesis.\",\n    UnexpectedExplicitInexactInObject:\n      \"Explicit inexact syntax must appear at the end of an inexact object.\",\n    UnexpectedReservedType: \"Unexpected reserved type %0.\",\n    UnexpectedReservedUnderscore:\n      \"`_` is only allowed as a type argument to call or new.\",\n    UnexpectedSpaceBetweenModuloChecks:\n      \"Spaces between `%` and `checks` are not allowed here.\",\n    UnexpectedSpreadType:\n      \"Spread operator cannot appear in class or interface definitions.\",\n    UnexpectedSubtractionOperand:\n      'Unexpected token, expected \"number\" or \"bigint\".',\n    UnexpectedTokenAfterTypeParameter:\n      \"Expected an arrow function after this type parameter declaration.\",\n    UnexpectedTypeParameterBeforeAsyncArrowFunction:\n      \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n    UnsupportedDeclareExportKind:\n      \"`declare export %0` is not supported. Use `%1` instead.\",\n    UnsupportedStatementInDeclareModule:\n      \"Only declares and type imports are allowed inside declare module.\",\n    UnterminatedFlowComment: \"Unterminated flow-comment.\",\n  },\n  /* code */ ErrorCodes.SyntaxError,\n  /* syntaxPlugin */ \"flow\",\n);\n/* eslint-disable sort-keys */\n\nfunction isEsModuleType(bodyElement: N.Node): boolean {\n  return (\n    bodyElement.type === \"DeclareExportAllDeclaration\" ||\n    (bodyElement.type === \"DeclareExportDeclaration\" &&\n      (!bodyElement.declaration ||\n        (bodyElement.declaration.type !== \"TypeAlias\" &&\n          bodyElement.declaration.type !== \"InterfaceDeclaration\")))\n  );\n}\n\nfunction hasTypeImportKind(node: N.Node): boolean {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(type: TokenType): boolean {\n  return tokenIsKeywordOrIdentifier(type) && type !== tt._from;\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\",\n};\n\n// Like Array#filter, but returns a tuple [ acceptedElements, discardedElements ]\nfunction partition<T>(\n  list: T[],\n  test: (T, number, T[]) => ?boolean,\n): [T[], T[]] {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\n\n// Flow enums types\ntype EnumExplicitType = null | \"boolean\" | \"number\" | \"string\" | \"symbol\";\ntype EnumContext = {|\n  enumName: string,\n  explicitType: EnumExplicitType,\n  memberName: string,\n|};\ntype EnumMemberInit =\n  | {| type: \"number\", pos: number, value: N.Node |}\n  | {| type: \"string\", pos: number, value: N.Node |}\n  | {| type: \"boolean\", pos: number, value: N.Node |}\n  | {| type: \"invalid\", pos: number |}\n  | {| type: \"none\", pos: number |};\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    // The value of the @flow/@noflow pragma. Initially undefined, transitions\n    // to \"@flow\" or \"@noflow\" if we see a pragma. Transitions to null if we are\n    // past the initial comment.\n    flowPragma: void | null | \"flow\" | \"noflow\" = undefined;\n\n    getScopeHandler(): Class<FlowScopeHandler> {\n      return FlowScopeHandler;\n    }\n\n    shouldParseTypes(): boolean {\n      return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n    }\n\n    shouldParseEnums(): boolean {\n      return !!this.getPluginOption(\"flow\", \"enums\");\n    }\n\n    finishToken(type: TokenType, val: any): void {\n      if (\n        type !== tt.string &&\n        type !== tt.semi &&\n        type !== tt.interpreterDirective\n      ) {\n        if (this.flowPragma === undefined) {\n          this.flowPragma = null;\n        }\n      }\n      return super.finishToken(type, val);\n    }\n\n    addComment(comment: N.Comment): void {\n      if (this.flowPragma === undefined) {\n        // Try to parse a flow pragma.\n        const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n        if (!matches) {\n          // do nothing\n        } else if (matches[1] === \"flow\") {\n          this.flowPragma = \"flow\";\n        } else if (matches[1] === \"noflow\") {\n          this.flowPragma = \"noflow\";\n        } else {\n          throw new Error(\"Unexpected flow pragma\");\n        }\n      }\n      return super.addComment(comment);\n    }\n\n    flowParseTypeInitialiser(tok?: TokenType): N.FlowType {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tok || tt.colon);\n\n      const type = this.flowParseType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParsePredicate(): N.FlowType {\n      const node = this.startNode();\n      const moduloPos = this.state.start;\n      this.next(); // eat `%`\n      this.expectContextual(tt._checks);\n      // Force '%' and 'checks' to be adjacent\n      if (this.state.lastTokStart > moduloPos + 1) {\n        this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);\n      }\n      if (this.eat(tt.parenL)) {\n        node.value = this.parseExpression();\n        this.expect(tt.parenR);\n        return this.finishNode(node, \"DeclaredPredicate\");\n      } else {\n        return this.finishNode(node, \"InferredPredicate\");\n      }\n    }\n\n    flowParseTypeAndPredicateInitialiser(): [?N.FlowType, ?N.FlowPredicate] {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      this.expect(tt.colon);\n      let type = null;\n      let predicate = null;\n      if (this.match(tt.modulo)) {\n        this.state.inType = oldInType;\n        predicate = this.flowParsePredicate();\n      } else {\n        type = this.flowParseType();\n        this.state.inType = oldInType;\n        if (this.match(tt.modulo)) {\n          predicate = this.flowParsePredicate();\n        }\n      }\n      return [type, predicate];\n    }\n\n    flowParseDeclareClass(node: N.FlowDeclareClass): N.FlowDeclareClass {\n      this.next();\n      this.flowParseInterfaceish(node, /*isClass*/ true);\n      return this.finishNode(node, \"DeclareClass\");\n    }\n\n    flowParseDeclareFunction(\n      node: N.FlowDeclareFunction,\n    ): N.FlowDeclareFunction {\n      this.next();\n\n      const id = (node.id = this.parseIdentifier());\n\n      const typeNode = this.startNode();\n      const typeContainer = this.startNode();\n\n      if (this.match(tt.lt)) {\n        typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        typeNode.typeParameters = null;\n      }\n\n      this.expect(tt.parenL);\n      const tmp = this.flowParseFunctionTypeParams();\n      typeNode.params = tmp.params;\n      typeNode.rest = tmp.rest;\n      typeNode.this = tmp._this;\n      this.expect(tt.parenR);\n\n      [\n        // $FlowFixMe (destructuring not supported yet)\n        typeNode.returnType,\n        // $FlowFixMe (destructuring not supported yet)\n        node.predicate,\n      ] = this.flowParseTypeAndPredicateInitialiser();\n\n      typeContainer.typeAnnotation = this.finishNode(\n        typeNode,\n        \"FunctionTypeAnnotation\",\n      );\n\n      id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n\n      this.resetEndLocation(id);\n      this.semicolon();\n\n      this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);\n\n      return this.finishNode(node, \"DeclareFunction\");\n    }\n\n    flowParseDeclare(\n      node: N.FlowDeclare,\n      insideModule?: boolean,\n    ): N.FlowDeclare {\n      if (this.match(tt._class)) {\n        return this.flowParseDeclareClass(node);\n      } else if (this.match(tt._function)) {\n        return this.flowParseDeclareFunction(node);\n      } else if (this.match(tt._var)) {\n        return this.flowParseDeclareVariable(node);\n      } else if (this.eatContextual(tt._module)) {\n        if (this.match(tt.dot)) {\n          return this.flowParseDeclareModuleExports(node);\n        } else {\n          if (insideModule) {\n            this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);\n          }\n          return this.flowParseDeclareModule(node);\n        }\n      } else if (this.isContextual(tt._type)) {\n        return this.flowParseDeclareTypeAlias(node);\n      } else if (this.isContextual(tt._opaque)) {\n        return this.flowParseDeclareOpaqueType(node);\n      } else if (this.isContextual(tt._interface)) {\n        return this.flowParseDeclareInterface(node);\n      } else if (this.match(tt._export)) {\n        return this.flowParseDeclareExportDeclaration(node, insideModule);\n      } else {\n        throw this.unexpected();\n      }\n    }\n\n    flowParseDeclareVariable(\n      node: N.FlowDeclareVariable,\n    ): N.FlowDeclareVariable {\n      this.next();\n      node.id = this.flowParseTypeAnnotatableIdentifier(\n        /*allowPrimitiveOverride*/ true,\n      );\n      this.scope.declareName(node.id.name, BIND_VAR, node.id.start);\n      this.semicolon();\n      return this.finishNode(node, \"DeclareVariable\");\n    }\n\n    flowParseDeclareModule(node: N.FlowDeclareModule): N.FlowDeclareModule {\n      this.scope.enter(SCOPE_OTHER);\n\n      if (this.match(tt.string)) {\n        node.id = this.parseExprAtom();\n      } else {\n        node.id = this.parseIdentifier();\n      }\n\n      const bodyNode = (node.body = this.startNode());\n      const body = (bodyNode.body = []);\n      this.expect(tt.braceL);\n      while (!this.match(tt.braceR)) {\n        let bodyNode = this.startNode();\n\n        if (this.match(tt._import)) {\n          this.next();\n          if (!this.isContextual(tt._type) && !this.match(tt._typeof)) {\n            this.raise(\n              this.state.lastTokStart,\n              FlowErrors.InvalidNonTypeImportInDeclareModule,\n            );\n          }\n          this.parseImport(bodyNode);\n        } else {\n          this.expectContextual(\n            tt._declare,\n            FlowErrors.UnsupportedStatementInDeclareModule,\n          );\n\n          bodyNode = this.flowParseDeclare(bodyNode, true);\n        }\n\n        body.push(bodyNode);\n      }\n\n      this.scope.exit();\n\n      this.expect(tt.braceR);\n\n      this.finishNode(bodyNode, \"BlockStatement\");\n\n      let kind = null;\n      let hasModuleExport = false;\n      body.forEach(bodyElement => {\n        if (isEsModuleType(bodyElement)) {\n          if (kind === \"CommonJS\") {\n            this.raise(\n              bodyElement.start,\n              FlowErrors.AmbiguousDeclareModuleKind,\n            );\n          }\n          kind = \"ES\";\n        } else if (bodyElement.type === \"DeclareModuleExports\") {\n          if (hasModuleExport) {\n            this.raise(\n              bodyElement.start,\n              FlowErrors.DuplicateDeclareModuleExports,\n            );\n          }\n          if (kind === \"ES\") {\n            this.raise(\n              bodyElement.start,\n              FlowErrors.AmbiguousDeclareModuleKind,\n            );\n          }\n          kind = \"CommonJS\";\n          hasModuleExport = true;\n        }\n      });\n\n      node.kind = kind || \"CommonJS\";\n      return this.finishNode(node, \"DeclareModule\");\n    }\n\n    flowParseDeclareExportDeclaration(\n      node: N.FlowDeclareExportDeclaration,\n      insideModule: ?boolean,\n    ): N.FlowDeclareExportDeclaration {\n      this.expect(tt._export);\n\n      if (this.eat(tt._default)) {\n        if (this.match(tt._function) || this.match(tt._class)) {\n          // declare export default class ...\n          // declare export default function ...\n          node.declaration = this.flowParseDeclare(this.startNode());\n        } else {\n          // declare export default [type];\n          node.declaration = this.flowParseType();\n          this.semicolon();\n        }\n        node.default = true;\n\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else {\n        if (\n          this.match(tt._const) ||\n          this.isLet() ||\n          ((this.isContextual(tt._type) || this.isContextual(tt._interface)) &&\n            !insideModule)\n        ) {\n          const label = this.state.value;\n          const suggestion = exportSuggestions[label];\n\n          throw this.raise(\n            this.state.start,\n            FlowErrors.UnsupportedDeclareExportKind,\n            label,\n            suggestion,\n          );\n        }\n\n        if (\n          this.match(tt._var) || // declare export var ...\n          this.match(tt._function) || // declare export function ...\n          this.match(tt._class) || // declare export class ...\n          this.isContextual(tt._opaque) // declare export opaque ..\n        ) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (\n          this.match(tt.star) || // declare export * from ''\n          this.match(tt.braceL) || // declare export {} ...\n          this.isContextual(tt._interface) || // declare export interface ...\n          this.isContextual(tt._type) || // declare export type ...\n          this.isContextual(tt._opaque) // declare export opaque type ...\n        ) {\n          node = this.parseExport(node);\n          if (node.type === \"ExportNamedDeclaration\") {\n            // flow does not support the ExportNamedDeclaration\n            // $FlowIgnore\n            node.type = \"ExportDeclaration\";\n            // $FlowFixMe\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          // $FlowIgnore\n          node.type = \"Declare\" + node.type;\n\n          return node;\n        }\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParseDeclareModuleExports(\n      node: N.FlowDeclareModuleExports,\n    ): N.FlowDeclareModuleExports {\n      this.next();\n      this.expectContextual(tt._exports);\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n      this.semicolon();\n\n      return this.finishNode(node, \"DeclareModuleExports\");\n    }\n\n    flowParseDeclareTypeAlias(\n      node: N.FlowDeclareTypeAlias,\n    ): N.FlowDeclareTypeAlias {\n      this.next();\n      this.flowParseTypeAlias(node);\n      // Don't do finishNode as we don't want to process comments twice\n      node.type = \"DeclareTypeAlias\";\n      return node;\n    }\n\n    flowParseDeclareOpaqueType(\n      node: N.FlowDeclareOpaqueType,\n    ): N.FlowDeclareOpaqueType {\n      this.next();\n      this.flowParseOpaqueType(node, true);\n      // Don't do finishNode as we don't want to process comments twice\n      node.type = \"DeclareOpaqueType\";\n      return node;\n    }\n\n    flowParseDeclareInterface(\n      node: N.FlowDeclareInterface,\n    ): N.FlowDeclareInterface {\n      this.next();\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"DeclareInterface\");\n    }\n\n    // Interfaces\n\n    flowParseInterfaceish(\n      node: N.FlowDeclare,\n      isClass?: boolean = false,\n    ): void {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ !isClass,\n        /* declaration */ true,\n      );\n\n      this.scope.declareName(\n        node.id.name,\n        isClass ? BIND_FUNCTION : BIND_LEXICAL,\n        node.id.start,\n      );\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.extends = [];\n      node.implements = [];\n      node.mixins = [];\n\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (!isClass && this.eat(tt.comma));\n      }\n\n      if (this.isContextual(tt._mixins)) {\n        this.next();\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      if (this.isContextual(tt._implements)) {\n        this.next();\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: isClass,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: isClass,\n        allowInexact: false,\n      });\n    }\n\n    flowParseInterfaceExtends(): N.FlowInterfaceExtends {\n      const node = this.startNode();\n\n      node.id = this.flowParseQualifiedTypeIdentifier();\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      } else {\n        node.typeParameters = null;\n      }\n\n      return this.finishNode(node, \"InterfaceExtends\");\n    }\n\n    flowParseInterface(node: N.FlowInterface): N.FlowInterface {\n      this.flowParseInterfaceish(node);\n      return this.finishNode(node, \"InterfaceDeclaration\");\n    }\n\n    checkNotUnderscore(word: string) {\n      if (word === \"_\") {\n        this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);\n      }\n    }\n\n    checkReservedType(word: string, startLoc: number, declaration?: boolean) {\n      if (!reservedTypes.has(word)) return;\n\n      this.raise(\n        startLoc,\n        declaration\n          ? FlowErrors.AssignReservedType\n          : FlowErrors.UnexpectedReservedType,\n        word,\n      );\n    }\n\n    flowParseRestrictedIdentifier(\n      liberal?: boolean,\n      declaration?: boolean,\n    ): N.Identifier {\n      this.checkReservedType(this.state.value, this.state.start, declaration);\n      return this.parseIdentifier(liberal);\n    }\n\n    // Type aliases\n\n    flowParseTypeAlias(node: N.FlowTypeAlias): N.FlowTypeAlias {\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ false,\n        /* declaration */ true,\n      );\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      node.right = this.flowParseTypeInitialiser(tt.eq);\n      this.semicolon();\n\n      return this.finishNode(node, \"TypeAlias\");\n    }\n\n    flowParseOpaqueType(\n      node: N.FlowOpaqueType,\n      declare: boolean,\n    ): N.FlowOpaqueType {\n      this.expectContextual(tt._type);\n      node.id = this.flowParseRestrictedIdentifier(\n        /* liberal */ true,\n        /* declaration */ true,\n      );\n      this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      } else {\n        node.typeParameters = null;\n      }\n\n      // Parse the supertype\n      node.supertype = null;\n      if (this.match(tt.colon)) {\n        node.supertype = this.flowParseTypeInitialiser(tt.colon);\n      }\n\n      node.impltype = null;\n      if (!declare) {\n        node.impltype = this.flowParseTypeInitialiser(tt.eq);\n      }\n      this.semicolon();\n\n      return this.finishNode(node, \"OpaqueType\");\n    }\n\n    // Type annotations\n\n    flowParseTypeParameter(requireDefault?: boolean = false): N.TypeParameter {\n      const nodeStart = this.state.start;\n\n      const node = this.startNode();\n\n      const variance = this.flowParseVariance();\n\n      const ident = this.flowParseTypeAnnotatableIdentifier();\n      node.name = ident.name;\n      node.variance = variance;\n      node.bound = ident.typeAnnotation;\n\n      if (this.match(tt.eq)) {\n        this.eat(tt.eq);\n        node.default = this.flowParseType();\n      } else {\n        if (requireDefault) {\n          this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);\n        }\n      }\n\n      return this.finishNode(node, \"TypeParameter\");\n    }\n\n    flowParseTypeParameterDeclaration(): N.TypeParameterDeclaration {\n      const oldInType = this.state.inType;\n      const node = this.startNode();\n      node.params = [];\n\n      this.state.inType = true;\n\n      // istanbul ignore else: this condition is already checked at all call sites\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      let defaultRequired = false;\n\n      do {\n        const typeParameter = this.flowParseTypeParameter(defaultRequired);\n\n        node.params.push(typeParameter);\n\n        if (typeParameter.default) {\n          defaultRequired = true;\n        }\n\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      } while (!this.match(tt.gt));\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterDeclaration\");\n    }\n\n    flowParseTypeParameterInstantiation(): N.TypeParameterInstantiation {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseType());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseTypeParameterInstantiationCallOrNew(): N.TypeParameterInstantiation {\n      const node = this.startNode();\n      const oldInType = this.state.inType;\n      node.params = [];\n\n      this.state.inType = true;\n\n      this.expect(tt.lt);\n      while (!this.match(tt.gt)) {\n        node.params.push(this.flowParseTypeOrImplicitInstantiation());\n        if (!this.match(tt.gt)) {\n          this.expect(tt.comma);\n        }\n      }\n      this.expect(tt.gt);\n\n      this.state.inType = oldInType;\n\n      return this.finishNode(node, \"TypeParameterInstantiation\");\n    }\n\n    flowParseInterfaceType(): N.FlowInterfaceType {\n      const node = this.startNode();\n      this.expectContextual(tt._interface);\n\n      node.extends = [];\n      if (this.eat(tt._extends)) {\n        do {\n          node.extends.push(this.flowParseInterfaceExtends());\n        } while (this.eat(tt.comma));\n      }\n\n      node.body = this.flowParseObjectType({\n        allowStatic: false,\n        allowExact: false,\n        allowSpread: false,\n        allowProto: false,\n        allowInexact: false,\n      });\n\n      return this.finishNode(node, \"InterfaceTypeAnnotation\");\n    }\n\n    flowParseObjectPropertyKey(): N.Expression {\n      return this.match(tt.num) || this.match(tt.string)\n        ? this.parseExprAtom()\n        : this.parseIdentifier(true);\n    }\n\n    flowParseObjectTypeIndexer(\n      node: N.FlowObjectTypeIndexer,\n      isStatic: boolean,\n      variance: ?N.FlowVariance,\n    ): N.FlowObjectTypeIndexer {\n      node.static = isStatic;\n\n      // Note: bracketL has already been consumed\n      if (this.lookahead().type === tt.colon) {\n        node.id = this.flowParseObjectPropertyKey();\n        node.key = this.flowParseTypeInitialiser();\n      } else {\n        node.id = null;\n        node.key = this.flowParseType();\n      }\n      this.expect(tt.bracketR);\n      node.value = this.flowParseTypeInitialiser();\n      node.variance = variance;\n\n      return this.finishNode(node, \"ObjectTypeIndexer\");\n    }\n\n    flowParseObjectTypeInternalSlot(\n      node: N.FlowObjectTypeInternalSlot,\n      isStatic: boolean,\n    ): N.FlowObjectTypeInternalSlot {\n      node.static = isStatic;\n      // Note: both bracketL have already been consumed\n      node.id = this.flowParseObjectPropertyKey();\n      this.expect(tt.bracketR);\n      this.expect(tt.bracketR);\n      if (this.match(tt.lt) || this.match(tt.parenL)) {\n        node.method = true;\n        node.optional = false;\n        node.value = this.flowParseObjectTypeMethodish(\n          this.startNodeAt(node.start, node.loc.start),\n        );\n      } else {\n        node.method = false;\n        if (this.eat(tt.question)) {\n          node.optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n      }\n      return this.finishNode(node, \"ObjectTypeInternalSlot\");\n    }\n\n    flowParseObjectTypeMethodish(\n      node: N.FlowFunctionTypeAnnotation,\n    ): N.FlowFunctionTypeAnnotation {\n      node.params = [];\n      node.rest = null;\n      node.typeParameters = null;\n      node.this = null;\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      this.expect(tt.parenL);\n      if (this.match(tt._this)) {\n        node.this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        node.this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        node.params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n\n      if (this.eat(tt.ellipsis)) {\n        node.rest = this.flowParseFunctionTypeParam(false);\n      }\n      this.expect(tt.parenR);\n      node.returnType = this.flowParseTypeInitialiser();\n\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    flowParseObjectTypeCallProperty(\n      node: N.FlowObjectTypeCallProperty,\n      isStatic: boolean,\n    ): N.FlowObjectTypeCallProperty {\n      const valueNode = this.startNode();\n      node.static = isStatic;\n      node.value = this.flowParseObjectTypeMethodish(valueNode);\n      return this.finishNode(node, \"ObjectTypeCallProperty\");\n    }\n\n    flowParseObjectType({\n      allowStatic,\n      allowExact,\n      allowSpread,\n      allowProto,\n      allowInexact,\n    }: {\n      allowStatic: boolean,\n      allowExact: boolean,\n      allowSpread: boolean,\n      allowProto: boolean,\n      allowInexact: boolean,\n    }): N.FlowObjectTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n\n      const nodeStart = this.startNode();\n\n      nodeStart.callProperties = [];\n      nodeStart.properties = [];\n      nodeStart.indexers = [];\n      nodeStart.internalSlots = [];\n\n      let endDelim;\n      let exact;\n      let inexact = false;\n      if (allowExact && this.match(tt.braceBarL)) {\n        this.expect(tt.braceBarL);\n        endDelim = tt.braceBarR;\n        exact = true;\n      } else {\n        this.expect(tt.braceL);\n        endDelim = tt.braceR;\n        exact = false;\n      }\n\n      nodeStart.exact = exact;\n\n      while (!this.match(endDelim)) {\n        let isStatic = false;\n        let protoStart: ?number = null;\n        let inexactStart: ?number = null;\n        const node = this.startNode();\n\n        if (allowProto && this.isContextual(tt._proto)) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            protoStart = this.state.start;\n            allowStatic = false;\n          }\n        }\n\n        if (allowStatic && this.isContextual(tt._static)) {\n          const lookahead = this.lookahead();\n\n          // static is a valid identifier name\n          if (lookahead.type !== tt.colon && lookahead.type !== tt.question) {\n            this.next();\n            isStatic = true;\n          }\n        }\n\n        const variance = this.flowParseVariance();\n\n        if (this.eat(tt.bracketL)) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n          if (this.eat(tt.bracketL)) {\n            if (variance) {\n              this.unexpected(variance.start);\n            }\n            nodeStart.internalSlots.push(\n              this.flowParseObjectTypeInternalSlot(node, isStatic),\n            );\n          } else {\n            nodeStart.indexers.push(\n              this.flowParseObjectTypeIndexer(node, isStatic, variance),\n            );\n          }\n        } else if (this.match(tt.parenL) || this.match(tt.lt)) {\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n          nodeStart.callProperties.push(\n            this.flowParseObjectTypeCallProperty(node, isStatic),\n          );\n        } else {\n          let kind = \"init\";\n\n          if (this.isContextual(tt._get) || this.isContextual(tt._set)) {\n            const lookahead = this.lookahead();\n            if (tokenIsLiteralPropertyName(lookahead.type)) {\n              kind = this.state.value;\n              this.next();\n            }\n          }\n\n          const propOrInexact = this.flowParseObjectTypeProperty(\n            node,\n            isStatic,\n            protoStart,\n            variance,\n            kind,\n            allowSpread,\n            allowInexact ?? !exact,\n          );\n\n          if (propOrInexact === null) {\n            inexact = true;\n            inexactStart = this.state.lastTokStart;\n          } else {\n            nodeStart.properties.push(propOrInexact);\n          }\n        }\n\n        this.flowObjectTypeSemicolon();\n\n        if (\n          inexactStart &&\n          !this.match(tt.braceR) &&\n          !this.match(tt.braceBarR)\n        ) {\n          this.raise(\n            inexactStart,\n            FlowErrors.UnexpectedExplicitInexactInObject,\n          );\n        }\n      }\n\n      this.expect(endDelim);\n\n      /* The inexact flag should only be added on ObjectTypeAnnotations that\n       * are not the body of an interface, declare interface, or declare class.\n       * Since spreads are only allowed in object types, checking that is\n       * sufficient here.\n       */\n      if (allowSpread) {\n        nodeStart.inexact = inexact;\n      }\n\n      const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n\n      this.state.inType = oldInType;\n\n      return out;\n    }\n\n    flowParseObjectTypeProperty(\n      node: N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty,\n      isStatic: boolean,\n      protoStart: ?number,\n      variance: ?N.FlowVariance,\n      kind: string,\n      allowSpread: boolean,\n      allowInexact: boolean,\n    ): (N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty) | null {\n      if (this.eat(tt.ellipsis)) {\n        const isInexactToken =\n          this.match(tt.comma) ||\n          this.match(tt.semi) ||\n          this.match(tt.braceR) ||\n          this.match(tt.braceBarR);\n\n        if (isInexactToken) {\n          if (!allowSpread) {\n            this.raise(\n              this.state.lastTokStart,\n              FlowErrors.InexactInsideNonObject,\n            );\n          } else if (!allowInexact) {\n            this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);\n          }\n          if (variance) {\n            this.raise(variance.start, FlowErrors.InexactVariance);\n          }\n\n          return null;\n        }\n\n        if (!allowSpread) {\n          this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);\n        }\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n        if (variance) {\n          this.raise(variance.start, FlowErrors.SpreadVariance);\n        }\n\n        node.argument = this.flowParseType();\n        return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n      } else {\n        node.key = this.flowParseObjectPropertyKey();\n        node.static = isStatic;\n        node.proto = protoStart != null;\n        node.kind = kind;\n\n        let optional = false;\n        if (this.match(tt.lt) || this.match(tt.parenL)) {\n          // This is a method property\n          node.method = true;\n\n          if (protoStart != null) {\n            this.unexpected(protoStart);\n          }\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          node.value = this.flowParseObjectTypeMethodish(\n            this.startNodeAt(node.start, node.loc.start),\n          );\n          if (kind === \"get\" || kind === \"set\") {\n            this.flowCheckGetterSetterParams(node);\n          }\n          /** Declared classes/interfaces do not allow spread */\n          if (\n            !allowSpread &&\n            node.key.name === \"constructor\" &&\n            node.value.this\n          ) {\n            this.raise(\n              node.value.this.start,\n              FlowErrors.ThisParamBannedInConstructor,\n            );\n          }\n        } else {\n          if (kind !== \"init\") this.unexpected();\n\n          node.method = false;\n\n          if (this.eat(tt.question)) {\n            optional = true;\n          }\n          node.value = this.flowParseTypeInitialiser();\n          node.variance = variance;\n        }\n\n        node.optional = optional;\n\n        return this.finishNode(node, \"ObjectTypeProperty\");\n      }\n    }\n\n    // This is similar to checkGetterSetterParams, but as\n    // @babel/parser uses non estree properties we cannot reuse it here\n    flowCheckGetterSetterParams(\n      property: N.FlowObjectTypeProperty | N.FlowObjectTypeSpreadProperty,\n    ): void {\n      const paramCount = property.kind === \"get\" ? 0 : 1;\n      const start = property.start;\n      const length =\n        property.value.params.length + (property.value.rest ? 1 : 0);\n\n      if (property.value.this) {\n        this.raise(\n          property.value.this.start,\n          property.kind === \"get\"\n            ? FlowErrors.GetterMayNotHaveThisParam\n            : FlowErrors.SetterMayNotHaveThisParam,\n        );\n      }\n\n      if (length !== paramCount) {\n        if (property.kind === \"get\") {\n          this.raise(start, Errors.BadGetterArity);\n        } else {\n          this.raise(start, Errors.BadSetterArity);\n        }\n      }\n\n      if (property.kind === \"set\" && property.value.rest) {\n        this.raise(start, Errors.BadSetterRestParameter);\n      }\n    }\n\n    flowObjectTypeSemicolon(): void {\n      if (\n        !this.eat(tt.semi) &&\n        !this.eat(tt.comma) &&\n        !this.match(tt.braceR) &&\n        !this.match(tt.braceBarR)\n      ) {\n        this.unexpected();\n      }\n    }\n\n    flowParseQualifiedTypeIdentifier(\n      startPos?: number,\n      startLoc?: Position,\n      id?: N.Identifier,\n    ): N.FlowQualifiedTypeIdentifier {\n      startPos = startPos || this.state.start;\n      startLoc = startLoc || this.state.startLoc;\n      let node = id || this.flowParseRestrictedIdentifier(true);\n\n      while (this.eat(tt.dot)) {\n        const node2 = this.startNodeAt(startPos, startLoc);\n        node2.qualification = node;\n        node2.id = this.flowParseRestrictedIdentifier(true);\n        node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n      }\n\n      return node;\n    }\n\n    flowParseGenericType(\n      startPos: number,\n      startLoc: Position,\n      id: N.Identifier,\n    ): N.FlowGenericTypeAnnotation {\n      const node = this.startNodeAt(startPos, startLoc);\n\n      node.typeParameters = null;\n      node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterInstantiation();\n      }\n\n      return this.finishNode(node, \"GenericTypeAnnotation\");\n    }\n\n    flowParseTypeofType(): N.FlowTypeofTypeAnnotation {\n      const node = this.startNode();\n      this.expect(tt._typeof);\n      node.argument = this.flowParsePrimaryType();\n      return this.finishNode(node, \"TypeofTypeAnnotation\");\n    }\n\n    flowParseTupleType(): N.FlowTupleTypeAnnotation {\n      const node = this.startNode();\n      node.types = [];\n      this.expect(tt.bracketL);\n      // We allow trailing commas\n      while (this.state.pos < this.length && !this.match(tt.bracketR)) {\n        node.types.push(this.flowParseType());\n        if (this.match(tt.bracketR)) break;\n        this.expect(tt.comma);\n      }\n      this.expect(tt.bracketR);\n      return this.finishNode(node, \"TupleTypeAnnotation\");\n    }\n\n    flowParseFunctionTypeParam(first: boolean): N.FlowFunctionTypeParam {\n      let name = null;\n      let optional = false;\n      let typeAnnotation = null;\n      const node = this.startNode();\n      const lh = this.lookahead();\n      const isThis = this.state.type === tt._this;\n\n      if (lh.type === tt.colon || lh.type === tt.question) {\n        if (isThis && !first) {\n          this.raise(node.start, FlowErrors.ThisParamMustBeFirst);\n        }\n        name = this.parseIdentifier(isThis);\n        if (this.eat(tt.question)) {\n          optional = true;\n          if (isThis) {\n            this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);\n          }\n        }\n        typeAnnotation = this.flowParseTypeInitialiser();\n      } else {\n        typeAnnotation = this.flowParseType();\n      }\n      node.name = name;\n      node.optional = optional;\n      node.typeAnnotation = typeAnnotation;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    reinterpretTypeAsFunctionTypeParam(\n      type: N.FlowType,\n    ): N.FlowFunctionTypeParam {\n      const node = this.startNodeAt(type.start, type.loc.start);\n      node.name = null;\n      node.optional = false;\n      node.typeAnnotation = type;\n      return this.finishNode(node, \"FunctionTypeParam\");\n    }\n\n    flowParseFunctionTypeParams(params: N.FlowFunctionTypeParam[] = []): {\n      params: N.FlowFunctionTypeParam[],\n      rest: ?N.FlowFunctionTypeParam,\n      _this: ?N.FlowFunctionTypeParam,\n    } {\n      let rest: ?N.FlowFunctionTypeParam = null;\n      let _this: ?N.FlowFunctionTypeParam = null;\n      if (this.match(tt._this)) {\n        _this = this.flowParseFunctionTypeParam(/* first */ true);\n        // match Flow parser behavior\n        _this.name = null;\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      while (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n        params.push(this.flowParseFunctionTypeParam(false));\n        if (!this.match(tt.parenR)) {\n          this.expect(tt.comma);\n        }\n      }\n      if (this.eat(tt.ellipsis)) {\n        rest = this.flowParseFunctionTypeParam(false);\n      }\n      return { params, rest, _this };\n    }\n\n    flowIdentToTypeAnnotation(\n      startPos: number,\n      startLoc: Position,\n      node: N.FlowTypeAnnotation,\n      id: N.Identifier,\n    ): N.FlowTypeAnnotation {\n      switch (id.name) {\n        case \"any\":\n          return this.finishNode(node, \"AnyTypeAnnotation\");\n\n        case \"bool\":\n        case \"boolean\":\n          return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n        case \"mixed\":\n          return this.finishNode(node, \"MixedTypeAnnotation\");\n\n        case \"empty\":\n          return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n        case \"number\":\n          return this.finishNode(node, \"NumberTypeAnnotation\");\n\n        case \"string\":\n          return this.finishNode(node, \"StringTypeAnnotation\");\n\n        case \"symbol\":\n          return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n        default:\n          this.checkNotUnderscore(id.name);\n          return this.flowParseGenericType(startPos, startLoc, id);\n      }\n    }\n\n    // The parsing of types roughly parallels the parsing of expressions, and\n    // primary types are kind of like primary expressions...they're the\n    // primitives with which other types are constructed.\n    flowParsePrimaryType(): N.FlowTypeAnnotation {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.startNode();\n      let tmp;\n      let type;\n      let isGroupedType = false;\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n      switch (this.state.type) {\n        case tt.braceL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: false,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: true,\n          });\n\n        case tt.braceBarL:\n          return this.flowParseObjectType({\n            allowStatic: false,\n            allowExact: true,\n            allowSpread: true,\n            allowProto: false,\n            allowInexact: false,\n          });\n\n        case tt.bracketL:\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseTupleType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n          return type;\n\n        case tt.lt:\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(tt.parenL);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.parenL:\n          this.next();\n\n          // Check to see if this is actually a grouped type\n          if (!this.match(tt.parenR) && !this.match(tt.ellipsis)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== tt.question && token !== tt.colon;\n            } else {\n              isGroupedType = true;\n            }\n          }\n\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n            // A `,` or a `) =>` means this is an anonymous function type\n            if (\n              this.state.noAnonFunctionType ||\n              !(\n                this.match(tt.comma) ||\n                (this.match(tt.parenR) && this.lookahead().type === tt.arrow)\n              )\n            ) {\n              this.expect(tt.parenR);\n              return type;\n            } else {\n              // Eat a comma if there is one\n              this.eat(tt.comma);\n            }\n          }\n\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([\n              this.reinterpretTypeAsFunctionTypeParam(type),\n            ]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n\n          this.expect(tt.parenR);\n\n          this.expect(tt.arrow);\n\n          node.returnType = this.flowParseType();\n\n          node.typeParameters = null;\n\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n        case tt.string:\n          return this.parseLiteral<N.StringLiteralTypeAnnotation>(\n            this.state.value,\n            \"StringLiteralTypeAnnotation\",\n          );\n\n        case tt._true:\n        case tt._false:\n          node.value = this.match(tt._true);\n          this.next();\n          return this.finishNode<N.BooleanLiteralTypeAnnotation>(\n            node,\n            \"BooleanLiteralTypeAnnotation\",\n          );\n\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            this.next();\n            if (this.match(tt.num)) {\n              return this.parseLiteralAtNode<N.NumberLiteralTypeAnnotation>(\n                -this.state.value,\n                \"NumberLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            if (this.match(tt.bigint)) {\n              return this.parseLiteralAtNode<N.BigIntLiteralTypeAnnotation>(\n                -this.state.value,\n                \"BigIntLiteralTypeAnnotation\",\n                node,\n              );\n            }\n\n            throw this.raise(\n              this.state.start,\n              FlowErrors.UnexpectedSubtractionOperand,\n            );\n          }\n\n          throw this.unexpected();\n        case tt.num:\n          return this.parseLiteral(\n            this.state.value,\n            \"NumberLiteralTypeAnnotation\",\n          );\n\n        case tt.bigint:\n          return this.parseLiteral(\n            this.state.value,\n            \"BigIntLiteralTypeAnnotation\",\n          );\n\n        case tt._void:\n          this.next();\n          return this.finishNode(node, \"VoidTypeAnnotation\");\n\n        case tt._null:\n          this.next();\n          return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n        case tt._this:\n          this.next();\n          return this.finishNode(node, \"ThisTypeAnnotation\");\n\n        case tt.star:\n          this.next();\n          return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n        case tt._typeof:\n          return this.flowParseTypeofType();\n\n        default:\n          if (tokenIsKeyword(this.state.type)) {\n            const label = tokenLabelName(this.state.type);\n            this.next();\n            return super.createIdentifier(node, label);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            if (this.isContextual(tt._interface)) {\n              return this.flowParseInterfaceType();\n            }\n\n            return this.flowIdentToTypeAnnotation(\n              startPos,\n              startLoc,\n              node,\n              this.parseIdentifier(),\n            );\n          }\n      }\n\n      throw this.unexpected();\n    }\n\n    flowParsePostfixType(): N.FlowTypeAnnotation {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let type = this.flowParsePrimaryType();\n      let seenOptionalIndexedAccess = false;\n      while (\n        (this.match(tt.bracketL) || this.match(tt.questionDot)) &&\n        !this.canInsertSemicolon()\n      ) {\n        const node = this.startNodeAt(startPos, startLoc);\n        const optional = this.eat(tt.questionDot);\n        seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n        this.expect(tt.bracketL);\n        if (!optional && this.match(tt.bracketR)) {\n          node.elementType = type;\n          this.next(); // eat `]`\n          type = this.finishNode(node, \"ArrayTypeAnnotation\");\n        } else {\n          node.objectType = type;\n          node.indexType = this.flowParseType();\n          this.expect(tt.bracketR);\n          if (seenOptionalIndexedAccess) {\n            node.optional = optional;\n            type = this.finishNode<N.FlowOptionalIndexedAccessType>(\n              node,\n              \"OptionalIndexedAccessType\",\n            );\n          } else {\n            type = this.finishNode<N.FlowIndexedAccessType>(\n              node,\n              \"IndexedAccessType\",\n            );\n          }\n        }\n      }\n      return type;\n    }\n\n    flowParsePrefixType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      if (this.eat(tt.question)) {\n        node.typeAnnotation = this.flowParsePrefixType();\n        return this.finishNode(node, \"NullableTypeAnnotation\");\n      } else {\n        return this.flowParsePostfixType();\n      }\n    }\n\n    flowParseAnonFunctionWithoutParens(): N.FlowTypeAnnotation {\n      const param = this.flowParsePrefixType();\n      if (!this.state.noAnonFunctionType && this.eat(tt.arrow)) {\n        // TODO: This should be a type error. Passing in a SourceLocation, and it expects a Position.\n        const node = this.startNodeAt(param.start, param.loc.start);\n        node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n        node.rest = null;\n        node.this = null;\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n      }\n      return param;\n    }\n\n    flowParseIntersectionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseAND);\n      const type = this.flowParseAnonFunctionWithoutParens();\n      node.types = [type];\n      while (this.eat(tt.bitwiseAND)) {\n        node.types.push(this.flowParseAnonFunctionWithoutParens());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"IntersectionTypeAnnotation\");\n    }\n\n    flowParseUnionType(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      this.eat(tt.bitwiseOR);\n      const type = this.flowParseIntersectionType();\n      node.types = [type];\n      while (this.eat(tt.bitwiseOR)) {\n        node.types.push(this.flowParseIntersectionType());\n      }\n      return node.types.length === 1\n        ? type\n        : this.finishNode(node, \"UnionTypeAnnotation\");\n    }\n\n    flowParseType(): N.FlowTypeAnnotation {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      const type = this.flowParseUnionType();\n      this.state.inType = oldInType;\n      return type;\n    }\n\n    flowParseTypeOrImplicitInstantiation(): N.FlowTypeAnnotation {\n      if (this.state.type === tt.name && this.state.value === \"_\") {\n        const startPos = this.state.start;\n        const startLoc = this.state.startLoc;\n        const node = this.parseIdentifier();\n        return this.flowParseGenericType(startPos, startLoc, node);\n      } else {\n        return this.flowParseType();\n      }\n    }\n\n    flowParseTypeAnnotation(): N.FlowTypeAnnotation {\n      const node = this.startNode();\n      node.typeAnnotation = this.flowParseTypeInitialiser();\n      return this.finishNode(node, \"TypeAnnotation\");\n    }\n\n    flowParseTypeAnnotatableIdentifier(\n      allowPrimitiveOverride?: boolean,\n    ): N.Identifier {\n      const ident = allowPrimitiveOverride\n        ? this.parseIdentifier()\n        : this.flowParseRestrictedIdentifier();\n      if (this.match(tt.colon)) {\n        ident.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(ident);\n      }\n      return ident;\n    }\n\n    typeCastToParameter(node: N.Node): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(\n        node.expression,\n        node.typeAnnotation.end,\n        node.typeAnnotation.loc.end,\n      );\n\n      return node.expression;\n    }\n\n    flowParseVariance(): ?N.FlowVariance {\n      let variance = null;\n      if (this.match(tt.plusMin)) {\n        variance = this.startNode();\n        if (this.state.value === \"+\") {\n          variance.kind = \"plus\";\n        } else {\n          variance.kind = \"minus\";\n        }\n        this.next();\n        this.finishNode(variance, \"Variance\");\n      }\n      return variance;\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseFunctionBody(\n      node: N.Function,\n      allowExpressionBody: ?boolean,\n      isMethod?: boolean = false,\n    ): void {\n      if (allowExpressionBody) {\n        return this.forwardNoArrowParamsConversionAt(node, () =>\n          super.parseFunctionBody(node, true, isMethod),\n        );\n      }\n\n      return super.parseFunctionBody(node, false, isMethod);\n    }\n\n    parseFunctionBodyAndFinish(\n      node: N.BodilessFunctionOrMethodBase,\n      type: string,\n      isMethod?: boolean = false,\n    ): void {\n      if (this.match(tt.colon)) {\n        const typeNode = this.startNode();\n\n        [\n          // $FlowFixMe (destructuring not supported yet)\n          typeNode.typeAnnotation,\n          // $FlowFixMe (destructuring not supported yet)\n          node.predicate,\n        ] = this.flowParseTypeAndPredicateInitialiser();\n\n        node.returnType = typeNode.typeAnnotation\n          ? this.finishNode(typeNode, \"TypeAnnotation\")\n          : null;\n      }\n\n      super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    // interfaces and enums\n    parseStatement(context: ?string, topLevel?: boolean): N.Statement {\n      // strict mode handling of `interface` since it's a reserved word\n      if (this.state.strict && this.isContextual(tt._interface)) {\n        const lookahead = this.lookahead();\n        if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n          const node = this.startNode();\n          this.next();\n          return this.flowParseInterface(node);\n        }\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      const stmt = super.parseStatement(context, topLevel);\n      // We will parse a flow pragma in any comment before the first statement.\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n      return stmt;\n    }\n\n    // declares, interfaces and type aliases\n    parseExpressionStatement(\n      node: N.ExpressionStatement,\n      expr: N.Expression,\n    ): N.ExpressionStatement {\n      if (expr.type === \"Identifier\") {\n        if (expr.name === \"declare\") {\n          if (\n            this.match(tt._class) ||\n            tokenIsIdentifier(this.state.type) ||\n            this.match(tt._function) ||\n            this.match(tt._var) ||\n            this.match(tt._export)\n          ) {\n            return this.flowParseDeclare(node);\n          }\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (expr.name === \"interface\") {\n            return this.flowParseInterface(node);\n          } else if (expr.name === \"type\") {\n            return this.flowParseTypeAlias(node);\n          } else if (expr.name === \"opaque\") {\n            return this.flowParseOpaqueType(node, false);\n          }\n        }\n      }\n\n      return super.parseExpressionStatement(node, expr);\n    }\n\n    // export type\n    shouldParseExportDeclaration(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return !this.state.containsEsc;\n      }\n      return super.shouldParseExportDeclaration();\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      const { type } = this.state;\n      if (\n        tokenIsFlowInterfaceOrTypeOrOpaque(type) ||\n        (this.shouldParseEnums() && type === tt._enum)\n      ) {\n        return this.state.containsEsc;\n      }\n\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(node);\n      }\n      return super.parseExportDefaultExpression();\n    }\n\n    parseConditional(\n      expr: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      refExpressionErrors?: ?ExpressionErrors,\n    ): N.Expression {\n      if (!this.match(tt.question)) return expr;\n\n      if (this.state.maybeInArrowParameters) {\n        const nextCh = this.lookaheadCharCode();\n        // These tokens cannot start an expression, so if one of them follows\n        // ? then we are probably in an arrow function parameters list and we\n        // don't parse the conditional expression.\n        if (\n          nextCh === charCodes.comma || // (a?, b) => c\n          nextCh === charCodes.equalsTo || // (a? = b) => c\n          nextCh === charCodes.colon || // (a?: b) => c\n          nextCh === charCodes.rightParenthesis // (a?) => c\n        ) {\n          /*:: invariant(refExpressionErrors != null) */\n          this.setOptionalParametersError(refExpressionErrors);\n          return expr;\n        }\n      }\n\n      this.expect(tt.question);\n      const state = this.state.clone();\n      const originalNoArrowAt = this.state.noArrowAt;\n      const node = this.startNodeAt(startPos, startLoc);\n      let { consequent, failed } = this.tryParseConditionalConsequent();\n      let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n      if (failed || invalid.length > 0) {\n        const noArrowAt = [...originalNoArrowAt];\n\n        if (invalid.length > 0) {\n          this.state = state;\n          this.state.noArrowAt = noArrowAt;\n\n          for (let i = 0; i < invalid.length; i++) {\n            noArrowAt.push(invalid[i].start);\n          }\n\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n          [valid, invalid] = this.getArrowLikeExpressions(consequent);\n        }\n\n        if (failed && valid.length > 1) {\n          // if there are two or more possible correct ways of parsing, throw an\n          // error.\n          // e.g.   Source: a ? (b): c => (d): e => f\n          //      Result 1: a ? b : (c => ((d): e => f))\n          //      Result 2: a ? ((b): c => d) : (e => f)\n          this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);\n        }\n\n        if (failed && valid.length === 1) {\n          this.state = state;\n          noArrowAt.push(valid[0].start);\n          this.state.noArrowAt = noArrowAt;\n          ({ consequent, failed } = this.tryParseConditionalConsequent());\n        }\n      }\n\n      this.getArrowLikeExpressions(consequent, true);\n\n      this.state.noArrowAt = originalNoArrowAt;\n      this.expect(tt.colon);\n\n      node.test = expr;\n      node.consequent = consequent;\n      node.alternate = this.forwardNoArrowParamsConversionAt(node, () =>\n        this.parseMaybeAssign(undefined, undefined),\n      );\n\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    tryParseConditionalConsequent(): {\n      consequent: N.Expression,\n      failed: boolean,\n    } {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n\n      const consequent = this.parseMaybeAssignAllowIn();\n      const failed = !this.match(tt.colon);\n\n      this.state.noArrowParamsConversionAt.pop();\n\n      return { consequent, failed };\n    }\n\n    // Given an expression, walks through out its arrow functions whose body is\n    // an expression and through out conditional expressions. It returns every\n    // function which has been parsed with a return type but could have been\n    // parenthesized expressions.\n    // These functions are separated into two arrays: one containing the ones\n    // whose parameters can be converted to assignable lists, one containing the\n    // others.\n    getArrowLikeExpressions(\n      node: N.Expression,\n      disallowInvalid?: boolean,\n    ): [N.ArrowFunctionExpression[], N.ArrowFunctionExpression[]] {\n      const stack = [node];\n      const arrows: N.ArrowFunctionExpression[] = [];\n\n      while (stack.length !== 0) {\n        const node = stack.pop();\n        if (node.type === \"ArrowFunctionExpression\") {\n          if (node.typeParameters || !node.returnType) {\n            // This is an arrow expression without ambiguity, so check its parameters\n            this.finishArrowValidation(node);\n          } else {\n            arrows.push(node);\n          }\n          stack.push(node.body);\n        } else if (node.type === \"ConditionalExpression\") {\n          stack.push(node.consequent);\n          stack.push(node.alternate);\n        }\n      }\n\n      if (disallowInvalid) {\n        arrows.forEach(node => this.finishArrowValidation(node));\n        return [arrows, []];\n      }\n\n      return partition(arrows, node =>\n        node.params.every(param => this.isAssignable(param, true)),\n      );\n    }\n\n    finishArrowValidation(node: N.ArrowFunctionExpression) {\n      this.toAssignableList(\n        // node.params is Expression[] instead of $ReadOnlyArray<Pattern> because it\n        // has not been converted yet.\n        ((node.params: any): N.Expression[]),\n        node.extra?.trailingComma,\n        /* isLHS */ false,\n      );\n      // Enter scope, as checkParams defines bindings\n      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n      // Use super's method to force the parameters to be checked\n      super.checkParams(node, false, true);\n      this.scope.exit();\n    }\n\n    forwardNoArrowParamsConversionAt<T>(node: N.Node, parse: () => T): T {\n      let result: T;\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        this.state.noArrowParamsConversionAt.push(this.state.start);\n        result = parse();\n        this.state.noArrowParamsConversionAt.pop();\n      } else {\n        result = parse();\n      }\n\n      return result;\n    }\n\n    parseParenItem(\n      node: N.Expression,\n      startPos: number,\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startPos, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode = this.startNodeAt(startPos, startLoc);\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    assertModuleNodeAllowed(node: N.Node) {\n      if (\n        (node.type === \"ImportDeclaration\" &&\n          (node.importKind === \"type\" || node.importKind === \"typeof\")) ||\n        (node.type === \"ExportNamedDeclaration\" &&\n          node.exportKind === \"type\") ||\n        (node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\")\n      ) {\n        // Allow Flowtype imports and exports in all conditions because\n        // Flow itself does not care about 'sourceType'.\n        return;\n      }\n\n      super.assertModuleNodeAllowed(node);\n    }\n\n    parseExport(node: N.Node): N.AnyExport {\n      const decl = super.parseExport(node);\n      if (\n        decl.type === \"ExportNamedDeclaration\" ||\n        decl.type === \"ExportAllDeclaration\"\n      ) {\n        decl.exportKind = decl.exportKind || \"value\";\n      }\n      return decl;\n    }\n\n    parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {\n      if (this.isContextual(tt._type)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n\n        if (this.match(tt.braceL)) {\n          // export type { foo, bar };\n          node.specifiers = this.parseExportSpecifiers(\n            /* isInTypeExport */ true,\n          );\n          this.parseExportFrom(node);\n          return null;\n        } else {\n          // export type Foo = Bar;\n          return this.flowParseTypeAlias(declarationNode);\n        }\n      } else if (this.isContextual(tt._opaque)) {\n        node.exportKind = \"type\";\n\n        const declarationNode = this.startNode();\n        this.next();\n        // export opaque type Foo = Bar;\n        return this.flowParseOpaqueType(declarationNode, false);\n      } else if (this.isContextual(tt._interface)) {\n        node.exportKind = \"type\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseInterface(declarationNode);\n      } else if (this.shouldParseEnums() && this.isContextual(tt._enum)) {\n        node.exportKind = \"value\";\n        const declarationNode = this.startNode();\n        this.next();\n        return this.flowParseEnumDeclaration(declarationNode);\n      } else {\n        return super.parseExportDeclaration(node);\n      }\n    }\n\n    eatExportStar(node: N.Node): boolean {\n      if (super.eatExportStar(...arguments)) return true;\n\n      if (this.isContextual(tt._type) && this.lookahead().type === tt.star) {\n        node.exportKind = \"type\";\n        this.next();\n        this.next();\n        return true;\n      }\n\n      return false;\n    }\n\n    maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n      const pos = this.state.start;\n      const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n      if (hasNamespace && node.exportKind === \"type\") {\n        this.unexpected(pos);\n      }\n      return hasNamespace;\n    }\n\n    parseClassId(node: N.Class, isStatement: boolean, optionalId: ?boolean) {\n      super.parseClassId(node, isStatement, optionalId);\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const pos = this.state.start;\n      if (this.isContextual(tt._declare)) {\n        if (this.parseClassMemberFromModifier(classBody, member)) {\n          // 'declare' is a class element name\n          return;\n        }\n\n        member.declare = true;\n      }\n\n      super.parseClassMember(classBody, member, state);\n\n      if (member.declare) {\n        if (\n          member.type !== \"ClassProperty\" &&\n          member.type !== \"ClassPrivateProperty\" &&\n          member.type !== \"PropertyDefinition\" // Used by estree plugin\n        ) {\n          this.raise(pos, FlowErrors.DeclareClassElement);\n        } else if (member.value) {\n          this.raise(\n            member.value.start,\n            FlowErrors.DeclareClassFieldInitializer,\n          );\n        }\n      }\n    }\n\n    isIterator(word: string): boolean {\n      return word === \"iterator\" || word === \"asyncIterator\";\n    }\n\n    readIterator(): void {\n      const word = super.readWord1();\n      const fullWord = \"@@\" + word;\n\n      // Allow @@iterator and @@asyncIterator as a identifier only inside type\n      if (!this.isIterator(word) || !this.state.inType) {\n        this.raise(this.state.pos, Errors.InvalidIdentifier, fullWord);\n      }\n\n      this.finishToken(tt.name, fullWord);\n    }\n\n    // ensure that inside flow types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (code === charCodes.leftCurlyBrace && next === charCodes.verticalBar) {\n        return this.finishOp(tt.braceBarL, 2);\n      } else if (\n        this.state.inType &&\n        (code === charCodes.greaterThan || code === charCodes.lessThan)\n      ) {\n        return this.finishOp(code === charCodes.greaterThan ? tt.gt : tt.lt, 1);\n      } else if (this.state.inType && code === charCodes.questionMark) {\n        if (next === charCodes.dot) {\n          return this.finishOp(tt.questionDot, 2);\n        }\n        // allow double nullable types in Flow: ??string\n        return this.finishOp(tt.question, 1);\n      } else if (isIteratorStart(code, next)) {\n        this.state.pos += 2; // eat \"@@\"\n        return this.readIterator();\n      } else {\n        return super.getTokenFromCode(code);\n      }\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      if (node.type === \"TypeCastExpression\") {\n        return this.isAssignable(node.expression, isBinding);\n      } else {\n        return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): N.Node {\n      if (node.type === \"TypeCastExpression\") {\n        return super.toAssignable(this.typeCastToParameter(node), isLHS);\n      } else {\n        return super.toAssignable(node, isLHS);\n      }\n    }\n\n    // turn type casts that we found in function parameter head into type annotated params\n    toAssignableList(\n      exprList: N.Expression[],\n      trailingCommaPos?: ?number,\n      isLHS: boolean,\n    ): $ReadOnlyArray<N.Pattern> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (expr?.type === \"TypeCastExpression\") {\n          exprList[i] = this.typeCastToParameter(expr);\n        }\n      }\n      return super.toAssignableList(exprList, trailingCommaPos, isLHS);\n    }\n\n    // this is a list of nodes, from something like a call expression, we need to filter the\n    // type casts that we've found that are illegal in this context\n    toReferencedList(\n      exprList: $ReadOnlyArray<?N.Expression>,\n      isParenthesizedExpr?: boolean,\n    ): $ReadOnlyArray<?N.Expression> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (\n          expr &&\n          expr.type === \"TypeCastExpression\" &&\n          !expr.extra?.parenthesized &&\n          (exprList.length > 1 || !isParenthesizedExpr)\n        ) {\n          this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);\n        }\n      }\n\n      return exprList;\n    }\n\n    parseArrayLike(\n      close: TokenType,\n      canBePattern: boolean,\n      isTuple: boolean,\n      refExpressionErrors: ?ExpressionErrors,\n    ): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(\n        close,\n        canBePattern,\n        isTuple,\n        refExpressionErrors,\n      );\n\n      // This could be an array pattern:\n      //   ([a: string, b: string]) => {}\n      // In this case, we don't have to call toReferencedList. We will\n      // call it, if needed, when we are sure that it is a parenthesized\n      // expression by calling toReferencedListDeep.\n      if (canBePattern && !this.state.maybeInArrowParameters) {\n        this.toReferencedList(node.elements);\n      }\n\n      return node;\n    }\n\n    checkLVal(\n      expr: N.Expression,\n      ...args:\n        | [string, BindingTypes | void]\n        | [\n            string,\n            BindingTypes | void,\n            ?Set<string>,\n            boolean | void,\n            boolean | void,\n          ]\n    ): void {\n      if (expr.type !== \"TypeCastExpression\") {\n        return super.checkLVal(expr, ...args);\n      }\n    }\n\n    // parse class property type annotations\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      if (this.match(tt.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      if (this.match(tt.colon)) {\n        node.typeAnnotation = this.flowParseTypeAnnotation();\n      }\n      return super.parseClassPrivateProperty(node);\n    }\n\n    // determine whether or not we're currently in the position where a class method would appear\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    // determine whether or not we're currently in the position where a class property would appear\n    isClassProperty(): boolean {\n      return this.match(tt.colon) || super.isClassProperty();\n    }\n\n    isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n      return !this.match(tt.colon) && super.isNonstaticConstructor(method);\n    }\n\n    // parse type parameters for class methods\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      if ((method: $FlowFixMe).variance) {\n        this.unexpected((method: $FlowFixMe).variance.start);\n      }\n      delete (method: $FlowFixMe).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n\n      if (method.params && isConstructor) {\n        const params = method.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);\n        }\n        // estree support\n      } else if (\n        // $FlowFixMe flow does not know about the face that estree can replace ClassMethod with MethodDefinition\n        method.type === \"MethodDefinition\" &&\n        isConstructor &&\n        method.value.params\n      ) {\n        const params = method.value.params;\n        if (params.length > 0 && this.isThisParam(params[0])) {\n          this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);\n        }\n      }\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      if ((method: $FlowFixMe).variance) {\n        this.unexpected((method: $FlowFixMe).variance.start);\n      }\n      delete (method: $FlowFixMe).variance;\n      if (this.match(tt.lt)) {\n        method.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    // parse a the super class type parameters and implements\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      if (node.superClass && this.match(tt.lt)) {\n        node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n      }\n      if (this.isContextual(tt._implements)) {\n        this.next();\n        const implemented: N.FlowClassImplements[] = (node.implements = []);\n        do {\n          const node = this.startNode();\n          node.id = this.flowParseRestrictedIdentifier(/*liberal*/ true);\n          if (this.match(tt.lt)) {\n            node.typeParameters = this.flowParseTypeParameterInstantiation();\n          } else {\n            node.typeParameters = null;\n          }\n          implemented.push(this.finishNode(node, \"ClassImplements\"));\n        } while (this.eat(tt.comma));\n      }\n    }\n\n    checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n      super.checkGetterSetterParams(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      if (params.length > 0) {\n        const param = params[0];\n        if (this.isThisParam(param) && method.kind === \"get\") {\n          this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);\n        } else if (this.isThisParam(param)) {\n          this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);\n        }\n      }\n    }\n\n    parsePropertyNamePrefixOperator(\n      node: N.ObjectOrClassMember | N.ClassMember,\n    ): void {\n      node.variance = this.flowParseVariance();\n    }\n\n    // parse type parameters for object method shorthand\n    parseObjPropValue(\n      prop: N.ObjectMember,\n      startPos: ?number,\n      startLoc: ?Position,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isPattern: boolean,\n      isAccessor: boolean,\n      refExpressionErrors: ?ExpressionErrors,\n    ): void {\n      if ((prop: $FlowFixMe).variance) {\n        this.unexpected((prop: $FlowFixMe).variance.start);\n      }\n      delete (prop: $FlowFixMe).variance;\n\n      let typeParameters;\n\n      // method shorthand\n      if (this.match(tt.lt) && !isAccessor) {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        if (!this.match(tt.parenL)) this.unexpected();\n      }\n\n      super.parseObjPropValue(\n        prop,\n        startPos,\n        startLoc,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n        refExpressionErrors,\n      );\n\n      // add typeParameters if we found them\n      if (typeParameters) {\n        (prop.value || prop).typeParameters = typeParameters;\n      }\n    }\n\n    parseAssignableListItemTypes(param: N.Pattern): N.Pattern {\n      if (this.eat(tt.question)) {\n        if (param.type !== \"Identifier\") {\n          this.raise(param.start, FlowErrors.PatternIsOptional);\n        }\n        if (this.isThisParam(param)) {\n          this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);\n        }\n\n        ((param: any): N.Identifier).optional = true;\n      }\n      if (this.match(tt.colon)) {\n        param.typeAnnotation = this.flowParseTypeAnnotation();\n      } else if (this.isThisParam(param)) {\n        this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);\n      }\n\n      if (this.match(tt.eq) && this.isThisParam(param)) {\n        this.raise(param.start, FlowErrors.ThisParamNoDefault);\n      }\n\n      this.resetEndLocation(param);\n      return param;\n    }\n\n    parseMaybeDefault(\n      startPos?: ?number,\n      startLoc?: ?Position,\n      left?: ?N.Pattern,\n    ): N.Pattern {\n      const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);\n      }\n\n      return node;\n    }\n\n    shouldParseDefaultImport(node: N.ImportDeclaration): boolean {\n      if (!hasTypeImportKind(node)) {\n        return super.shouldParseDefaultImport(node);\n      }\n\n      return isMaybeDefaultImport(this.state.type);\n    }\n\n    parseImportSpecifierLocal(\n      node: N.ImportDeclaration,\n      specifier: N.Node,\n      type: string,\n      contextDescription: string,\n    ): void {\n      specifier.local = hasTypeImportKind(node)\n        ? this.flowParseRestrictedIdentifier(\n            /* liberal */ true,\n            /* declaration */ true,\n          )\n        : this.parseIdentifier();\n\n      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n      node.specifiers.push(this.finishNode(specifier, type));\n    }\n\n    // parse typeof and type imports\n    maybeParseDefaultImportSpecifier(node: N.ImportDeclaration): boolean {\n      node.importKind = \"value\";\n\n      let kind = null;\n      if (this.match(tt._typeof)) {\n        kind = \"typeof\";\n      } else if (this.isContextual(tt._type)) {\n        kind = \"type\";\n      }\n      if (kind) {\n        const lh = this.lookahead();\n        const { type } = lh;\n\n        // import type * is not allowed\n        if (kind === \"type\" && type === tt.star) {\n          this.unexpected(lh.start);\n        }\n\n        if (\n          isMaybeDefaultImport(type) ||\n          type === tt.braceL ||\n          type === tt.star\n        ) {\n          this.next();\n          node.importKind = kind;\n        }\n      }\n\n      return super.maybeParseDefaultImportSpecifier(node);\n    }\n\n    // parse import-type/typeof shorthand\n    parseImportSpecifier(\n      specifier: any,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      // eslint-disable-next-line no-unused-vars\n      isMaybeTypeOnly: boolean,\n    ): N.ImportSpecifier {\n      const firstIdent = specifier.imported;\n\n      let specifierTypeKind = null;\n      if (firstIdent.type === \"Identifier\") {\n        if (firstIdent.name === \"type\") {\n          specifierTypeKind = \"type\";\n        } else if (firstIdent.name === \"typeof\") {\n          specifierTypeKind = \"typeof\";\n        }\n      }\n\n      let isBinding = false;\n      if (this.isContextual(tt._as) && !this.isLookaheadContextual(\"as\")) {\n        const as_ident = this.parseIdentifier(true);\n        if (\n          specifierTypeKind !== null &&\n          !tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type as ,` or `import {type as }`\n          specifier.imported = as_ident;\n          specifier.importKind = specifierTypeKind;\n          specifier.local = cloneIdentifier(as_ident);\n        } else {\n          // `import {type as foo`\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n          specifier.local = this.parseIdentifier();\n        }\n      } else {\n        if (\n          specifierTypeKind !== null &&\n          tokenIsKeywordOrIdentifier(this.state.type)\n        ) {\n          // `import {type foo`\n          specifier.imported = this.parseIdentifier(true);\n          specifier.importKind = specifierTypeKind;\n        } else {\n          if (importedIsString) {\n            /*:: invariant(firstIdent instanceof N.StringLiteral) */\n            throw this.raise(\n              specifier.start,\n              Errors.ImportBindingIsString,\n              firstIdent.value,\n            );\n          }\n          /*:: invariant(firstIdent instanceof N.Node) */\n          specifier.imported = firstIdent;\n          specifier.importKind = null;\n        }\n\n        if (this.eatContextual(tt._as)) {\n          specifier.local = this.parseIdentifier();\n        } else {\n          isBinding = true;\n          specifier.local = cloneIdentifier(specifier.imported);\n        }\n      }\n\n      const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n      if (isInTypeOnlyImport && specifierIsTypeImport) {\n        this.raise(\n          specifier.start,\n          FlowErrors.ImportTypeShorthandOnlyInPureImport,\n        );\n      }\n\n      if (isInTypeOnlyImport || specifierIsTypeImport) {\n        this.checkReservedType(\n          specifier.local.name,\n          specifier.local.start,\n          /* declaration */ true,\n        );\n      }\n\n      if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n        this.checkReservedWord(\n          specifier.local.name,\n          specifier.start,\n          true,\n          true,\n        );\n      }\n\n      this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    // parse function type parameters - function foo<T>() {}\n    parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\n      // $FlowFixMe\n      const kind = node.kind;\n      if (kind !== \"get\" && kind !== \"set\" && this.match(tt.lt)) {\n        node.typeParameters = this.flowParseTypeParameterDeclaration();\n      }\n      super.parseFunctionParams(node, allowModifiers);\n    }\n\n    // parse flow type annotations on variable declarator heads - let foo: string = bar\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (this.match(tt.colon)) {\n        decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        node.returnType = this.flowParseTypeAnnotation();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n      }\n\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    // todo description\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    // We need to support type parameter declarations for arrow functions. This\n    // is tricky. There are three situations we need to handle\n    //\n    // 1. This is either JSX or an arrow function. We'll try JSX first. If that\n    //    fails, we'll try an arrow function. If that fails, we'll throw the JSX\n    //    error.\n    // 2. This is an arrow function. We'll parse the type parameter declaration,\n    //    parse the rest, make sure the rest is an arrow function, and go from\n    //    there\n    // 3. This is neither. Just call the super method\n    parseMaybeAssign(\n      refExpressionErrors?: ?ExpressionErrors,\n      afterLeftParse?: Function,\n    ): N.Expression {\n      let state = null;\n\n      let jsx;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        state = this.state.clone();\n\n        jsx = this.tryParse(\n          () => super.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n          state,\n        );\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` and `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        const curContext = context[context.length - 1];\n        if (curContext === tc.j_oTag) {\n          context.length -= 2;\n        } else if (curContext === tc.j_expr) {\n          context.length -= 1;\n        }\n      }\n\n      if (jsx?.error || this.match(tt.lt)) {\n        state = state || this.state.clone();\n\n        let typeParameters;\n\n        const arrow = this.tryParse(abort => {\n          typeParameters = this.flowParseTypeParameterDeclaration();\n\n          const arrowExpression = this.forwardNoArrowParamsConversionAt(\n            typeParameters,\n            () => {\n              const result = super.parseMaybeAssign(\n                refExpressionErrors,\n                afterLeftParse,\n              );\n\n              this.resetStartLocationFromNode(result, typeParameters);\n\n              return result;\n            },\n          );\n\n          // <T>(() => {});\n          // <T>(() => {}: any);\n          if (arrowExpression.extra?.parenthesized) abort();\n\n          // The above can return a TypeCastExpression when the arrow\n          // expression is not wrapped in parens. See also `this.parseParenItem`.\n          // (<T>() => {}: any);\n          const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n\n          if (expr.type !== \"ArrowFunctionExpression\") abort();\n\n          expr.typeParameters = typeParameters;\n          this.resetStartLocationFromNode(expr, typeParameters);\n\n          return arrowExpression;\n        }, state);\n\n        let arrowExpression: ?(\n          | N.ArrowFunctionExpression\n          | N.TypeCastExpression\n        ) = null;\n\n        if (\n          arrow.node &&\n          this.maybeUnwrapTypeCastExpression(arrow.node).type ===\n            \"ArrowFunctionExpression\"\n        ) {\n          if (!arrow.error && !arrow.aborted) {\n            // <T> async () => {}\n            if (arrow.node.async) {\n              /*:: invariant(typeParameters) */\n              this.raise(\n                typeParameters.start,\n                FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction,\n              );\n            }\n\n            return arrow.node;\n          }\n\n          arrowExpression = arrow.node;\n        }\n\n        // If we are here, both JSX and Flow parsing attempts failed.\n        // Give the precedence to the JSX error, except if JSX had an\n        // unrecoverable error while Flow didn't.\n        // If the error is recoverable, we can only re-report it if there is\n        // a node we can return.\n\n        if (jsx?.node) {\n          /*:: invariant(jsx.failState) */\n          this.state = jsx.failState;\n          return jsx.node;\n        }\n\n        if (arrowExpression) {\n          /*:: invariant(arrow.failState) */\n          this.state = arrow.failState;\n          return arrowExpression;\n        }\n\n        if (jsx?.thrown) throw jsx.error;\n        if (arrow.thrown) throw arrow.error;\n\n        /*:: invariant(typeParameters) */\n        throw this.raise(\n          typeParameters.start,\n          FlowErrors.UnexpectedTokenAfterTypeParameter,\n        );\n      }\n\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n\n    // handle return types for arrow functions\n    parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        const result = this.tryParse(() => {\n          const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n          this.state.noAnonFunctionType = true;\n\n          const typeNode = this.startNode();\n\n          [\n            // $FlowFixMe (destructuring not supported yet)\n            typeNode.typeAnnotation,\n            // $FlowFixMe (destructuring not supported yet)\n            node.predicate,\n          ] = this.flowParseTypeAndPredicateInitialiser();\n\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.canInsertSemicolon()) this.unexpected();\n          if (!this.match(tt.arrow)) this.unexpected();\n\n          return typeNode;\n        });\n\n        if (result.thrown) return null;\n        /*:: invariant(result.node) */\n\n        if (result.error) this.state = result.failState;\n\n        // assign after it is clear it is an arrow\n        node.returnType = result.node.typeAnnotation\n          ? this.finishNode(result.node, \"TypeAnnotation\")\n          : null;\n      }\n\n      return super.parseArrow(node);\n    }\n\n    shouldParseArrow(params: Array<N.Node>): boolean {\n      return this.match(tt.colon) || super.shouldParseArrow(params);\n    }\n\n    setArrowFunctionParameters(\n      node: N.ArrowFunctionExpression,\n      params: N.Expression[],\n    ): void {\n      if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n        node.params = params;\n      } else {\n        super.setArrowFunctionParameters(node, params);\n      }\n    }\n\n    checkParams(\n      node: N.Function,\n      allowDuplicates: boolean,\n      isArrowFunction: ?boolean,\n    ): void {\n      if (\n        isArrowFunction &&\n        this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1\n      ) {\n        return;\n      }\n\n      // ensure the `this` param is first, if it exists\n      for (let i = 0; i < node.params.length; i++) {\n        if (this.isThisParam(node.params[i]) && i > 0) {\n          this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);\n        }\n      }\n\n      return super.checkParams(...arguments);\n    }\n\n    parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\n      return super.parseParenAndDistinguishExpression(\n        canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1,\n      );\n    }\n\n    parseSubscripts(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls?: ?boolean,\n    ): N.Expression {\n      if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.state.noArrowAt.indexOf(startPos) !== -1\n      ) {\n        this.next();\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n        base = this.finishNode(node, \"CallExpression\");\n      } else if (\n        base.type === \"Identifier\" &&\n        base.name === \"async\" &&\n        this.match(tt.lt)\n      ) {\n        const state = this.state.clone();\n        const arrow = this.tryParse(\n          abort =>\n            this.parseAsyncArrowWithTypeParameters(startPos, startLoc) ||\n            abort(),\n          state,\n        );\n\n        /*:: invariant(arrow.node != null) */\n        if (!arrow.error && !arrow.aborted) return arrow.node;\n\n        const result = this.tryParse(\n          () => super.parseSubscripts(base, startPos, startLoc, noCalls),\n          state,\n        );\n\n        if (result.node && !result.error) return result.node;\n\n        if (arrow.node) {\n          this.state = arrow.failState;\n          return arrow.node;\n        }\n\n        if (result.node) {\n          this.state = result.failState;\n          return result.node;\n        }\n\n        throw arrow.error || result.error;\n      }\n\n      return super.parseSubscripts(base, startPos, startLoc, noCalls);\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls: ?boolean,\n      subscriptState: N.ParseSubscriptState,\n    ): N.Expression {\n      if (this.match(tt.questionDot) && this.isLookaheadToken_lt()) {\n        subscriptState.optionalChainMember = true;\n        if (noCalls) {\n          subscriptState.stop = true;\n          return base;\n        }\n        this.next();\n        const node: N.OptionalCallExpression = this.startNodeAt(\n          startPos,\n          startLoc,\n        );\n        node.callee = base;\n        node.typeArguments = this.flowParseTypeParameterInstantiation();\n        this.expect(tt.parenL);\n        // $FlowFixMe\n        node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n        node.optional = true;\n        return this.finishCallExpression(node, /* optional */ true);\n      } else if (!noCalls && this.shouldParseTypes() && this.match(tt.lt)) {\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n\n        const result = this.tryParse(() => {\n          node.typeArguments =\n            this.flowParseTypeParameterInstantiationCallOrNew();\n          this.expect(tt.parenL);\n          node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n          if (subscriptState.optionalChainMember) node.optional = false;\n          return this.finishCallExpression(\n            node,\n            subscriptState.optionalChainMember,\n          );\n        });\n\n        if (result.node) {\n          if (result.error) this.state = result.failState;\n          return result.node;\n        }\n      }\n\n      return super.parseSubscript(\n        base,\n        startPos,\n        startLoc,\n        noCalls,\n        subscriptState,\n      );\n    }\n\n    parseNewArguments(node: N.NewExpression): void {\n      let targs = null;\n      if (this.shouldParseTypes() && this.match(tt.lt)) {\n        targs = this.tryParse(() =>\n          this.flowParseTypeParameterInstantiationCallOrNew(),\n        ).node;\n      }\n      node.typeArguments = targs;\n\n      super.parseNewArguments(node);\n    }\n\n    parseAsyncArrowWithTypeParameters(\n      startPos: number,\n      startLoc: Position,\n    ): ?N.ArrowFunctionExpression {\n      const node = this.startNodeAt(startPos, startLoc);\n      this.parseFunctionParams(node);\n      if (!this.parseArrow(node)) return;\n      return this.parseArrowExpression(\n        node,\n        /* params */ undefined,\n        /* isAsync */ true,\n      );\n    }\n\n    readToken_mult_modulo(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.asterisk &&\n        next === charCodes.slash &&\n        this.state.hasFlowComment\n      ) {\n        this.state.hasFlowComment = false;\n        this.state.pos += 2;\n        this.nextToken();\n        return;\n      }\n\n      super.readToken_mult_modulo(code);\n    }\n\n    readToken_pipe_amp(code: number): void {\n      const next = this.input.charCodeAt(this.state.pos + 1);\n      if (\n        code === charCodes.verticalBar &&\n        next === charCodes.rightCurlyBrace\n      ) {\n        // '|}'\n        this.finishOp(tt.braceBarR, 2);\n        return;\n      }\n\n      super.readToken_pipe_amp(code);\n    }\n\n    parseTopLevel(file: N.File, program: N.Program): N.File {\n      const fileNode = super.parseTopLevel(file, program);\n      if (this.state.hasFlowComment) {\n        this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);\n      }\n      return fileNode;\n    }\n\n    skipBlockComment(): N.CommentBlock | void {\n      if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n        if (this.state.hasFlowComment) {\n          this.unexpected(null, FlowErrors.NestedFlowComment);\n        }\n        this.hasFlowCommentCompletion();\n        this.state.pos += this.skipFlowComment();\n        this.state.hasFlowComment = true;\n        return;\n      }\n\n      if (this.state.hasFlowComment) {\n        const end = this.input.indexOf(\"*-/\", (this.state.pos += 2));\n        if (end === -1) {\n          throw this.raise(this.state.pos - 2, Errors.UnterminatedComment);\n        }\n        this.state.pos = end + 3;\n        return;\n      }\n\n      return super.skipBlockComment();\n    }\n\n    skipFlowComment(): number | boolean {\n      const { pos } = this.state;\n      let shiftToFirstNonWhiteSpace = 2;\n      while (\n        [charCodes.space, charCodes.tab].includes(\n          this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace),\n        )\n      ) {\n        shiftToFirstNonWhiteSpace++;\n      }\n\n      const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n      const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n      if (ch2 === charCodes.colon && ch3 === charCodes.colon) {\n        return shiftToFirstNonWhiteSpace + 2; // check for /*::\n      }\n      if (\n        this.input.slice(\n          shiftToFirstNonWhiteSpace + pos,\n          shiftToFirstNonWhiteSpace + pos + 12,\n        ) === \"flow-include\"\n      ) {\n        return shiftToFirstNonWhiteSpace + 12; // check for /*flow-include\n      }\n      if (ch2 === charCodes.colon && ch3 !== charCodes.colon) {\n        return shiftToFirstNonWhiteSpace; // check for /*:, advance up to :\n      }\n      return false;\n    }\n\n    hasFlowCommentCompletion(): void {\n      const end = this.input.indexOf(\"*/\", this.state.pos);\n      if (end === -1) {\n        throw this.raise(this.state.pos, Errors.UnterminatedComment);\n      }\n    }\n\n    // Flow enum parsing\n\n    flowEnumErrorBooleanMemberNotInitialized(\n      pos: number,\n      { enumName, memberName }: { enumName: string, memberName: string },\n    ): void {\n      this.raise(\n        pos,\n        FlowErrors.EnumBooleanMemberNotInitialized,\n        memberName,\n        enumName,\n      );\n    }\n\n    flowEnumErrorInvalidMemberName(\n      pos: number,\n      { enumName, memberName }: { enumName: string, memberName: string },\n    ): void {\n      const suggestion = memberName[0].toUpperCase() + memberName.slice(1);\n      this.raise(\n        pos,\n        FlowErrors.EnumInvalidMemberName,\n        memberName,\n        suggestion,\n        enumName,\n      );\n    }\n\n    flowEnumErrorDuplicateMemberName(\n      pos: number,\n      { enumName, memberName }: { enumName: string, memberName: string },\n    ): void {\n      this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);\n    }\n\n    flowEnumErrorInconsistentMemberValues(\n      pos: number,\n      { enumName }: { enumName: string },\n    ): void {\n      this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);\n    }\n\n    flowEnumErrorInvalidExplicitType(\n      pos: number,\n      {\n        enumName,\n        suppliedType,\n      }: { enumName: string, suppliedType: null | string },\n    ) {\n      return this.raise(\n        pos,\n        suppliedType === null\n          ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied\n          : FlowErrors.EnumInvalidExplicitType,\n        enumName,\n        suppliedType,\n      );\n    }\n\n    flowEnumErrorInvalidMemberInitializer(\n      pos: number,\n      { enumName, explicitType, memberName }: EnumContext,\n    ) {\n      let message = null;\n      switch (explicitType) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n          message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;\n          break;\n        case \"symbol\":\n          message = FlowErrors.EnumInvalidMemberInitializerSymbolType;\n          break;\n        default:\n          // null\n          message = FlowErrors.EnumInvalidMemberInitializerUnknownType;\n      }\n      return this.raise(pos, message, enumName, memberName, explicitType);\n    }\n\n    flowEnumErrorNumberMemberNotInitialized(\n      pos: number,\n      { enumName, memberName }: { enumName: string, memberName: string },\n    ): void {\n      this.raise(\n        pos,\n        FlowErrors.EnumNumberMemberNotInitialized,\n        enumName,\n        memberName,\n      );\n    }\n\n    flowEnumErrorStringMemberInconsistentlyInitailized(\n      pos: number,\n      { enumName }: { enumName: string },\n    ): void {\n      this.raise(\n        pos,\n        FlowErrors.EnumStringMemberInconsistentlyInitailized,\n        enumName,\n      );\n    }\n\n    flowEnumMemberInit(): EnumMemberInit {\n      const startPos = this.state.start;\n      const endOfInit = () => this.match(tt.comma) || this.match(tt.braceR);\n      switch (this.state.type) {\n        case tt.num: {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"number\", pos: literal.start, value: literal };\n          }\n          return { type: \"invalid\", pos: startPos };\n        }\n        case tt.string: {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return { type: \"string\", pos: literal.start, value: literal };\n          }\n          return { type: \"invalid\", pos: startPos };\n        }\n        case tt._true:\n        case tt._false: {\n          const literal = this.parseBooleanLiteral(this.match(tt._true));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              pos: literal.start,\n              value: literal,\n            };\n          }\n          return { type: \"invalid\", pos: startPos };\n        }\n        default:\n          return { type: \"invalid\", pos: startPos };\n      }\n    }\n\n    flowEnumMemberRaw(): { id: N.Node, init: EnumMemberInit } {\n      const pos = this.state.start;\n      const id = this.parseIdentifier(true);\n      const init = this.eat(tt.eq)\n        ? this.flowEnumMemberInit()\n        : { type: \"none\", pos };\n      return { id, init };\n    }\n\n    flowEnumCheckExplicitTypeMismatch(\n      pos: number,\n      context: EnumContext,\n      expectedType: EnumExplicitType,\n    ): void {\n      const { explicitType } = context;\n      if (explicitType === null) {\n        return;\n      }\n      if (explicitType !== expectedType) {\n        this.flowEnumErrorInvalidMemberInitializer(pos, context);\n      }\n    }\n\n    flowEnumMembers({\n      enumName,\n      explicitType,\n    }: {\n      enumName: string,\n      explicitType: EnumExplicitType,\n    }): {|\n      members: {|\n        booleanMembers: Array<N.Node>,\n        numberMembers: Array<N.Node>,\n        stringMembers: Array<N.Node>,\n        defaultedMembers: Array<N.Node>,\n      |},\n      hasUnknownMembers: boolean,\n    |} {\n      const seenNames = new Set();\n      const members = {\n        booleanMembers: [],\n        numberMembers: [],\n        stringMembers: [],\n        defaultedMembers: [],\n      };\n      let hasUnknownMembers = false;\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.ellipsis)) {\n          hasUnknownMembers = true;\n          break;\n        }\n        const memberNode = this.startNode();\n        const { id, init } = this.flowEnumMemberRaw();\n        const memberName = id.name;\n        if (memberName === \"\") {\n          continue;\n        }\n        if (/^[a-z]/.test(memberName)) {\n          this.flowEnumErrorInvalidMemberName(id.start, {\n            enumName,\n            memberName,\n          });\n        }\n        if (seenNames.has(memberName)) {\n          this.flowEnumErrorDuplicateMemberName(id.start, {\n            enumName,\n            memberName,\n          });\n        }\n        seenNames.add(memberName);\n        const context = { enumName, explicitType, memberName };\n        memberNode.id = id;\n        switch (init.type) {\n          case \"boolean\": {\n            this.flowEnumCheckExplicitTypeMismatch(\n              init.pos,\n              context,\n              \"boolean\",\n            );\n            memberNode.init = init.value;\n            members.booleanMembers.push(\n              this.finishNode(memberNode, \"EnumBooleanMember\"),\n            );\n            break;\n          }\n          case \"number\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(\n              this.finishNode(memberNode, \"EnumNumberMember\"),\n            );\n            break;\n          }\n          case \"string\": {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(\n              this.finishNode(memberNode, \"EnumStringMember\"),\n            );\n            break;\n          }\n          case \"invalid\": {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);\n          }\n          case \"none\": {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(\n                  init.pos,\n                  context,\n                );\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);\n                break;\n              default:\n                members.defaultedMembers.push(\n                  this.finishNode(memberNode, \"EnumDefaultedMember\"),\n                );\n            }\n          }\n        }\n\n        if (!this.match(tt.braceR)) {\n          this.expect(tt.comma);\n        }\n      }\n      return { members, hasUnknownMembers };\n    }\n\n    flowEnumStringMembers(\n      initializedMembers: Array<N.Node>,\n      defaultedMembers: Array<N.Node>,\n      { enumName }: { enumName: string },\n    ): Array<N.Node> {\n      if (initializedMembers.length === 0) {\n        return defaultedMembers;\n      } else if (defaultedMembers.length === 0) {\n        return initializedMembers;\n      } else if (defaultedMembers.length > initializedMembers.length) {\n        for (const member of initializedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(\n            member.start,\n            { enumName },\n          );\n        }\n        return defaultedMembers;\n      } else {\n        for (const member of defaultedMembers) {\n          this.flowEnumErrorStringMemberInconsistentlyInitailized(\n            member.start,\n            { enumName },\n          );\n        }\n        return initializedMembers;\n      }\n    }\n\n    flowEnumParseExplicitType({\n      enumName,\n    }: {\n      enumName: string,\n    }): EnumExplicitType {\n      if (this.eatContextual(tt._of)) {\n        if (!tokenIsIdentifier(this.state.type)) {\n          throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: null,\n          });\n        }\n\n        const { value } = this.state;\n        this.next();\n\n        if (\n          value !== \"boolean\" &&\n          value !== \"number\" &&\n          value !== \"string\" &&\n          value !== \"symbol\"\n        ) {\n          this.flowEnumErrorInvalidExplicitType(this.state.start, {\n            enumName,\n            suppliedType: value,\n          });\n        }\n\n        return value;\n      }\n      return null;\n    }\n\n    flowEnumBody(node: N.Node, { enumName, nameLoc }): N.Node {\n      const explicitType = this.flowEnumParseExplicitType({ enumName });\n      this.expect(tt.braceL);\n      const { members, hasUnknownMembers } = this.flowEnumMembers({\n        enumName,\n        explicitType,\n      });\n      node.hasUnknownMembers = hasUnknownMembers;\n\n      switch (explicitType) {\n        case \"boolean\":\n          node.explicitType = true;\n          node.members = members.booleanMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumBooleanBody\");\n        case \"number\":\n          node.explicitType = true;\n          node.members = members.numberMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumNumberBody\");\n        case \"string\":\n          node.explicitType = true;\n          node.members = this.flowEnumStringMembers(\n            members.stringMembers,\n            members.defaultedMembers,\n            { enumName },\n          );\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumStringBody\");\n        case \"symbol\":\n          node.members = members.defaultedMembers;\n          this.expect(tt.braceR);\n          return this.finishNode(node, \"EnumSymbolBody\");\n        default: {\n          // `explicitType` is `null`\n          const empty = () => {\n            node.members = [];\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(\n              members.stringMembers,\n              members.defaultedMembers,\n              { enumName },\n            );\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name,\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(tt.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.flowEnumErrorInconsistentMemberValues(nameLoc, { enumName });\n            return empty();\n          }\n        }\n      }\n    }\n\n    flowParseEnumDeclaration(node: N.Node): N.Node {\n      const id = this.parseIdentifier();\n      node.id = id;\n      node.body = this.flowEnumBody(this.startNode(), {\n        enumName: id.name,\n        nameLoc: id.start,\n      });\n      return this.finishNode(node, \"EnumDeclaration\");\n    }\n\n    // check if the next token is a tt.lt\n    isLookaheadToken_lt(): boolean {\n      const next = this.nextTokenStart();\n      if (this.input.charCodeAt(next) === charCodes.lessThan) {\n        const afterNext = this.input.charCodeAt(next + 1);\n        return (\n          afterNext !== charCodes.lessThan && afterNext !== charCodes.equalsTo\n        );\n      }\n      return false;\n    }\n\n    maybeUnwrapTypeCastExpression(node: N.Node) {\n      return node.type === \"TypeCastExpression\" ? node.expression : node;\n    }\n  };\n", "// @flow\n\nconst entities: { [name: string]: string } = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\",\n};\nexport default entities;\n", "// @flow\n\n// Error messages are colocated with the plugin.\n/* eslint-disable @babel/development-internal/dry-error-messages */\n\nimport * as charCodes from \"charcodes\";\n\nimport XHTMLEntities from \"./xhtml\";\nimport type Parser from \"../../parser\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport {\n  tokenComesBeforeExpression,\n  tokenIsKeyword,\n  tokenLabelName,\n  type TokenType,\n  tt,\n} from \"../../tokenizer/types\";\nimport { TokContext, types as tc } from \"../../tokenizer/context\";\nimport * as N from \"../../types\";\nimport { isIdentifierChar, isIdentifierStart } from \"../../util/identifier\";\nimport type { Position } from \"../../util/location\";\nimport { isNewLine } from \"../../util/whitespace\";\nimport { Errors, makeErrorTemplates, ErrorCodes } from \"../../parser/error\";\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\n\n/* eslint sort-keys: \"error\" */\nconst JsxErrors = makeErrorTemplates(\n  {\n    AttributeIsEmpty:\n      \"JSX attributes must only be assigned a non-empty expression.\",\n    MissingClosingTagElement:\n      \"Expected corresponding JSX closing tag for <%0>.\",\n    MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n    UnexpectedSequenceExpression:\n      \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n    UnsupportedJsxValue:\n      \"JSX value should be either an expression or a quoted JSX text.\",\n    UnterminatedJsxContent: \"Unterminated JSX contents.\",\n    UnwrappedAdjacentJSXElements:\n      \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\",\n  },\n  /* code */ ErrorCodes.SyntaxError,\n  /* syntaxPlugin */ \"jsx\",\n);\n/* eslint-disable sort-keys */\n\n// Be aware that this file is always executed and not only when the plugin is enabled.\n// Therefore the contexts do always exist.\ntc.j_oTag = new TokContext(\"<tag\");\ntc.j_cTag = new TokContext(\"</tag\");\ntc.j_expr = new TokContext(\"<tag>...</tag>\", true);\n\nfunction isFragment(object: ?N.JSXElement): boolean {\n  return object\n    ? object.type === \"JSXOpeningFragment\" ||\n        object.type === \"JSXClosingFragment\"\n    : false;\n}\n\n// Transforms JSX element name to string.\n\nfunction getQualifiedJSXName(\n  object: N.JSXIdentifier | N.JSXNamespacedName | N.JSXMemberExpression,\n): string {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return (\n      getQualifiedJSXName(object.object) +\n      \".\" +\n      getQualifiedJSXName(object.property)\n    );\n  }\n\n  // istanbul ignore next\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    // Reads inline JSX contents token.\n\n    jsxReadToken(): void {\n      let out = \"\";\n      let chunkStart = this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n\n        switch (ch) {\n          case charCodes.lessThan:\n          case charCodes.leftCurlyBrace:\n            if (this.state.pos === this.state.start) {\n              if (ch === charCodes.lessThan && this.state.canStartJSXElement) {\n                ++this.state.pos;\n                return this.finishToken(tt.jsxTagStart);\n              }\n              return super.getTokenFromCode(ch);\n            }\n            out += this.input.slice(chunkStart, this.state.pos);\n            return this.finishToken(tt.jsxText, out);\n\n          case charCodes.ampersand:\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadEntity();\n            chunkStart = this.state.pos;\n            break;\n\n          case charCodes.greaterThan:\n          case charCodes.rightCurlyBrace:\n            if (process.env.BABEL_8_BREAKING) {\n              const htmlEntity =\n                ch === charCodes.rightCurlyBrace ? \"&rbrace;\" : \"&gt;\";\n              const char = this.input[this.state.pos];\n              this.raise(this.state.pos, {\n                code: ErrorCodes.SyntaxError,\n                reasonCode: \"UnexpectedToken\",\n                template: `Unexpected token \\`${char}\\`. Did you mean \\`${htmlEntity}\\` or \\`{'${char}'}\\`?`,\n              });\n            }\n          /* falls through */\n\n          default:\n            if (isNewLine(ch)) {\n              out += this.input.slice(chunkStart, this.state.pos);\n              out += this.jsxReadNewLine(true);\n              chunkStart = this.state.pos;\n            } else {\n              ++this.state.pos;\n            }\n        }\n      }\n    }\n\n    jsxReadNewLine(normalizeCRLF: boolean): string {\n      const ch = this.input.charCodeAt(this.state.pos);\n      let out;\n      ++this.state.pos;\n      if (\n        ch === charCodes.carriageReturn &&\n        this.input.charCodeAt(this.state.pos) === charCodes.lineFeed\n      ) {\n        ++this.state.pos;\n        out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n      } else {\n        out = String.fromCharCode(ch);\n      }\n      ++this.state.curLine;\n      this.state.lineStart = this.state.pos;\n\n      return out;\n    }\n\n    jsxReadString(quote: number): void {\n      let out = \"\";\n      let chunkStart = ++this.state.pos;\n      for (;;) {\n        if (this.state.pos >= this.length) {\n          throw this.raise(this.state.start, Errors.UnterminatedString);\n        }\n\n        const ch = this.input.charCodeAt(this.state.pos);\n        if (ch === quote) break;\n        if (ch === charCodes.ampersand) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n        } else if (isNewLine(ch)) {\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadNewLine(false);\n          chunkStart = this.state.pos;\n        } else {\n          ++this.state.pos;\n        }\n      }\n      out += this.input.slice(chunkStart, this.state.pos++);\n      return this.finishToken(tt.string, out);\n    }\n\n    jsxReadEntity(): string {\n      let str = \"\";\n      let count = 0;\n      let entity;\n      let ch = this.input[this.state.pos];\n\n      const startPos = ++this.state.pos;\n      while (this.state.pos < this.length && count++ < 10) {\n        ch = this.input[this.state.pos++];\n        if (ch === \";\") {\n          if (str[0] === \"#\") {\n            if (str[1] === \"x\") {\n              str = str.substr(2);\n              if (HEX_NUMBER.test(str)) {\n                entity = String.fromCodePoint(parseInt(str, 16));\n              }\n            } else {\n              str = str.substr(1);\n              if (DECIMAL_NUMBER.test(str)) {\n                entity = String.fromCodePoint(parseInt(str, 10));\n              }\n            }\n          } else {\n            entity = XHTMLEntities[str];\n          }\n          break;\n        }\n        str += ch;\n      }\n      if (!entity) {\n        this.state.pos = startPos;\n        return \"&\";\n      }\n      return entity;\n    }\n\n    // Read a JSX identifier (valid tag or attribute name).\n    //\n    // Optimized version since JSX identifiers can\"t contain\n    // escape characters and so can be read as single slice.\n    // Also assumes that first character was already checked\n    // by isIdentifierStart in readToken.\n\n    jsxReadWord(): void {\n      let ch;\n      const start = this.state.pos;\n      do {\n        ch = this.input.charCodeAt(++this.state.pos);\n      } while (isIdentifierChar(ch) || ch === charCodes.dash);\n      return this.finishToken(\n        tt.jsxName,\n        this.input.slice(start, this.state.pos),\n      );\n    }\n\n    // Parse next token as JSX identifier\n\n    jsxParseIdentifier(): N.JSXIdentifier {\n      const node = this.startNode();\n      if (this.match(tt.jsxName)) {\n        node.name = this.state.value;\n      } else if (tokenIsKeyword(this.state.type)) {\n        node.name = tokenLabelName(this.state.type);\n      } else {\n        this.unexpected();\n      }\n      this.next();\n      return this.finishNode(node, \"JSXIdentifier\");\n    }\n\n    // Parse namespaced identifier.\n\n    jsxParseNamespacedName(): N.JSXNamespacedName {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const name = this.jsxParseIdentifier();\n      if (!this.eat(tt.colon)) return name;\n\n      const node = this.startNodeAt(startPos, startLoc);\n      node.namespace = name;\n      node.name = this.jsxParseIdentifier();\n      return this.finishNode(node, \"JSXNamespacedName\");\n    }\n\n    // Parses element name in any form - namespaced, member\n    // or single identifier.\n\n    jsxParseElementName():\n      | N.JSXIdentifier\n      | N.JSXNamespacedName\n      | N.JSXMemberExpression {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let node = this.jsxParseNamespacedName();\n      if (node.type === \"JSXNamespacedName\") {\n        return node;\n      }\n      while (this.eat(tt.dot)) {\n        const newNode = this.startNodeAt(startPos, startLoc);\n        newNode.object = node;\n        newNode.property = this.jsxParseIdentifier();\n        node = this.finishNode(newNode, \"JSXMemberExpression\");\n      }\n      return node;\n    }\n\n    // Parses any type of JSX attribute value.\n\n    jsxParseAttributeValue(): N.Expression {\n      let node;\n      switch (this.state.type) {\n        case tt.braceL:\n          node = this.startNode();\n          this.next();\n          node = this.jsxParseExpressionContainer(node);\n          if (node.expression.type === \"JSXEmptyExpression\") {\n            this.raise(node.start, JsxErrors.AttributeIsEmpty);\n          }\n          return node;\n\n        case tt.jsxTagStart:\n        case tt.string:\n          return this.parseExprAtom();\n\n        default:\n          throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);\n      }\n    }\n\n    // JSXEmptyExpression is unique type since it doesn't actually parse anything,\n    // and so it should start at the end of last read token (left brace) and finish\n    // at the beginning of the next one (right brace).\n\n    jsxParseEmptyExpression(): N.JSXEmptyExpression {\n      const node = this.startNodeAt(\n        this.state.lastTokEnd,\n        this.state.lastTokEndLoc,\n      );\n      return this.finishNodeAt(\n        node,\n        \"JSXEmptyExpression\",\n        this.state.start,\n        this.state.startLoc,\n      );\n    }\n\n    // Parse JSX spread child\n\n    jsxParseSpreadChild(node: N.JSXSpreadChild): N.JSXSpreadChild {\n      this.next(); // ellipsis\n      node.expression = this.parseExpression();\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXSpreadChild\");\n    }\n\n    // Parses JSX expression enclosed into curly brackets.\n\n    jsxParseExpressionContainer(\n      node: N.JSXExpressionContainer,\n    ): N.JSXExpressionContainer {\n      if (this.match(tt.braceR)) {\n        node.expression = this.jsxParseEmptyExpression();\n      } else {\n        const expression = this.parseExpression();\n\n        if (process.env.BABEL_8_BREAKING) {\n          if (\n            expression.type === \"SequenceExpression\" &&\n            !expression.extra?.parenthesized\n          ) {\n            this.raise(\n              expression.expressions[1].start,\n              JsxErrors.UnexpectedSequenceExpression,\n            );\n          }\n        }\n\n        node.expression = expression;\n      }\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"JSXExpressionContainer\");\n    }\n\n    // Parses following JSX attribute name-value pair.\n\n    jsxParseAttribute(): N.JSXAttribute {\n      const node = this.startNode();\n      if (this.eat(tt.braceL)) {\n        this.expect(tt.ellipsis);\n        node.argument = this.parseMaybeAssignAllowIn();\n        this.expect(tt.braceR);\n        return this.finishNode(node, \"JSXSpreadAttribute\");\n      }\n      node.name = this.jsxParseNamespacedName();\n      node.value = this.eat(tt.eq) ? this.jsxParseAttributeValue() : null;\n      return this.finishNode(node, \"JSXAttribute\");\n    }\n\n    // Parses JSX opening tag starting after \"<\".\n\n    jsxParseOpeningElementAt(\n      startPos: number,\n      startLoc: Position,\n    ): N.JSXOpeningElement {\n      const node = this.startNodeAt(startPos, startLoc);\n      if (this.match(tt.jsxTagEnd)) {\n        this.expect(tt.jsxTagEnd);\n        return this.finishNode(node, \"JSXOpeningFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      return this.jsxParseOpeningElementAfterName(node);\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: N.JSXOpeningElement,\n    ): N.JSXOpeningElement {\n      const attributes: N.JSXAttribute[] = [];\n      while (!this.match(tt.slash) && !this.match(tt.jsxTagEnd)) {\n        attributes.push(this.jsxParseAttribute());\n      }\n      node.attributes = attributes;\n      node.selfClosing = this.eat(tt.slash);\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningElement\");\n    }\n\n    // Parses JSX closing tag starting after \"</\".\n\n    jsxParseClosingElementAt(\n      startPos: number,\n      startLoc: Position,\n    ): N.JSXClosingElement {\n      const node = this.startNodeAt(startPos, startLoc);\n      if (this.match(tt.jsxTagEnd)) {\n        this.expect(tt.jsxTagEnd);\n        return this.finishNode(node, \"JSXClosingFragment\");\n      }\n      node.name = this.jsxParseElementName();\n      this.expect(tt.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingElement\");\n    }\n\n    // Parses entire JSX element, including it\"s opening tag\n    // (starting after \"<\"), attributes, contents and closing tag.\n\n    jsxParseElementAt(startPos: number, startLoc: Position): N.JSXElement {\n      const node = this.startNodeAt(startPos, startLoc);\n      const children = [];\n      const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n      let closingElement = null;\n\n      if (!openingElement.selfClosing) {\n        contents: for (;;) {\n          switch (this.state.type) {\n            case tt.jsxTagStart:\n              startPos = this.state.start;\n              startLoc = this.state.startLoc;\n              this.next();\n              if (this.eat(tt.slash)) {\n                closingElement = this.jsxParseClosingElementAt(\n                  startPos,\n                  startLoc,\n                );\n                break contents;\n              }\n              children.push(this.jsxParseElementAt(startPos, startLoc));\n              break;\n\n            case tt.jsxText:\n              children.push(this.parseExprAtom());\n              break;\n\n            case tt.braceL: {\n              const node = this.startNode();\n              this.next();\n              if (this.match(tt.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node));\n              }\n\n              break;\n            }\n            // istanbul ignore next - should never happen\n            default:\n              throw this.unexpected();\n          }\n        }\n\n        if (isFragment(openingElement) && !isFragment(closingElement)) {\n          this.raise(\n            // $FlowIgnore\n            closingElement.start,\n            JsxErrors.MissingClosingTagFragment,\n          );\n        } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n          this.raise(\n            // $FlowIgnore\n            closingElement.start,\n            JsxErrors.MissingClosingTagElement,\n            getQualifiedJSXName(openingElement.name),\n          );\n        } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n          if (\n            // $FlowIgnore\n            getQualifiedJSXName(closingElement.name) !==\n            getQualifiedJSXName(openingElement.name)\n          ) {\n            this.raise(\n              // $FlowIgnore\n              closingElement.start,\n              JsxErrors.MissingClosingTagElement,\n              getQualifiedJSXName(openingElement.name),\n            );\n          }\n        }\n      }\n\n      if (isFragment(openingElement)) {\n        node.openingFragment = openingElement;\n        node.closingFragment = closingElement;\n      } else {\n        node.openingElement = openingElement;\n        node.closingElement = closingElement;\n      }\n      node.children = children;\n      if (this.match(tt.lt)) {\n        throw this.raise(\n          this.state.start,\n          JsxErrors.UnwrappedAdjacentJSXElements,\n        );\n      }\n\n      return isFragment(openingElement)\n        ? this.finishNode(node, \"JSXFragment\")\n        : this.finishNode(node, \"JSXElement\");\n    }\n\n    // Parses entire JSX element from current position.\n\n    jsxParseElement(): N.JSXElement {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      this.next();\n      return this.jsxParseElementAt(startPos, startLoc);\n    }\n\n    // ==================================\n    // Overrides\n    // ==================================\n\n    parseExprAtom(refExpressionErrors: ?ExpressionErrors): N.Expression {\n      if (this.match(tt.jsxText)) {\n        return this.parseLiteral(this.state.value, \"JSXText\");\n      } else if (this.match(tt.jsxTagStart)) {\n        return this.jsxParseElement();\n      } else if (\n        this.match(tt.lt) &&\n        this.input.charCodeAt(this.state.pos) !== charCodes.exclamationMark\n      ) {\n        // In case we encounter an lt token here it will always be the start of\n        // jsx as the lt sign is not allowed in places that expect an expression\n        this.replaceToken(tt.jsxTagStart);\n        return this.jsxParseElement();\n      } else {\n        return super.parseExprAtom(refExpressionErrors);\n      }\n    }\n\n    getTokenFromCode(code: number): void {\n      const context = this.curContext();\n\n      if (context === tc.j_expr) {\n        return this.jsxReadToken();\n      }\n\n      if (context === tc.j_oTag || context === tc.j_cTag) {\n        if (isIdentifierStart(code)) {\n          return this.jsxReadWord();\n        }\n\n        if (code === charCodes.greaterThan) {\n          ++this.state.pos;\n          return this.finishToken(tt.jsxTagEnd);\n        }\n\n        if (\n          (code === charCodes.quotationMark || code === charCodes.apostrophe) &&\n          context === tc.j_oTag\n        ) {\n          return this.jsxReadString(code);\n        }\n      }\n\n      if (\n        code === charCodes.lessThan &&\n        this.state.canStartJSXElement &&\n        this.input.charCodeAt(this.state.pos + 1) !== charCodes.exclamationMark\n      ) {\n        ++this.state.pos;\n        return this.finishToken(tt.jsxTagStart);\n      }\n\n      return super.getTokenFromCode(code);\n    }\n\n    updateContext(prevType: TokenType): void {\n      super.updateContext(prevType);\n      const { context, type } = this.state;\n      if (type === tt.slash && prevType === tt.jsxTagStart) {\n        // do not consider JSX expr -> JSX open tag -> ... anymore\n        // reconsider as closing tag context\n        context.splice(-2, 2, tc.j_cTag);\n        this.state.canStartJSXElement = false;\n      } else if (type === tt.jsxTagStart) {\n        context.push(\n          tc.j_expr, // treat as beginning of JSX expression\n          tc.j_oTag, // start opening tag context\n        );\n      } else if (type === tt.jsxTagEnd) {\n        const out = context.pop();\n        if ((out === tc.j_oTag && prevType === tt.slash) || out === tc.j_cTag) {\n          context.pop();\n          this.state.canStartJSXElement =\n            context[context.length - 1] === tc.j_expr;\n        } else {\n          this.state.canStartJSXElement = true;\n        }\n      } else {\n        this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n      }\n    }\n  };\n", "// @flow\n\nimport ScopeHandler, { Scope } from \"../../util/scope\";\nimport {\n  BIND_KIND_TYPE,\n  BIND_FLAGS_TS_ENUM,\n  BIND_FLAGS_TS_CONST_ENUM,\n  BIND_FLAGS_TS_EXPORT_ONLY,\n  BIND_KIND_VALUE,\n  BIND_FLAGS_CLASS,\n  type ScopeFlags,\n  type BindingTypes,\n} from \"../../util/scopeflags\";\nimport * as N from \"../../types\";\n\nclass TypeScriptScope extends Scope {\n  types: Set<string> = new Set();\n\n  // enums (which are also in .types)\n  enums: Set<string> = new Set();\n\n  // const enums (which are also in .enums and .types)\n  constEnums: Set<string> = new Set();\n\n  // classes (which are also in .lexical) and interface (which are also in .types)\n  classes: Set<string> = new Set();\n\n  // namespaces and ambient functions (or classes) are too difficult to track,\n  // especially without type analysis.\n  // We need to track them anyway, to avoid \"X is not defined\" errors\n  // when exporting them.\n  exportOnlyBindings: Set<string> = new Set();\n}\n\n// See https://github.com/babel/babel/pull/9766#discussion_r268920730 for an\n// explanation of how typescript handles scope.\n\nexport default class TypeScriptScopeHandler extends ScopeHandler<TypeScriptScope> {\n  createScope(flags: ScopeFlags): TypeScriptScope {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name: string, bindingType: BindingTypes, pos: number) {\n    const scope = this.currentScope();\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.add(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        // \"Value\" bindings have already been registered by the superclass.\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        this.maybeExportDefined(scope, name);\n      }\n      scope.types.add(name);\n    }\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);\n  }\n\n  isRedeclaredInScope(\n    scope: TypeScriptScope,\n    name: string,\n    bindingType: BindingTypes,\n  ): boolean {\n    if (scope.enums.has(name)) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        // Enums can be merged with other enums if they are both\n        //  const or both non-const.\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.has(name);\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {\n      if (scope.lexical.has(name)) {\n        // Classes can be merged with interfaces\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        // Interface can be merged with other classes or interfaces\n        return false;\n      }\n    }\n    if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id: N.Identifier) {\n    const topLevelScope = this.scopeStack[0];\n    const { name } = id;\n    if (\n      !topLevelScope.types.has(name) &&\n      !topLevelScope.exportOnlyBindings.has(name)\n    ) {\n      super.checkLocalExport(id);\n    }\n  }\n}\n", "// @flow\n\n/*:: declare var invariant; */\n\n// Error messages are colocated with the plugin.\n/* eslint-disable @babel/development-internal/dry-error-messages */\n\nimport type State from \"../../tokenizer/state\";\nimport {\n  tokenIsIdentifier,\n  tokenIsTSDeclarationStart,\n  tokenIsTSTypeOperator,\n  tokenOperatorPrecedence,\n  tokenIsKeywordOrIdentifier,\n  tt,\n  type TokenType,\n} from \"../../tokenizer/types\";\nimport { types as ct } from \"../../tokenizer/context\";\nimport * as N from \"../../types\";\nimport type { Position } from \"../../util/location\";\nimport type Parser from \"../../parser\";\nimport {\n  type BindingTypes,\n  SCOPE_TS_MODULE,\n  SCOPE_OTHER,\n  BIND_TS_ENUM,\n  BIND_TS_CONST_ENUM,\n  BIND_TS_TYPE,\n  BIND_TS_INTERFACE,\n  BIND_TS_AMBIENT,\n  BIND_TS_NAMESPACE,\n  BIND_CLASS,\n  BIND_LEXICAL,\n} from \"../../util/scopeflags\";\nimport TypeScriptScopeHandler from \"./scope\";\nimport * as charCodes from \"charcodes\";\nimport type { ExpressionErrors } from \"../../parser/util\";\nimport { PARAM } from \"../../util/production-parameter\";\nimport {\n  Errors,\n  makeErrorTemplates,\n  type ErrorTemplate,\n  ErrorCodes,\n} from \"../../parser/error\";\nimport { cloneIdentifier } from \"../../parser/node\";\n\ntype TsModifier =\n  | \"readonly\"\n  | \"abstract\"\n  | \"declare\"\n  | \"static\"\n  | \"override\"\n  | N.Accessibility;\n\nfunction nonNull<T>(x: ?T): T {\n  if (x == null) {\n    // $FlowIgnore\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\n\nfunction assert(x: boolean): void {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\ntype ParsingContext =\n  | \"EnumMembers\"\n  | \"HeritageClauseElement\"\n  | \"TupleElementTypes\"\n  | \"TypeMembers\"\n  | \"TypeParametersOrArguments\";\n\n/* eslint sort-keys: \"error\" */\nconst TSErrors = makeErrorTemplates(\n  {\n    AbstractMethodHasImplementation:\n      \"Method '%0' cannot have an implementation because it is marked abstract.\",\n    AbstractPropertyHasInitializer:\n      \"Property '%0' cannot have an initializer because it is marked abstract.\",\n    AccesorCannotDeclareThisParameter:\n      \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n    AccesorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n    ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n    ClassMethodHasReadonly:\n      \"Class methods cannot have the 'readonly' modifier.\",\n    ConstructorHasTypeParameters:\n      \"Type parameters cannot appear on a constructor declaration.\",\n    DeclareAccessor: \"'declare' is not allowed in %0ters.\",\n    DeclareClassFieldHasInitializer:\n      \"Initializers are not allowed in ambient contexts.\",\n    DeclareFunctionHasImplementation:\n      \"An implementation cannot be declared in ambient contexts.\",\n    DuplicateAccessibilityModifier: \"Accessibility modifier already seen.\",\n    DuplicateModifier: \"Duplicate modifier: '%0'.\",\n    EmptyHeritageClauseType: \"'%0' list cannot be empty.\",\n    EmptyTypeArguments: \"Type argument list cannot be empty.\",\n    EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n    ExpectedAmbientAfterExportDeclare:\n      \"'export declare' must be followed by an ambient declaration.\",\n    ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n    IncompatibleModifiers: \"'%0' modifier cannot be used with '%1' modifier.\",\n    IndexSignatureHasAbstract:\n      \"Index signatures cannot have the 'abstract' modifier.\",\n    IndexSignatureHasAccessibility:\n      \"Index signatures cannot have an accessibility modifier ('%0').\",\n    IndexSignatureHasDeclare:\n      \"Index signatures cannot have the 'declare' modifier.\",\n    IndexSignatureHasOverride:\n      \"'override' modifier cannot appear on an index signature.\",\n    IndexSignatureHasStatic:\n      \"Index signatures cannot have the 'static' modifier.\",\n    InvalidModifierOnTypeMember:\n      \"'%0' modifier cannot appear on a type member.\",\n    InvalidModifiersOrder: \"'%0' modifier must precede '%1' modifier.\",\n    InvalidTupleMemberLabel:\n      \"Tuple members must be labeled with a simple identifier.\",\n    MissingInterfaceName:\n      \"'interface' declarations must be followed by an identifier.\",\n    MixedLabeledAndUnlabeledElements:\n      \"Tuple members must all have names or all not have names.\",\n    NonAbstractClassHasAbstractMethod:\n      \"Abstract methods can only appear within an abstract class.\",\n    NonClassMethodPropertyHasAbstractModifer:\n      \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n    OptionalTypeBeforeRequired:\n      \"A required element cannot follow an optional element.\",\n    OverrideNotInSubClass:\n      \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n    PatternIsOptional:\n      \"A binding pattern parameter cannot be optional in an implementation signature.\",\n    PrivateElementHasAbstract:\n      \"Private elements cannot have the 'abstract' modifier.\",\n    PrivateElementHasAccessibility:\n      \"Private elements cannot have an accessibility modifier ('%0').\",\n    ReadonlyForMethodSignature:\n      \"'readonly' modifier can only appear on a property declaration or index signature.\",\n    ReservedArrowTypeParam:\n      \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n    ReservedTypeAssertion:\n      \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n    SetAccesorCannotHaveOptionalParameter:\n      \"A 'set' accessor cannot have an optional parameter.\",\n    SetAccesorCannotHaveRestParameter:\n      \"A 'set' accessor cannot have rest parameter.\",\n    SetAccesorCannotHaveReturnType:\n      \"A 'set' accessor cannot have a return type annotation.\",\n    StaticBlockCannotHaveModifier:\n      \"Static class blocks cannot have any modifier.\",\n    TypeAnnotationAfterAssign:\n      \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n    TypeImportCannotSpecifyDefaultAndNamed:\n      \"A type-only import can specify a default import or named bindings, but not both.\",\n    TypeModifierIsUsedInTypeExports:\n      \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n    TypeModifierIsUsedInTypeImports:\n      \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n    UnexpectedParameterModifier:\n      \"A parameter property is only allowed in a constructor implementation.\",\n    UnexpectedReadonly:\n      \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n    UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n    UnexpectedTypeCastInParameter:\n      \"Unexpected type cast in parameter position.\",\n    UnsupportedImportTypeArgument:\n      \"Argument in a type import must be a string literal.\",\n    UnsupportedParameterPropertyKind:\n      \"A parameter property may not be declared using a binding pattern.\",\n    UnsupportedSignatureParameterKind:\n      \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0.\",\n  },\n  /* code */ ErrorCodes.SyntaxError,\n  /* syntaxPlugin */ \"typescript\",\n);\n/* eslint-disable sort-keys */\n\n// Doesn't handle \"void\" or \"null\" because those are keywords, not identifiers.\n// It also doesn't handle \"intrinsic\", since usually it's not a keyword.\nfunction keywordTypeFromName(\n  value: string,\n): N.TsKeywordTypeType | typeof undefined {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\n\nfunction tsIsAccessModifier(modifier: string): boolean %checks {\n  return (\n    modifier === \"private\" || modifier === \"public\" || modifier === \"protected\"\n  );\n}\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    getScopeHandler(): Class<TypeScriptScopeHandler> {\n      return TypeScriptScopeHandler;\n    }\n\n    tsIsIdentifier(): boolean {\n      // TODO: actually a bit more complex in TypeScript, but shouldn't matter.\n      // See https://github.com/Microsoft/TypeScript/issues/15008\n      return tokenIsIdentifier(this.state.type);\n    }\n\n    tsTokenCanFollowModifier() {\n      return (\n        (this.match(tt.bracketL) ||\n          this.match(tt.braceL) ||\n          this.match(tt.star) ||\n          this.match(tt.ellipsis) ||\n          this.match(tt.privateName) ||\n          this.isLiteralPropertyName()) &&\n        !this.hasPrecedingLineBreak()\n      );\n    }\n\n    tsNextTokenCanFollowModifier() {\n      // Note: TypeScript's implementation is much more complicated because\n      // more things are considered modifiers there.\n      // This implementation only handles modifiers not handled by @babel/parser itself. And \"static\".\n      // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...\n      this.next();\n      return this.tsTokenCanFollowModifier();\n    }\n\n    /** Parses a modifier matching one the given modifier names. */\n    tsParseModifier<T: TsModifier>(\n      allowedModifiers: T[],\n      stopOnStartOfClassStaticBlock?: boolean,\n    ): ?T {\n      if (!tokenIsIdentifier(this.state.type)) {\n        return undefined;\n      }\n\n      const modifier = this.state.value;\n      if (allowedModifiers.indexOf(modifier) !== -1) {\n        if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n          return undefined;\n        }\n        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n          return modifier;\n        }\n      }\n      return undefined;\n    }\n\n    /** Parses a list of modifiers, in any order.\n     *  If you need a specific order, you must call this function multiple times:\n     *    this.tsParseModifiers(node, [\"public\"]);\n     *    this.tsParseModifiers(node, [\"abstract\", \"readonly\"]);\n     */\n    tsParseModifiers(\n      modified: {\n        [key: TsModifier]: ?true,\n        accessibility?: N.Accessibility,\n      },\n      allowedModifiers: TsModifier[],\n      disallowedModifiers?: TsModifier[],\n      errorTemplate?: ErrorTemplate,\n      stopOnStartOfClassStaticBlock?: boolean,\n    ): void {\n      const enforceOrder = (pos, modifier, before, after) => {\n        if (modifier === before && modified[after]) {\n          this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);\n        }\n      };\n      const incompatible = (pos, modifier, mod1, mod2) => {\n        if (\n          (modified[mod1] && modifier === mod2) ||\n          (modified[mod2] && modifier === mod1)\n        ) {\n          this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);\n        }\n      };\n\n      for (;;) {\n        const startPos = this.state.start;\n        const modifier: ?TsModifier = this.tsParseModifier(\n          allowedModifiers.concat(disallowedModifiers ?? []),\n          stopOnStartOfClassStaticBlock,\n        );\n\n        if (!modifier) break;\n\n        if (tsIsAccessModifier(modifier)) {\n          if (modified.accessibility) {\n            this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);\n          } else {\n            enforceOrder(startPos, modifier, modifier, \"override\");\n            enforceOrder(startPos, modifier, modifier, \"static\");\n            enforceOrder(startPos, modifier, modifier, \"readonly\");\n\n            modified.accessibility = modifier;\n          }\n        } else {\n          if (Object.hasOwnProperty.call(modified, modifier)) {\n            this.raise(startPos, TSErrors.DuplicateModifier, modifier);\n          } else {\n            enforceOrder(startPos, modifier, \"static\", \"readonly\");\n            enforceOrder(startPos, modifier, \"static\", \"override\");\n            enforceOrder(startPos, modifier, \"override\", \"readonly\");\n            enforceOrder(startPos, modifier, \"abstract\", \"override\");\n\n            incompatible(startPos, modifier, \"declare\", \"override\");\n            incompatible(startPos, modifier, \"static\", \"abstract\");\n          }\n          modified[modifier] = true;\n        }\n\n        if (disallowedModifiers?.includes(modifier)) {\n          this.raise(\n            startPos,\n            // $FlowIgnore\n            errorTemplate,\n            modifier,\n          );\n        }\n      }\n    }\n\n    tsIsListTerminator(kind: ParsingContext): boolean {\n      switch (kind) {\n        case \"EnumMembers\":\n        case \"TypeMembers\":\n          return this.match(tt.braceR);\n        case \"HeritageClauseElement\":\n          return this.match(tt.braceL);\n        case \"TupleElementTypes\":\n          return this.match(tt.bracketR);\n        case \"TypeParametersOrArguments\":\n          return this.match(tt.gt);\n      }\n\n      throw new Error(\"Unreachable\");\n    }\n\n    tsParseList<T: N.Node>(kind: ParsingContext, parseElement: () => T): T[] {\n      const result: T[] = [];\n      while (!this.tsIsListTerminator(kind)) {\n        // Skipping \"parseListElement\" from the TS source since that's just for error handling.\n        result.push(parseElement());\n      }\n      return result;\n    }\n\n    tsParseDelimitedList<T: N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      refTrailingCommaPos?: { value: number },\n    ): T[] {\n      return nonNull(\n        this.tsParseDelimitedListWorker(\n          kind,\n          parseElement,\n          /* expectSuccess */ true,\n          refTrailingCommaPos,\n        ),\n      );\n    }\n\n    /**\n     * If !expectSuccess, returns undefined instead of failing to parse.\n     * If expectSuccess, parseElement should always return a defined value.\n     */\n    tsParseDelimitedListWorker<T: N.Node>(\n      kind: ParsingContext,\n      parseElement: () => ?T,\n      expectSuccess: boolean,\n      refTrailingCommaPos?: { value: number },\n    ): ?(T[]) {\n      const result = [];\n      let trailingCommaPos = -1;\n\n      for (;;) {\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n        trailingCommaPos = -1;\n\n        const element = parseElement();\n        if (element == null) {\n          return undefined;\n        }\n        result.push(element);\n\n        if (this.eat(tt.comma)) {\n          trailingCommaPos = this.state.lastTokStart;\n          continue;\n        }\n\n        if (this.tsIsListTerminator(kind)) {\n          break;\n        }\n\n        if (expectSuccess) {\n          // This will fail with an error about a missing comma\n          this.expect(tt.comma);\n        }\n        return undefined;\n      }\n\n      if (refTrailingCommaPos) {\n        refTrailingCommaPos.value = trailingCommaPos;\n      }\n\n      return result;\n    }\n\n    tsParseBracketedList<T: N.Node>(\n      kind: ParsingContext,\n      parseElement: () => T,\n      bracket: boolean,\n      skipFirstToken: boolean,\n      refTrailingCommaPos?: { value: number },\n    ): T[] {\n      if (!skipFirstToken) {\n        if (bracket) {\n          this.expect(tt.bracketL);\n        } else {\n          this.expect(tt.lt);\n        }\n      }\n\n      const result = this.tsParseDelimitedList(\n        kind,\n        parseElement,\n        refTrailingCommaPos,\n      );\n\n      if (bracket) {\n        this.expect(tt.bracketR);\n      } else {\n        this.expect(tt.gt);\n      }\n\n      return result;\n    }\n\n    tsParseImportType(): N.TsImportType {\n      const node: N.TsImportType = this.startNode();\n      this.expect(tt._import);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);\n      }\n\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.argument = this.parseExprAtom();\n      this.expect(tt.parenR);\n\n      if (this.eat(tt.dot)) {\n        node.qualifier = this.tsParseEntityName(/* allowReservedWords */ true);\n      }\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSImportType\");\n    }\n\n    tsParseEntityName(allowReservedWords: boolean): N.TsEntityName {\n      let entity: N.TsEntityName = this.parseIdentifier();\n      while (this.eat(tt.dot)) {\n        const node: N.TsQualifiedName = this.startNodeAtNode(entity);\n        node.left = entity;\n        node.right = this.parseIdentifier(allowReservedWords);\n        entity = this.finishNode(node, \"TSQualifiedName\");\n      }\n      return entity;\n    }\n\n    tsParseTypeReference(): N.TsTypeReference {\n      const node: N.TsTypeReference = this.startNode();\n      node.typeName = this.tsParseEntityName(/* allowReservedWords */ false);\n      if (!this.hasPrecedingLineBreak() && this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSTypeReference\");\n    }\n\n    tsParseThisTypePredicate(lhs: N.TsThisType): N.TsTypePredicate {\n      this.next();\n      const node: N.TsTypePredicate = this.startNodeAtNode(lhs);\n      node.parameterName = lhs;\n      node.typeAnnotation = this.tsParseTypeAnnotation(/* eatColon */ false);\n      node.asserts = false;\n      return this.finishNode(node, \"TSTypePredicate\");\n    }\n\n    tsParseThisTypeNode(): N.TsThisType {\n      const node: N.TsThisType = this.startNode();\n      this.next();\n      return this.finishNode(node, \"TSThisType\");\n    }\n\n    tsParseTypeQuery(): N.TsTypeQuery {\n      const node: N.TsTypeQuery = this.startNode();\n      this.expect(tt._typeof);\n      if (this.match(tt._import)) {\n        node.exprName = this.tsParseImportType();\n      } else {\n        node.exprName = this.tsParseEntityName(/* allowReservedWords */ true);\n      }\n      return this.finishNode(node, \"TSTypeQuery\");\n    }\n\n    tsParseTypeParameter(): N.TsTypeParameter {\n      const node: N.TsTypeParameter = this.startNode();\n      node.name = this.tsParseTypeParameterName();\n      node.constraint = this.tsEatThenParseType(tt._extends);\n      node.default = this.tsEatThenParseType(tt.eq);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsTryParseTypeParameters(): ?N.TsTypeParameterDeclaration {\n      if (this.match(tt.lt)) {\n        return this.tsParseTypeParameters();\n      }\n    }\n\n    tsParseTypeParameters() {\n      const node: N.TsTypeParameterDeclaration = this.startNode();\n\n      if (this.match(tt.lt) || this.match(tt.jsxTagStart)) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n\n      const refTrailingCommaPos = { value: -1 };\n\n      node.params = this.tsParseBracketedList(\n        \"TypeParametersOrArguments\",\n        this.tsParseTypeParameter.bind(this),\n        /* bracket */ false,\n        /* skipFirstToken */ true,\n        refTrailingCommaPos,\n      );\n      if (node.params.length === 0) {\n        this.raise(node.start, TSErrors.EmptyTypeParameters);\n      }\n      if (refTrailingCommaPos.value !== -1) {\n        this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n      }\n      return this.finishNode(node, \"TSTypeParameterDeclaration\");\n    }\n\n    tsTryNextParseConstantContext(): ?N.TsTypeReference {\n      if (this.lookahead().type === tt._const) {\n        this.next();\n        return this.tsParseTypeReference();\n      }\n      return null;\n    }\n\n    // Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,\n    // but here it's always false, because this is only used for types.\n    tsFillSignature(\n      returnToken: TokenType,\n      signature: N.TsSignatureDeclaration,\n    ): void {\n      // Arrow fns *must* have return token (`=>`). Normal functions can omit it.\n      const returnTokenRequired = returnToken === tt.arrow;\n      signature.typeParameters = this.tsTryParseTypeParameters();\n      this.expect(tt.parenL);\n      signature.parameters = this.tsParseBindingListForSignature();\n      if (returnTokenRequired) {\n        signature.typeAnnotation =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      } else if (this.match(returnToken)) {\n        signature.typeAnnotation =\n          this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n      }\n    }\n\n    tsParseBindingListForSignature(): $ReadOnlyArray<\n      N.Identifier | N.RestElement | N.ObjectPattern | N.ArrayPattern,\n    > {\n      return this.parseBindingList(tt.parenR, charCodes.rightParenthesis).map(\n        pattern => {\n          if (\n            pattern.type !== \"Identifier\" &&\n            pattern.type !== \"RestElement\" &&\n            pattern.type !== \"ObjectPattern\" &&\n            pattern.type !== \"ArrayPattern\"\n          ) {\n            this.raise(\n              pattern.start,\n              TSErrors.UnsupportedSignatureParameterKind,\n              pattern.type,\n            );\n          }\n          return (pattern: any);\n        },\n      );\n    }\n\n    tsParseTypeMemberSemicolon(): void {\n      if (!this.eat(tt.comma) && !this.isLineTerminator()) {\n        this.expect(tt.semi);\n      }\n    }\n\n    tsParseSignatureMember(\n      kind: \"TSCallSignatureDeclaration\" | \"TSConstructSignatureDeclaration\",\n      node: N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration,\n    ): N.TsCallSignatureDeclaration | N.TsConstructSignatureDeclaration {\n      this.tsFillSignature(tt.colon, node);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, kind);\n    }\n\n    tsIsUnambiguouslyIndexSignature() {\n      this.next(); // Skip '{'\n      if (tokenIsIdentifier(this.state.type)) {\n        this.next();\n        return this.match(tt.colon);\n      }\n      return false;\n    }\n\n    tsTryParseIndexSignature(node: N.Node): ?N.TsIndexSignature {\n      if (\n        !(\n          this.match(tt.bracketL) &&\n          this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))\n        )\n      ) {\n        return undefined;\n      }\n\n      this.expect(tt.bracketL);\n      const id = this.parseIdentifier();\n      id.typeAnnotation = this.tsParseTypeAnnotation();\n      this.resetEndLocation(id); // set end position to end of type\n\n      this.expect(tt.bracketR);\n      node.parameters = [id];\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(node, \"TSIndexSignature\");\n    }\n\n    tsParsePropertyOrMethodSignature(\n      node: N.TsPropertySignature | N.TsMethodSignature,\n      readonly: boolean,\n    ): N.TsPropertySignature | N.TsMethodSignature {\n      if (this.eat(tt.question)) node.optional = true;\n      const nodeAny: any = node;\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        if (readonly) {\n          this.raise(node.start, TSErrors.ReadonlyForMethodSignature);\n        }\n        const method: N.TsMethodSignature = nodeAny;\n        if (method.kind && this.match(tt.lt)) {\n          this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);\n        }\n        this.tsFillSignature(tt.colon, method);\n        this.tsParseTypeMemberSemicolon();\n        if (method.kind === \"get\") {\n          if (method.parameters.length > 0) {\n            this.raise(this.state.pos, Errors.BadGetterArity);\n            if (this.isThisParam(method.parameters[0])) {\n              this.raise(\n                this.state.pos,\n                TSErrors.AccesorCannotDeclareThisParameter,\n              );\n            }\n          }\n        } else if (method.kind === \"set\") {\n          if (method.parameters.length !== 1) {\n            this.raise(this.state.pos, Errors.BadSetterArity);\n          } else {\n            const firstParameter = method.parameters[0];\n            if (this.isThisParam(firstParameter)) {\n              this.raise(\n                this.state.pos,\n                TSErrors.AccesorCannotDeclareThisParameter,\n              );\n            }\n            if (\n              firstParameter.type === \"Identifier\" &&\n              firstParameter.optional\n            ) {\n              this.raise(\n                this.state.pos,\n                TSErrors.SetAccesorCannotHaveOptionalParameter,\n              );\n            }\n            if (firstParameter.type === \"RestElement\") {\n              this.raise(\n                this.state.pos,\n                TSErrors.SetAccesorCannotHaveRestParameter,\n              );\n            }\n          }\n          if (method.typeAnnotation) {\n            this.raise(\n              method.typeAnnotation.start,\n              TSErrors.SetAccesorCannotHaveReturnType,\n            );\n          }\n        } else {\n          method.kind = \"method\";\n        }\n        return this.finishNode(method, \"TSMethodSignature\");\n      } else {\n        const property: N.TsPropertySignature = nodeAny;\n        if (readonly) property.readonly = true;\n        const type = this.tsTryParseTypeAnnotation();\n        if (type) property.typeAnnotation = type;\n        this.tsParseTypeMemberSemicolon();\n        return this.finishNode(property, \"TSPropertySignature\");\n      }\n    }\n\n    tsParseTypeMember(): N.TsTypeElement {\n      const node: any = this.startNode();\n\n      if (this.match(tt.parenL) || this.match(tt.lt)) {\n        return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n      }\n\n      if (this.match(tt._new)) {\n        const id: N.Identifier = this.startNode();\n        this.next();\n        if (this.match(tt.parenL) || this.match(tt.lt)) {\n          return this.tsParseSignatureMember(\n            \"TSConstructSignatureDeclaration\",\n            node,\n          );\n        } else {\n          node.key = this.createIdentifier(id, \"new\");\n          return this.tsParsePropertyOrMethodSignature(node, false);\n        }\n      }\n\n      this.tsParseModifiers(\n        node,\n        [\"readonly\"],\n        [\n          \"declare\",\n          \"abstract\",\n          \"private\",\n          \"protected\",\n          \"public\",\n          \"static\",\n          \"override\",\n        ],\n        TSErrors.InvalidModifierOnTypeMember,\n      );\n\n      const idx = this.tsTryParseIndexSignature(node);\n      if (idx) {\n        return idx;\n      }\n\n      this.parsePropertyName(node);\n      if (\n        !node.computed &&\n        node.key.type === \"Identifier\" &&\n        (node.key.name === \"get\" || node.key.name === \"set\") &&\n        this.tsTokenCanFollowModifier()\n      ) {\n        node.kind = node.key.name;\n        this.parsePropertyName(node);\n      }\n      return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n    }\n\n    tsParseTypeLiteral(): N.TsTypeLiteral {\n      const node: N.TsTypeLiteral = this.startNode();\n      node.members = this.tsParseObjectTypeMembers();\n      return this.finishNode(node, \"TSTypeLiteral\");\n    }\n\n    tsParseObjectTypeMembers(): $ReadOnlyArray<N.TsTypeElement> {\n      this.expect(tt.braceL);\n      const members = this.tsParseList(\n        \"TypeMembers\",\n        this.tsParseTypeMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return members;\n    }\n\n    tsIsStartOfMappedType(): boolean {\n      this.next();\n      if (this.eat(tt.plusMin)) {\n        return this.isContextual(tt._readonly);\n      }\n      if (this.isContextual(tt._readonly)) {\n        this.next();\n      }\n      if (!this.match(tt.bracketL)) {\n        return false;\n      }\n      this.next();\n      if (!this.tsIsIdentifier()) {\n        return false;\n      }\n      this.next();\n      return this.match(tt._in);\n    }\n\n    tsParseMappedTypeParameter(): N.TsTypeParameter {\n      const node: N.TsTypeParameter = this.startNode();\n      node.name = this.tsParseTypeParameterName();\n      node.constraint = this.tsExpectThenParseType(tt._in);\n      return this.finishNode(node, \"TSTypeParameter\");\n    }\n\n    tsParseMappedType(): N.TsMappedType {\n      const node: N.TsMappedType = this.startNode();\n\n      this.expect(tt.braceL);\n\n      if (this.match(tt.plusMin)) {\n        node.readonly = this.state.value;\n        this.next();\n        this.expectContextual(tt._readonly);\n      } else if (this.eatContextual(tt._readonly)) {\n        node.readonly = true;\n      }\n\n      this.expect(tt.bracketL);\n      node.typeParameter = this.tsParseMappedTypeParameter();\n      node.nameType = this.eatContextual(tt._as) ? this.tsParseType() : null;\n\n      this.expect(tt.bracketR);\n\n      if (this.match(tt.plusMin)) {\n        node.optional = this.state.value;\n        this.next();\n        this.expect(tt.question);\n      } else if (this.eat(tt.question)) {\n        node.optional = true;\n      }\n\n      node.typeAnnotation = this.tsTryParseType();\n      this.semicolon();\n      this.expect(tt.braceR);\n\n      return this.finishNode(node, \"TSMappedType\");\n    }\n\n    tsParseTupleType(): N.TsTupleType {\n      const node: N.TsTupleType = this.startNode();\n      node.elementTypes = this.tsParseBracketedList(\n        \"TupleElementTypes\",\n        this.tsParseTupleElementType.bind(this),\n        /* bracket */ true,\n        /* skipFirstToken */ false,\n      );\n\n      // Validate the elementTypes to ensure that no mandatory elements\n      // follow optional elements\n      let seenOptionalElement = false;\n      let labeledElements = null;\n      node.elementTypes.forEach(elementNode => {\n        let { type } = elementNode;\n\n        if (\n          seenOptionalElement &&\n          type !== \"TSRestType\" &&\n          type !== \"TSOptionalType\" &&\n          !(type === \"TSNamedTupleMember\" && elementNode.optional)\n        ) {\n          this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);\n        }\n\n        // Flow doesn't support ||=\n        seenOptionalElement =\n          seenOptionalElement ||\n          (type === \"TSNamedTupleMember\" && elementNode.optional) ||\n          type === \"TSOptionalType\";\n\n        // When checking labels, check the argument of the spread operator\n        if (type === \"TSRestType\") {\n          elementNode = elementNode.typeAnnotation;\n          type = elementNode.type;\n        }\n\n        const isLabeled = type === \"TSNamedTupleMember\";\n        // Flow doesn't support ??=\n        labeledElements = labeledElements ?? isLabeled;\n        if (labeledElements !== isLabeled) {\n          this.raise(\n            elementNode.start,\n            TSErrors.MixedLabeledAndUnlabeledElements,\n          );\n        }\n      });\n\n      return this.finishNode(node, \"TSTupleType\");\n    }\n\n    tsParseTupleElementType(): N.TsType | N.TsNamedTupleMember {\n      // parses `...TsType[]`\n\n      const { start: startPos, startLoc } = this.state;\n\n      const rest = this.eat(tt.ellipsis);\n      let type = this.tsParseType();\n      const optional = this.eat(tt.question);\n      const labeled = this.eat(tt.colon);\n\n      if (labeled) {\n        const labeledNode: N.TsNamedTupleMember = this.startNodeAtNode(type);\n        labeledNode.optional = optional;\n\n        if (\n          type.type === \"TSTypeReference\" &&\n          !type.typeParameters &&\n          type.typeName.type === \"Identifier\"\n        ) {\n          labeledNode.label = (type.typeName: N.Identifier);\n        } else {\n          this.raise(type.start, TSErrors.InvalidTupleMemberLabel);\n          // This produces an invalid AST, but at least we don't drop\n          // nodes representing the invalid source.\n          // $FlowIgnore\n          labeledNode.label = type;\n        }\n\n        labeledNode.elementType = this.tsParseType();\n        type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n      } else if (optional) {\n        const optionalTypeNode: N.TsOptionalType = this.startNodeAtNode(type);\n        optionalTypeNode.typeAnnotation = type;\n        type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n      }\n\n      if (rest) {\n        const restNode: N.TsRestType = this.startNodeAt(startPos, startLoc);\n        restNode.typeAnnotation = type;\n        type = this.finishNode(restNode, \"TSRestType\");\n      }\n\n      return type;\n    }\n\n    tsParseParenthesizedType(): N.TsParenthesizedType {\n      const node = this.startNode();\n      this.expect(tt.parenL);\n      node.typeAnnotation = this.tsParseType();\n      this.expect(tt.parenR);\n      return this.finishNode(node, \"TSParenthesizedType\");\n    }\n\n    tsParseFunctionOrConstructorType(\n      type: \"TSFunctionType\" | \"TSConstructorType\",\n      abstract?: boolean,\n    ): N.TsFunctionOrConstructorType {\n      const node: N.TsFunctionOrConstructorType = this.startNode();\n      if (type === \"TSConstructorType\") {\n        // $FlowIgnore\n        node.abstract = !!abstract;\n        if (abstract) this.next();\n        this.next(); // eat `new`\n      }\n      this.tsFillSignature(tt.arrow, node);\n      return this.finishNode(node, type);\n    }\n\n    tsParseLiteralTypeNode(): N.TsLiteralType {\n      const node: N.TsLiteralType = this.startNode();\n      node.literal = (() => {\n        switch (this.state.type) {\n          case tt.num:\n          case tt.bigint:\n          case tt.string:\n          case tt._true:\n          case tt._false:\n            // For compatibility to estree we cannot call parseLiteral directly here\n            return this.parseExprAtom();\n          default:\n            throw this.unexpected();\n        }\n      })();\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    tsParseTemplateLiteralType(): N.TsType {\n      const node: N.TsLiteralType = this.startNode();\n      node.literal = this.parseTemplate(false);\n      return this.finishNode(node, \"TSLiteralType\");\n    }\n\n    parseTemplateSubstitution(): N.TsType {\n      if (this.state.inType) return this.tsParseType();\n      return super.parseTemplateSubstitution();\n    }\n\n    tsParseThisTypeOrThisTypePredicate(): N.TsThisType | N.TsTypePredicate {\n      const thisKeyword = this.tsParseThisTypeNode();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        return this.tsParseThisTypePredicate(thisKeyword);\n      } else {\n        return thisKeyword;\n      }\n    }\n\n    tsParseNonArrayType(): N.TsType {\n      switch (this.state.type) {\n        case tt.string:\n        case tt.num:\n        case tt.bigint:\n        case tt._true:\n        case tt._false:\n          return this.tsParseLiteralTypeNode();\n        case tt.plusMin:\n          if (this.state.value === \"-\") {\n            const node: N.TsLiteralType = this.startNode();\n            const nextToken = this.lookahead();\n            if (nextToken.type !== tt.num && nextToken.type !== tt.bigint) {\n              throw this.unexpected();\n            }\n            node.literal = this.parseMaybeUnary();\n            return this.finishNode(node, \"TSLiteralType\");\n          }\n          break;\n        case tt._this:\n          return this.tsParseThisTypeOrThisTypePredicate();\n        case tt._typeof:\n          return this.tsParseTypeQuery();\n        case tt._import:\n          return this.tsParseImportType();\n        case tt.braceL:\n          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this))\n            ? this.tsParseMappedType()\n            : this.tsParseTypeLiteral();\n        case tt.bracketL:\n          return this.tsParseTupleType();\n        case tt.parenL:\n          if (process.env.BABEL_8_BREAKING) {\n            if (!this.options.createParenthesizedExpressions) {\n              const startPos = this.state.start;\n              this.next();\n              const type = this.tsParseType();\n              this.expect(tt.parenR);\n              this.addExtra(type, \"parenthesized\", true);\n              this.addExtra(type, \"parenStart\", startPos);\n              return type;\n            }\n          }\n\n          return this.tsParseParenthesizedType();\n        case tt.backQuote:\n          return this.tsParseTemplateLiteralType();\n        default: {\n          const { type } = this.state;\n          if (\n            tokenIsIdentifier(type) ||\n            type === tt._void ||\n            type === tt._null\n          ) {\n            const nodeType =\n              type === tt._void\n                ? \"TSVoidKeyword\"\n                : type === tt._null\n                ? \"TSNullKeyword\"\n                : keywordTypeFromName(this.state.value);\n            if (\n              nodeType !== undefined &&\n              this.lookaheadCharCode() !== charCodes.dot\n            ) {\n              const node: N.TsKeywordType = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n      }\n\n      throw this.unexpected();\n    }\n\n    tsParseArrayTypeOrHigher(): N.TsType {\n      let type = this.tsParseNonArrayType();\n      while (!this.hasPrecedingLineBreak() && this.eat(tt.bracketL)) {\n        if (this.match(tt.bracketR)) {\n          const node: N.TsArrayType = this.startNodeAtNode(type);\n          node.elementType = type;\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSArrayType\");\n        } else {\n          const node: N.TsIndexedAccessType = this.startNodeAtNode(type);\n          node.objectType = type;\n          node.indexType = this.tsParseType();\n          this.expect(tt.bracketR);\n          type = this.finishNode(node, \"TSIndexedAccessType\");\n        }\n      }\n      return type;\n    }\n\n    tsParseTypeOperator(): N.TsTypeOperator {\n      const node: N.TsTypeOperator = this.startNode();\n      const operator = this.state.value;\n      this.next(); // eat operator\n      node.operator = operator;\n      node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n      if (operator === \"readonly\") {\n        this.tsCheckTypeAnnotationForReadOnly(node);\n      }\n\n      return this.finishNode(node, \"TSTypeOperator\");\n    }\n\n    tsCheckTypeAnnotationForReadOnly(node: N.Node) {\n      switch (node.typeAnnotation.type) {\n        case \"TSTupleType\":\n        case \"TSArrayType\":\n          return;\n        default:\n          this.raise(node.start, TSErrors.UnexpectedReadonly);\n      }\n    }\n\n    tsParseInferType(): N.TsInferType {\n      const node = this.startNode();\n      this.expectContextual(tt._infer);\n      const typeParameter = this.startNode();\n      typeParameter.name = this.tsParseTypeParameterName();\n      node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n      return this.finishNode(node, \"TSInferType\");\n    }\n\n    tsParseTypeOperatorOrHigher(): N.TsType {\n      const isTypeOperator =\n        tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n      return isTypeOperator\n        ? this.tsParseTypeOperator()\n        : this.isContextual(tt._infer)\n        ? this.tsParseInferType()\n        : this.tsParseArrayTypeOrHigher();\n    }\n\n    tsParseUnionOrIntersectionType(\n      kind: \"TSUnionType\" | \"TSIntersectionType\",\n      parseConstituentType: () => N.TsType,\n      operator: TokenType,\n    ): N.TsType {\n      const node: N.TsUnionType | N.TsIntersectionType = this.startNode();\n      const hasLeadingOperator = this.eat(operator);\n      const types = [];\n      do {\n        types.push(parseConstituentType());\n      } while (this.eat(operator));\n      if (types.length === 1 && !hasLeadingOperator) {\n        return types[0];\n      }\n      node.types = types;\n      return this.finishNode(node, kind);\n    }\n\n    tsParseIntersectionTypeOrHigher(): N.TsType {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSIntersectionType\",\n        this.tsParseTypeOperatorOrHigher.bind(this),\n        tt.bitwiseAND,\n      );\n    }\n\n    tsParseUnionTypeOrHigher() {\n      return this.tsParseUnionOrIntersectionType(\n        \"TSUnionType\",\n        this.tsParseIntersectionTypeOrHigher.bind(this),\n        tt.bitwiseOR,\n      );\n    }\n\n    tsIsStartOfFunctionType() {\n      if (this.match(tt.lt)) {\n        return true;\n      }\n      return (\n        this.match(tt.parenL) &&\n        this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this))\n      );\n    }\n\n    tsSkipParameterStart(): boolean {\n      if (tokenIsIdentifier(this.state.type) || this.match(tt._this)) {\n        this.next();\n        return true;\n      }\n\n      if (this.match(tt.braceL)) {\n        let braceStackCounter = 1;\n        this.next();\n\n        while (braceStackCounter > 0) {\n          if (this.match(tt.braceL)) {\n            ++braceStackCounter;\n          } else if (this.match(tt.braceR)) {\n            --braceStackCounter;\n          }\n          this.next();\n        }\n        return true;\n      }\n\n      if (this.match(tt.bracketL)) {\n        let braceStackCounter = 1;\n        this.next();\n\n        while (braceStackCounter > 0) {\n          if (this.match(tt.bracketL)) {\n            ++braceStackCounter;\n          } else if (this.match(tt.bracketR)) {\n            --braceStackCounter;\n          }\n          this.next();\n        }\n        return true;\n      }\n\n      return false;\n    }\n\n    tsIsUnambiguouslyStartOfFunctionType(): boolean {\n      this.next();\n      if (this.match(tt.parenR) || this.match(tt.ellipsis)) {\n        // ( )\n        // ( ...\n        return true;\n      }\n      if (this.tsSkipParameterStart()) {\n        if (\n          this.match(tt.colon) ||\n          this.match(tt.comma) ||\n          this.match(tt.question) ||\n          this.match(tt.eq)\n        ) {\n          // ( xxx :\n          // ( xxx ,\n          // ( xxx ?\n          // ( xxx =\n          return true;\n        }\n        if (this.match(tt.parenR)) {\n          this.next();\n          if (this.match(tt.arrow)) {\n            // ( xxx ) =>\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    tsParseTypeOrTypePredicateAnnotation(\n      returnToken: TokenType,\n    ): N.TsTypeAnnotation {\n      return this.tsInType(() => {\n        const t: N.TsTypeAnnotation = this.startNode();\n        this.expect(returnToken);\n\n        const node = this.startNode<N.TsTypePredicate>();\n\n        const asserts = !!this.tsTryParse(\n          this.tsParseTypePredicateAsserts.bind(this),\n        );\n\n        if (asserts && this.match(tt._this)) {\n          // When asserts is false, thisKeyword is handled by tsParseNonArrayType\n          // : asserts this is type\n          let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n          // if it turns out to be a `TSThisType`, wrap it with `TSTypePredicate`\n          // : asserts this\n          if (thisTypePredicate.type === \"TSThisType\") {\n            node.parameterName = (thisTypePredicate: N.TsThisType);\n            node.asserts = true;\n            (node: N.TsTypePredicate).typeAnnotation = null;\n            thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n          } else {\n            this.resetStartLocationFromNode(thisTypePredicate, node);\n            (thisTypePredicate: N.TsTypePredicate).asserts = true;\n          }\n          t.typeAnnotation = thisTypePredicate;\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        const typePredicateVariable =\n          this.tsIsIdentifier() &&\n          this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n        if (!typePredicateVariable) {\n          if (!asserts) {\n            // : type\n            return this.tsParseTypeAnnotation(/* eatColon */ false, t);\n          }\n\n          // : asserts foo\n          node.parameterName = this.parseIdentifier();\n          node.asserts = asserts;\n          (node: N.TsTypePredicate).typeAnnotation = null;\n          t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n          return this.finishNode(t, \"TSTypeAnnotation\");\n        }\n\n        // : asserts foo is type\n        const type = this.tsParseTypeAnnotation(/* eatColon */ false);\n        node.parameterName = typePredicateVariable;\n        node.typeAnnotation = type;\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      });\n    }\n\n    tsTryParseTypeOrTypePredicateAnnotation(): ?N.TsTypeAnnotation {\n      return this.match(tt.colon)\n        ? this.tsParseTypeOrTypePredicateAnnotation(tt.colon)\n        : undefined;\n    }\n\n    tsTryParseTypeAnnotation(): ?N.TsTypeAnnotation {\n      return this.match(tt.colon) ? this.tsParseTypeAnnotation() : undefined;\n    }\n\n    tsTryParseType(): ?N.TsType {\n      return this.tsEatThenParseType(tt.colon);\n    }\n\n    tsParseTypePredicatePrefix(): ?N.Identifier {\n      const id = this.parseIdentifier();\n      if (this.isContextual(tt._is) && !this.hasPrecedingLineBreak()) {\n        this.next();\n        return id;\n      }\n    }\n\n    tsParseTypePredicateAsserts(): boolean {\n      if (this.state.type !== tt._asserts) {\n        return false;\n      }\n      const containsEsc = this.state.containsEsc;\n      this.next();\n      if (!tokenIsIdentifier(this.state.type) && !this.match(tt._this)) {\n        return false;\n      }\n\n      if (containsEsc) {\n        this.raise(\n          this.state.lastTokStart,\n          Errors.InvalidEscapedReservedWord,\n          \"asserts\",\n        );\n      }\n\n      return true;\n    }\n\n    tsParseTypeAnnotation(\n      eatColon = true,\n      t: N.TsTypeAnnotation = this.startNode(),\n    ): N.TsTypeAnnotation {\n      this.tsInType(() => {\n        if (eatColon) this.expect(tt.colon);\n        t.typeAnnotation = this.tsParseType();\n      });\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    }\n\n    /** Be sure to be in a type context before calling this, using `tsInType`. */\n    tsParseType(): N.TsType {\n      // Need to set `state.inType` so that we don't parse JSX in a type context.\n      assert(this.state.inType);\n      const type = this.tsParseNonConditionalType();\n      if (this.hasPrecedingLineBreak() || !this.eat(tt._extends)) {\n        return type;\n      }\n      const node: N.TsConditionalType = this.startNodeAtNode(type);\n      node.checkType = type;\n      node.extendsType = this.tsParseNonConditionalType();\n      this.expect(tt.question);\n      node.trueType = this.tsParseType();\n      this.expect(tt.colon);\n      node.falseType = this.tsParseType();\n      return this.finishNode(node, \"TSConditionalType\");\n    }\n\n    isAbstractConstructorSignature(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._new\n      );\n    }\n\n    tsParseNonConditionalType(): N.TsType {\n      if (this.tsIsStartOfFunctionType()) {\n        return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n      }\n      if (this.match(tt._new)) {\n        // As in `new () => Date`\n        return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n      } else if (this.isAbstractConstructorSignature()) {\n        // As in `abstract new () => Date`\n        return this.tsParseFunctionOrConstructorType(\n          \"TSConstructorType\",\n          /* abstract */ true,\n        );\n      }\n      return this.tsParseUnionTypeOrHigher();\n    }\n\n    tsParseTypeAssertion(): N.TsTypeAssertion {\n      if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n        this.raise(this.state.start, TSErrors.ReservedTypeAssertion);\n      }\n\n      const node: N.TsTypeAssertion = this.startNode();\n      const _const = this.tsTryNextParseConstantContext();\n      node.typeAnnotation = _const || this.tsNextThenParseType();\n      this.expect(tt.gt);\n      node.expression = this.parseMaybeUnary();\n      return this.finishNode(node, \"TSTypeAssertion\");\n    }\n\n    tsParseHeritageClause(\n      descriptor: string,\n    ): $ReadOnlyArray<N.TsExpressionWithTypeArguments> {\n      const originalStart = this.state.start;\n\n      const delimitedList = this.tsParseDelimitedList(\n        \"HeritageClauseElement\",\n        this.tsParseExpressionWithTypeArguments.bind(this),\n      );\n\n      if (!delimitedList.length) {\n        this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);\n      }\n\n      return delimitedList;\n    }\n\n    tsParseExpressionWithTypeArguments(): N.TsExpressionWithTypeArguments {\n      const node: N.TsExpressionWithTypeArguments = this.startNode();\n      // Note: TS uses parseLeftHandSideExpressionOrHigher,\n      // then has grammar errors later if it's not an EntityName.\n      node.expression = this.tsParseEntityName(/* allowReservedWords */ false);\n      if (this.match(tt.lt)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    }\n\n    tsParseInterfaceDeclaration(\n      node: N.TsInterfaceDeclaration,\n    ): N.TsInterfaceDeclaration {\n      if (tokenIsIdentifier(this.state.type)) {\n        node.id = this.parseIdentifier();\n        this.checkLVal(\n          node.id,\n          \"typescript interface declaration\",\n          BIND_TS_INTERFACE,\n        );\n      } else {\n        node.id = null;\n        this.raise(this.state.start, TSErrors.MissingInterfaceName);\n      }\n\n      node.typeParameters = this.tsTryParseTypeParameters();\n      if (this.eat(tt._extends)) {\n        node.extends = this.tsParseHeritageClause(\"extends\");\n      }\n      const body: N.TSInterfaceBody = this.startNode();\n      body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n      node.body = this.finishNode(body, \"TSInterfaceBody\");\n      return this.finishNode(node, \"TSInterfaceDeclaration\");\n    }\n\n    tsParseTypeAliasDeclaration(\n      node: N.TsTypeAliasDeclaration,\n    ): N.TsTypeAliasDeclaration {\n      node.id = this.parseIdentifier();\n      this.checkLVal(node.id, \"typescript type alias\", BIND_TS_TYPE);\n\n      node.typeParameters = this.tsTryParseTypeParameters();\n      node.typeAnnotation = this.tsInType(() => {\n        this.expect(tt.eq);\n\n        if (\n          this.isContextual(tt._intrinsic) &&\n          this.lookahead().type !== tt.dot\n        ) {\n          const node: N.TsKeywordType = this.startNode();\n          this.next();\n          return this.finishNode(node, \"TSIntrinsicKeyword\");\n        }\n\n        return this.tsParseType();\n      });\n\n      this.semicolon();\n      return this.finishNode(node, \"TSTypeAliasDeclaration\");\n    }\n\n    tsInNoContext<T>(cb: () => T): T {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    }\n\n    /**\n     * Runs `cb` in a type context.\n     * This should be called one token *before* the first type token,\n     * so that the call to `next()` is run in type context.\n     */\n    tsInType<T>(cb: () => T): T {\n      const oldInType = this.state.inType;\n      this.state.inType = true;\n      try {\n        return cb();\n      } finally {\n        this.state.inType = oldInType;\n      }\n    }\n\n    tsEatThenParseType(token: TokenType): N.TsType | typeof undefined {\n      return !this.match(token) ? undefined : this.tsNextThenParseType();\n    }\n\n    tsExpectThenParseType(token: TokenType): N.TsType {\n      return this.tsDoThenParseType(() => this.expect(token));\n    }\n\n    tsNextThenParseType(): N.TsType {\n      return this.tsDoThenParseType(() => this.next());\n    }\n\n    tsDoThenParseType(cb: () => void): N.TsType {\n      return this.tsInType(() => {\n        cb();\n        return this.tsParseType();\n      });\n    }\n\n    tsParseEnumMember(): N.TsEnumMember {\n      const node: N.TsEnumMember = this.startNode();\n      // Computed property names are grammar errors in an enum, so accept just string literal or identifier.\n      node.id = this.match(tt.string)\n        ? this.parseExprAtom()\n        : this.parseIdentifier(/* liberal */ true);\n      if (this.eat(tt.eq)) {\n        node.initializer = this.parseMaybeAssignAllowIn();\n      }\n      return this.finishNode(node, \"TSEnumMember\");\n    }\n\n    tsParseEnumDeclaration(\n      node: N.TsEnumDeclaration,\n      isConst: boolean,\n    ): N.TsEnumDeclaration {\n      if (isConst) node.const = true;\n      node.id = this.parseIdentifier();\n      this.checkLVal(\n        node.id,\n        \"typescript enum declaration\",\n        isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM,\n      );\n\n      this.expect(tt.braceL);\n      node.members = this.tsParseDelimitedList(\n        \"EnumMembers\",\n        this.tsParseEnumMember.bind(this),\n      );\n      this.expect(tt.braceR);\n      return this.finishNode(node, \"TSEnumDeclaration\");\n    }\n\n    tsParseModuleBlock(): N.TsModuleBlock {\n      const node: N.TsModuleBlock = this.startNode();\n      this.scope.enter(SCOPE_OTHER);\n\n      this.expect(tt.braceL);\n      // Inside of a module block is considered \"top-level\", meaning it can have imports and exports.\n      this.parseBlockOrModuleBlockBody(\n        (node.body = []),\n        /* directives */ undefined,\n        /* topLevel */ true,\n        /* end */ tt.braceR,\n      );\n      this.scope.exit();\n      return this.finishNode(node, \"TSModuleBlock\");\n    }\n\n    tsParseModuleOrNamespaceDeclaration(\n      node: N.TsModuleDeclaration,\n      nested?: boolean = false,\n    ): N.TsModuleDeclaration {\n      node.id = this.parseIdentifier();\n\n      if (!nested) {\n        this.checkLVal(\n          node.id,\n          \"module or namespace declaration\",\n          BIND_TS_NAMESPACE,\n        );\n      }\n\n      if (this.eat(tt.dot)) {\n        const inner = this.startNode();\n        this.tsParseModuleOrNamespaceDeclaration(inner, true);\n        node.body = inner;\n      } else {\n        this.scope.enter(SCOPE_TS_MODULE);\n        this.prodParam.enter(PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      }\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseAmbientExternalModuleDeclaration(\n      node: N.TsModuleDeclaration,\n    ): N.TsModuleDeclaration {\n      if (this.isContextual(tt._global)) {\n        node.global = true;\n        node.id = this.parseIdentifier();\n      } else if (this.match(tt.string)) {\n        node.id = this.parseExprAtom();\n      } else {\n        this.unexpected();\n      }\n      if (this.match(tt.braceL)) {\n        this.scope.enter(SCOPE_TS_MODULE);\n        this.prodParam.enter(PARAM);\n        node.body = this.tsParseModuleBlock();\n        this.prodParam.exit();\n        this.scope.exit();\n      } else {\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"TSModuleDeclaration\");\n    }\n\n    tsParseImportEqualsDeclaration(\n      node: N.TsImportEqualsDeclaration,\n      isExport?: boolean,\n    ): N.TsImportEqualsDeclaration {\n      node.isExport = isExport || false;\n      node.id = this.parseIdentifier();\n      this.checkLVal(node.id, \"import equals declaration\", BIND_LEXICAL);\n      this.expect(tt.eq);\n      const moduleReference = this.tsParseModuleReference();\n      if (\n        node.importKind === \"type\" &&\n        moduleReference.type !== \"TSExternalModuleReference\"\n      ) {\n        this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);\n      }\n      node.moduleReference = moduleReference;\n      this.semicolon();\n      return this.finishNode(node, \"TSImportEqualsDeclaration\");\n    }\n\n    tsIsExternalModuleReference(): boolean {\n      return (\n        this.isContextual(tt._require) &&\n        this.lookaheadCharCode() === charCodes.leftParenthesis\n      );\n    }\n\n    tsParseModuleReference(): N.TsModuleReference {\n      return this.tsIsExternalModuleReference()\n        ? this.tsParseExternalModuleReference()\n        : this.tsParseEntityName(/* allowReservedWords */ false);\n    }\n\n    tsParseExternalModuleReference(): N.TsExternalModuleReference {\n      const node: N.TsExternalModuleReference = this.startNode();\n      this.expectContextual(tt._require);\n      this.expect(tt.parenL);\n      if (!this.match(tt.string)) {\n        throw this.unexpected();\n      }\n      // For compatibility to estree we cannot call parseLiteral directly here\n      node.expression = this.parseExprAtom();\n      this.expect(tt.parenR);\n      return this.finishNode(node, \"TSExternalModuleReference\");\n    }\n\n    // Utilities\n\n    tsLookAhead<T>(f: () => T): T {\n      const state = this.state.clone();\n      const res = f();\n      this.state = state;\n      return res;\n    }\n\n    tsTryParseAndCatch<T: ?N.NodeBase>(f: () => T): ?T {\n      const result = this.tryParse(abort => f() || abort());\n\n      if (result.aborted || !result.node) return undefined;\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    tsTryParse<T>(f: () => ?T): ?T {\n      const state = this.state.clone();\n      const result = f();\n      if (result !== undefined && result !== false) {\n        return result;\n      } else {\n        this.state = state;\n        return undefined;\n      }\n    }\n\n    tsTryParseDeclare(nany: any): ?N.Declaration {\n      if (this.isLineTerminator()) {\n        return;\n      }\n      let starttype = this.state.type;\n      let kind;\n\n      if (this.isContextual(tt._let)) {\n        starttype = tt._var;\n        kind = \"let\";\n      }\n\n      return this.tsInAmbientContext(() => {\n        switch (starttype) {\n          case tt._function:\n            nany.declare = true;\n            return this.parseFunctionStatement(\n              nany,\n              /* async */ false,\n              /* declarationPosition */ true,\n            );\n          case tt._class:\n            // While this is also set by tsParseExpressionStatement, we need to set it\n            // before parsing the class declaration to now how to register it in the scope.\n            nany.declare = true;\n            return this.parseClass(\n              nany,\n              /* isStatement */ true,\n              /* optionalId */ false,\n            );\n          case tt._const:\n            if (this.match(tt._const) && this.isLookaheadContextual(\"enum\")) {\n              // `const enum = 0;` not allowed because \"enum\" is a strict mode reserved word.\n              this.expect(tt._const);\n              this.expectContextual(tt._enum);\n              return this.tsParseEnumDeclaration(nany, /* isConst */ true);\n            }\n          // falls through\n          case tt._var:\n            kind = kind || this.state.value;\n            return this.parseVarStatement(nany, kind);\n          case tt._global:\n            return this.tsParseAmbientExternalModuleDeclaration(nany);\n          default: {\n            if (tokenIsIdentifier(starttype)) {\n              return this.tsParseDeclaration(\n                nany,\n                this.state.value,\n                /* next */ true,\n              );\n            }\n          }\n        }\n      });\n    }\n\n    // Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.\n    tsTryParseExportDeclaration(): ?N.Declaration {\n      return this.tsParseDeclaration(\n        this.startNode(),\n        this.state.value,\n        /* next */ true,\n      );\n    }\n\n    tsParseExpressionStatement(node: any, expr: N.Identifier): ?N.Declaration {\n      switch (expr.name) {\n        case \"declare\": {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n          break;\n        }\n        case \"global\":\n          // `global { }` (with no `declare`) may appear inside an ambient module declaration.\n          // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past \"global\".\n          if (this.match(tt.braceL)) {\n            this.scope.enter(SCOPE_TS_MODULE);\n            this.prodParam.enter(PARAM);\n            const mod: N.TsModuleDeclaration = node;\n            mod.global = true;\n            mod.id = expr;\n            mod.body = this.tsParseModuleBlock();\n            this.scope.exit();\n            this.prodParam.exit();\n            return this.finishNode(mod, \"TSModuleDeclaration\");\n          }\n          break;\n\n        default:\n          return this.tsParseDeclaration(node, expr.name, /* next */ false);\n      }\n    }\n\n    // Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.\n    tsParseDeclaration(\n      node: any,\n      value: string,\n      next: boolean,\n    ): ?N.Declaration {\n      // no declaration apart from enum can be followed by a line break.\n      switch (value) {\n        case \"abstract\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            (this.match(tt._class) || tokenIsIdentifier(this.state.type))\n          ) {\n            return this.tsParseAbstractDeclaration(node);\n          }\n          break;\n\n        case \"enum\":\n          if (next || tokenIsIdentifier(this.state.type)) {\n            if (next) this.next();\n            return this.tsParseEnumDeclaration(node, /* isConst */ false);\n          }\n          break;\n\n        case \"interface\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseInterfaceDeclaration(node);\n          }\n          break;\n\n        case \"module\":\n          if (this.tsCheckLineTerminator(next)) {\n            if (this.match(tt.string)) {\n              return this.tsParseAmbientExternalModuleDeclaration(node);\n            } else if (tokenIsIdentifier(this.state.type)) {\n              return this.tsParseModuleOrNamespaceDeclaration(node);\n            }\n          }\n          break;\n\n        case \"namespace\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n          break;\n\n        case \"type\":\n          if (\n            this.tsCheckLineTerminator(next) &&\n            tokenIsIdentifier(this.state.type)\n          ) {\n            return this.tsParseTypeAliasDeclaration(node);\n          }\n          break;\n      }\n    }\n\n    tsCheckLineTerminator(next: boolean) {\n      if (next) {\n        if (this.hasFollowingLineBreak()) return false;\n        this.next();\n        return true;\n      }\n      return !this.isLineTerminator();\n    }\n\n    tsTryParseGenericAsyncArrowFunction(\n      startPos: number,\n      startLoc: Position,\n    ): ?N.ArrowFunctionExpression {\n      if (!this.match(tt.lt)) {\n        return undefined;\n      }\n\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n      this.state.maybeInArrowParameters = true;\n\n      const res: ?N.ArrowFunctionExpression = this.tsTryParseAndCatch(() => {\n        const node: N.ArrowFunctionExpression = this.startNodeAt(\n          startPos,\n          startLoc,\n        );\n        node.typeParameters = this.tsParseTypeParameters();\n        // Don't use overloaded parseFunctionParams which would look for \"<\" again.\n        super.parseFunctionParams(node);\n        node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n        this.expect(tt.arrow);\n        return node;\n      });\n\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n      if (!res) {\n        return undefined;\n      }\n\n      return this.parseArrowExpression(\n        res,\n        /* params are already set */ null,\n        /* async */ true,\n      );\n    }\n\n    tsParseTypeArguments(): N.TsTypeParameterInstantiation {\n      const node = this.startNode();\n      node.params = this.tsInType(() =>\n        // Temporarily remove a JSX parsing context, which makes us scan different tokens.\n        this.tsInNoContext(() => {\n          this.expect(tt.lt);\n          return this.tsParseDelimitedList(\n            \"TypeParametersOrArguments\",\n            this.tsParseType.bind(this),\n          );\n        }),\n      );\n      if (node.params.length === 0) {\n        this.raise(node.start, TSErrors.EmptyTypeArguments);\n      }\n      this.expect(tt.gt);\n      return this.finishNode(node, \"TSTypeParameterInstantiation\");\n    }\n\n    tsIsDeclarationStart(): boolean {\n      return tokenIsTSDeclarationStart(this.state.type);\n    }\n\n    // ======================================================\n    // OVERRIDES\n    // ======================================================\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.tsIsDeclarationStart()) return false;\n      return super.isExportDefaultSpecifier();\n    }\n\n    parseAssignableListItem(\n      allowModifiers: ?boolean,\n      decorators: N.Decorator[],\n    ): N.Pattern | N.TSParameterProperty {\n      // Store original location/position to include modifiers in range\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n\n      let accessibility: ?N.Accessibility;\n      let readonly = false;\n      let override = false;\n      if (allowModifiers !== undefined) {\n        const modified = {};\n        this.tsParseModifiers(modified, [\n          \"public\",\n          \"private\",\n          \"protected\",\n          \"override\",\n          \"readonly\",\n        ]);\n        accessibility = modified.accessibility;\n        override = modified.override;\n        readonly = modified.readonly;\n        if (\n          allowModifiers === false &&\n          (accessibility || readonly || override)\n        ) {\n          this.raise(startPos, TSErrors.UnexpectedParameterModifier);\n        }\n      }\n\n      const left = this.parseMaybeDefault();\n      this.parseAssignableListItemTypes(left);\n      const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n      if (accessibility || readonly || override) {\n        const pp: N.TSParameterProperty = this.startNodeAt(startPos, startLoc);\n        if (decorators.length) {\n          pp.decorators = decorators;\n        }\n        if (accessibility) pp.accessibility = accessibility;\n        if (readonly) pp.readonly = readonly;\n        if (override) pp.override = override;\n        if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n          this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);\n        }\n        pp.parameter = ((elt: any): N.Identifier | N.AssignmentPattern);\n        return this.finishNode(pp, \"TSParameterProperty\");\n      }\n\n      if (decorators.length) {\n        left.decorators = decorators;\n      }\n\n      return elt;\n    }\n\n    parseFunctionBodyAndFinish(\n      node: N.BodilessFunctionOrMethodBase,\n      type: string,\n      isMethod?: boolean = false,\n    ): void {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeOrTypePredicateAnnotation(tt.colon);\n      }\n\n      const bodilessType =\n        type === \"FunctionDeclaration\"\n          ? \"TSDeclareFunction\"\n          : type === \"ClassMethod\" || type === \"ClassPrivateMethod\"\n          ? \"TSDeclareMethod\"\n          : undefined;\n      if (bodilessType && !this.match(tt.braceL) && this.isLineTerminator()) {\n        this.finishNode(node, bodilessType);\n        return;\n      }\n      if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n        this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);\n        if (\n          // $FlowIgnore\n          node.declare\n        ) {\n          super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n          return;\n        }\n      }\n\n      super.parseFunctionBodyAndFinish(node, type, isMethod);\n    }\n\n    registerFunctionStatementId(node: N.Function): void {\n      if (!node.body && node.id) {\n        // Function ids are validated after parsing their body.\n        // For bodyless function, we need to do it here.\n        this.checkLVal(node.id, \"function name\", BIND_TS_AMBIENT);\n      } else {\n        super.registerFunctionStatementId(...arguments);\n      }\n    }\n\n    tsCheckForInvalidTypeCasts(items: $ReadOnlyArray<?N.Expression>) {\n      items.forEach(node => {\n        if (node?.type === \"TSTypeCastExpression\") {\n          this.raise(\n            node.typeAnnotation.start,\n            TSErrors.UnexpectedTypeAnnotation,\n          );\n        }\n      });\n    }\n\n    toReferencedList(\n      exprList: $ReadOnlyArray<?N.Expression>,\n      isInParens?: boolean, // eslint-disable-line no-unused-vars\n    ): $ReadOnlyArray<?N.Expression> {\n      // Handles invalid scenarios like: `f(a:b)`, `(a:b);`, and `(a:b,c:d)`.\n      //\n      // Note that `f<T>(a:b)` goes through a different path and is handled\n      // in `parseSubscript` directly.\n      this.tsCheckForInvalidTypeCasts(exprList);\n      return exprList;\n    }\n\n    parseArrayLike(...args): N.ArrayExpression | N.TupleExpression {\n      const node = super.parseArrayLike(...args);\n\n      if (node.type === \"ArrayExpression\") {\n        this.tsCheckForInvalidTypeCasts(node.elements);\n      }\n\n      return node;\n    }\n\n    parseSubscript(\n      base: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      noCalls: ?boolean,\n      state: N.ParseSubscriptState,\n    ): N.Expression {\n      if (!this.hasPrecedingLineBreak() && this.match(tt.bang)) {\n        // When ! is consumed as a postfix operator (non-null assertion),\n        // disallow JSX tag forming after. e.g. When parsing `p! < n.p!`\n        // `<n.p` can not be a start of JSX tag\n        this.state.canStartJSXElement = false;\n        this.next();\n\n        const nonNullExpression: N.TsNonNullExpression = this.startNodeAt(\n          startPos,\n          startLoc,\n        );\n        nonNullExpression.expression = base;\n        return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n      }\n\n      let isOptionalCall = false;\n      if (\n        this.match(tt.questionDot) &&\n        this.lookaheadCharCode() === charCodes.lessThan\n      ) {\n        if (noCalls) {\n          state.stop = true;\n          return base;\n        }\n        state.optionalChainMember = isOptionalCall = true;\n        this.next();\n      }\n\n      if (this.match(tt.lt)) {\n        let missingParenErrorPos;\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\n        // There are number of things we are going to \"maybe\" parse, like type arguments on\n        // tagged template expressions. If any of them fail, walk it back and continue.\n        const result = this.tsTryParseAndCatch(() => {\n          if (!noCalls && this.atPossibleAsyncArrow(base)) {\n            // Almost certainly this is a generic async function `async <T>() => ...\n            // But it might be a call with a type argument `async<T>();`\n            const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(\n              startPos,\n              startLoc,\n            );\n            if (asyncArrowFn) {\n              return asyncArrowFn;\n            }\n          }\n\n          const node: N.CallExpression = this.startNodeAt(startPos, startLoc);\n          node.callee = base;\n\n          const typeArguments = this.tsParseTypeArguments();\n\n          if (typeArguments) {\n            if (isOptionalCall && !this.match(tt.parenL)) {\n              missingParenErrorPos = this.state.pos;\n              this.unexpected();\n            }\n\n            if (!noCalls && this.eat(tt.parenL)) {\n              // possibleAsync always false here, because we would have handled it above.\n              // $FlowIgnore (won't be any undefined arguments)\n              node.arguments = this.parseCallExpressionArguments(\n                tt.parenR,\n                /* possibleAsync */ false,\n              );\n\n              // Handles invalid case: `f<T>(a:b)`\n              this.tsCheckForInvalidTypeCasts(node.arguments);\n\n              node.typeParameters = typeArguments;\n              if (state.optionalChainMember) {\n                // $FlowIgnore\n                node.optional = isOptionalCall;\n              }\n\n              return this.finishCallExpression(node, state.optionalChainMember);\n            } else if (this.match(tt.backQuote)) {\n              const result = this.parseTaggedTemplateExpression(\n                base,\n                startPos,\n                startLoc,\n                state,\n              );\n              result.typeParameters = typeArguments;\n              return result;\n            }\n          }\n\n          this.unexpected();\n        });\n\n        if (missingParenErrorPos) {\n          this.unexpected(missingParenErrorPos, tt.parenL);\n        }\n\n        if (result) return result;\n      }\n\n      return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n    }\n\n    parseNewArguments(node: N.NewExpression): void {\n      if (this.match(tt.lt)) {\n        // tsTryParseAndCatch is expensive, so avoid if not necessary.\n        // 99% certain this is `new C<T>();`. But may be `new C < T;`, which is also legal.\n        const typeParameters = this.tsTryParseAndCatch(() => {\n          const args = this.tsParseTypeArguments();\n          if (!this.match(tt.parenL)) this.unexpected();\n          return args;\n        });\n        if (typeParameters) {\n          node.typeParameters = typeParameters;\n        }\n      }\n\n      super.parseNewArguments(node);\n    }\n\n    parseExprOp(\n      left: N.Expression,\n      leftStartPos: number,\n      leftStartLoc: Position,\n      minPrec: number,\n    ) {\n      if (\n        tokenOperatorPrecedence(tt._in) > minPrec &&\n        !this.hasPrecedingLineBreak() &&\n        this.isContextual(tt._as)\n      ) {\n        const node: N.TsAsExpression = this.startNodeAt(\n          leftStartPos,\n          leftStartLoc,\n        );\n        node.expression = left;\n        const _const = this.tsTryNextParseConstantContext();\n        if (_const) {\n          node.typeAnnotation = _const;\n        } else {\n          node.typeAnnotation = this.tsNextThenParseType();\n        }\n        this.finishNode(node, \"TSAsExpression\");\n        // rescan `<`, `>` because they were scanned when this.state.inType was true\n        this.reScan_lt_gt();\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n      }\n\n      return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec);\n    }\n\n    checkReservedWord(\n      word: string, // eslint-disable-line no-unused-vars\n      startLoc: number, // eslint-disable-line no-unused-vars\n      checkKeywords: boolean, // eslint-disable-line no-unused-vars\n      // eslint-disable-next-line no-unused-vars\n      isBinding: boolean,\n    ): void {\n      // Don't bother checking for TypeScript code.\n      // Strict mode words may be allowed as in `declare namespace N { const static: number; }`.\n      // And we have a type checker anyway, so don't bother having the parser do it.\n    }\n\n    /*\n    Don't bother doing this check in TypeScript code because:\n    1. We may have a nested export statement with the same name:\n      export const x = 0;\n      export namespace N {\n        export const x = 1;\n      }\n    2. We have a type checker to warn us about this sort of thing.\n    */\n    checkDuplicateExports() {}\n\n    parseImport(node: N.Node): N.AnyImport {\n      node.importKind = \"value\";\n      if (\n        tokenIsIdentifier(this.state.type) ||\n        this.match(tt.star) ||\n        this.match(tt.braceL)\n      ) {\n        let ahead = this.lookahead();\n\n        if (\n          this.isContextual(tt._type) &&\n          // import type, { a } from \"b\";\n          ahead.type !== tt.comma &&\n          // import type from \"a\";\n          ahead.type !== tt._from &&\n          // import type = require(\"a\");\n          ahead.type !== tt.eq\n        ) {\n          node.importKind = \"type\";\n          this.next();\n          ahead = this.lookahead();\n        }\n\n        if (tokenIsIdentifier(this.state.type) && ahead.type === tt.eq) {\n          return this.tsParseImportEqualsDeclaration(node);\n        }\n      }\n\n      const importNode = super.parseImport(node);\n      /*:: invariant(importNode.type !== \"TSImportEqualsDeclaration\") */\n\n      // `import type` can only be used on imports with named imports or with a\n      // default import - but not both\n      if (\n        importNode.importKind === \"type\" &&\n        importNode.specifiers.length > 1 &&\n        importNode.specifiers[0].type === \"ImportDefaultSpecifier\"\n      ) {\n        this.raise(\n          importNode.start,\n          TSErrors.TypeImportCannotSpecifyDefaultAndNamed,\n        );\n      }\n\n      return importNode;\n    }\n\n    parseExport(node: N.Node): N.AnyExport {\n      if (this.match(tt._import)) {\n        // `export import A = B;`\n        this.next(); // eat `tt._import`\n        if (\n          this.isContextual(tt._type) &&\n          this.lookaheadCharCode() !== charCodes.equalsTo\n        ) {\n          node.importKind = \"type\";\n          this.next(); // eat \"type\"\n        } else {\n          node.importKind = \"value\";\n        }\n        return this.tsParseImportEqualsDeclaration(node, /* isExport */ true);\n      } else if (this.eat(tt.eq)) {\n        // `export = x;`\n        const assign: N.TsExportAssignment = node;\n        assign.expression = this.parseExpression();\n        this.semicolon();\n        return this.finishNode(assign, \"TSExportAssignment\");\n      } else if (this.eatContextual(tt._as)) {\n        // `export as namespace A;`\n        const decl: N.TsNamespaceExportDeclaration = node;\n        // See `parseNamespaceExportDeclaration` in TypeScript's own parser\n        this.expectContextual(tt._namespace);\n        decl.id = this.parseIdentifier();\n        this.semicolon();\n        return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n      } else {\n        if (\n          this.isContextual(tt._type) &&\n          this.lookahead().type === tt.braceL\n        ) {\n          this.next();\n          node.exportKind = \"type\";\n        } else {\n          node.exportKind = \"value\";\n        }\n\n        return super.parseExport(node);\n      }\n    }\n\n    isAbstractClass(): boolean {\n      return (\n        this.isContextual(tt._abstract) && this.lookahead().type === tt._class\n      );\n    }\n\n    parseExportDefaultExpression(): N.Expression | N.Declaration {\n      if (this.isAbstractClass()) {\n        const cls = this.startNode();\n        this.next(); // Skip \"abstract\"\n        cls.abstract = true;\n        this.parseClass(cls, true, true);\n        return cls;\n      }\n\n      // export default interface allowed in:\n      // https://github.com/Microsoft/TypeScript/pull/16040\n      if (this.match(tt._interface)) {\n        const interfaceNode = this.startNode();\n        this.next();\n        const result = this.tsParseInterfaceDeclaration(interfaceNode);\n        if (result) return result;\n      }\n\n      return super.parseExportDefaultExpression();\n    }\n\n    parseStatementContent(context: ?string, topLevel: ?boolean): N.Statement {\n      if (this.state.type === tt._const) {\n        const ahead = this.lookahead();\n        if (ahead.type === tt._enum) {\n          const node: N.TsEnumDeclaration = this.startNode();\n          this.next(); // eat 'const'\n          this.expectContextual(tt._enum);\n          return this.tsParseEnumDeclaration(node, /* isConst */ true);\n        }\n      }\n      return super.parseStatementContent(context, topLevel);\n    }\n\n    parseAccessModifier(): ?N.Accessibility {\n      return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n    }\n\n    tsHasSomeModifiers(member: any, modifiers: TsModifier[]): boolean {\n      return modifiers.some(modifier => {\n        if (tsIsAccessModifier(modifier)) {\n          return member.accessibility === modifier;\n        }\n        return !!member[modifier];\n      });\n    }\n\n    tsIsStartOfStaticBlocks() {\n      return (\n        this.isContextual(tt._static) &&\n        this.lookaheadCharCode() === charCodes.leftCurlyBrace\n      );\n    }\n\n    parseClassMember(\n      classBody: N.ClassBody,\n      member: any,\n      state: N.ParseClassMemberState,\n    ): void {\n      const modifiers = [\n        \"declare\",\n        \"private\",\n        \"public\",\n        \"protected\",\n        \"override\",\n        \"abstract\",\n        \"readonly\",\n        \"static\",\n      ];\n      this.tsParseModifiers(\n        member,\n        modifiers,\n        /* disallowedModifiers */ undefined,\n        /* errorTemplate */ undefined,\n        /* stopOnStartOfClassStaticBlock */ true,\n      );\n\n      const callParseClassMemberWithIsStatic = () => {\n        if (this.tsIsStartOfStaticBlocks()) {\n          this.next(); // eat \"static\"\n          this.next(); // eat \"{\"\n          if (this.tsHasSomeModifiers(member, modifiers)) {\n            this.raise(this.state.pos, TSErrors.StaticBlockCannotHaveModifier);\n          }\n          this.parseClassStaticBlock(classBody, ((member: any): N.StaticBlock));\n        } else {\n          this.parseClassMemberWithIsStatic(\n            classBody,\n            member,\n            state,\n            !!member.static,\n          );\n        }\n      };\n      if (member.declare) {\n        this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n      } else {\n        callParseClassMemberWithIsStatic();\n      }\n    }\n\n    parseClassMemberWithIsStatic(\n      classBody: N.ClassBody,\n      member: N.ClassMember | N.TsIndexSignature,\n      state: N.ParseClassMemberState,\n      isStatic: boolean,\n    ): void {\n      const idx = this.tsTryParseIndexSignature(member);\n      if (idx) {\n        classBody.body.push(idx);\n\n        if ((member: any).abstract) {\n          this.raise(member.start, TSErrors.IndexSignatureHasAbstract);\n        }\n        if ((member: any).accessibility) {\n          this.raise(\n            member.start,\n            TSErrors.IndexSignatureHasAccessibility,\n            (member: any).accessibility,\n          );\n        }\n        if ((member: any).declare) {\n          this.raise(member.start, TSErrors.IndexSignatureHasDeclare);\n        }\n        if ((member: any).override) {\n          this.raise(member.start, TSErrors.IndexSignatureHasOverride);\n        }\n\n        return;\n      }\n\n      if (!this.state.inAbstractClass && (member: any).abstract) {\n        this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);\n      }\n\n      if ((member: any).override) {\n        if (!state.hadSuperClass) {\n          this.raise(member.start, TSErrors.OverrideNotInSubClass);\n        }\n      }\n\n      /*:: invariant(member.type !== \"TSIndexSignature\") */\n\n      super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n    }\n\n    parsePostMemberNameModifiers(\n      methodOrProp: N.ClassMethod | N.ClassProperty | N.ClassPrivateProperty,\n    ): void {\n      const optional = this.eat(tt.question);\n      if (optional) methodOrProp.optional = true;\n\n      if ((methodOrProp: any).readonly && this.match(tt.parenL)) {\n        this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);\n      }\n\n      if ((methodOrProp: any).declare && this.match(tt.parenL)) {\n        this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);\n      }\n    }\n\n    // Note: The reason we do this in `parseExpressionStatement` and not `parseStatement`\n    // is that e.g. `type()` is valid JS, so we must try parsing that first.\n    // If it's really a type, we will parse `type` as the statement, and can correct it here\n    // by parsing the rest.\n    parseExpressionStatement(\n      node: N.ExpressionStatement,\n      expr: N.Expression,\n    ): N.Statement {\n      const decl =\n        expr.type === \"Identifier\"\n          ? this.tsParseExpressionStatement(node, expr)\n          : undefined;\n      return decl || super.parseExpressionStatement(node, expr);\n    }\n\n    // export type\n    // Should be true for anything parsed by `tsTryParseExportDeclaration`.\n    shouldParseExportDeclaration(): boolean {\n      if (this.tsIsDeclarationStart()) return true;\n      return super.shouldParseExportDeclaration();\n    }\n\n    // An apparent conditional expression could actually be an optional parameter in an arrow function.\n    parseConditional(\n      expr: N.Expression,\n      startPos: number,\n      startLoc: Position,\n      refExpressionErrors?: ?ExpressionErrors,\n    ): N.Expression {\n      // only do the expensive clone if there is a question mark\n      // and if we come from inside parens\n      if (!this.state.maybeInArrowParameters || !this.match(tt.question)) {\n        return super.parseConditional(\n          expr,\n          startPos,\n          startLoc,\n          refExpressionErrors,\n        );\n      }\n\n      const result = this.tryParse(() =>\n        super.parseConditional(expr, startPos, startLoc),\n      );\n\n      if (!result.node) {\n        if (result.error) {\n          /*:: invariant(refExpressionErrors != null) */\n          super.setOptionalParametersError(refExpressionErrors, result.error);\n        }\n\n        return expr;\n      }\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    // Note: These \"type casts\" are *not* valid TS expressions.\n    // But we parse them here and change them when completing the arrow function.\n    parseParenItem(\n      node: N.Expression,\n      startPos: number,\n      startLoc: Position,\n    ): N.Expression {\n      node = super.parseParenItem(node, startPos, startLoc);\n      if (this.eat(tt.question)) {\n        node.optional = true;\n        // Include questionmark in location of node\n        // Don't use this.finishNode() as otherwise we might process comments twice and\n        // include already consumed parens\n        this.resetEndLocation(node);\n      }\n\n      if (this.match(tt.colon)) {\n        const typeCastNode: N.TsTypeCastExpression = this.startNodeAt(\n          startPos,\n          startLoc,\n        );\n        typeCastNode.expression = node;\n        typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n\n        return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n      }\n\n      return node;\n    }\n\n    parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {\n      // Store original location/position\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n\n      // \"export declare\" is equivalent to just \"export\".\n      const isDeclare = this.eatContextual(tt._declare);\n\n      if (\n        isDeclare &&\n        (this.isContextual(tt._declare) || !this.shouldParseExportDeclaration())\n      ) {\n        throw this.raise(\n          this.state.start,\n          TSErrors.ExpectedAmbientAfterExportDeclare,\n        );\n      }\n\n      let declaration: ?N.Declaration;\n\n      if (tokenIsIdentifier(this.state.type)) {\n        declaration = this.tsTryParseExportDeclaration();\n      }\n      if (!declaration) {\n        declaration = super.parseExportDeclaration(node);\n      }\n      if (\n        declaration &&\n        (declaration.type === \"TSInterfaceDeclaration\" ||\n          declaration.type === \"TSTypeAliasDeclaration\" ||\n          isDeclare)\n      ) {\n        node.exportKind = \"type\";\n      }\n\n      if (declaration && isDeclare) {\n        // Reset location to include `declare` in range\n        this.resetStartLocation(declaration, startPos, startLoc);\n\n        declaration.declare = true;\n      }\n\n      return declaration;\n    }\n\n    parseClassId(\n      node: N.Class,\n      isStatement: boolean,\n      optionalId: ?boolean,\n    ): void {\n      if ((!isStatement || optionalId) && this.isContextual(tt._implements)) {\n        return;\n      }\n\n      super.parseClassId(\n        node,\n        isStatement,\n        optionalId,\n        (node: any).declare ? BIND_TS_AMBIENT : BIND_CLASS,\n      );\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) node.typeParameters = typeParameters;\n    }\n\n    parseClassPropertyAnnotation(\n      node: N.ClassProperty | N.ClassPrivateProperty,\n    ): void {\n      if (!node.optional && this.eat(tt.bang)) {\n        node.definite = true;\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) node.typeAnnotation = type;\n    }\n\n    parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n      this.parseClassPropertyAnnotation(node);\n\n      if (this.state.isAmbientContext && this.match(tt.eq)) {\n        this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);\n      }\n      if (node.abstract && this.match(tt.eq)) {\n        const { key } = node;\n        this.raise(\n          this.state.start,\n          TSErrors.AbstractPropertyHasInitializer,\n          key.type === \"Identifier\" && !node.computed\n            ? key.name\n            : `[${this.input.slice(key.start, key.end)}]`,\n        );\n      }\n\n      return super.parseClassProperty(node);\n    }\n\n    parseClassPrivateProperty(\n      node: N.ClassPrivateProperty,\n    ): N.ClassPrivateProperty {\n      // $FlowIgnore\n      if (node.abstract) {\n        this.raise(node.start, TSErrors.PrivateElementHasAbstract);\n      }\n\n      // $FlowIgnore\n      if (node.accessibility) {\n        this.raise(\n          node.start,\n          TSErrors.PrivateElementHasAccessibility,\n          node.accessibility,\n        );\n      }\n\n      this.parseClassPropertyAnnotation(node);\n      return super.parseClassPrivateProperty(node);\n    }\n\n    pushClassMethod(\n      classBody: N.ClassBody,\n      method: N.ClassMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n      isConstructor: boolean,\n      allowsDirectSuper: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters && isConstructor) {\n        this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);\n      }\n\n      // $FlowIgnore\n      if (method.declare && (method.kind === \"get\" || method.kind === \"set\")) {\n        this.raise(method.start, TSErrors.DeclareAccessor, method.kind);\n      }\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassMethod(\n        classBody,\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    }\n\n    pushClassPrivateMethod(\n      classBody: N.ClassBody,\n      method: N.ClassPrivateMethod,\n      isGenerator: boolean,\n      isAsync: boolean,\n    ): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) method.typeParameters = typeParameters;\n      super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n    }\n\n    declareClassPrivateMethodInScope(\n      node: N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod,\n      kind: number,\n    ) {\n      if (node.type === \"TSDeclareMethod\") return;\n      // This happens when using the \"estree\" plugin.\n      if (node.type === \"MethodDefinition\" && !node.value.body) return;\n\n      super.declareClassPrivateMethodInScope(node, kind);\n    }\n\n    parseClassSuper(node: N.Class): void {\n      super.parseClassSuper(node);\n      if (node.superClass && this.match(tt.lt)) {\n        node.superTypeParameters = this.tsParseTypeArguments();\n      }\n      if (this.eatContextual(tt._implements)) {\n        node.implements = this.tsParseHeritageClause(\"implements\");\n      }\n    }\n\n    parseObjPropValue(prop: N.ObjectMember, ...args): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) prop.typeParameters = typeParameters;\n\n      super.parseObjPropValue(prop, ...args);\n    }\n\n    parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\n      const typeParameters = this.tsTryParseTypeParameters();\n      if (typeParameters) node.typeParameters = typeParameters;\n      super.parseFunctionParams(node, allowModifiers);\n    }\n\n    // `let x: number;`\n    parseVarId(\n      decl: N.VariableDeclarator,\n      kind: \"var\" | \"let\" | \"const\",\n    ): void {\n      super.parseVarId(decl, kind);\n      if (decl.id.type === \"Identifier\" && this.eat(tt.bang)) {\n        decl.definite = true;\n      }\n\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) {\n        decl.id.typeAnnotation = type;\n        this.resetEndLocation(decl.id); // set end position to end of type\n      }\n    }\n\n    // parse the return type of an async arrow function - let foo = (async (): number => {});\n    parseAsyncArrowFromCallExpression(\n      node: N.ArrowFunctionExpression,\n      call: N.CallExpression,\n    ): N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        node.returnType = this.tsParseTypeAnnotation();\n      }\n      return super.parseAsyncArrowFromCallExpression(node, call);\n    }\n\n    parseMaybeAssign(...args): N.Expression {\n      // Note: When the JSX plugin is on, type assertions (`<T> x`) aren't valid syntax.\n\n      let state: ?State;\n      let jsx;\n      let typeCast;\n\n      if (\n        this.hasPlugin(\"jsx\") &&\n        (this.match(tt.jsxTagStart) || this.match(tt.lt))\n      ) {\n        // Prefer to parse JSX if possible. But may be an arrow fn.\n        state = this.state.clone();\n\n        jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n\n        /*:: invariant(!jsx.aborted) */\n        /*:: invariant(jsx.node != null) */\n        if (!jsx.error) return jsx.node;\n\n        // Remove `tc.j_expr` and `tc.j_oTag` from context added\n        // by parsing `jsxTagStart` to stop the JSX plugin from\n        // messing with the tokens\n        const { context } = this.state;\n        if (context[context.length - 1] === ct.j_oTag) {\n          context.length -= 2;\n        } else if (context[context.length - 1] === ct.j_expr) {\n          context.length -= 1;\n        }\n      }\n\n      if (!jsx?.error && !this.match(tt.lt)) {\n        return super.parseMaybeAssign(...args);\n      }\n\n      // Either way, we're looking at a '<': tt.jsxTagStart or relational.\n\n      let typeParameters: ?N.TsTypeParameterDeclaration;\n      state = state || this.state.clone();\n\n      const arrow = this.tryParse(abort => {\n        // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.\n        typeParameters = this.tsParseTypeParameters();\n        const expr = super.parseMaybeAssign(...args);\n\n        if (\n          expr.type !== \"ArrowFunctionExpression\" ||\n          expr.extra?.parenthesized\n        ) {\n          abort();\n        }\n\n        // Correct TypeScript code should have at least 1 type parameter, but don't crash on bad code.\n        if (typeParameters?.params.length !== 0) {\n          this.resetStartLocationFromNode(expr, typeParameters);\n        }\n        expr.typeParameters = typeParameters;\n        return expr;\n      }, state);\n\n      /*:: invariant(arrow.node != null) */\n      if (!arrow.error && !arrow.aborted) {\n        // This error is reported outside of the this.tryParse call so that\n        // in case of <T>(x) => 2, we don't consider <T>(x) as a type assertion\n        // because of this error.\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        return arrow.node;\n      }\n\n      if (!jsx) {\n        // Try parsing a type cast instead of an arrow function.\n        // This will never happen outside of JSX.\n        // (Because in JSX the '<' should be a jsxTagStart and not a relational.\n        assert(!this.hasPlugin(\"jsx\"));\n\n        // This will start with a type assertion (via parseMaybeUnary).\n        // But don't directly call `this.tsParseTypeAssertion` because we want to handle any binary after it.\n        typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n        /*:: invariant(!typeCast.aborted) */\n        /*:: invariant(typeCast.node != null) */\n        if (!typeCast.error) return typeCast.node;\n      }\n\n      if (jsx?.node) {\n        /*:: invariant(jsx.failState) */\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrow.node) {\n        /*:: invariant(arrow.failState) */\n        this.state = arrow.failState;\n        if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n        return arrow.node;\n      }\n\n      if (typeCast?.node) {\n        /*:: invariant(typeCast.failState) */\n        this.state = typeCast.failState;\n        return typeCast.node;\n      }\n\n      if (jsx?.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      if (typeCast?.thrown) throw typeCast.error;\n\n      throw jsx?.error || arrow.error || typeCast?.error;\n    }\n\n    reportReservedArrowTypeParam(node: any) {\n      if (\n        node.params.length === 1 &&\n        !node.extra?.trailingComma &&\n        this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")\n      ) {\n        this.raise(node.start, TSErrors.ReservedArrowTypeParam);\n      }\n    }\n\n    // Handle type assertions\n    parseMaybeUnary(refExpressionErrors?: ?ExpressionErrors): N.Expression {\n      if (!this.hasPlugin(\"jsx\") && this.match(tt.lt)) {\n        return this.tsParseTypeAssertion();\n      } else {\n        return super.parseMaybeUnary(refExpressionErrors);\n      }\n    }\n\n    parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {\n      if (this.match(tt.colon)) {\n        // This is different from how the TS parser does it.\n        // TS uses lookahead. The Babel Parser parses it as a parenthesized expression and converts.\n\n        const result = this.tryParse(abort => {\n          const returnType = this.tsParseTypeOrTypePredicateAnnotation(\n            tt.colon,\n          );\n          if (this.canInsertSemicolon() || !this.match(tt.arrow)) abort();\n          return returnType;\n        });\n\n        if (result.aborted) return;\n\n        if (!result.thrown) {\n          if (result.error) this.state = result.failState;\n          node.returnType = result.node;\n        }\n      }\n\n      return super.parseArrow(node);\n    }\n\n    // Allow type annotations inside of a parameter list.\n    parseAssignableListItemTypes(param: N.Pattern) {\n      if (this.eat(tt.question)) {\n        if (\n          param.type !== \"Identifier\" &&\n          !this.state.isAmbientContext &&\n          !this.state.inType\n        ) {\n          this.raise(param.start, TSErrors.PatternIsOptional);\n        }\n\n        ((param: any): N.Identifier).optional = true;\n      }\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) param.typeAnnotation = type;\n      this.resetEndLocation(param);\n\n      return param;\n    }\n\n    isAssignable(node: N.Node, isBinding?: boolean): boolean {\n      switch (node.type) {\n        case \"TSTypeCastExpression\":\n          return this.isAssignable(node.expression, isBinding);\n        case \"TSParameterProperty\":\n          return true;\n        default:\n          return super.isAssignable(node, isBinding);\n      }\n    }\n\n    toAssignable(node: N.Node, isLHS: boolean = false): N.Node {\n      switch (node.type) {\n        case \"TSTypeCastExpression\":\n          return super.toAssignable(this.typeCastToParameter(node), isLHS);\n        case \"TSParameterProperty\":\n          return super.toAssignable(node, isLHS);\n        case \"ParenthesizedExpression\":\n          return this.toAssignableParenthesizedExpression(node, isLHS);\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n          node.expression = this.toAssignable(node.expression, isLHS);\n          return node;\n        default:\n          return super.toAssignable(node, isLHS);\n      }\n    }\n\n    toAssignableParenthesizedExpression(node: N.Node, isLHS: boolean) {\n      switch (node.expression.type) {\n        case \"TSAsExpression\":\n        case \"TSNonNullExpression\":\n        case \"TSTypeAssertion\":\n        case \"ParenthesizedExpression\":\n          node.expression = this.toAssignable(node.expression, isLHS);\n          return node;\n        default:\n          return super.toAssignable(node, isLHS);\n      }\n    }\n\n    checkLVal(\n      expr: N.Expression,\n      contextDescription: string,\n      ...args:\n        | [BindingTypes | void]\n        | [BindingTypes | void, ?Set<string>, boolean | void, boolean | void]\n    ): void {\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          // Allow \"typecasts\" to appear on the left of assignment expressions,\n          // because it may be in an arrow function.\n          // e.g. `const f = (foo: number = 0) => foo;`\n          return;\n        case \"TSParameterProperty\":\n          this.checkLVal(expr.parameter, \"parameter property\", ...args);\n          return;\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n          if (\n            /*bindingType*/ !args[0] &&\n            contextDescription !== \"parenthesized expression\" &&\n            !expr.extra?.parenthesized\n          ) {\n            this.raise(expr.start, Errors.InvalidLhs, contextDescription);\n            break;\n          }\n          this.checkLVal(expr.expression, \"parenthesized expression\", ...args);\n          return;\n        case \"TSNonNullExpression\":\n          this.checkLVal(expr.expression, contextDescription, ...args);\n          return;\n        default:\n          super.checkLVal(expr, contextDescription, ...args);\n          return;\n      }\n    }\n\n    parseBindingAtom(): N.Pattern {\n      switch (this.state.type) {\n        case tt._this:\n          // \"this\" may be the name of a parameter, so allow it.\n          return this.parseIdentifier(/* liberal */ true);\n        default:\n          return super.parseBindingAtom();\n      }\n    }\n\n    parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {\n      if (this.match(tt.lt)) {\n        const typeArguments = this.tsParseTypeArguments();\n\n        if (this.match(tt.parenL)) {\n          const call = super.parseMaybeDecoratorArguments(expr);\n          call.typeParameters = typeArguments;\n          return call;\n        }\n\n        this.unexpected(this.state.start, tt.parenL);\n      }\n\n      return super.parseMaybeDecoratorArguments(expr);\n    }\n\n    checkCommaAfterRest(close) {\n      if (\n        this.state.isAmbientContext &&\n        this.match(tt.comma) &&\n        this.lookaheadCharCode() === close\n      ) {\n        this.next();\n      } else {\n        super.checkCommaAfterRest(close);\n      }\n    }\n\n    // === === === === === === === === === === === === === === === ===\n    // Note: All below methods are duplicates of something in flow.js.\n    // Not sure what the best way to combine these is.\n    // === === === === === === === === === === === === === === === ===\n\n    isClassMethod(): boolean {\n      return this.match(tt.lt) || super.isClassMethod();\n    }\n\n    isClassProperty(): boolean {\n      return (\n        this.match(tt.bang) || this.match(tt.colon) || super.isClassProperty()\n      );\n    }\n\n    parseMaybeDefault(...args): N.Pattern {\n      const node = super.parseMaybeDefault(...args);\n\n      if (\n        node.type === \"AssignmentPattern\" &&\n        node.typeAnnotation &&\n        node.right.start < node.typeAnnotation.start\n      ) {\n        this.raise(\n          node.typeAnnotation.start,\n          TSErrors.TypeAnnotationAfterAssign,\n        );\n      }\n\n      return node;\n    }\n\n    // ensure that inside types, we bypass the jsx parser plugin\n    getTokenFromCode(code: number): void {\n      if (this.state.inType) {\n        if (code === charCodes.greaterThan) {\n          return this.finishOp(tt.gt, 1);\n        }\n        if (code === charCodes.lessThan) {\n          return this.finishOp(tt.lt, 1);\n        }\n      }\n      return super.getTokenFromCode(code);\n    }\n\n    // used after we have finished parsing types\n    reScan_lt_gt() {\n      const { type } = this.state;\n      if (type === tt.lt) {\n        this.state.pos -= 1;\n        this.readToken_lt();\n      } else if (type === tt.gt) {\n        this.state.pos -= 1;\n        this.readToken_gt();\n      }\n    }\n\n    toAssignableList(exprList: N.Expression[]): $ReadOnlyArray<N.Pattern> {\n      for (let i = 0; i < exprList.length; i++) {\n        const expr = exprList[i];\n        if (!expr) continue;\n        switch (expr.type) {\n          case \"TSTypeCastExpression\":\n            exprList[i] = this.typeCastToParameter(expr);\n            break;\n          case \"TSAsExpression\":\n          case \"TSTypeAssertion\":\n            if (!this.state.maybeInArrowParameters) {\n              exprList[i] = this.typeCastToParameter(expr);\n            } else {\n              this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);\n            }\n            break;\n        }\n      }\n      return super.toAssignableList(...arguments);\n    }\n\n    typeCastToParameter(node: N.TsTypeCastExpression): N.Node {\n      node.expression.typeAnnotation = node.typeAnnotation;\n\n      this.resetEndLocation(\n        node.expression,\n        node.typeAnnotation.end,\n        node.typeAnnotation.loc.end,\n      );\n\n      return node.expression;\n    }\n\n    shouldParseArrow(params: Array<N.Node>) {\n      if (this.match(tt.colon)) {\n        return params.every(expr => this.isAssignable(expr, true));\n      }\n      return super.shouldParseArrow(params);\n    }\n\n    shouldParseAsyncArrow(): boolean {\n      return this.match(tt.colon) || super.shouldParseAsyncArrow();\n    }\n\n    canHaveLeadingDecorator() {\n      // Avoid unnecessary lookahead in checking for abstract class unless needed!\n      return super.canHaveLeadingDecorator() || this.isAbstractClass();\n    }\n\n    jsxParseOpeningElementAfterName(\n      node: N.JSXOpeningElement,\n    ): N.JSXOpeningElement {\n      if (this.match(tt.lt)) {\n        const typeArguments = this.tsTryParseAndCatch(() =>\n          this.tsParseTypeArguments(),\n        );\n        if (typeArguments) node.typeParameters = typeArguments;\n      }\n      return super.jsxParseOpeningElementAfterName(node);\n    }\n\n    getGetterSetterExpectedParamCount(\n      method: N.ObjectMethod | N.ClassMethod,\n    ): number {\n      const baseCount = super.getGetterSetterExpectedParamCount(method);\n      const params = this.getObjectOrClassMethodParams(method);\n      const firstParam = params[0];\n      const hasContextParam = firstParam && this.isThisParam(firstParam);\n\n      return hasContextParam ? baseCount + 1 : baseCount;\n    }\n\n    parseCatchClauseParam(): N.Pattern {\n      const param = super.parseCatchClauseParam();\n      const type = this.tsTryParseTypeAnnotation();\n\n      if (type) {\n        param.typeAnnotation = type;\n        this.resetEndLocation(param);\n      }\n\n      return param;\n    }\n\n    tsInAmbientContext<T>(cb: () => T): T {\n      const oldIsAmbientContext = this.state.isAmbientContext;\n      this.state.isAmbientContext = true;\n      try {\n        return cb();\n      } finally {\n        this.state.isAmbientContext = oldIsAmbientContext;\n      }\n    }\n\n    parseClass<T: N.Class>(node: T, ...args: any[]): T {\n      const oldInAbstractClass = this.state.inAbstractClass;\n      this.state.inAbstractClass = !!(node: any).abstract;\n      try {\n        return super.parseClass(node, ...args);\n      } finally {\n        this.state.inAbstractClass = oldInAbstractClass;\n      }\n    }\n\n    tsParseAbstractDeclaration(\n      node: any,\n    ): N.ClassDeclaration | N.TsInterfaceDeclaration | typeof undefined {\n      if (this.match(tt._class)) {\n        node.abstract = true;\n        return this.parseClass<N.ClassDeclaration>(\n          (node: N.ClassDeclaration),\n          /* isStatement */ true,\n          /* optionalId */ false,\n        );\n      } else if (this.isContextual(tt._interface)) {\n        // for invalid abstract interface\n\n        // To avoid\n        //   abstract interface\n        //   Foo {}\n        if (!this.hasFollowingLineBreak()) {\n          node.abstract = true;\n          this.raise(\n            node.start,\n            TSErrors.NonClassMethodPropertyHasAbstractModifer,\n          );\n          this.next();\n          return this.tsParseInterfaceDeclaration(\n            (node: N.TsInterfaceDeclaration),\n          );\n        }\n      } else {\n        this.unexpected(null, tt._class);\n      }\n    }\n\n    parseMethod(...args: any[]) {\n      const method = super.parseMethod(...args);\n      if (method.abstract) {\n        const hasBody = this.hasPlugin(\"estree\")\n          ? !!method.value.body\n          : !!method.body;\n        if (hasBody) {\n          const { key } = method;\n          this.raise(\n            method.start,\n            TSErrors.AbstractMethodHasImplementation,\n            key.type === \"Identifier\" && !method.computed\n              ? key.name\n              : `[${this.input.slice(key.start, key.end)}]`,\n          );\n        }\n      }\n      return method;\n    }\n\n    tsParseTypeParameterName(): N.Identifier | string {\n      const typeName: N.Identifier = this.parseIdentifier();\n      return process.env.BABEL_8_BREAKING ? typeName : typeName.name;\n    }\n\n    shouldParseAsAmbientContext(): boolean {\n      return !!this.getPluginOption(\"typescript\", \"dts\");\n    }\n\n    parse() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.parse();\n    }\n\n    getExpression() {\n      if (this.shouldParseAsAmbientContext()) {\n        this.state.isAmbientContext = true;\n      }\n      return super.getExpression();\n    }\n\n    parseExportSpecifier(\n      node: any,\n      isString: boolean,\n      isInTypeExport: boolean,\n      isMaybeTypeOnly: boolean,\n    ) {\n      if (!isString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          node,\n          /* isImport */ false,\n          isInTypeExport,\n        );\n        return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n      }\n      node.exportKind = \"value\";\n      return super.parseExportSpecifier(\n        node,\n        isString,\n        isInTypeExport,\n        isMaybeTypeOnly,\n      );\n    }\n\n    parseImportSpecifier(\n      specifier: any,\n      importedIsString: boolean,\n      isInTypeOnlyImport: boolean,\n      isMaybeTypeOnly: boolean,\n    ): N.ImportSpecifier {\n      if (!importedIsString && isMaybeTypeOnly) {\n        this.parseTypeOnlyImportExportSpecifier(\n          specifier,\n          /* isImport */ true,\n          isInTypeOnlyImport,\n        );\n        return this.finishNode<N.ImportSpecifier>(specifier, \"ImportSpecifier\");\n      }\n      specifier.importKind = \"value\";\n      return super.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        isInTypeOnlyImport,\n        isMaybeTypeOnly,\n      );\n    }\n\n    parseTypeOnlyImportExportSpecifier(\n      node: any,\n      isImport: boolean,\n      isInTypeOnlyImportExport: boolean,\n    ): void {\n      const leftOfAsKey = isImport ? \"imported\" : \"local\";\n      const rightOfAsKey = isImport ? \"local\" : \"exported\";\n\n      let leftOfAs = node[leftOfAsKey];\n      let rightOfAs;\n\n      let hasTypeSpecifier = false;\n      let canParseAsKeyword = true;\n\n      const pos = leftOfAs.start;\n\n      // https://github.com/microsoft/TypeScript/blob/fc4f9d83d5939047aa6bb2a43965c6e9bbfbc35b/src/compiler/parser.ts#L7411-L7456\n      // import { type } from \"mod\";          - hasTypeSpecifier: false, leftOfAs: type\n      // import { type as } from \"mod\";       - hasTypeSpecifier: true,  leftOfAs: as\n      // import { type as as } from \"mod\";    - hasTypeSpecifier: false, leftOfAs: type, rightOfAs: as\n      // import { type as as as } from \"mod\"; - hasTypeSpecifier: true,  leftOfAs: as,   rightOfAs: as\n      if (this.isContextual(tt._as)) {\n        // { type as ...? }\n        const firstAs = this.parseIdentifier();\n        if (this.isContextual(tt._as)) {\n          // { type as as ...? }\n          const secondAs = this.parseIdentifier();\n          if (tokenIsKeywordOrIdentifier(this.state.type)) {\n            // { type as as something }\n            hasTypeSpecifier = true;\n            leftOfAs = firstAs;\n            rightOfAs = this.parseIdentifier();\n            canParseAsKeyword = false;\n          } else {\n            // { type as as }\n            rightOfAs = secondAs;\n            canParseAsKeyword = false;\n          }\n        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          // { type as something }\n          canParseAsKeyword = false;\n          rightOfAs = this.parseIdentifier();\n        } else {\n          // { type as }\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        // { type something ...? }\n        hasTypeSpecifier = true;\n        leftOfAs = this.parseIdentifier();\n      }\n      if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n        this.raise(\n          pos,\n          isImport\n            ? TSErrors.TypeModifierIsUsedInTypeImports\n            : TSErrors.TypeModifierIsUsedInTypeExports,\n        );\n      }\n\n      node[leftOfAsKey] = leftOfAs;\n      node[rightOfAsKey] = rightOfAs;\n\n      const kindKey = isImport ? \"importKind\" : \"exportKind\";\n      node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n\n      if (canParseAsKeyword && this.eatContextual(tt._as)) {\n        node[rightOfAsKey] = isImport\n          ? this.parseIdentifier()\n          : this.parseModuleExportName();\n      }\n      if (!node[rightOfAsKey]) {\n        node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n      }\n      if (isImport) {\n        this.checkLVal(node[rightOfAsKey], \"import specifier\", BIND_LEXICAL);\n      }\n    }\n  };\n", "// @flow\n\nimport * as charCodes from \"charcodes\";\n\nimport { tokenLabelName, tt } from \"../tokenizer/types\";\nimport type Parser from \"../parser\";\nimport * as N from \"../types\";\nimport { makeErrorTemplates, ErrorCodes } from \"../parser/error\";\n\nexport type PlaceholderTypes =\n  | \"Identifier\"\n  | \"StringLiteral\"\n  | \"Expression\"\n  | \"Statement\"\n  | \"Declaration\"\n  | \"BlockStatement\"\n  | \"ClassBody\"\n  | \"Pattern\";\n\n// $PropertyType doesn't support enums. Use a fake \"switch\" (GetPlaceholderNode)\n//type MaybePlaceholder<T: PlaceholderTypes> = $PropertyType<N, T> | N.Placeholder<T>;\n\ntype _Switch<Value, Cases, Index> = $Call<\n  (\n    $ElementType<$ElementType<Cases, Index>, 0>,\n  ) => $ElementType<$ElementType<Cases, Index>, 1>,\n  Value,\n>;\ntype $Switch<Value, Cases> = _Switch<Value, Cases, *>;\n\ntype NodeOf<T: PlaceholderTypes> = $Switch<\n  T,\n  [\n    [\"Identifier\", N.Identifier],\n    [\"StringLiteral\", N.StringLiteral],\n    [\"Expression\", N.Expression],\n    [\"Statement\", N.Statement],\n    [\"Declaration\", N.Declaration],\n    [\"BlockStatement\", N.BlockStatement],\n    [\"ClassBody\", N.ClassBody],\n    [\"Pattern\", N.Pattern],\n  ],\n>;\n\n// Placeholder<T> breaks everything, because its type is incompatible with\n// the substituted nodes.\ntype MaybePlaceholder<T: PlaceholderTypes> = NodeOf<T>; // | Placeholder<T>\n\nconst PlaceHolderErrors = makeErrorTemplates(\n  {\n    ClassNameIsRequired: \"A class name is required.\",\n  },\n  /* code */ ErrorCodes.SyntaxError,\n);\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    parsePlaceholder<T: PlaceholderTypes>(\n      expectedNode: T,\n    ): /*?N.Placeholder<T>*/ ?MaybePlaceholder<T> {\n      if (this.match(tt.placeholder)) {\n        const node = this.startNode();\n        this.next();\n        this.assertNoSpace(\"Unexpected space in placeholder.\");\n\n        // We can't use this.parseIdentifier because\n        // we don't want nested placeholders.\n        node.name = super.parseIdentifier(/* liberal */ true);\n\n        this.assertNoSpace(\"Unexpected space in placeholder.\");\n        this.expect(tt.placeholder);\n        return this.finishPlaceholder(node, expectedNode);\n      }\n    }\n\n    finishPlaceholder<T: PlaceholderTypes>(\n      node: N.Node,\n      expectedNode: T,\n    ): /*N.Placeholder<T>*/ MaybePlaceholder<T> {\n      const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n      node.expectedNode = expectedNode;\n\n      return isFinished ? node : this.finishNode(node, \"Placeholder\");\n    }\n\n    /* ============================================================ *\n     * tokenizer/index.js                                           *\n     * ============================================================ */\n\n    getTokenFromCode(code: number) {\n      if (\n        code === charCodes.percentSign &&\n        this.input.charCodeAt(this.state.pos + 1) === charCodes.percentSign\n      ) {\n        return this.finishOp(tt.placeholder, 2);\n      }\n\n      return super.getTokenFromCode(...arguments);\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(): MaybePlaceholder<\"Expression\"> {\n      return (\n        this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments)\n      );\n    }\n\n    parseIdentifier(): MaybePlaceholder<\"Identifier\"> {\n      // NOTE: This function only handles identifiers outside of\n      // expressions and binding patterns, since they are already\n      // handled by the parseExprAtom and parseBindingAtom functions.\n      // This is needed, for example, to parse \"class %%NAME%% {}\".\n      return (\n        this.parsePlaceholder(\"Identifier\") ||\n        super.parseIdentifier(...arguments)\n      );\n    }\n\n    checkReservedWord(word: string): void {\n      // Sometimes we call #checkReservedWord(node.name), expecting\n      // that node is an Identifier. If it is a Placeholder, name\n      // will be undefined.\n      if (word !== undefined) super.checkReservedWord(...arguments);\n    }\n\n    /* ============================================================ *\n     * parser/lval.js                                               *\n     * ============================================================ */\n\n    parseBindingAtom(): MaybePlaceholder<\"Pattern\"> {\n      return (\n        this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments)\n      );\n    }\n\n    checkLVal(expr: N.Expression): void {\n      if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\n    }\n\n    toAssignable(node: N.Node): N.Node {\n      if (\n        node &&\n        node.type === \"Placeholder\" &&\n        node.expectedNode === \"Expression\"\n      ) {\n        node.expectedNode = \"Pattern\";\n        return node;\n      }\n      return super.toAssignable(...arguments);\n    }\n\n    /* ============================================================ *\n     * parser/statement.js                                          *\n     * ============================================================ */\n\n    isLet(context: ?string): boolean {\n      if (super.isLet(context)) {\n        return true;\n      }\n\n      // Replicate the original checks that lead to looking ahead for an\n      // identifier.\n      if (!this.isContextual(tt._let)) {\n        return false;\n      }\n      if (context) return false;\n\n      // Accept \"let %%\" as the start of \"let %%placeholder%%\", as though the\n      // placeholder were an identifier.\n      const nextToken = this.lookahead();\n      if (nextToken.type === tt.placeholder) {\n        return true;\n      }\n\n      return false;\n    }\n\n    verifyBreakContinue(node: N.BreakStatement | N.ContinueStatement) {\n      if (node.label && node.label.type === \"Placeholder\") return;\n      super.verifyBreakContinue(...arguments);\n    }\n\n    parseExpressionStatement(\n      node: MaybePlaceholder<\"Statement\">,\n      expr: N.Expression,\n    ): MaybePlaceholder<\"Statement\"> {\n      if (\n        expr.type !== \"Placeholder\" ||\n        (expr.extra && expr.extra.parenthesized)\n      ) {\n        return super.parseExpressionStatement(...arguments);\n      }\n\n      if (this.match(tt.colon)) {\n        const stmt: N.LabeledStatement = node;\n        stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n        this.next();\n        stmt.body = this.parseStatement(\"label\");\n        return this.finishNode(stmt, \"LabeledStatement\");\n      }\n\n      this.semicolon();\n\n      node.name = expr.name;\n      return this.finishPlaceholder(node, \"Statement\");\n    }\n\n    parseBlock(): MaybePlaceholder<\"BlockStatement\"> {\n      return (\n        this.parsePlaceholder(\"BlockStatement\") ||\n        super.parseBlock(...arguments)\n      );\n    }\n\n    parseFunctionId(): ?MaybePlaceholder<\"Identifier\"> {\n      return (\n        this.parsePlaceholder(\"Identifier\") ||\n        super.parseFunctionId(...arguments)\n      );\n    }\n\n    parseClass<T: N.Class>(\n      node: T,\n      isStatement: /* T === ClassDeclaration */ boolean,\n      optionalId?: boolean,\n    ): T {\n      const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n\n      this.next();\n      this.takeDecorators(node);\n      const oldStrict = this.state.strict;\n\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (placeholder) {\n        if (\n          this.match(tt._extends) ||\n          this.match(tt.placeholder) ||\n          this.match(tt.braceL)\n        ) {\n          node.id = placeholder;\n        } else if (optionalId || !isStatement) {\n          node.id = null;\n          node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n          return this.finishNode(node, type);\n        } else {\n          this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);\n        }\n      } else {\n        this.parseClassId(node, isStatement, optionalId);\n      }\n\n      this.parseClassSuper(node);\n      node.body =\n        this.parsePlaceholder(\"ClassBody\") ||\n        this.parseClassBody(!!node.superClass, oldStrict);\n      return this.finishNode(node, type);\n    }\n\n    parseExport(node: N.Node): N.Node {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseExport(...arguments);\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // export %%DECL%%;\n        node.specifiers = [];\n        node.source = null;\n        node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n        return this.finishNode(node, \"ExportNamedDeclaration\");\n      }\n\n      // export %%NAME%% from \"foo\";\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = placeholder;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n\n      return super.parseExport(node);\n    }\n\n    isExportDefaultSpecifier(): boolean {\n      if (this.match(tt._default)) {\n        const next = this.nextTokenStart();\n        if (this.isUnparsedContextual(next, \"from\")) {\n          if (\n            this.input.startsWith(\n              tokenLabelName(tt.placeholder),\n              this.nextTokenStartSince(next + 4),\n            )\n          ) {\n            return true;\n          }\n        }\n      }\n      return super.isExportDefaultSpecifier();\n    }\n\n    maybeParseExportDefaultSpecifier(node: N.Node): boolean {\n      if (node.specifiers && node.specifiers.length > 0) {\n        // \"export %%NAME%%\" has already been parsed by #parseExport.\n        return true;\n      }\n      return super.maybeParseExportDefaultSpecifier(...arguments);\n    }\n\n    checkExport(node: N.ExportNamedDeclaration): void {\n      const { specifiers } = node;\n      if (specifiers?.length) {\n        node.specifiers = specifiers.filter(\n          node => node.exported.type === \"Placeholder\",\n        );\n      }\n      super.checkExport(node);\n      node.specifiers = specifiers;\n    }\n\n    parseImport(\n      node: N.Node,\n    ): N.ImportDeclaration | N.TsImportEqualsDeclaration {\n      const placeholder = this.parsePlaceholder(\"Identifier\");\n      if (!placeholder) return super.parseImport(...arguments);\n\n      node.specifiers = [];\n\n      if (!this.isContextual(tt._from) && !this.match(tt.comma)) {\n        // import %%STRING%%;\n        node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n        this.semicolon();\n        return this.finishNode(node, \"ImportDeclaration\");\n      }\n\n      // import %%DEFAULT%% ...\n      const specifier = this.startNodeAtNode(placeholder);\n      specifier.local = placeholder;\n      this.finishNode(specifier, \"ImportDefaultSpecifier\");\n      node.specifiers.push(specifier);\n\n      if (this.eat(tt.comma)) {\n        // import %%DEFAULT%%, * as ...\n        const hasStarImport = this.maybeParseStarImportSpecifier(node);\n\n        // import %%DEFAULT%%, { ...\n        if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n      }\n\n      this.expectContextual(tt._from);\n      node.source = this.parseImportSource();\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportSource(): MaybePlaceholder<\"StringLiteral\"> {\n      // import ... from %%STRING%%;\n\n      return (\n        this.parsePlaceholder(\"StringLiteral\") ||\n        super.parseImportSource(...arguments)\n      );\n    }\n  };\n", "import type Parser from \"../parser\";\nimport { tokenIsIdentifier, tt } from \"../tokenizer/types\";\nimport * as N from \"../types\";\n\nexport default (superClass: Class<Parser>): Class<Parser> =>\n  class extends superClass {\n    parseV8Intrinsic(): N.Expression {\n      if (this.match(tt.modulo)) {\n        const v8IntrinsicStart = this.state.start;\n        // let the `loc` of Identifier starts from `%`\n        const node = this.startNode();\n        this.next(); // eat '%'\n        if (tokenIsIdentifier(this.state.type)) {\n          const name = this.parseIdentifierName(this.state.start);\n          const identifier = this.createIdentifier(node, name);\n          identifier.type = \"V8IntrinsicIdentifier\";\n          if (this.match(tt.parenL)) {\n            return identifier;\n          }\n        }\n        this.unexpected(v8IntrinsicStart);\n      }\n    }\n\n    /* ============================================================ *\n     * parser/expression.js                                         *\n     * ============================================================ */\n\n    parseExprAtom(): N.Expression {\n      return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n    }\n  };\n", "// @flow\n\nimport type Parser from \"./parser\";\n\nexport type Plugin = string | [string, Object];\n\nexport type PluginList = $ReadOnlyArray<Plugin>;\n\nexport type MixinPlugin = (superClass: Class<Parser>) => Class<Parser>;\n\nexport function hasPlugin(plugins: PluginList, name: string): boolean {\n  return plugins.some(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n}\n\nexport function getPluginOption(\n  plugins: PluginList,\n  name: string,\n  option: string,\n) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\n\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^\", \"%\", \"#\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\n\nexport function validatePlugins(plugins: PluginList) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\n        \"Cannot use the decorators and decorators-legacy plugin together\",\n      );\n    }\n\n    const decoratorsBeforeExport = getPluginOption(\n      plugins,\n      \"decorators\",\n      \"decoratorsBeforeExport\",\n    );\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\n        \"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" +\n          \" whose value must be a boolean. If you are migrating from\" +\n          \" Babylon/Babel 6 or want to use the old decorators proposal, you\" +\n          \" should use the 'decorators-legacy' plugin instead of 'decorators'.\",\n      );\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\")) {\n    const proposal = getPluginOption(plugins, \"pipelineOperator\", \"proposal\");\n\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(\n        `\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`,\n      );\n    }\n\n    const tupleSyntaxIsHash =\n      hasPlugin(plugins, \"recordAndTuple\") &&\n      getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\") === \"hash\";\n\n    if (proposal === \"hack\") {\n      if (hasPlugin(plugins, \"placeholders\")) {\n        throw new Error(\n          \"Cannot combine placeholders plugin and Hack-style pipes.\",\n        );\n      }\n\n      if (hasPlugin(plugins, \"v8intrinsic\")) {\n        throw new Error(\n          \"Cannot combine v8intrinsic plugin and Hack-style pipes.\",\n        );\n      }\n\n      const topicToken = getPluginOption(\n        plugins,\n        \"pipelineOperator\",\n        \"topicToken\",\n      );\n\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n\n        throw new Error(\n          `\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`,\n        );\n      }\n\n      if (topicToken === \"#\" && tupleSyntaxIsHash) {\n        throw new Error(\n          'Plugin conflict between `[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.',\n        );\n      }\n    } else if (proposal === \"smart\" && tupleSyntaxIsHash) {\n      throw new Error(\n        'Plugin conflict between `[\"pipelineOperator\", { proposal: \"smart\" }]` and `[\"recordAndtuple\", { syntaxType: \"hash\"}]`.',\n      );\n    }\n  }\n\n  if (hasPlugin(plugins, \"moduleAttributes\")) {\n    if (process.env.BABEL_8_BREAKING) {\n      throw new Error(\n        \"`moduleAttributes` has been removed in Babel 8, please use `importAssertions` parser plugin, or `@babel/plugin-syntax-import-assertions`.\",\n      );\n    } else {\n      if (hasPlugin(plugins, \"importAssertions\")) {\n        throw new Error(\n          \"Cannot combine importAssertions and moduleAttributes plugins.\",\n        );\n      }\n      const moduleAttributesVerionPluginOption = getPluginOption(\n        plugins,\n        \"moduleAttributes\",\n        \"version\",\n      );\n      if (moduleAttributesVerionPluginOption !== \"may-2020\") {\n        throw new Error(\n          \"The 'moduleAttributes' plugin requires a 'version' option,\" +\n            \" representing the last proposal update. Currently, the\" +\n            \" only supported value is 'may-2020'.\",\n        );\n      }\n    }\n  }\n\n  if (\n    hasPlugin(plugins, \"recordAndTuple\") &&\n    !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(\n      getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"),\n    )\n  ) {\n    throw new Error(\n      \"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" +\n        RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"),\n    );\n  }\n\n  if (\n    hasPlugin(plugins, \"asyncDoExpressions\") &&\n    !hasPlugin(plugins, \"doExpressions\")\n  ) {\n    const error = new Error(\n      \"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\",\n    );\n    // $FlowIgnore\n    error.missingPlugins = \"doExpressions\"; // so @babel/core can provide better error message\n    throw error;\n  }\n}\n\n// These plugins are defined using a mixin which extends the parser class.\n\nimport estree from \"./plugins/estree\";\nimport flow from \"./plugins/flow\";\nimport jsx from \"./plugins/jsx\";\nimport typescript from \"./plugins/typescript\";\nimport placeholders from \"./plugins/placeholders\";\nimport v8intrinsic from \"./plugins/v8intrinsic\";\n\n// NOTE: order is important. estree must come first; placeholders must come last.\nexport const mixinPlugins: { [name: string]: MixinPlugin } = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders,\n};\n\nexport const mixinPluginNames: $ReadOnlyArray<string> =\n  Object.keys(mixinPlugins);\n", "// @flow\n\nimport type { PluginList } from \"./plugin-utils\";\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nexport type SourceType = \"script\" | \"module\" | \"unambiguous\";\n\nexport type Options = {\n  sourceType: SourceType,\n  sourceFilename?: string,\n  startColumn: number,\n  startLine: number,\n  allowAwaitOutsideFunction: boolean,\n  allowReturnOutsideFunction: boolean,\n  allowImportExportEverywhere: boolean,\n  allowSuperOutsideMethod: boolean,\n  allowUndeclaredExports: boolean,\n  plugins: PluginList,\n  strictMode: ?boolean,\n  ranges: boolean,\n  tokens: boolean,\n  createParenthesizedExpressions: boolean,\n  errorRecovery: boolean,\n  attachComment: boolean,\n};\n\nexport const defaultOptions: Options = {\n  // Source type (\"script\" or \"module\") for different semantics\n  sourceType: \"script\",\n  // Source filename.\n  sourceFilename: undefined,\n  // Column (0-based) from which to start counting source. Useful for\n  // integration with other tools.\n  startColumn: 0,\n  // Line (1-based) from which to start counting source. Useful for\n  // integration with other tools.\n  startLine: 1,\n  // When enabled, await at the top level is not considered an\n  // error.\n  allowAwaitOutsideFunction: false,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // TODO\n  allowSuperOutsideMethod: false,\n  // When enabled, export statements can reference undeclared variables.\n  allowUndeclaredExports: false,\n  // An array of plugins to enable\n  plugins: [],\n  // TODO\n  strictMode: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // Adds all parsed tokens to a `tokens` property on the `File` node\n  tokens: false,\n  // Whether to create ParenthesizedExpression AST nodes (if false\n  // the parser sets extra.parenthesized on the expression nodes instead).\n  createParenthesizedExpressions: false,\n  // When enabled, errors are attached to the AST instead of being directly thrown.\n  // Some errors will still throw, because @babel/parser can't always recover.\n  errorRecovery: false,\n  // When enabled, comments will be attached to adjacent AST nodes as one of\n  // `leadingComments`, `trailingComments` and `innerComments`. The comment attachment\n  // is vital to preserve comments after transform. If you don't print AST back,\n  // consider set this option to `false` for performance\n  attachComment: true,\n};\n\n// Interpret and default an options object\n\nexport function getOptions(opts: ?Options): Options {\n  const options: any = {};\n  for (const key of Object.keys(defaultOptions)) {\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n  return options;\n}\n", "// @flow\n\n/*:: declare var invariant; */\nimport * as charCodes from \"charcodes\";\nimport { tt, type TokenType } from \"../tokenizer/types\";\nimport type {\n  TSParameterProperty,\n  Decorator,\n  Expression,\n  Node,\n  Pattern,\n  RestElement,\n  SpreadElement,\n  /*:: ObjectOrClassMember, */\n  /*:: ClassMember, */\n  /*:: ObjectMember, */\n  /*:: TsNamedTypeElementBase, */\n  /*:: Identifier, */\n  /*:: ObjectExpression, */\n  /*:: ObjectPattern, */\n} from \"../types\";\nimport type { Pos, Position } from \"../util/location\";\nimport {\n  isStrictBindOnlyReservedWord,\n  isStrictBindReservedWord,\n} from \"../util/identifier\";\nimport { NodeUtils } from \"./node\";\nimport { type BindingTypes, BIND_NONE } from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport { Errors } from \"./error\";\n\nconst unwrapParenthesizedExpression = (node: Node): Node => {\n  return node.type === \"ParenthesizedExpression\"\n    ? unwrapParenthesizedExpression(node.expression)\n    : node;\n};\n\nexport default class LValParser extends NodeUtils {\n  // Forward-declaration: defined in expression.js\n  /*::\n  +parseIdentifier: (liberal?: boolean) => Identifier;\n  +parseMaybeAssignAllowIn: (\n    refExpressionErrors?: ?ExpressionErrors,\n    afterLeftParse?: Function,\n    refNeedsArrowPos?: ?Pos,\n  ) => Expression;\n  +parseObjectLike: <T: ObjectPattern | ObjectExpression>(\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: ?boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n  ) => T;\n  +parseObjPropValue: (\n    prop: any,\n    startPos: ?number,\n    startLoc: ?Position,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n  ) => void;\n  +parsePropertyName: (\n    prop: ObjectOrClassMember | ClassMember | TsNamedTypeElementBase,\n  ) => Expression | Identifier;\n  */\n  // Forward-declaration: defined in statement.js\n  /*::\n  +parseDecorator: () => Decorator;\n  */\n\n  /**\n   * Convert existing expression atom to assignable pattern\n   * if possible. Also checks invalid destructuring targets:\n\n   - Parenthesized Destructuring patterns\n   - RestElement is not the last element\n   - Missing `=` in assignment pattern\n\n   NOTE: There is a corresponding \"isAssignable\" method.\n   When this one is updated, please check if also that one needs to be updated.\n\n   * @param {Node} node The expression atom\n   * @param {boolean} [isLHS=false] Whether we are parsing a LeftHandSideExpression. If isLHS is `true`, the following cases are allowed:\n                                    `[(a)] = [0]`, `[(a.b)] = [0]`\n\n   * @returns {Node} The converted assignable pattern\n   * @memberof LValParser\n   */\n  toAssignable(node: Node, isLHS: boolean = false): Node {\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || node.extra?.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        // an LHS can be reinterpreted to a binding pattern but not vice versa.\n        // therefore a parenthesized identifier is ambiguous until we are sure it is an assignment expression\n        // i.e. `([(a) = []] = []) => {}`\n        // see also `recordParenthesizedIdentifierError` signature in packages/babel-parser/src/util/expression-scope.js\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordParenthesizedIdentifierError(\n            node.start,\n            Errors.InvalidParenthesizedAssignment,\n          );\n        } else if (parenthesized.type !== \"MemberExpression\") {\n          // A parenthesized member expression can be in LHS but not in pattern.\n          // If the LHS is later interpreted as a pattern, `checkLVal` will throw for member expression binding\n          // i.e. `([(a.b) = []] = []) => {}`\n          this.raise(node.start, Errors.InvalidParenthesizedAssignment);\n        }\n      } else {\n        this.raise(node.start, Errors.InvalidParenthesizedAssignment);\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        for (\n          let i = 0, length = node.properties.length, last = length - 1;\n          i < length;\n          i++\n        ) {\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n\n          if (\n            isLast &&\n            prop.type === \"RestElement\" &&\n            node.extra?.trailingComma\n          ) {\n            this.raiseRestNotLast(node.extra.trailingComma);\n          }\n        }\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value, isLHS);\n        break;\n\n      case \"SpreadElement\": {\n        this.checkToRestConversion(node);\n\n        node.type = \"RestElement\";\n        const arg = node.argument;\n        this.toAssignable(arg, isLHS);\n        break;\n      }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, node.extra?.trailingComma, isLHS);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, Errors.MissingEqInAssignment);\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n\n      case \"ParenthesizedExpression\":\n        /*::invariant (parenthesized !== undefined) */\n        this.toAssignable(parenthesized, isLHS);\n        break;\n\n      default:\n      // We don't know how to deal with this node. It will\n      // be reported by a later call to checkLVal\n    }\n    return node;\n  }\n\n  toAssignableObjectExpressionProp(\n    prop: Node,\n    isLast: boolean,\n    isLHS: boolean,\n  ) {\n    if (prop.type === \"ObjectMethod\") {\n      const error =\n        prop.kind === \"get\" || prop.kind === \"set\"\n          ? Errors.PatternHasAccessor\n          : Errors.PatternHasMethod;\n\n      /* eslint-disable @babel/development-internal/dry-error-messages */\n      this.raise(prop.key.start, error);\n      /* eslint-enable @babel/development-internal/dry-error-messages */\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raiseRestNotLast(prop.start);\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n\n  // Convert list of expression atoms to binding list.\n\n  toAssignableList(\n    exprList: Expression[],\n    trailingCommaPos?: ?number,\n    isLHS: boolean,\n  ): $ReadOnlyArray<Pattern> {\n    let end = exprList.length;\n    if (end) {\n      const last = exprList[end - 1];\n      if (last?.type === \"RestElement\") {\n        --end;\n      } else if (last?.type === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        let arg = last.argument;\n        this.toAssignable(arg, isLHS);\n        arg = unwrapParenthesizedExpression(arg);\n        if (\n          arg.type !== \"Identifier\" &&\n          arg.type !== \"MemberExpression\" &&\n          arg.type !== \"ArrayPattern\" &&\n          arg.type !== \"ObjectPattern\"\n        ) {\n          this.unexpected(arg.start);\n        }\n\n        if (trailingCommaPos) {\n          this.raiseTrailingCommaAfterRest(trailingCommaPos);\n        }\n\n        --end;\n      }\n    }\n    for (let i = 0; i < end; i++) {\n      const elt = exprList[i];\n      if (elt) {\n        this.toAssignable(elt, isLHS);\n        if (elt.type === \"RestElement\") {\n          this.raiseRestNotLast(elt.start);\n        }\n      }\n    }\n    return exprList;\n  }\n\n  isAssignable(node: Node, isBinding?: boolean): boolean {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n        return true;\n\n      case \"ObjectExpression\": {\n        const last = node.properties.length - 1;\n        return node.properties.every((prop, i) => {\n          return (\n            prop.type !== \"ObjectMethod\" &&\n            (i === last || prop.type !== \"SpreadElement\") &&\n            this.isAssignable(prop)\n          );\n        });\n      }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return node.elements.every(\n          element => element === null || this.isAssignable(element),\n        );\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  // Convert list of expression atoms to a list of\n\n  toReferencedList(\n    exprList: $ReadOnlyArray<?Expression>,\n    isParenthesizedExpr?: boolean, // eslint-disable-line no-unused-vars\n  ): $ReadOnlyArray<?Expression> {\n    return exprList;\n  }\n\n  toReferencedListDeep(\n    exprList: $ReadOnlyArray<?Expression>,\n    isParenthesizedExpr?: boolean,\n  ): void {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (const expr of exprList) {\n      if (expr?.type === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  // Parses spread element.\n\n  parseSpread(\n    refExpressionErrors: ?ExpressionErrors,\n    refNeedsArrowPos?: ?Pos,\n  ): SpreadElement {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(\n      refExpressionErrors,\n      undefined,\n      refNeedsArrowPos,\n    );\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  // https://tc39.es/ecma262/#prod-BindingRestElement\n  parseRestBinding(): RestElement {\n    const node = this.startNode();\n    this.next(); // eat `...`\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  // Parses lvalue (assignable) atom.\n  parseBindingAtom(): Pattern {\n    // https://tc39.es/ecma262/#prod-BindingPattern\n    switch (this.state.type) {\n      case tt.bracketL: {\n        const node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(\n          tt.bracketR,\n          charCodes.rightSquareBracket,\n          true,\n        );\n        return this.finishNode(node, \"ArrayPattern\");\n      }\n\n      case tt.braceL:\n        return this.parseObjectLike(tt.braceR, true);\n    }\n\n    // https://tc39.es/ecma262/#prod-BindingIdentifier\n    return this.parseIdentifier();\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingElementList\n  parseBindingList(\n    close: TokenType,\n    closeCharCode: $Values<typeof charCodes>,\n    allowEmpty?: boolean,\n    allowModifiers?: boolean,\n  ): $ReadOnlyArray<Pattern | TSParameterProperty> {\n    const elts: Array<Pattern | TSParameterProperty> = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n      }\n      if (allowEmpty && this.match(tt.comma)) {\n        // $FlowFixMe This method returns `$ReadOnlyArray<?Pattern>` if `allowEmpty` is set.\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(tt.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        this.checkCommaAfterRest(closeCharCode);\n        this.expect(close);\n        break;\n      } else {\n        const decorators = [];\n        if (this.match(tt.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(this.state.start, Errors.UnsupportedParameterDecorator);\n        }\n        // invariant: hasPlugin(\"decorators-legacy\")\n        while (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n    return elts;\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingRestProperty\n  parseBindingRestProperty(prop: RestElement): RestElement {\n    this.next(); // eat '...'\n    // Don't use parseRestBinding() as we only allow Identifier here.\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(charCodes.rightCurlyBrace);\n    return this.finishNode(prop, \"RestElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-BindingProperty\n  parseBindingProperty(): ObjectMember | RestElement {\n    const prop = this.startNode();\n    const { type, start: startPos, startLoc } = this.state;\n    if (type === tt.ellipsis) {\n      return this.parseBindingRestProperty(prop);\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    this.parseObjPropValue(\n      prop,\n      startPos,\n      startLoc,\n      false /* isGenerator */,\n      false /* isAsync */,\n      true /* isPattern */,\n      false /* isAccessor */,\n    );\n\n    return prop;\n  }\n\n  parseAssignableListItem(\n    allowModifiers: ?boolean,\n    decorators: Decorator[],\n  ): Pattern | TSParameterProperty {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n\n  // Used by flow/typescript plugin to add type annotations to binding elements\n  parseAssignableListItemTypes(param: Pattern): Pattern {\n    return param;\n  }\n\n  // Parses assignment pattern around given atom if possible.\n  // https://tc39.es/ecma262/#prod-BindingElement\n  parseMaybeDefault(\n    startPos?: ?number,\n    startLoc?: ?Position,\n    left?: ?Pattern,\n  ): Pattern {\n    startLoc = startLoc ?? this.state.startLoc;\n    startPos = startPos ?? this.state.start;\n    // $FlowIgnore\n    left = left ?? this.parseBindingAtom();\n    if (!this.eat(tt.eq)) return left;\n\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  /**\n   * Verify that if a node is an lval - something that can be assigned to.\n   *\n   * @param {Expression} expr The given node\n   * @param {string} contextDescription The auxiliary context information printed when error is thrown\n   * @param {BindingTypes} [bindingType=BIND_NONE] The desired binding type. If the given node is an identifier and `bindingType` is not\n                                                   BIND_NONE, `checkLVal` will register binding to the parser scope\n                                                   See also src/util/scopeflags.js\n   * @param {?Set<string>} checkClashes An optional string set to check if an identifier name is included. `checkLVal` will add checked\n                                        identifier name to `checkClashes` It is used in tracking duplicates in function parameter lists. If\n                                        it is nullish, `checkLVal` will skip duplicate checks\n   * @param {boolean} [disallowLetBinding] Whether an identifier named \"let\" should be disallowed\n   * @param {boolean} [strictModeChanged=false] Whether an identifier has been parsed in a sloppy context but should be reinterpreted as\n                                                strict-mode. e.g. `(arguments) => { \"use strict \"}`\n   * @memberof LValParser\n   */\n  checkLVal(\n    expr: Expression,\n    contextDescription: string,\n    bindingType: BindingTypes = BIND_NONE,\n    checkClashes: ?Set<string>,\n    disallowLetBinding?: boolean,\n    strictModeChanged?: boolean = false,\n  ): void {\n    switch (expr.type) {\n      case \"Identifier\": {\n        const { name } = expr;\n        if (\n          this.state.strict &&\n          // \"Global\" reserved words have already been checked by parseIdentifier,\n          // unless they have been found in the id or parameters of a strict-mode\n          // function in a sloppy context.\n          (strictModeChanged\n            ? isStrictBindReservedWord(name, this.inModule)\n            : isStrictBindOnlyReservedWord(name))\n        ) {\n          this.raise(\n            expr.start,\n            bindingType === BIND_NONE\n              ? Errors.StrictEvalArguments\n              : Errors.StrictEvalArgumentsBinding,\n            name,\n          );\n        }\n\n        if (checkClashes) {\n          if (checkClashes.has(name)) {\n            this.raise(expr.start, Errors.ParamDupe);\n          } else {\n            checkClashes.add(name);\n          }\n        }\n        if (disallowLetBinding && name === \"let\") {\n          this.raise(expr.start, Errors.LetInLexicalBinding);\n        }\n        if (!(bindingType & BIND_NONE)) {\n          this.scope.declareName(name, bindingType, expr.start);\n        }\n        break;\n      }\n\n      case \"MemberExpression\":\n        if (bindingType !== BIND_NONE) {\n          this.raise(expr.start, Errors.InvalidPropertyBindingPattern);\n        }\n        break;\n\n      case \"ObjectPattern\":\n        for (let prop of expr.properties) {\n          if (this.isObjectProperty(prop)) prop = prop.value;\n          // If we find here an ObjectMethod, it's because this was originally\n          // an ObjectExpression which has then been converted.\n          // toAssignable already reported this error with a nicer message.\n          else if (this.isObjectMethod(prop)) continue;\n\n          this.checkLVal(\n            prop,\n            \"object destructuring pattern\",\n            bindingType,\n            checkClashes,\n            disallowLetBinding,\n          );\n        }\n        break;\n\n      case \"ArrayPattern\":\n        for (const elem of expr.elements) {\n          if (elem) {\n            this.checkLVal(\n              elem,\n              \"array destructuring pattern\",\n              bindingType,\n              checkClashes,\n              disallowLetBinding,\n            );\n          }\n        }\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(\n          expr.left,\n          \"assignment pattern\",\n          bindingType,\n          checkClashes,\n        );\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(\n          expr.argument,\n          \"rest element\",\n          bindingType,\n          checkClashes,\n        );\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(\n          expr.expression,\n          \"parenthesized expression\",\n          bindingType,\n          checkClashes,\n        );\n        break;\n\n      default: {\n        this.raise(\n          expr.start,\n          bindingType === BIND_NONE\n            ? Errors.InvalidLhs\n            : Errors.InvalidLhsBinding,\n          contextDescription,\n        );\n      }\n    }\n  }\n\n  checkToRestConversion(node: SpreadElement): void {\n    if (\n      node.argument.type !== \"Identifier\" &&\n      node.argument.type !== \"MemberExpression\"\n    ) {\n      this.raise(node.argument.start, Errors.InvalidRestAssignmentPattern);\n    }\n  }\n\n  checkCommaAfterRest(close: $Values<typeof charCodes>): void {\n    if (this.match(tt.comma)) {\n      if (this.lookaheadCharCode() === close) {\n        this.raiseTrailingCommaAfterRest(this.state.start);\n      } else {\n        this.raiseRestNotLast(this.state.start);\n      }\n    }\n  }\n\n  raiseRestNotLast(pos: number) {\n    throw this.raise(pos, Errors.ElementAfterRest);\n  }\n\n  raiseTrailingCommaAfterRest(pos: number) {\n    this.raise(pos, Errors.RestTrailingComma);\n  }\n}\n", "// @flow\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts \u2014 that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {\n  tokenCanStartExpression,\n  tokenIsAssignment,\n  tokenIsIdentifier,\n  tokenIsKeywordOrIdentifier,\n  tokenIsOperator,\n  tokenIsPostfix,\n  tokenIsPrefix,\n  tokenIsRightAssociative,\n  tokenKeywordOrIdentifierIsKeyword,\n  tokenLabelName,\n  tokenOperatorPrecedence,\n  tt,\n  type TokenType,\n} from \"../tokenizer/types\";\nimport * as N from \"../types\";\nimport LValParser from \"./lval\";\nimport {\n  isKeyword,\n  isReservedWord,\n  isStrictReservedWord,\n  isStrictBindReservedWord,\n  isIdentifierStart,\n  canBeReservedWord,\n} from \"../util/identifier\";\nimport { Position } from \"../util/location\";\nimport * as charCodes from \"charcodes\";\nimport {\n  BIND_OUTSIDE,\n  BIND_VAR,\n  SCOPE_ARROW,\n  SCOPE_CLASS,\n  SCOPE_DIRECT_SUPER,\n  SCOPE_FUNCTION,\n  SCOPE_SUPER,\n} from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport {\n  PARAM_AWAIT,\n  PARAM_IN,\n  PARAM_RETURN,\n  functionFlags,\n} from \"../util/production-parameter\";\nimport {\n  newArrowHeadScope,\n  newAsyncArrowScope,\n  newExpressionScope,\n} from \"../util/expression-scope\";\nimport { Errors, SourceTypeModuleErrors } from \"./error\";\nimport type { ParsingError } from \"./error\";\nimport { setInnerComments } from \"./comments\";\nimport { cloneIdentifier } from \"./node\";\n\n/*::\nimport type { SourceType } from \"../options\";\n*/\n\nconst invalidHackPipeBodies = new Map([\n  [\"ArrowFunctionExpression\", \"arrow function\"],\n  [\"AssignmentExpression\", \"assignment\"],\n  [\"ConditionalExpression\", \"conditional\"],\n  [\"YieldExpression\", \"yield\"],\n]);\n\nexport default class ExpressionParser extends LValParser {\n  // Forward-declaration: defined in statement.js\n  /*::\n  +parseBlock: (\n    allowDirectives?: boolean,\n    createNewLexicalScope?: boolean,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ) => N.BlockStatement;\n  +parseClass: (\n    node: N.Class,\n    isStatement: boolean,\n    optionalId?: boolean,\n  ) => N.Class;\n  +parseDecorators: (allowExport?: boolean) => void;\n  +parseFunction: <T: N.NormalFunction>(\n    node: T,\n    statement?: number,\n    allowExpressionBody?: boolean,\n    isAsync?: boolean,\n  ) => T;\n  +parseFunctionParams: (node: N.Function, allowModifiers?: boolean) => void;\n  +takeDecorators: (node: N.HasDecorators) => void;\n  +parseBlockOrModuleBlockBody: (\n    body: N.Statement[],\n    directives: ?(N.Directive[]),\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void\n  ) => void\n  +parseProgram: (\n    program: N.Program, end: TokenType, sourceType?: SourceType\n  ) => N.Program\n  */\n\n  // For object literal, check if property __proto__ has been used more than once.\n  // If the expression is a destructuring assignment, then __proto__ may appear\n  // multiple times. Otherwise, __proto__ is a duplicated key.\n\n  // For record expression, check if property __proto__ exists\n\n  checkProto(\n    prop: N.ObjectMember | N.SpreadElement,\n    isRecord: ?boolean,\n    protoRef: { used: boolean },\n    refExpressionErrors: ?ExpressionErrors,\n  ): void {\n    if (\n      prop.type === \"SpreadElement\" ||\n      this.isObjectMethod(prop) ||\n      prop.computed ||\n      // $FlowIgnore\n      prop.shorthand\n    ) {\n      return;\n    }\n\n    const key = prop.key;\n    // It is either an Identifier or a String/NumericLiteral\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(key.start, Errors.RecordNoProto);\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          // Store the first redefinition's position, otherwise ignore because\n          // we are parsing ambiguous pattern\n          if (refExpressionErrors.doubleProto === -1) {\n            refExpressionErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raise(key.start, Errors.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  shouldExitDescending(expr: N.Expression, potentialArrowAt: number): boolean {\n    return (\n      expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt\n    );\n  }\n\n  // Convenience method to parse an Expression only\n  getExpression(): N.Expression & N.ParserOutput {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(tt.eof)) {\n      this.unexpected();\n    }\n    // Unlike parseTopLevel, we need to drain remaining commentStacks\n    // because the top level node is _not_ Program.\n    this.finalizeRemainingComments();\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function (s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression.\n  // - `disallowIn`\n  //   is used to forbid the `in` operator (in for loops initialization expressions)\n  //   When `disallowIn` is true, the production parameter [In] is not present.\n\n  // - `refExpressionErrors `\n  //   provides reference for storing '=' operator inside shorthand\n  //   property assignment in contexts where both object expression\n  //   and object pattern might appear (so it's possible to raise\n  //   delayed syntax error at correct position).\n\n  parseExpression(\n    disallowIn?: boolean,\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression {\n    if (disallowIn) {\n      return this.disallowInAnd(() =>\n        this.parseExpressionBase(refExpressionErrors),\n      );\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n\n  // https://tc39.es/ecma262/#prod-Expression\n  parseExpressionBase(refExpressionErrors?: ExpressionErrors): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(tt.comma)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(tt.comma)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n\n  // Set [~In] parameter for assignment expression\n  parseMaybeAssignDisallowIn(\n    refExpressionErrors?: ?ExpressionErrors,\n    afterLeftParse?: Function,\n  ) {\n    return this.disallowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // Set [+In] parameter for assignment expression\n  parseMaybeAssignAllowIn(\n    refExpressionErrors?: ?ExpressionErrors,\n    afterLeftParse?: Function,\n  ) {\n    return this.allowInAnd(() =>\n      this.parseMaybeAssign(refExpressionErrors, afterLeftParse),\n    );\n  }\n\n  // This method is only used by\n  // the typescript and flow plugins.\n  setOptionalParametersError(\n    refExpressionErrors: ExpressionErrors,\n    resultError?: ParsingError,\n  ) {\n    refExpressionErrors.optionalParameters =\n      resultError?.pos ?? this.state.start;\n  }\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n  // https://tc39.es/ecma262/#prod-AssignmentExpression\n  parseMaybeAssign(\n    refExpressionErrors?: ?ExpressionErrors,\n    afterLeftParse?: Function,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(tt._yield)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n        return left;\n      }\n    }\n\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const { type } = this.state;\n\n    if (type === tt.parenL || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (this.match(tt.eq)) {\n        node.left = this.toAssignable(left, /* isLHS */ true);\n\n        if (refExpressionErrors.doubleProto >= startPos) {\n          refExpressionErrors.doubleProto = -1; // reset because double __proto__ is valid in assignment expression\n        }\n        if (refExpressionErrors.shorthandAssign >= startPos) {\n          refExpressionErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n        }\n      } else {\n        node.left = left;\n      }\n\n      this.checkLVal(left, \"assignment expression\");\n      this.next();\n      node.right = this.parseMaybeAssign();\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  // Parse a ternary conditional (`?:`) operator.\n  // https://tc39.es/ecma262/#prod-ConditionalExpression\n\n  parseMaybeConditional(refExpressionErrors: ExpressionErrors): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);\n  }\n\n  parseConditional(\n    expr: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    // eslint-disable-next-line no-unused-vars\n    refExpressionErrors?: ?ExpressionErrors,\n  ): N.Expression {\n    if (this.eat(tt.question)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(tt.colon);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n\n  parseMaybeUnaryOrPrivate(\n    refExpressionErrors?: ExpressionErrors,\n  ): N.Expression | N.PrivateName {\n    return this.match(tt.privateName)\n      ? this.parsePrivateName()\n      : this.parseMaybeUnary(refExpressionErrors);\n  }\n\n  // Start the precedence parser.\n  // https://tc39.es/ecma262/#prod-ShortCircuitExpression\n\n  parseExprOps(refExpressionErrors: ExpressionErrors): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1);\n  }\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  parseExprOp(\n    left: N.Expression | N.PrivateName,\n    leftStartPos: number,\n    leftStartLoc: Position,\n    minPrec: number,\n  ): N.Expression {\n    if (this.isPrivateName(left)) {\n      // https://tc39.es/ecma262/#prod-RelationalExpression\n      // RelationalExpression [In, Yield, Await]\n      //   [+In] PrivateIdentifier in ShiftExpression[?Yield, ?Await]\n\n      const value = this.getPrivateNameSV(left);\n      const { start } = left;\n\n      if (\n        minPrec >= tokenOperatorPrecedence(tt._in) ||\n        !this.prodParam.hasIn ||\n        !this.match(tt._in)\n      ) {\n        this.raise(start, Errors.PrivateInExpectedIn, value);\n      }\n\n      this.classScope.usePrivateName(value, start);\n    }\n\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(tt._in))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === tt.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\n        }\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n\n        const logical = op === tt.logicalOR || op === tt.logicalAND;\n        const coalesce = op === tt.nullishCoalescing;\n\n        if (coalesce) {\n          // Handle the precedence of `tt.coalesce` as equal to the range of logical expressions.\n          // In other words, `node.right` shouldn't contain logical expressions in order to check the mixed error.\n          prec = tokenOperatorPrecedence(tt.logicalAND);\n        }\n\n        this.next();\n\n        if (\n          op === tt.pipeline &&\n          this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\"\n        ) {\n          if (this.state.type === tt._await && this.prodParam.hasAwait) {\n            throw this.raise(\n              this.state.start,\n              Errors.UnexpectedAwaitAfterPipelineBody,\n            );\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec);\n        this.finishNode(\n          node,\n          logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\",\n        );\n        /* this check is for all ?? operators\n         * a ?? b && c for this example\n         * when op is coalesce and nextOp is logical (&&), throw at the pos of nextOp that it can not be mixed.\n         * Symmetrically it also throws when op is logical and nextOp is coalesce\n         */\n        const nextOp = this.state.type;\n        if (\n          (coalesce && (nextOp === tt.logicalOR || nextOp === tt.logicalAND)) ||\n          (logical && nextOp === tt.nullishCoalescing)\n        ) {\n          throw this.raise(this.state.start, Errors.MixingCoalesceWithLogical);\n        }\n\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n\n  // Helper function for `parseExprOp`. Parse the right-hand side of binary-\n  // operator expressions, then apply any operator-specific functions.\n\n  parseExprOpRightExpr(op: TokenType, prec: number): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case tt.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n\n          case \"smart\":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(tt._yield)) {\n                throw this.raise(\n                  this.state.start,\n                  Errors.PipeBodyIsTighter,\n                  this.state.value,\n                );\n              }\n              return this.parseSmartPipelineBodyInStyle(\n                this.parseExprOpBaseRightExpr(op, prec),\n                startPos,\n                startLoc,\n              );\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n\n      // Falls through.\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n\n  // Helper function for `parseExprOpRightExpr`. Parse the right-hand side of\n  // binary-operator expressions without applying any operator-specific functions.\n\n  parseExprOpBaseRightExpr(op: TokenType, prec: number): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    return this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startPos,\n      startLoc,\n      tokenIsRightAssociative(op) ? prec - 1 : prec,\n    );\n  }\n\n  parseHackPipeBody(): N.Expression {\n    const { start } = this.state;\n\n    const body = this.parseMaybeAssign();\n\n    // TODO: Check how to handle type casts in Flow and TS once they are supported\n    if (invalidHackPipeBodies.has(body.type) && !body.extra?.parenthesized) {\n      this.raise(\n        start,\n        Errors.PipeUnparenthesizedBody,\n        invalidHackPipeBodies.get(body.type),\n      );\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      // A Hack pipe body must use the topic reference at least once.\n      this.raise(start, Errors.PipeTopicUnused);\n    }\n\n    return body;\n  }\n\n  checkExponentialAfterUnary(node: N.AwaitExpression | N.UnaryExpression) {\n    if (this.match(tt.exponent)) {\n      this.raise(\n        node.argument.start,\n        Errors.UnexpectedTokenUnaryExponentiation,\n      );\n    }\n  }\n\n  // Parse unary operators, both prefix and postfix.\n  // https://tc39.es/ecma262/#prod-UnaryExpression\n  parseMaybeUnary(\n    refExpressionErrors: ?ExpressionErrors,\n    sawUnary?: boolean,\n  ): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(tt._await);\n\n    if (isAwait && this.isAwaitAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startPos, startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(tt.incDec);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (this.match(tt._throw)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(tt._delete);\n      this.next();\n\n      node.argument = this.parseMaybeUnary(null, true);\n\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(node.start, Errors.StrictDelete);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(node.start, Errors.DeletePrivateField);\n        }\n      }\n\n      if (!update) {\n        if (!sawUnary) this.checkExponentialAfterUnary(node);\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n\n    if (isAwait) {\n      const { type } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\")\n        ? tokenCanStartExpression(type)\n        : tokenCanStartExpression(type) && !this.match(tt.modulo);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(startPos, Errors.AwaitNotInAsyncContext);\n        return this.parseAwait(startPos, startLoc);\n      }\n    }\n\n    return expr;\n  }\n\n  // https://tc39.es/ecma262/#prod-UpdateExpression\n  parseUpdate(\n    node: N.Expression,\n    update: boolean,\n    refExpressionErrors: ?ExpressionErrors,\n  ): N.Expression {\n    if (update) {\n      this.checkLVal(node.argument, \"prefix operation\");\n      return this.finishNode(node, \"UpdateExpression\");\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.checkLVal(expr, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(node, \"UpdateExpression\");\n    }\n    return expr;\n  }\n\n  // Parse call, dot, and `[]`-subscript expressions.\n  // https://tc39.es/ecma262/#prod-LeftHandSideExpression\n  parseExprSubscripts(refExpressionErrors: ?ExpressionErrors): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    noCalls?: ?boolean,\n  ): N.Expression {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false,\n    };\n    do {\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n\n      // After parsing a subscript, this isn't \"async\" for sure.\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n\n  /**\n   * @param state Set 'state.stop = true' to indicate that we should stop parsing subscripts.\n   *   state.optionalChainMember to indicate that the member is currently in OptionalChain\n   */\n  parseSubscript(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    noCalls: ?boolean,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    if (!noCalls && this.eat(tt.doubleColon)) {\n      return this.parseBind(base, startPos, startLoc, noCalls, state);\n    } else if (this.match(tt.backQuote)) {\n      return this.parseTaggedTemplateExpression(\n        base,\n        startPos,\n        startLoc,\n        state,\n      );\n    }\n\n    let optional = false;\n\n    if (this.match(tt.questionDot)) {\n      if (noCalls && this.lookaheadCharCode() === charCodes.leftParenthesis) {\n        // stop at `?.` when parsing `new a?.()`\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n\n    if (!noCalls && this.match(tt.parenL)) {\n      return this.parseCoverCallAndAsyncArrowHead(\n        base,\n        startPos,\n        startLoc,\n        state,\n        optional,\n      );\n    } else {\n      const computed = this.eat(tt.bracketL);\n      if (computed || optional || this.eat(tt.dot)) {\n        return this.parseMember(\n          base,\n          startPos,\n          startLoc,\n          state,\n          computed,\n          optional,\n        );\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n\n  // base[?Yield, ?Await] [ Expression[+In, ?Yield, ?Await] ]\n  // base[?Yield, ?Await] . IdentifierName\n  // base[?Yield, ?Await] . PrivateIdentifier\n  //   where `base` is one of CallExpression, MemberExpression and OptionalChain\n  parseMember(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    computed: boolean,\n    optional: boolean,\n  ): N.OptionalMemberExpression | N.MemberExpression {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.computed = computed;\n    const privateName =\n      !computed && this.match(tt.privateName) && this.state.value;\n    const property = computed\n      ? this.parseExpression()\n      : privateName\n      ? this.parsePrivateName()\n      : this.parseIdentifier(true);\n\n    if (privateName !== false) {\n      if (node.object.type === \"Super\") {\n        this.raise(startPos, Errors.SuperPrivateField);\n      }\n      this.classScope.usePrivateName(privateName, property.start);\n    }\n    node.property = property;\n\n    if (computed) {\n      this.expect(tt.bracketR);\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n\n  // https://github.com/tc39/proposal-bind-operator#syntax\n  parseBind(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    noCalls: ?boolean,\n    state: N.ParseSubscriptState,\n  ): N.Expression {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.object = base;\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(\n      this.finishNode(node, \"BindExpression\"),\n      startPos,\n      startLoc,\n      noCalls,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverCallExpressionAndAsyncArrowHead\n  // CoverCallExpressionAndAsyncArrowHead\n  // CallExpression[?Yield, ?Await] Arguments[?Yield, ?Await]\n  // OptionalChain[?Yield, ?Await] Arguments[?Yield, ?Await]\n  parseCoverCallAndAsyncArrowHead(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n    optional: boolean,\n  ): N.Expression {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n\n    this.state.maybeInArrowParameters = true;\n    this.next(); // eat `(`\n\n    let node = this.startNodeAt(startPos, startLoc);\n    node.callee = base;\n\n    if (state.maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n\n    if (state.optionalChainMember) {\n      node.optional = optional;\n    }\n\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(tt.parenR);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(\n        tt.parenR,\n        base.type === \"Import\",\n        base.type !== \"Super\",\n        node,\n        refExpressionErrors,\n      );\n    }\n    this.finishCallExpression(node, state.optionalChainMember);\n\n    if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      node = this.parseAsyncArrowFromCallExpression(\n        this.startNodeAt(startPos, startLoc),\n        node,\n      );\n    } else {\n      if (state.maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return node;\n  }\n\n  toReferencedArguments(\n    node: N.CallExpression | N.OptionalCallExpression,\n    isParenthesizedExpr?: boolean,\n  ) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n\n  // MemberExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  // CallExpression [?Yield, ?Await] TemplateLiteral[?Yield, ?Await, +Tagged]\n  parseTaggedTemplateExpression(\n    base: N.Expression,\n    startPos: number,\n    startLoc: Position,\n    state: N.ParseSubscriptState,\n  ): N.TaggedTemplateExpression {\n    const node: N.TaggedTemplateExpression = this.startNodeAt(\n      startPos,\n      startLoc,\n    );\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(startPos, Errors.OptionalChainingNoTemplate);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base: N.Expression): boolean {\n    return (\n      base.type === \"Identifier\" &&\n      base.name === \"async\" &&\n      this.state.lastTokEnd === base.end &&\n      !this.canInsertSemicolon() &&\n      // check there are no escape sequences, such as \\u{61}sync\n      base.end - base.start === 5 &&\n      base.start === this.state.potentialArrowAt\n    );\n  }\n\n  finishCallExpression<T: N.CallExpression | N.OptionalCallExpression>(\n    node: T,\n    optional: boolean,\n  ): N.Expression {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 2) {\n        if (process.env.BABEL_8_BREAKING) {\n          this.expectPlugin(\"importAssertions\");\n        } else {\n          if (!this.hasPlugin(\"moduleAttributes\")) {\n            this.expectPlugin(\"importAssertions\");\n          }\n        }\n      }\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(\n          node.start,\n          Errors.ImportCallArity,\n          this.hasPlugin(\"importAssertions\") ||\n            this.hasPlugin(\"moduleAttributes\")\n            ? \"one or two arguments\"\n            : \"one argument\",\n        );\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(arg.start, Errors.ImportCallSpreadArgument);\n          }\n        }\n      }\n    }\n    return this.finishNode(\n      node,\n      optional ? \"OptionalCallExpression\" : \"CallExpression\",\n    );\n  }\n\n  parseCallExpressionArguments(\n    close: TokenType,\n    dynamicImport?: boolean,\n    allowPlaceholder?: boolean,\n    nodeForExtra?: ?N.Node,\n    refExpressionErrors?: ?ExpressionErrors,\n  ): $ReadOnlyArray<?N.Expression> {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (\n            dynamicImport &&\n            !this.hasPlugin(\"importAssertions\") &&\n            !this.hasPlugin(\"moduleAttributes\")\n          ) {\n            this.raise(\n              this.state.lastTokStart,\n              Errors.ImportCallArgumentTrailingComma,\n            );\n          }\n          if (nodeForExtra) {\n            this.addExtra(\n              nodeForExtra,\n              \"trailingComma\",\n              this.state.lastTokStart,\n            );\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(\n        this.parseExprListItem(false, refExpressionErrors, allowPlaceholder),\n      );\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return elts;\n  }\n\n  shouldParseAsyncArrow(): boolean {\n    return this.match(tt.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(\n    node: N.ArrowFunctionExpression,\n    call: N.CallExpression,\n  ): N.ArrowFunctionExpression {\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(tt.arrow);\n    this.parseArrowExpression(\n      node,\n      call.arguments,\n      true,\n      call.extra?.trailingComma,\n    );\n    // mark inner comments of `async()` as inner comments of `async () =>`\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    // mark trailing comments of `async` to be inner comments\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n\n  // Parse a no-call expression (like argument of `new` or `::` operators).\n  // https://tc39.es/ecma262/#prod-MemberExpression\n  parseNoCallExpr(): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  // Parse an atomic expression \u2014 either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  // https://tc39.es/ecma262/#prod-PrimaryExpression\n  // https://tc39.es/ecma262/#prod-AsyncArrowFunction\n  // PrimaryExpression\n  // Super\n  // Import\n  // AsyncArrowFunction\n\n  parseExprAtom(refExpressionErrors?: ?ExpressionErrors): N.Expression {\n    let node;\n\n    const { type } = this.state;\n    switch (type) {\n      case tt._super:\n        return this.parseSuper();\n\n      case tt._import:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(tt.dot)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(tt.parenL)) {\n          this.raise(this.state.lastTokStart, Errors.UnsupportedImport);\n        }\n        return this.finishNode(node, \"Import\");\n      case tt._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case tt._do: {\n        return this.parseDo(this.startNode(), false);\n      }\n\n      case tt.slash:\n      case tt.slashAssign: {\n        this.readRegexp();\n        return this.parseRegExpLiteral(this.state.value);\n      }\n\n      case tt.num:\n        return this.parseNumericLiteral(this.state.value);\n\n      case tt.bigint:\n        return this.parseBigIntLiteral(this.state.value);\n\n      case tt.decimal:\n        return this.parseDecimalLiteral(this.state.value);\n\n      case tt.string:\n        return this.parseStringLiteral(this.state.value);\n\n      case tt._null:\n        return this.parseNullLiteral();\n\n      case tt._true:\n        return this.parseBooleanLiteral(true);\n      case tt._false:\n        return this.parseBooleanLiteral(false);\n\n      case tt.parenL: {\n        const canBeArrow = this.state.potentialArrowAt === this.state.start;\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n      }\n\n      case tt.bracketBarL:\n      case tt.bracketHashL: {\n        return this.parseArrayLike(\n          this.state.type === tt.bracketBarL ? tt.bracketBarR : tt.bracketR,\n          /* canBePattern */ false,\n          /* isTuple */ true,\n        );\n      }\n      case tt.bracketL: {\n        return this.parseArrayLike(\n          tt.bracketR,\n          /* canBePattern */ true,\n          /* isTuple */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt.braceBarL:\n      case tt.braceHashL: {\n        return this.parseObjectLike(\n          this.state.type === tt.braceBarL ? tt.braceBarR : tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ true,\n        );\n      }\n      case tt.braceL: {\n        return this.parseObjectLike(\n          tt.braceR,\n          /* isPattern */ false,\n          /* isRecord */ false,\n          refExpressionErrors,\n        );\n      }\n      case tt._function:\n        return this.parseFunctionOrFunctionSent();\n\n      case tt.at:\n        this.parseDecorators();\n      // fall through\n      case tt._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case tt._new:\n        return this.parseNewOrNewTarget();\n\n      case tt.backQuote:\n        return this.parseTemplate(false);\n\n      // BindExpression[Yield]\n      //   :: MemberExpression[?Yield]\n      case tt.doubleColon: {\n        node = this.startNode();\n        this.next();\n        node.object = null;\n        const callee = (node.callee = this.parseNoCallExpr());\n        if (callee.type === \"MemberExpression\") {\n          return this.finishNode(node, \"BindExpression\");\n        } else {\n          throw this.raise(callee.start, Errors.UnsupportedBind);\n        }\n      }\n\n      case tt.privateName: {\n        // Standalone private names are only allowed in \"#x in obj\"\n        // expressions, and they are directly handled by callers of\n        // parseExprOp. If we reach this, the input is always invalid.\n        // We can throw a better error message and recover, rather than\n        // just throwing \"Unexpected token\" (which is the default\n        // behavior of this big switch statement).\n        this.raise(\n          this.state.start,\n          Errors.PrivateInExpectedIn,\n          this.state.value,\n        );\n        return this.parsePrivateName();\n      }\n\n      case tt.moduloAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.modulo, \"%\");\n      }\n\n      case tt.xorAssign: {\n        return this.parseTopicReferenceThenEqualsSign(tt.bitwiseXOR, \"^\");\n      }\n\n      case tt.bitwiseXOR:\n      case tt.modulo:\n      case tt.hash: {\n        const pipeProposal = this.getPluginOption(\n          \"pipelineOperator\",\n          \"proposal\",\n        );\n\n        if (pipeProposal) {\n          return this.parseTopicReference(pipeProposal);\n        } else {\n          throw this.unexpected();\n        }\n      }\n\n      case tt.lt: {\n        const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n        if (\n          isIdentifierStart(lookaheadCh) || // Element/Type Parameter <foo>\n          lookaheadCh === charCodes.greaterThan // Fragment <>\n        ) {\n          this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n          break;\n        } else {\n          throw this.unexpected();\n        }\n      }\n\n      default:\n        if (tokenIsIdentifier(type)) {\n          if (\n            this.isContextual(tt._module) &&\n            this.lookaheadCharCode() === charCodes.leftCurlyBrace &&\n            !this.hasFollowingLineBreak()\n          ) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (\n            !containsEsc &&\n            id.name === \"async\" &&\n            !this.canInsertSemicolon()\n          ) {\n            const { type } = this.state;\n            if (type === tt._function) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseFunction(\n                this.startNodeAtNode(id),\n                undefined,\n                true,\n              );\n            } else if (tokenIsIdentifier(type)) {\n              // If the next token begins with \"=\", commit to parsing an async\n              // arrow function. (Peeking ahead for \"=\" lets us avoid a more\n              // expensive full-token lookahead on this common path.)\n              if (this.lookaheadCharCode() === charCodes.equalsTo) {\n                // although `id` is not used in async arrow unary function,\n                // we don't need to reset `async`'s trailing comments because\n                // it will be attached to the upcoming async arrow binding identifier\n                return this.parseAsyncArrowUnaryFunction(\n                  this.startNodeAtNode(id),\n                );\n              } else {\n                // Otherwise, treat \"async\" as an identifier and let calling code\n                // deal with the current tt.name token.\n                return id;\n              }\n            } else if (type === tt._do) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n\n          if (\n            canBeArrow &&\n            this.match(tt.arrow) &&\n            !this.canInsertSemicolon()\n          ) {\n            this.next();\n            return this.parseArrowExpression(\n              this.startNodeAtNode(id),\n              [id],\n              false,\n            );\n          }\n\n          return id;\n        } else {\n          throw this.unexpected();\n        }\n    }\n  }\n\n  // This helper method should only be called\n  // when the parser has reached a potential Hack pipe topic token\n  // that is followed by an equals sign.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  // If we find ^= or %= in an expression position\n  // (i.e., the tt.moduloAssign or tt.xorAssign token types),\n  // and if the Hack-pipes proposal is active with ^ or % as its topicToken,\n  // then the ^ or % could be the topic token (e.g., in x |> ^==y or x |> ^===y),\n  // and so we reparse the current token as ^ or %.\n  // Otherwise, this throws an unexpected-token error.\n  parseTopicReferenceThenEqualsSign(\n    topicTokenType: TokenType,\n    topicTokenValue: string,\n  ): N.Expression {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n\n    if (pipeProposal) {\n      // Set the most-recent token to be a topic token\n      // given by the tokenType and tokenValue.\n      // Now the next readToken() call (in parseTopicReference)\n      // will consume that \u201Ctopic token\u201D.\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      // Rewind the tokenizer to the end of the \u201Ctopic token\u201D,\n      // so that the following token starts at the equals sign after that topic token.\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc.column--;\n      // Now actually consume the topic token.\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  // This helper method should only be called\n  // when the proposal-pipeline-operator plugin is active,\n  // and when the parser has reached a potential Hack pipe topic token.\n  // Although a pipe-operator proposal is assumed to be active,\n  // its configuration might not match the current token\u2019s type.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  parseTopicReference(pipeProposal: string): N.Expression {\n    const node = this.startNode();\n    const start = this.state.start;\n    const tokenType = this.state.type;\n\n    // Consume the current token.\n    this.next();\n\n    // If the pipe-operator plugin\u2019s configuration matches the current token\u2019s type,\n    // then this will return `node`, will have been finished as a topic reference.\n    // Otherwise, this will throw a `PipeTopicUnconfiguredToken` error.\n    return this.finishTopicReference(node, start, pipeProposal, tokenType);\n  }\n\n  // This helper method attempts to finish the given `node`\n  // into a topic-reference node for the given `pipeProposal`.\n  // See <https://github.com/js-choi/proposal-hack-pipes>.\n  //\n  // The method assumes that any topic token was consumed before it was called.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // and if the given `tokenType` matches the plugin\u2019s configuration,\n  // then this method will return the finished `node`.\n  //\n  // If the `pipelineOperator` plugin is active,\n  // but if the given `tokenType` does not match the plugin\u2019s configuration,\n  // then this method will throw a `PipeTopicUnconfiguredToken` error.\n  finishTopicReference(\n    node: N.Node,\n    start: number,\n    pipeProposal: string,\n    tokenType: TokenType,\n  ): N.Expression {\n    if (this.testTopicReferenceConfiguration(pipeProposal, start, tokenType)) {\n      // The token matches the plugin\u2019s configuration.\n      // The token is therefore a topic reference.\n\n      // Determine the node type for the topic reference\n      // that is appropriate for the active pipe-operator proposal.\n      let nodeType;\n      if (pipeProposal === \"smart\") {\n        nodeType = \"PipelinePrimaryTopicReference\";\n      } else {\n        // The proposal must otherwise be \"hack\",\n        // as enforced by testTopicReferenceConfiguration.\n        nodeType = \"TopicReference\";\n      }\n\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        // The topic reference is not allowed in the current context:\n        // it is outside of a pipe body.\n        // Raise recoverable errors.\n        if (pipeProposal === \"smart\") {\n          this.raise(start, Errors.PrimaryTopicNotAllowed);\n        } else {\n          // In this case, `pipeProposal === \"hack\"` is true.\n          this.raise(start, Errors.PipeTopicUnbound);\n        }\n      }\n\n      // Register the topic reference so that its pipe body knows\n      // that its topic was used at least once.\n      this.registerTopicReference();\n\n      return this.finishNode(node, nodeType);\n    } else {\n      // The token does not match the plugin\u2019s configuration.\n      throw this.raise(\n        start,\n        Errors.PipeTopicUnconfiguredToken,\n        tokenLabelName(tokenType),\n      );\n    }\n  }\n\n  // This helper method tests whether the given token type\n  // matches the pipelineOperator parser plugin\u2019s configuration.\n  // If the active pipe proposal is Hack style,\n  // and if the given token is the same as the plugin configuration\u2019s `topicToken`,\n  // then this is a valid topic reference.\n  // If the active pipe proposal is smart mix,\n  // then the topic token must always be `#`.\n  // If the active pipe proposal is neither (e.g., \"minimal\" or \"fsharp\"),\n  // then an error is thrown.\n  testTopicReferenceConfiguration(\n    pipeProposal: string,\n    start: number,\n    tokenType: TokenType,\n  ): boolean {\n    switch (pipeProposal) {\n      case \"hack\": {\n        const pluginTopicToken = this.getPluginOption(\n          \"pipelineOperator\",\n          \"topicToken\",\n        );\n        return tokenLabelName(tokenType) === pluginTopicToken;\n      }\n      case \"smart\":\n        return tokenType === tt.hash;\n      default:\n        throw this.raise(start, Errors.PipeTopicRequiresHackPipes);\n    }\n  }\n\n  // async [no LineTerminator here] AsyncArrowBindingIdentifier[?Yield] [no LineTerminator here] => AsyncConciseBody[?In]\n  parseAsyncArrowUnaryFunction(node: N.Node): N.ArrowFunctionExpression {\n    // We don't need to push a new ParameterDeclarationScope here since we are sure\n    // 1) it is an async arrow, 2) no biding pattern is allowed in params\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.pos, Errors.LineTerminatorBeforeArrow);\n    }\n    this.expect(tt.arrow);\n    // let foo = async bar => {};\n    this.parseArrowExpression(node, params, true);\n    return node;\n  }\n\n  // https://github.com/tc39/proposal-do-expressions\n  // https://github.com/tc39/proposal-async-do-expressions\n  parseDo(node: N.Node, isAsync: boolean): N.DoExpression {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next(); // eat `do`\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      // AsyncDoExpression :\n      // async [no LineTerminator here] do Block[~Yield, +Await, ~Return]\n      this.prodParam.enter(PARAM_AWAIT);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n\n  // Parse the `super` keyword\n  parseSuper(): N.Super {\n    const node = this.startNode();\n    this.next(); // eat `super`\n    if (\n      this.match(tt.parenL) &&\n      !this.scope.allowDirectSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(node.start, Errors.SuperNotAllowed);\n    } else if (\n      !this.scope.allowSuper &&\n      !this.options.allowSuperOutsideMethod\n    ) {\n      this.raise(node.start, Errors.UnexpectedSuper);\n    }\n\n    if (\n      !this.match(tt.parenL) &&\n      !this.match(tt.bracketL) &&\n      !this.match(tt.dot)\n    ) {\n      this.raise(node.start, Errors.UnsupportedSuper);\n    }\n\n    return this.finishNode(node, \"Super\");\n  }\n\n  parsePrivateName(): N.PrivateName {\n    const node = this.startNode();\n    const id = this.startNodeAt(\n      this.state.start + 1,\n      // The position is hardcoded because we merge `#` and name into a single\n      // tt.privateName token\n      new Position(\n        this.state.curLine,\n        this.state.start + 1 - this.state.lineStart,\n      ),\n    );\n    const name = this.state.value;\n    this.next(); // eat #name;\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n\n  parseFunctionOrFunctionSent(): N.FunctionExpression | N.MetaProperty {\n    const node = this.startNode();\n\n    // We do not do parseIdentifier here because when parseFunctionOrFunctionSent\n    // is called we already know that the current token is a \"name\" with the value \"function\"\n    // This will improve perf a tiny little bit as we do not do validation but more importantly\n    // here is that parseIdentifier will remove an item from the expression stack\n    // if \"function\" or \"class\" is parsed as identifier (in objects e.g.), which should not happen here.\n    this.next(); // eat `function`\n\n    if (this.prodParam.hasYield && this.match(tt.dot)) {\n      const meta = this.createIdentifier(\n        this.startNodeAtNode(node),\n        \"function\",\n      );\n      this.next(); // eat `.`\n      // https://github.com/tc39/proposal-function.sent#syntax-1\n      if (this.match(tt._sent)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        // The code wasn't `function.sent` but just `function.`, so a simple error is less confusing.\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(\n    node: N.MetaProperty,\n    meta: N.Identifier,\n    propertyName: string,\n  ): N.MetaProperty {\n    node.meta = meta;\n\n    const containsEsc = this.state.containsEsc;\n\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(\n        node.property.start,\n        Errors.UnsupportedMetaProperty,\n        meta.name,\n        propertyName,\n      );\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportMeta\n  parseImportMetaProperty(node: N.MetaProperty): N.MetaProperty {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.next(); // eat `.`\n\n    if (this.isContextual(tt._meta)) {\n      if (!this.inModule) {\n        this.raise(id.start, SourceTypeModuleErrors.ImportMetaOutsideModule);\n      }\n      this.sawUnambiguousESM = true;\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteralAtNode<T: N.Node>(\n    value: any,\n    type: $ElementType<T, \"type\">,\n    node: any,\n  ): T {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(node.start, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode<T>(node, type);\n  }\n\n  parseLiteral<T: N.Node>(value: any, type: $ElementType<T, \"type\">): T {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n\n  parseStringLiteral(value: any) {\n    return this.parseLiteral<N.StringLiteral>(value, \"StringLiteral\");\n  }\n\n  parseNumericLiteral(value: any) {\n    return this.parseLiteral<N.NumericLiteral>(value, \"NumericLiteral\");\n  }\n\n  parseBigIntLiteral(value: any) {\n    return this.parseLiteral<N.BigIntLiteral>(value, \"BigIntLiteral\");\n  }\n\n  parseDecimalLiteral(value: any) {\n    return this.parseLiteral<N.DecimalLiteral>(value, \"DecimalLiteral\");\n  }\n\n  parseRegExpLiteral(value: { value: any, pattern: string, flags: string }) {\n    const node = this.parseLiteral<N.RegExpLiteral>(\n      value.value,\n      \"RegExpLiteral\",\n    );\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    return node;\n  }\n\n  parseBooleanLiteral(value: boolean) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode<N.BooleanLiteral>(node, \"BooleanLiteral\");\n  }\n\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode<N.NullLiteral>(node, \"NullLiteral\");\n  }\n\n  // https://tc39.es/ecma262/#prod-CoverParenthesizedExpressionAndArrowParameterList\n  parseParenAndDistinguishExpression(canBeArrow: boolean): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    let val;\n    this.next(); // eat `(`\n    this.expressionScope.enter(newArrowHeadScope());\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStart;\n    let optionalCommaStart;\n\n    while (!this.match(tt.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(\n          tt.comma,\n          refExpressionErrors.optionalParameters === -1\n            ? null\n            : refExpressionErrors.optionalParameters,\n        );\n        if (this.match(tt.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(tt.ellipsis)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(\n          this.parseParenItem(\n            this.parseRestBinding(),\n            spreadNodeStartPos,\n            spreadNodeStartLoc,\n          ),\n        );\n\n        this.checkCommaAfterRest(charCodes.rightParenthesis);\n\n        break;\n      } else {\n        exprList.push(\n          this.parseMaybeAssignAllowIn(\n            refExpressionErrors,\n            this.parseParenItem,\n          ),\n        );\n      }\n    }\n\n    const innerEndPos = this.state.lastTokEnd;\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(tt.parenR);\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n    if (\n      canBeArrow &&\n      this.shouldParseArrow(exprList) &&\n      (arrowNode = this.parseArrow(arrowNode))\n    ) {\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    this.checkExpressionErrors(refExpressionErrors, true);\n\n    this.toReferencedListDeep(exprList, /* isParenthesizedExpr */ true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      // finish node at current location so it can pick up comments after `)`\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(val, \"parenthesized\", true);\n      this.addExtra(val, \"parenStart\", startPos);\n\n      this.takeSurroundingComments(val, startPos, this.state.lastTokEnd);\n\n      return val;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = val;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  // eslint-disable-next-line no-unused-vars -- `params` is used in typescript plugin\n  shouldParseArrow(params: Array<N.Node>): boolean {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node: N.ArrowFunctionExpression): ?N.ArrowFunctionExpression {\n    if (this.eat(tt.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(\n    node: N.Expression,\n    startPos: number, // eslint-disable-line no-unused-vars\n    startLoc: Position, // eslint-disable-line no-unused-vars\n  ): N.Expression {\n    return node;\n  }\n\n  parseNewOrNewTarget(): N.NewExpression | N.MetaProperty {\n    const node = this.startNode();\n    this.next();\n    if (this.match(tt.dot)) {\n      // https://tc39.es/ecma262/#prod-NewTarget\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        this.raise(metaProp.start, Errors.UnexpectedNewTarget);\n      }\n\n      return metaProp;\n    }\n\n    return this.parseNew(node);\n  }\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call \u2014 at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n  // https://tc39.es/ecma262/#prod-NewExpression\n  parseNew(node: N.Expression): N.NewExpression {\n    node.callee = this.parseNoCallExpr();\n    if (node.callee.type === \"Import\") {\n      this.raise(node.callee.start, Errors.ImportCallNotNewExpression);\n    } else if (this.isOptionalChain(node.callee)) {\n      this.raise(this.state.lastTokEnd, Errors.OptionalChainingNoNew);\n    } else if (this.eat(tt.questionDot)) {\n      this.raise(this.state.start, Errors.OptionalChainingNoNew);\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewArguments(node: N.NewExpression): void {\n    if (this.eat(tt.parenL)) {\n      const args = this.parseExprList(tt.parenR);\n      this.toReferencedList(args);\n      // $FlowFixMe (parseExprList should be all non-null in this case)\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }\n\n  // Parse template expression.\n\n  parseTemplateElement(isTagged: boolean): N.TemplateElement {\n    const elem = this.startNode();\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.start + 1, Errors.InvalidEscapeSequenceTemplate);\n      }\n    }\n    elem.value = {\n      raw: this.input\n        .slice(this.state.start, this.state.end)\n        .replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value,\n    };\n    this.next();\n    elem.tail = this.match(tt.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-TemplateLiteral\n  parseTemplate(isTagged: boolean): N.TemplateLiteral {\n    const node = this.startNode();\n    this.next();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      this.expect(tt.dollarBraceL);\n      node.expressions.push(this.parseTemplateSubstitution());\n      this.expect(tt.braceR);\n      node.quasis.push((curElt = this.parseTemplateElement(isTagged)));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  // This is overwritten by the TypeScript plugin to parse template types\n  parseTemplateSubstitution(): N.Expression {\n    return this.parseExpression();\n  }\n\n  // Parse an object literal, binding pattern, or record.\n\n  parseObjectLike<T: N.ObjectPattern | N.ObjectExpression>(\n    close: TokenType,\n    isPattern: boolean,\n    isRecord?: ?boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n  ): T {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash: any = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n\n    node.properties = [];\n    this.next();\n\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n          break;\n        }\n      }\n\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n\n      if (\n        isRecord &&\n        !this.isObjectProperty(prop) &&\n        prop.type !== \"SpreadElement\"\n      ) {\n        this.raise(prop.start, Errors.InvalidRecordProperty);\n      }\n\n      // $FlowIgnore\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    this.next();\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n\n  // Check grammar production:\n  //   IdentifierName *_opt PropertyName\n  // It is used in `parsePropertyDefinition` to detect AsyncMethod and Accessors\n  maybeAsyncOrAccessorProp(prop: N.ObjectProperty): boolean {\n    return (\n      !prop.computed &&\n      prop.key.type === \"Identifier\" &&\n      (this.isLiteralPropertyName() ||\n        this.match(tt.bracketL) ||\n        this.match(tt.star))\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-PropertyDefinition\n  parsePropertyDefinition(\n    refExpressionErrors?: ?ExpressionErrors,\n  ): N.ObjectMember | N.SpreadElement {\n    let decorators = [];\n    if (this.match(tt.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(this.state.start, Errors.UnsupportedPropertyDecorator);\n      }\n\n      // we needn't check if decorators (stage 0) plugin is enabled since it's checked by\n      // the call to this.parseDecorator\n      while (this.match(tt.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(tt.ellipsis)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    let isGenerator = this.eat(tt.star);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    const key = this.parsePropertyName(prop);\n\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const keyName = key.name;\n      // https://tc39.es/ecma262/#prod-AsyncMethod\n      // https://tc39.es/ecma262/#prod-AsyncGeneratorMethod\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(tt.star);\n        this.parsePropertyName(prop);\n      }\n      // get PropertyName[?Yield, ?Await] () { FunctionBody[~Yield, ~Await] }\n      // set PropertyName[?Yield, ?Await] ( PropertySetParameterList ) { FunctionBody[~Yield, ~Await] }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(tt.star)) {\n          isGenerator = true;\n          this.raise(this.state.pos, Errors.AccessorIsGenerator, keyName);\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n\n    this.parseObjPropValue(\n      prop,\n      startPos,\n      startLoc,\n      isGenerator,\n      isAsync,\n      false /* isPattern */,\n      isAccessor,\n      refExpressionErrors,\n    );\n\n    return prop;\n  }\n\n  getGetterSetterExpectedParamCount(\n    method: N.ObjectMethod | N.ClassMethod,\n  ): number {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  // This exists so we can override within the ESTree plugin\n  getObjectOrClassMethodParams(method: N.ObjectMethod | N.ClassMethod) {\n    return method.params;\n  }\n\n  // get methods aren't allowed to have any parameters\n  // set methods must have exactly 1 parameter which is not a rest parameter\n  checkGetterSetterParams(method: N.ObjectMethod | N.ClassMethod): void {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n\n    const start = method.start;\n\n    if (params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, Errors.BadGetterArity);\n      } else {\n        this.raise(start, Errors.BadSetterArity);\n      }\n    }\n\n    if (\n      method.kind === \"set\" &&\n      params[params.length - 1]?.type === \"RestElement\"\n    ) {\n      this.raise(start, Errors.BadSetterRestParameter);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-MethodDefinition\n  parseObjectMethod(\n    prop: N.ObjectMethod,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n  ): ?N.ObjectMethod {\n    if (isAccessor) {\n      // isAccessor implies isAsync: false, isPattern: false, isGenerator: false\n      this.parseMethod(\n        prop,\n        // This _should_ be false, but with error recovery, we allow it to be\n        // set for informational purposes\n        isGenerator,\n        /* isAsync */ false,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n\n    if (isAsync || isGenerator || this.match(tt.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        /* isConstructor */ false,\n        false,\n        \"ObjectMethod\",\n      );\n    }\n  }\n\n  // if `isPattern` is true, parse https://tc39.es/ecma262/#prod-BindingProperty\n  // else https://tc39.es/ecma262/#prod-PropertyDefinition\n  parseObjectProperty(\n    prop: N.ObjectProperty,\n    startPos: ?number,\n    startLoc: ?Position,\n    isPattern: boolean,\n    refExpressionErrors: ?ExpressionErrors,\n  ): ?N.ObjectProperty {\n    prop.shorthand = false;\n\n    if (this.eat(tt.colon)) {\n      prop.value = isPattern\n        ? this.parseMaybeDefault(this.state.start, this.state.startLoc)\n        : this.parseMaybeAssignAllowIn(refExpressionErrors);\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      // PropertyDefinition:\n      //   IdentifierReference\n      //   CoveredInitializedName\n      // Note: `{ eval } = {}` will be checked in `checkLVal` later.\n      this.checkReservedWord(prop.key.name, prop.key.start, true, false);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(\n          startPos,\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else if (this.match(tt.eq) && refExpressionErrors) {\n        if (refExpressionErrors.shorthandAssign === -1) {\n          refExpressionErrors.shorthandAssign = this.state.start;\n        }\n        prop.value = this.parseMaybeDefault(\n          startPos,\n          startLoc,\n          cloneIdentifier(prop.key),\n        );\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(\n    prop: any,\n    startPos: ?number,\n    startLoc: ?Position,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isPattern: boolean,\n    isAccessor: boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n  ): void {\n    const node =\n      this.parseObjectMethod(\n        prop,\n        isGenerator,\n        isAsync,\n        isPattern,\n        isAccessor,\n      ) ||\n      this.parseObjectProperty(\n        prop,\n        startPos,\n        startLoc,\n        isPattern,\n        refExpressionErrors,\n      );\n\n    if (!node) this.unexpected();\n\n    // $FlowFixMe\n    return node;\n  }\n\n  parsePropertyName(\n    prop: N.ObjectOrClassMember | N.ClassMember | N.TsNamedTypeElementBase,\n  ): N.Expression | N.Identifier {\n    if (this.eat(tt.bracketL)) {\n      (prop: $FlowSubtype<N.ObjectOrClassMember>).computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(tt.bracketR);\n    } else {\n      // We check if it's valid for it to be a private name when we push it.\n      const { type, value } = this.state;\n      let key;\n      // most un-computed property names are identifiers\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case tt.num:\n            key = this.parseNumericLiteral(value);\n            break;\n          case tt.string:\n            key = this.parseStringLiteral(value);\n            break;\n          case tt.bigint:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case tt.decimal:\n            key = this.parseDecimalLiteral(value);\n            break;\n          case tt.privateName: {\n            // the class private key has been handled in parseClassElementName\n            const privateKeyPos = this.state.start + 1;\n            this.raise(privateKeyPos, Errors.UnexpectedPrivateField);\n            key = this.parsePrivateName();\n            break;\n          }\n          default:\n            throw this.unexpected();\n        }\n      }\n      (prop: $FlowFixMe).key = key;\n      if (type !== tt.privateName) {\n        // ClassPrivateProperty is never computed, so we don't assign in that case.\n        prop.computed = false;\n      }\n    }\n\n    return prop.key;\n  }\n\n  // Initialize empty function node.\n\n  initFunction(node: N.BodilessFunctionOrMethodBase, isAsync: ?boolean): void {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  // Parse object or class method.\n\n  parseMethod<T: N.MethodLike>(\n    node: T,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowDirectSuper: boolean,\n    type: string,\n    inClassScope: boolean = false,\n  ): T {\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor; // For TypeScript parameter properties\n    this.scope.enter(\n      SCOPE_FUNCTION |\n        SCOPE_SUPER |\n        (inClassScope ? SCOPE_CLASS : 0) |\n        (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0),\n    );\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams((node: any), allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n\n    return node;\n  }\n\n  // parse an array literal or tuple literal\n  // https://tc39.es/ecma262/#prod-ArrayLiteral\n  // https://tc39.es/proposal-record-tuple/#prod-TupleLiteral\n  parseArrayLike(\n    close: TokenType,\n    canBePattern: boolean,\n    isTuple: boolean,\n    refExpressionErrors: ?ExpressionErrors,\n  ): N.ArrayExpression | N.TupleExpression {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(\n      close,\n      /* allowEmpty */ !isTuple,\n      refExpressionErrors,\n      node,\n    );\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(\n      node,\n      isTuple ? \"TupleExpression\" : \"ArrayExpression\",\n    );\n  }\n\n  // Parse arrow function expression.\n  // If the parameters are provided, they will be converted to an\n  // assignable list.\n  parseArrowExpression(\n    node: N.ArrowFunctionExpression,\n    params: ?(N.Expression[]),\n    isAsync: boolean,\n    trailingCommaPos: ?number,\n  ): N.ArrowFunctionExpression {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    let flags = functionFlags(isAsync, false);\n    // ConciseBody and AsyncConciseBody inherit [In]\n    if (!this.match(tt.bracketL) && this.prodParam.hasIn) {\n      flags |= PARAM_IN;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaPos);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(\n    node: N.ArrowFunctionExpression,\n    params: N.Expression[],\n    trailingCommaPos: ?number,\n  ): void {\n    node.params = this.toAssignableList(params, trailingCommaPos, false);\n  }\n\n  parseFunctionBodyAndFinish(\n    node: N.BodilessFunctionOrMethodBase,\n    type: string,\n    isMethod?: boolean = false,\n  ): void {\n    // $FlowIgnore (node is not bodiless if we get here)\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  // Parse function body and check parameters.\n  parseFunctionBody(\n    node: N.Function,\n    allowExpression: ?boolean,\n    isMethod?: boolean = false,\n  ): void {\n    const isExpression = allowExpression && !this.match(tt.braceL);\n    this.expressionScope.enter(newExpressionScope());\n\n    if (isExpression) {\n      // https://tc39.es/ecma262/#prod-ExpressionBody\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      // Start a new scope with regard to labels\n      // flag (restore them to their old value afterwards).\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n\n      // FunctionBody[Yield, Await]:\n      //   StatementList[?Yield, ?Await, +Return] opt\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(\n        true,\n        false,\n        // Strict mode function checks after we parse the statements in the function body.\n        (hasStrictModeDirective: boolean) => {\n          const nonSimple = !this.isSimpleParamList(node.params);\n\n          if (hasStrictModeDirective && nonSimple) {\n            // This logic is here to align the error location with the ESTree plugin.\n            const errorPos =\n              // $FlowIgnore\n              (node.kind === \"method\" || node.kind === \"constructor\") &&\n              // $FlowIgnore\n              !!node.key\n                ? node.key.end\n                : node.start;\n            this.raise(errorPos, Errors.IllegalLanguageModeDirective);\n          }\n\n          const strictModeChanged = !oldStrict && this.state.strict;\n\n          // Add the params to varDeclaredNames to ensure that an error is thrown\n          // if a let/const declaration in the function clashes with one of the params.\n          this.checkParams(\n            node,\n            !this.state.strict && !allowExpression && !isMethod && !nonSimple,\n            allowExpression,\n            strictModeChanged,\n          );\n\n          // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n          if (this.state.strict && node.id) {\n            this.checkLVal(\n              node.id,\n              \"function name\",\n              BIND_OUTSIDE,\n              undefined,\n              undefined,\n              strictModeChanged,\n            );\n          }\n        },\n      );\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n\n  isSimpleParamList(\n    params: $ReadOnlyArray<N.Pattern | N.TSParameterProperty>,\n  ): boolean {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (params[i].type !== \"Identifier\") return false;\n    }\n    return true;\n  }\n\n  checkParams(\n    node: N.Function,\n    allowDuplicates: boolean,\n    // eslint-disable-next-line no-unused-vars\n    isArrowFunction: ?boolean,\n    strictModeChanged?: boolean = true,\n  ): void {\n    const checkClashes = new Set();\n    for (const param of node.params) {\n      this.checkLVal(\n        param,\n        \"function parameter list\",\n        BIND_VAR,\n        allowDuplicates ? null : checkClashes,\n        undefined,\n        strictModeChanged,\n      );\n    }\n  }\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  parseExprList(\n    close: TokenType,\n    allowEmpty?: boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n    nodeForExtra?: ?N.Node,\n  ): $ReadOnlyArray<?N.Expression> {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addExtra(\n              nodeForExtra,\n              \"trailingComma\",\n              this.state.lastTokStart,\n            );\n          }\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n\n  parseExprListItem(\n    allowEmpty: ?boolean,\n    refExpressionErrors?: ?ExpressionErrors,\n    allowPlaceholder: ?boolean,\n  ): ?N.Expression {\n    let elt;\n    if (this.match(tt.comma)) {\n      if (!allowEmpty) {\n        this.raise(this.state.pos, Errors.UnexpectedToken, \",\");\n      }\n      elt = null;\n    } else if (this.match(tt.ellipsis)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n\n      elt = this.parseParenItem(\n        this.parseSpread(refExpressionErrors),\n        spreadNodeStartPos,\n        spreadNodeStartLoc,\n      );\n    } else if (this.match(tt.question)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(this.state.start, Errors.UnexpectedArgumentPlaceholder);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(\n        refExpressionErrors,\n        this.parseParenItem,\n      );\n    }\n    return elt;\n  }\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n  // This shouldn't be used to parse the keywords of meta properties, since they\n  // are not identifiers and cannot contain escape sequences.\n\n  parseIdentifier(liberal?: boolean): N.Identifier {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node: N.Identifier, name: string): N.Identifier {\n    node.name = name;\n    node.loc.identifierName = name;\n\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos: number, liberal?: boolean): string {\n    let name: string;\n\n    const { start, type } = this.state;\n\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      throw this.unexpected();\n    }\n\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n\n    if (liberal) {\n      // If the current token is not used as a keyword, set its type to \"tt.name\".\n      // This will prevent this.next() from throwing about unexpected escapes.\n      if (tokenIsKeyword) {\n        this.replaceToken(tt.name);\n      }\n    } else {\n      this.checkReservedWord(name, start, tokenIsKeyword, false);\n    }\n\n    this.next();\n\n    return name;\n  }\n\n  checkReservedWord(\n    word: string,\n    startLoc: number,\n    checkKeywords: boolean,\n    isBinding: boolean,\n  ): void {\n    // Every JavaScript reserved word is 10 characters or less.\n    if (word.length > 10) {\n      return;\n    }\n    // Most identifiers are not reservedWord-like, they don't need special\n    // treatments afterward, which very likely ends up throwing errors\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n\n    if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(startLoc, Errors.YieldBindingIdentifier);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(startLoc, Errors.AwaitBindingIdentifier);\n        return;\n      } else if (this.scope.inStaticBlock) {\n        this.raise(startLoc, Errors.AwaitBindingIdentifierInStaticBlock);\n        return;\n      } else {\n        this.expressionScope.recordAsyncArrowParametersError(\n          startLoc,\n          Errors.AwaitBindingIdentifier,\n        );\n      }\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(startLoc, Errors.ArgumentsInClass);\n        return;\n      }\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(startLoc, Errors.UnexpectedKeyword, word);\n      return;\n    }\n\n    const reservedTest = !this.state.strict\n      ? isReservedWord\n      : isBinding\n      ? isStrictBindReservedWord\n      : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      this.raise(startLoc, Errors.UnexpectedReservedWord, word);\n    }\n  }\n\n  isAwaitAllowed(): boolean {\n    if (this.prodParam.hasAwait) return true;\n    if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {\n      return true;\n    }\n    return false;\n  }\n\n  // Parses await expression inside async function.\n\n  parseAwait(startPos: number, startLoc: Position): N.AwaitExpression {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    this.expressionScope.recordParameterInitializerError(\n      node.start,\n      Errors.AwaitExpressionFormalParameter,\n    );\n\n    if (this.eat(tt.star)) {\n      this.raise(node.start, Errors.ObsoleteAwaitStar);\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  isAmbiguousAwait(): boolean {\n    return (\n      this.hasPrecedingLineBreak() ||\n      // All the following expressions are ambiguous:\n      //   await + 0, await - 0, await ( 0 ), await [ 0 ], await / 0 /u, await ``\n      this.match(tt.plusMin) ||\n      this.match(tt.parenL) ||\n      this.match(tt.bracketL) ||\n      this.match(tt.backQuote) ||\n      // Sometimes the tokenizer generates tt.slash for regexps, and this is\n      // handler by parseExprAtom\n      this.match(tt.regexp) ||\n      this.match(tt.slash) ||\n      // This code could be parsed both as a modulo operator or as an intrinsic:\n      //   await %x(0)\n      (this.hasPlugin(\"v8intrinsic\") && this.match(tt.modulo))\n    );\n  }\n\n  // Parses yield expression inside generator.\n\n  parseYield(): N.YieldExpression {\n    const node = this.startNode();\n\n    this.expressionScope.recordParameterInitializerError(\n      node.start,\n      Errors.YieldInParameter,\n    );\n\n    this.next();\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(tt.star);\n      switch (this.state.type) {\n        case tt.semi:\n        case tt.eof:\n        case tt.braceR:\n        case tt.parenR:\n        case tt.bracketR:\n        case tt.braceBarR:\n        case tt.colon:\n        case tt.comma:\n          // The above is the complete set of tokens that can\n          // follow an AssignmentExpression, and none of them\n          // can start an AssignmentExpression\n          if (!delegating) break;\n        /* fallthrough */\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  // Validates a pipeline (for any of the pipeline Babylon plugins) at the point\n  // of the infix operator `|>`.\n\n  checkPipelineAtInfixOperator(left: N.Expression, leftStartPos: number) {\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      if (left.type === \"SequenceExpression\") {\n        // Ensure that the pipeline head is not a comma-delimited\n        // sequence expression.\n        this.raise(leftStartPos, Errors.PipelineHeadSequenceExpression);\n      }\n    }\n  }\n\n  // This helper method is to be called immediately\n  // after a Hack-style pipe body is parsed.\n  // The `startPos` is the starting position of the pipe body.\n\n  checkHackPipeBodyEarlyErrors(startPos: number): void {\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      // A Hack pipe body must use the topic reference at least once.\n      this.raise(startPos, Errors.PipeTopicUnused);\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(\n    childExpr: N.Expression,\n    startPos: number,\n    startLoc: Position,\n  ): N.PipelineBody {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n    if (this.isSimpleReference(childExpr)) {\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      this.checkSmartPipeTopicBodyEarlyErrors(startPos);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n\n  isSimpleReference(expression: N.Expression): boolean {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return (\n          !expression.computed && this.isSimpleReference(expression.object)\n        );\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // This helper method is to be called immediately\n  // after a topic-style smart-mix pipe body is parsed.\n  // The `startPos` is the starting position of the pipe body.\n\n  checkSmartPipeTopicBodyEarlyErrors(startPos: number): void {\n    // If the following token is invalidly `=>`, then throw a human-friendly error\n    // instead of something like 'Unexpected token, expected \";\"'.\n    // For example, `x => x |> y => #` (assuming `#` is the topic reference)\n    // groups into `x => (x |> y) => #`,\n    // and `(x |> y) => #` is an invalid arrow function.\n    // This is because smart-mix `|>` has tighter precedence than `=>`.\n    if (this.match(tt.arrow)) {\n      throw this.raise(this.state.start, Errors.PipelineBodyNoArrow);\n    }\n\n    // A topic-style smart-mix pipe body must use the topic reference at least once.\n    else if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(startPos, Errors.PipelineTopicUnused);\n    }\n  }\n\n  // Enable topic references from outer contexts within Hack-style pipe bodies.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references.\n  // The function then calls a callback, then resets the parser\n  // to the old topic-context state that it had before the function was called.\n\n  withTopicBindingContext<T>(callback: () => T): T {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      // Enable the use of the primary topic reference.\n      maxNumOfResolvableTopics: 1,\n      // Hide the use of any topic references from outer contexts.\n      maxTopicIndex: null,\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  // This helper method is used only with the deprecated smart-mix pipe proposal.\n  // Disables topic references from outer contexts within syntax constructs\n  // such as the bodies of iteration statements.\n  // The function modifies the parser's topic-context state to enable or disable\n  // the use of topic references with the smartPipelines plugin. They then run a\n  // callback, then they reset the parser to the old topic-context state that it\n  // had before the function was called.\n\n  withSmartMixTopicForbiddingContext<T>(callback: () => T): T {\n    const proposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (proposal === \"smart\") {\n      // Reset the parser\u2019s topic context only if the smart-mix pipe proposal is active.\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        // Disable the use of the primary topic reference.\n        maxNumOfResolvableTopics: 0,\n        // Hide the use of any topic references from outer contexts.\n        maxTopicIndex: null,\n      };\n\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      // If the pipe proposal is \"minimal\", \"fsharp\", or \"hack\",\n      // or if no pipe proposal is active,\n      // then the callback result is returned\n      // without touching any extra parser state.\n      return callback();\n    }\n  }\n\n  withSoloAwaitPermittingContext<T>(callback: () => T): T {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  allowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = PARAM_IN & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  disallowInAnd<T>(callback: () => T): T {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = PARAM_IN & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~PARAM_IN);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n\n  // Register the use of a topic reference within the current\n  // topic-binding context.\n  registerTopicReference(): void {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  topicReferenceIsAllowedInCurrentContext(): boolean {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentContext(): boolean {\n    return (\n      this.state.topicContext.maxTopicIndex != null &&\n      this.state.topicContext.maxTopicIndex >= 0\n    );\n  }\n\n  parseFSharpPipelineBody(prec: number): N.Expression {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n\n    const ret = this.parseExprOp(\n      this.parseMaybeUnaryOrPrivate(),\n      startPos,\n      startLoc,\n      prec,\n    );\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n\n    return ret;\n  }\n\n  // https://github.com/tc39/proposal-js-module-blocks\n  parseModuleExpression(): N.ModuleExpression {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode<N.ModuleExpression>();\n    this.next(); // eat \"module\"\n    this.eat(tt.braceL);\n\n    const revertScopes = this.initializeScopes(/** inModule */ true);\n    this.enterInitialScopes();\n\n    const program = this.startNode<N.Program>();\n    try {\n      node.body = this.parseProgram(program, tt.braceR, \"module\");\n    } finally {\n      revertScopes();\n    }\n    this.eat(tt.braceR);\n    return this.finishNode<N.ModuleExpression>(node, \"ModuleExpression\");\n  }\n\n  // Used in Flow plugin\n  parsePropertyNamePrefixOperator(\n    // eslint-disable-next-line no-unused-vars\n    prop: N.ObjectOrClassMember | N.ClassMember,\n  ): void {}\n}\n", "// @flow\n\nimport * as N from \"../types\";\nimport {\n  tokenIsIdentifier,\n  tokenIsLoop,\n  tt,\n  type TokenType,\n  getExportedToken,\n} from \"../tokenizer/types\";\nimport ExpressionParser from \"./expression\";\nimport { Errors, SourceTypeModuleErrors } from \"./error\";\nimport { isIdentifierChar, isIdentifierStart } from \"../util/identifier\";\nimport { lineBreak } from \"../util/whitespace\";\nimport * as charCodes from \"charcodes\";\nimport {\n  BIND_CLASS,\n  BIND_LEXICAL,\n  BIND_VAR,\n  BIND_FUNCTION,\n  SCOPE_CLASS,\n  SCOPE_FUNCTION,\n  SCOPE_OTHER,\n  SCOPE_SIMPLE_CATCH,\n  SCOPE_STATIC_BLOCK,\n  SCOPE_SUPER,\n  CLASS_ELEMENT_OTHER,\n  CLASS_ELEMENT_INSTANCE_GETTER,\n  CLASS_ELEMENT_INSTANCE_SETTER,\n  CLASS_ELEMENT_STATIC_GETTER,\n  CLASS_ELEMENT_STATIC_SETTER,\n  type BindingTypes,\n} from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport { PARAM, functionFlags } from \"../util/production-parameter\";\nimport {\n  newExpressionScope,\n  newParameterDeclarationScope,\n} from \"../util/expression-scope\";\nimport type { SourceType } from \"../options\";\nimport { Token } from \"../tokenizer\";\nimport { Position } from \"../util/location\";\nimport { cloneStringLiteral, cloneIdentifier } from \"./node\";\n\nconst loopLabel = { kind: \"loop\" },\n  switchLabel = { kind: \"switch\" };\n\nconst FUNC_NO_FLAGS = 0b000,\n  FUNC_STATEMENT = 0b001,\n  FUNC_HANGING_STATEMENT = 0b010,\n  FUNC_NULLABLE_ID = 0b100;\n\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\n\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\n/**\n * Convert tt.privateName to tt.hash + tt.name for backward Babel 7 compat.\n * For performance reasons this routine mutates `tokens`, it is okay\n * here since we execute `parseTopLevel` once for every file.\n * @param {*} tokens\n * @returns\n */\nfunction babel7CompatTokens(tokens) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const { type } = token;\n    if (type === tt.privateName) {\n      if (!process.env.BABEL_8_BREAKING) {\n        const { loc, start, value, end } = token;\n        const hashEndPos = start + 1;\n        const hashEndLoc = new Position(loc.start.line, loc.start.column + 1);\n        tokens.splice(\n          i,\n          1,\n          // $FlowIgnore: hacky way to create token\n          new Token({\n            type: getExportedToken(tt.hash),\n            value: \"#\",\n            start: start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc,\n          }),\n          // $FlowIgnore: hacky way to create token\n          new Token({\n            type: getExportedToken(tt.name),\n            value: value,\n            start: hashEndPos,\n            end: end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end,\n          }),\n        );\n        i++;\n        continue;\n      }\n    }\n    if (typeof type === \"number\") {\n      // $FlowIgnore: we manipulate `token` for performance reasons\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nexport default class StatementParser extends ExpressionParser {\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  parseTopLevel(file: N.File, program: N.Program): N.File {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n\n    if (this.options.tokens) file.tokens = babel7CompatTokens(this.tokens);\n\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(\n    program: N.Program,\n    end: TokenType = tt.eof,\n    sourceType: SourceType = this.options.sourceType,\n  ): N.Program {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (\n      this.inModule &&\n      !this.options.allowUndeclaredExports &&\n      this.scope.undefinedExports.size > 0\n    ) {\n      for (const [name] of Array.from(this.scope.undefinedExports)) {\n        const pos = this.scope.undefinedExports.get(name);\n        // $FlowIssue\n        this.raise(pos, Errors.ModuleExportUndefined, name);\n      }\n    }\n    return this.finishNode<N.Program>(program, \"Program\");\n  }\n\n  // TODO\n\n  /**\n   * cast a Statement to a Directive. This method mutates input statement.\n   *\n   * @param {N.Statement} stmt\n   * @returns {N.Directive}\n   * @memberof StatementParser\n   */\n  stmtToDirective(stmt: N.Statement): N.Directive {\n    const directive = (stmt: any);\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes\n\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n\n    directiveLiteral.type = \"DirectiveLiteral\";\n\n    return directive;\n  }\n\n  parseInterpreterDirective(): N.InterpreterDirective | null {\n    if (!this.match(tt.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context: ?string): boolean {\n    if (!this.isContextual(tt._let)) {\n      return false;\n    }\n    return this.isLetKeyword(context);\n  }\n\n  /**\n   * Assuming we have seen a contextual `let`, check if it starts a variable declaration\n   so that `left` should be interpreted as a `let` keyword.\n   *\n   * @param {?string} context When `context` is non nullish, it will return early and _skip_ checking\n                              if the next token after `let` is `{` or a keyword relational operator\n   * @returns {boolean}\n   * @memberof StatementParser\n   */\n  isLetKeyword(context: ?string): boolean {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    // Also, `let \\` is never valid as an expression so this must be a keyword.\n    if (\n      nextCh === charCodes.backslash ||\n      nextCh === charCodes.leftSquareBracket\n    ) {\n      return true;\n    }\n    if (context) return false;\n\n    if (nextCh === charCodes.leftCurlyBrace) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      keywordRelationalOperator.lastIndex = next;\n      if (keywordRelationalOperator.test(this.input)) {\n        // We have seen `in` or `instanceof` so far, now check if the identfier\n        // ends here\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== charCodes.backslash) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n  // https://tc39.es/ecma262/#prod-Statement\n  // ImportDeclaration and ExportDeclaration are also handled here so we can throw recoverable errors\n  // when they are not at the top level\n  parseStatement(context: ?string, topLevel?: boolean): N.Statement {\n    if (this.match(tt.at)) {\n      this.parseDecorators(true);\n    }\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context: ?string, topLevel: ?boolean): N.Statement {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = tt._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n      case tt._break:\n        return this.parseBreakContinueStatement(node, /* isBreak */ true);\n      case tt._continue:\n        return this.parseBreakContinueStatement(node, /* isBreak */ false);\n      case tt._debugger:\n        return this.parseDebuggerStatement(node);\n      case tt._do:\n        return this.parseDoStatement(node);\n      case tt._for:\n        return this.parseForStatement(node);\n      case tt._function:\n        if (this.lookaheadCharCode() === charCodes.dot) break;\n        if (context) {\n          if (this.state.strict) {\n            this.raise(this.state.start, Errors.StrictFunction);\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(this.state.start, Errors.SloppyFunction);\n          }\n        }\n        return this.parseFunctionStatement(node, false, !context);\n\n      case tt._class:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case tt._if:\n        return this.parseIfStatement(node);\n      case tt._return:\n        return this.parseReturnStatement(node);\n      case tt._switch:\n        return this.parseSwitchStatement(node);\n      case tt._throw:\n        return this.parseThrowStatement(node);\n      case tt._try:\n        return this.parseTryStatement(node);\n\n      case tt._const:\n      case tt._var:\n        kind = kind || this.state.value;\n        if (context && kind !== \"var\") {\n          this.raise(this.state.start, Errors.UnexpectedLexicalDeclaration);\n        }\n        return this.parseVarStatement(node, kind);\n\n      case tt._while:\n        return this.parseWhileStatement(node);\n      case tt._with:\n        return this.parseWithStatement(node);\n      case tt.braceL:\n        return this.parseBlock();\n      case tt.semi:\n        return this.parseEmptyStatement(node);\n      case tt._import: {\n        const nextTokenCharCode = this.lookaheadCharCode();\n        if (\n          nextTokenCharCode === charCodes.leftParenthesis || // import()\n          nextTokenCharCode === charCodes.dot // import.meta\n        ) {\n          break;\n        }\n      }\n      // fall through\n      case tt._export: {\n        if (!this.options.allowImportExportEverywhere && !topLevel) {\n          this.raise(this.state.start, Errors.UnexpectedImportExport);\n        }\n\n        this.next(); // eat `import`/`export`\n\n        let result;\n        if (starttype === tt._import) {\n          result = this.parseImport(node);\n\n          if (\n            result.type === \"ImportDeclaration\" &&\n            (!result.importKind || result.importKind === \"value\")\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        } else {\n          result = this.parseExport(node);\n\n          if (\n            (result.type === \"ExportNamedDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            (result.type === \"ExportAllDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            result.type === \"ExportDefaultDeclaration\"\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        }\n\n        this.assertModuleNodeAllowed(node);\n\n        return result;\n      }\n\n      default: {\n        if (this.isAsyncFunction()) {\n          if (context) {\n            this.raise(\n              this.state.start,\n              Errors.AsyncFunctionInSingleStatementContext,\n            );\n          }\n          this.next();\n          return this.parseFunctionStatement(node, true, !context);\n        }\n      }\n    }\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (\n      tokenIsIdentifier(starttype) &&\n      expr.type === \"Identifier\" &&\n      this.eat(tt.colon)\n    ) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node: N.Node): void {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(node.start, SourceTypeModuleErrors.ImportOutsideModule);\n    }\n  }\n\n  takeDecorators(node: N.HasDecorators): void {\n    const decorators =\n      this.state.decoratorStack[this.state.decoratorStack.length - 1];\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator(): boolean {\n    return this.match(tt._class);\n  }\n\n  parseDecorators(allowExport?: boolean): void {\n    const currentContextDecorators =\n      this.state.decoratorStack[this.state.decoratorStack.length - 1];\n    while (this.match(tt.at)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(tt._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (\n        this.hasPlugin(\"decorators\") &&\n        !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")\n      ) {\n        this.raise(this.state.start, Errors.DecoratorExportClass);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(this.state.start, Errors.UnexpectedLeadingDecorator);\n    }\n  }\n\n  parseDecorator(): N.Decorator {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      // Every time a decorator class expression is evaluated, a new empty array is pushed onto the stack\n      // So that the decorators of any nested class expressions will be dealt with separately\n      this.state.decoratorStack.push([]);\n\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr: N.Expression;\n\n      if (this.eat(tt.parenL)) {\n        expr = this.parseExpression();\n        this.expect(tt.parenR);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(tt.dot)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr: N.Expression): N.Expression {\n    if (this.eat(tt.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(\n    node: N.BreakStatement | N.ContinueStatement,\n    isBreak: boolean,\n  ): N.BreakStatement | N.ContinueStatement {\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, isBreak);\n\n    return this.finishNode(\n      node,\n      isBreak ? \"BreakStatement\" : \"ContinueStatement\",\n    );\n  }\n\n  verifyBreakContinue(\n    node: N.BreakStatement | N.ContinueStatement,\n    isBreak: boolean,\n  ) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      this.raise(\n        node.start,\n        Errors.IllegalBreakContinue,\n        isBreak ? \"break\" : \"continue\",\n      );\n    }\n  }\n\n  parseDebuggerStatement(node: N.DebuggerStatement): N.DebuggerStatement {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression(): N.Expression {\n    this.expect(tt.parenL);\n    const val = this.parseExpression();\n    this.expect(tt.parenR);\n    return val;\n  }\n\n  parseDoStatement(node: N.DoWhileStatement): N.DoWhileStatement {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body's body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body's body.\n        this.parseStatement(\"do\"),\n      );\n\n    this.state.labels.pop();\n\n    this.expect(tt._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(tt.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  parseForStatement(node: N.Node): N.ForLike {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    let awaitAt = -1;\n    if (this.isAwaitAllowed() && this.eatContextual(tt._await)) {\n      awaitAt = this.state.lastTokStart;\n    }\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(tt.parenL);\n\n    if (this.match(tt.semi)) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n\n    const startsWithLet = this.isContextual(tt._let);\n    const isLet = startsWithLet && this.isLetKeyword();\n    if (this.match(tt._var) || this.match(tt._const) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if (\n        (this.match(tt._in) || this.isContextual(tt._of)) &&\n        init.declarations.length === 1\n      ) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, init);\n    }\n\n    // Check whether the first token is possibly a contextual keyword, so that\n    // we can forbid `for (async of` if this turns out to be a for-of loop.\n    const startsWithAsync = this.isContextual(tt._async);\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(tt._of);\n    if (isForOf) {\n      // Check for leading tokens that are forbidden in for-of loops:\n      if (startsWithLet) {\n        this.raise(init.start, Errors.ForOfLet);\n      } else if (\n        // `for await (async of []);` is allowed.\n        awaitAt === -1 &&\n        startsWithAsync &&\n        init.type === \"Identifier\"\n      ) {\n        // This catches the case where the `async` in `for (async of` was\n        // parsed as an identifier. If it was parsed as the start of an async\n        // arrow function (e.g. `for (async of => {} of []);`), the LVal check\n        // further down will raise a more appropriate error.\n        this.raise(init.start, Errors.ForOfAsync);\n      }\n    }\n    if (isForOf || this.match(tt._in)) {\n      this.toAssignable(init, /* isLHS */ true);\n      const description = isForOf ? \"for-of statement\" : \"for-in statement\";\n      this.checkLVal(init, description);\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(\n    node: N.FunctionDeclaration,\n    isAsync?: boolean,\n    declarationPosition?: boolean,\n  ): N.FunctionDeclaration {\n    this.next();\n    return this.parseFunction(\n      node,\n      FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT),\n      isAsync,\n    );\n  }\n\n  parseIfStatement(node: N.IfStatement): N.IfStatement {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(tt._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node: N.ReturnStatement): N.ReturnStatement {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, Errors.IllegalReturn);\n    }\n\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node: N.SwitchStatement): N.SwitchStatement {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = (node.cases = []);\n    this.expect(tt.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    let cur;\n    for (let sawDefault; !this.match(tt.braceR); ) {\n      if (this.match(tt._case) || this.match(tt._default)) {\n        const isCase = this.match(tt._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push((cur = this.startNode()));\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(\n              this.state.lastTokStart,\n              Errors.MultipleDefaultsInSwitch,\n            );\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(tt.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node: N.ThrowStatement): N.ThrowStatement {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(this.state.lastTokEnd, Errors.NewlineAfterThrow);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam(): N.Pattern {\n    const param = this.parseBindingAtom();\n\n    const simple = param.type === \"Identifier\";\n    this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n    this.checkLVal(param, \"catch clause\", BIND_LEXICAL);\n\n    return param;\n  }\n\n  parseTryStatement(node: N.TryStatement): N.TryStatement {\n    this.next();\n\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(tt._catch)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(tt.parenL)) {\n        this.expect(tt.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(tt.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      // Parse the catch clause's body.\n      clause.body =\n        // For the smartPipelines plugin: Disable topic references from outer\n        // contexts within the catch clause's body.\n        this.withSmartMixTopicForbiddingContext(() =>\n          // Parse the catch clause's body.\n          this.parseBlock(false, false),\n        );\n\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, Errors.NoCatchOrFinally);\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(\n    node: N.VariableDeclaration,\n    kind: \"var\" | \"let\" | \"const\",\n  ): N.VariableDeclaration {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node: N.WhileStatement): N.WhileStatement {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(\"while\"),\n      );\n\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node: N.WithStatement): N.WithStatement {\n    if (this.state.strict) {\n      this.raise(this.state.start, Errors.StrictWith);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n\n    // Parse the statement body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the with statement's body.\n      // They are permitted in function default-parameter expressions, which are\n      // part of the outer context, outside of the with statement's body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the statement body.\n        this.parseStatement(\"with\"),\n      );\n\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node: N.EmptyStatement): N.EmptyStatement {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(\n    node: N.LabeledStatement,\n    maybeName: string,\n    expr: N.Identifier,\n    context: ?string,\n  ): N.LabeledStatement {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(expr.start, Errors.LabelRedeclaration, maybeName);\n      }\n    }\n\n    const kind = tokenIsLoop(this.state.type)\n      ? \"loop\"\n      : this.match(tt._switch)\n      ? \"switch\"\n      : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start,\n    });\n    node.body = this.parseStatement(\n      context\n        ? context.indexOf(\"label\") === -1\n          ? context + \"label\"\n          : context\n        : \"label\",\n    );\n\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(\n    node: N.ExpressionStatement,\n    expr: N.Expression,\n  ): N.Statement {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowDirectives` is true (used for\n  // function bodies).\n\n  parseBlock(\n    allowDirectives?: boolean = false,\n    createNewLexicalScope?: boolean = true,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(tt.braceL);\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n    this.parseBlockBody(\n      node,\n      allowDirectives,\n      false,\n      tt.braceR,\n      afterBlockParse,\n    );\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt: N.Statement): boolean {\n    return (\n      stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"StringLiteral\" &&\n      !stmt.expression.extra.parenthesized\n    );\n  }\n\n  parseBlockBody(\n    node: N.BlockStatementLike,\n    allowDirectives: ?boolean,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const body = (node.body = []);\n    const directives = (node.directives = []);\n    this.parseBlockOrModuleBlockBody(\n      body,\n      allowDirectives ? directives : undefined,\n      topLevel,\n      end,\n      afterBlockParse,\n    );\n  }\n\n  // Undefined directives means that directives are not allowed.\n  // https://tc39.es/ecma262/#prod-Block\n  // https://tc39.es/ecma262/#prod-ModuleBody\n  parseBlockOrModuleBlockBody(\n    body: N.Statement[],\n    directives: ?(N.Directive[]),\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (\n            !hasStrictModeDirective &&\n            directive.value.value === \"use strict\"\n          ) {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n        parsedNonDirective = true;\n        // clear strict errors since the strict mode will not change within the block\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  parseFor(\n    node: N.ForStatement,\n    init: ?(N.VariableDeclaration | N.Expression),\n  ): N.ForStatement {\n    node.init = init;\n    this.semicolon(/* allowAsi */ false);\n    node.test = this.match(tt.semi) ? null : this.parseExpression();\n    this.semicolon(/* allowAsi */ false);\n    node.update = this.match(tt.parenR) ? null : this.parseExpression();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body.\n        this.parseStatement(\"for\"),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  parseForIn(\n    node: N.ForInOf,\n    init: N.VariableDeclaration | N.AssignmentPattern,\n    awaitAt: number,\n  ): N.ForInOf {\n    const isForIn = this.match(tt._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt > -1) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt > -1;\n    }\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (!isForIn ||\n        this.state.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\")\n    ) {\n      this.raise(\n        init.start,\n        Errors.ForInOfLoopInitializer,\n        isForIn ? \"for-in\" : \"for-of\",\n      );\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, Errors.InvalidLhs, \"for-loop\");\n    }\n\n    node.left = init;\n    node.right = isForIn\n      ? this.parseExpression()\n      : this.parseMaybeAssignAllowIn();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(\"for\"),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  parseVar(\n    node: N.VariableDeclaration,\n    isFor: boolean,\n    kind: \"var\" | \"let\" | \"const\",\n  ): N.VariableDeclaration {\n    const declarations = (node.declarations = []);\n    const isTypescript = this.hasPlugin(\"typescript\");\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      if (this.eat(tt.eq)) {\n        decl.init = isFor\n          ? this.parseMaybeAssignDisallowIn()\n          : this.parseMaybeAssignAllowIn();\n      } else {\n        if (\n          kind === \"const\" &&\n          !(this.match(tt._in) || this.isContextual(tt._of))\n        ) {\n          // `const` with no initializer is allowed in TypeScript.\n          // It could be a declaration like `const x: number;`.\n          if (!isTypescript) {\n            this.raise(\n              this.state.lastTokEnd,\n              Errors.DeclarationMissingInitializer,\n              \"Const declarations\",\n            );\n          }\n        } else if (\n          decl.id.type !== \"Identifier\" &&\n          !(isFor && (this.match(tt._in) || this.isContextual(tt._of)))\n        ) {\n          this.raise(\n            this.state.lastTokEnd,\n            Errors.DeclarationMissingInitializer,\n            \"Complex binding patterns\",\n          );\n        }\n        decl.init = null;\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(tt.comma)) break;\n    }\n    return node;\n  }\n\n  parseVarId(decl: N.VariableDeclarator, kind: \"var\" | \"let\" | \"const\"): void {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(\n      decl.id,\n      \"variable declaration\",\n      kind === \"var\" ? BIND_VAR : BIND_LEXICAL,\n      undefined,\n      kind !== \"var\",\n    );\n  }\n\n  // Parse a function declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseFunction<T: N.NormalFunction>(\n    node: T,\n    statement?: number = FUNC_NO_FLAGS,\n    isAsync?: boolean = false,\n  ): T {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n\n    this.initFunction(node, isAsync);\n\n    if (this.match(tt.star) && isHangingStatement) {\n      this.raise(this.state.start, Errors.GeneratorInSingleStatementContext);\n    }\n    node.generator = this.eat(tt.star);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, /* allowModifiers */ false);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the function body. They are permitted in function\n    // default-parameter expressions, outside of the function body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the function body.\n      this.parseFunctionBodyAndFinish(\n        node,\n        isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\",\n      );\n    });\n\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      // We need to register this _after_ parsing the function body\n      // because of TypeScript body-less function declarations,\n      // which shouldn't be added to the scope.\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n\n  parseFunctionId(requireId?: boolean): ?N.Identifier {\n    return requireId || tokenIsIdentifier(this.state.type)\n      ? this.parseIdentifier()\n      : null;\n  }\n\n  parseFunctionParams(node: N.Function, allowModifiers?: boolean): void {\n    this.expect(tt.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(\n      tt.parenR,\n      charCodes.rightParenthesis,\n      /* allowEmpty */ false,\n      allowModifiers,\n    );\n\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node: N.Function): void {\n    if (!node.id) return;\n\n    // If it is a regular function declaration in sloppy mode, then it is\n    // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n    // mode depends on properties of the current scope (see\n    // treatFunctionsAsVar).\n    this.scope.declareName(\n      node.id.name,\n      this.state.strict || node.generator || node.async\n        ? this.scope.treatFunctionsAsVar\n          ? BIND_VAR\n          : BIND_LEXICAL\n        : BIND_FUNCTION,\n      node.id.start,\n    );\n  }\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseClass<T: N.Class>(\n    node: T,\n    isStatement: /* T === ClassDeclaration */ boolean,\n    optionalId?: boolean,\n  ): T {\n    this.next();\n    this.takeDecorators(node);\n\n    // A class definition is always strict mode code.\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    // this.state.strict is restored in parseClassBody\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n\n    return this.finishNode(\n      node,\n      isStatement ? \"ClassDeclaration\" : \"ClassExpression\",\n    );\n  }\n\n  isClassProperty(): boolean {\n    return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);\n  }\n\n  isClassMethod(): boolean {\n    return this.match(tt.parenL);\n  }\n\n  isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n    return (\n      !method.computed &&\n      !method.static &&\n      (method.key.name === \"constructor\" || // Identifier\n        method.key.value === \"constructor\") // String literal\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassBody\n  parseClassBody(hadSuperClass: boolean, oldStrict: boolean): N.ClassBody {\n    this.classScope.enter();\n\n    const state: N.ParseClassMemberState = {\n      hadConstructor: false,\n      hadSuperClass,\n    };\n    let decorators: N.Decorator[] = [];\n    const classBody: N.ClassBody = this.startNode();\n    classBody.body = [];\n\n    this.expect(tt.braceL);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the class body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the contents within the braces.\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(this.state.lastTokEnd, Errors.DecoratorSemicolon);\n          }\n          continue;\n        }\n\n        if (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        // steal the decorators if there are any\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (\n          member.kind === \"constructor\" &&\n          member.decorators &&\n          member.decorators.length > 0\n        ) {\n          this.raise(member.start, Errors.DecoratorConstructor);\n        }\n      }\n    });\n\n    this.state.strict = oldStrict;\n\n    this.next(); // eat `}`\n\n    if (decorators.length) {\n      throw this.raise(this.state.start, Errors.TrailingDecorator);\n    }\n\n    this.classScope.exit();\n\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  // returns true if the current identifier is a method/field name,\n  // false if it is a modifier\n  parseClassMemberFromModifier(\n    classBody: N.ClassBody,\n    member: N.ClassMember,\n  ): boolean {\n    const key = this.parseIdentifier(true); // eats the modifier\n\n    if (this.isClassMethod()) {\n      const method: N.ClassMethod = (member: any);\n\n      // a method named like the modifier\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(\n        classBody,\n        method,\n        false,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop: N.ClassProperty = (member: any);\n\n      // a property named like the modifier\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n\n  parseClassMember(\n    classBody: N.ClassBody,\n    member: N.ClassMember,\n    state: N.ParseClassMemberState,\n  ): void {\n    const isStatic = this.isContextual(tt._static);\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        // a class element named 'static'\n        return;\n      }\n      if (this.eat(tt.braceL)) {\n        this.parseClassStaticBlock(classBody, ((member: any): N.StaticBlock));\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(\n    classBody: N.ClassBody,\n    member: N.ClassMember,\n    state: N.ParseClassMemberState,\n    isStatic: boolean,\n  ) {\n    const publicMethod: $FlowSubtype<N.ClassMethod> = member;\n    const privateMethod: $FlowSubtype<N.ClassPrivateMethod> = member;\n    const publicProp: $FlowSubtype<N.ClassMethod> = member;\n    const privateProp: $FlowSubtype<N.ClassPrivateMethod> = member;\n\n    const method: typeof publicMethod | typeof privateMethod = publicMethod;\n    const publicMember: typeof publicMethod | typeof publicProp = publicMethod;\n\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n\n    if (this.eat(tt.star)) {\n      // a generator\n      method.kind = \"method\";\n      const isPrivateName = this.match(tt.privateName);\n      this.parseClassElementName(method);\n\n      if (isPrivateName) {\n        // Private generator method\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, Errors.ConstructorIsGenerator);\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        true,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n\n      return;\n    }\n\n    const isContextual =\n      tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(tt.privateName);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStart = this.state.start;\n\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      // a normal method\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        // TypeScript allows multiple overloaded constructor declarations.\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, Errors.DuplicateConstructor);\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(key.start, Errors.OverrideOnConstructor);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        false,\n        false,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (\n      isContextual &&\n      key.name === \"async\" &&\n      !this.isLineTerminator()\n    ) {\n      // an async method\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(tt.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStart);\n      }\n\n      method.kind = \"method\";\n      // The so-called parsed name would have been \"async\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (isPrivate) {\n        // private async method\n        this.pushClassPrivateMethod(\n          classBody,\n          privateMethod,\n          isGenerator,\n          true,\n        );\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, Errors.ConstructorIsAsync);\n        }\n\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          isGenerator,\n          true,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n    } else if (\n      isContextual &&\n      (key.name === \"get\" || key.name === \"set\") &&\n      !(this.match(tt.star) && this.isLineTerminator())\n    ) {\n      // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n      // a getter or setter\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      // The so-called parsed name would have been \"get/set\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicMethod);\n\n      if (isPrivate) {\n        // private getter/setter\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, Errors.ConstructorIsAccessor);\n        }\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          false,\n          false,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassElementName\n  parseClassElementName(member: N.ClassMember): N.Expression | N.Identifier {\n    const { type, value, start } = this.state;\n    if (\n      (type === tt.name || type === tt.string) &&\n      member.static &&\n      value === \"prototype\"\n    ) {\n      this.raise(start, Errors.StaticPrototype);\n    }\n\n    if (type === tt.privateName) {\n      if (value === \"constructor\") {\n        this.raise(start, Errors.ConstructorClassPrivateField);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n\n    return this.parsePropertyName(member);\n  }\n\n  parseClassStaticBlock(\n    classBody: N.ClassBody,\n    member: N.StaticBlock & { decorators?: Array<N.Decorator> },\n  ) {\n    // Start a new lexical scope\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    // Start a new scope with regard to loop labels\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    // ClassStaticBlockStatementList:\n    //   StatementList[~Yield, ~Await, ~Return] opt\n    this.prodParam.enter(PARAM);\n    const body = (member.body = []);\n    this.parseBlockOrModuleBlockBody(body, undefined, false, tt.braceR);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode<N.StaticBlock>(member, \"StaticBlock\"));\n    if (member.decorators?.length) {\n      this.raise(member.start, Errors.DecoratorStaticBlock);\n    }\n  }\n\n  pushClassProperty(classBody: N.ClassBody, prop: N.ClassProperty) {\n    if (\n      !prop.computed &&\n      (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")\n    ) {\n      // Non-computed field, which is either an identifier named \"constructor\"\n      // or a string literal named \"constructor\"\n      this.raise(prop.key.start, Errors.ConstructorClassField);\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(\n    classBody: N.ClassBody,\n    prop: N.ClassPrivateProperty,\n  ) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      CLASS_ELEMENT_OTHER,\n      node.key.start,\n    );\n  }\n\n  pushClassMethod(\n    classBody: N.ClassBody,\n    method: N.ClassMethod,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowsDirectSuper: boolean,\n  ): void {\n    classBody.body.push(\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      ),\n    );\n  }\n\n  pushClassPrivateMethod(\n    classBody: N.ClassBody,\n    method: N.ClassPrivateMethod,\n    isGenerator: boolean,\n    isAsync: boolean,\n  ): void {\n    const node = this.parseMethod(\n      method,\n      isGenerator,\n      isAsync,\n      /* isConstructor */ false,\n      false,\n      \"ClassPrivateMethod\",\n      true,\n    );\n    classBody.body.push(node);\n\n    const kind =\n      node.kind === \"get\"\n        ? node.static\n          ? CLASS_ELEMENT_STATIC_GETTER\n          : CLASS_ELEMENT_INSTANCE_GETTER\n        : node.kind === \"set\"\n        ? node.static\n          ? CLASS_ELEMENT_STATIC_SETTER\n          : CLASS_ELEMENT_INSTANCE_SETTER\n        : CLASS_ELEMENT_OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  declareClassPrivateMethodInScope(\n    node: N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod,\n    kind: number,\n  ) {\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      kind,\n      node.key.start,\n    );\n  }\n\n  // Overridden in typescript.js\n  parsePostMemberNameModifiers(\n    // eslint-disable-next-line no-unused-vars\n    methodOrProp: N.ClassMethod | N.ClassProperty,\n  ): void {}\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassPrivateProperty(\n    node: N.ClassPrivateProperty,\n  ): N.ClassPrivateProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassProperty(node: N.ClassProperty): N.ClassProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-Initializer\n  parseInitializer(node: N.ClassProperty | N.ClassPrivateProperty): void {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(tt.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(\n    node: N.Class,\n    isStatement: boolean,\n    optionalId: ?boolean,\n    bindingType: BindingTypes = BIND_CLASS,\n  ): void {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.checkLVal(node.id, \"class name\", bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, Errors.MissingClassName);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassHeritage\n  parseClassSuper(node: N.Class): void {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  // Parses module export declaration.\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n\n  parseExport(node: N.Node): N.AnyExport {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(tt.comma);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace =\n      hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace =\n      parseAfterDefault && (!hasNamespace || this.eat(tt.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (\n      (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) ||\n      (hasNamespace && parseAfterNamespace && !hasSpecifiers)\n    ) {\n      throw this.unexpected(null, tt.braceL);\n    }\n\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(tt._default)) {\n      // export default ...\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, tt.braceL);\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  eatExportStar(node: N.Node): boolean {\n    return this.eat(tt.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node: N.Node): boolean {\n    if (this.isExportDefaultSpecifier()) {\n      // export defaultObj ...\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n    if (this.isContextual(tt._as)) {\n      if (!node.specifiers) node.specifiers = [];\n\n      const specifier = this.startNodeAt(\n        this.state.lastTokStart,\n        this.state.lastTokStartLoc,\n      );\n\n      this.next();\n\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(\n        this.finishNode(specifier, \"ExportNamespaceSpecifier\"),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node: N.Node): boolean {\n    if (this.match(tt.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportDeclaration(node: N.Node): boolean {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n\n  isAsyncFunction(): boolean {\n    if (!this.isContextual(tt._async)) return false;\n    const next = this.nextTokenStart();\n    return (\n      !lineBreak.test(this.input.slice(this.state.pos, next)) &&\n      this.isUnparsedContextual(next, \"function\")\n    );\n  }\n\n  parseExportDefaultExpression(): N.Expression | N.Declaration {\n    const expr = this.startNode();\n\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(tt._function) || isAsync) {\n      this.next();\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(\n        expr,\n        FUNC_STATEMENT | FUNC_NULLABLE_ID,\n        isAsync,\n      );\n    } else if (this.match(tt._class)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(tt.at)) {\n      if (\n        this.hasPlugin(\"decorators\") &&\n        this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")\n      ) {\n        this.raise(this.state.start, Errors.DecoratorBeforeExport);\n      }\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else if (this.match(tt._const) || this.match(tt._var) || this.isLet()) {\n      throw this.raise(this.state.start, Errors.UnsupportedDefaultExport);\n    } else {\n      const res = this.parseMaybeAssignAllowIn();\n      this.semicolon();\n      return res;\n    }\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  parseExportDeclaration(node: N.ExportNamedDeclaration): ?N.Declaration {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier(): boolean {\n    const { type } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if ((type === tt._async && !this.state.containsEsc) || type === tt._let) {\n        return false;\n      }\n      if (\n        (type === tt._type || type === tt._interface) &&\n        !this.state.containsEsc\n      ) {\n        const { type: nextType } = this.lookahead();\n        // If we see any variable name other than `from` after `type` keyword,\n        // we consider it as flow/typescript type exports\n        // note that this approach may fail on some pedantic cases\n        // export type from = number\n        if (\n          (tokenIsIdentifier(nextType) && nextType !== tt._from) ||\n          nextType === tt.braceL\n        ) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(tt._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (\n      this.input.charCodeAt(next) === charCodes.comma ||\n      (tokenIsIdentifier(this.state.type) && hasFrom)\n    ) {\n      return true;\n    }\n    // lookahead again when `export default from` is seen\n    if (this.match(tt._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(\n        this.nextTokenStartSince(next + 4),\n      );\n      return (\n        nextAfterFrom === charCodes.quotationMark ||\n        nextAfterFrom === charCodes.apostrophe\n      );\n    }\n    return false;\n  }\n\n  parseExportFrom(node: N.ExportNamedDeclaration, expect?: boolean): void {\n    if (this.eatContextual(tt._from)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n      if (assertions) {\n        node.assertions = assertions;\n      }\n    } else if (expect) {\n      this.unexpected();\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration(): boolean {\n    const { type } = this.state;\n    if (type === tt.at) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          this.unexpected(this.state.start, Errors.DecoratorBeforeExport);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return (\n      type === tt._var ||\n      type === tt._const ||\n      type === tt._function ||\n      type === tt._class ||\n      this.isLet() ||\n      this.isAsyncFunction()\n    );\n  }\n\n  checkExport(\n    node: N.ExportNamedDeclaration,\n    checkNames?: boolean,\n    isDefault?: boolean,\n    isFrom?: boolean,\n  ): void {\n    if (checkNames) {\n      // Check for duplicate exports\n      if (isDefault) {\n        // Default exports\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          const declaration = ((node: any): N.ExportDefaultDeclaration)\n            .declaration;\n          if (\n            declaration.type === \"Identifier\" &&\n            declaration.name === \"from\" &&\n            declaration.end - declaration.start === 4 && // does not contain escape\n            !declaration.extra?.parenthesized\n          ) {\n            this.raise(declaration.start, Errors.ExportDefaultFromAsIdentifier);\n          }\n        }\n      } else if (node.specifiers && node.specifiers.length) {\n        // Named exports\n        for (const specifier of node.specifiers) {\n          const { exported } = specifier;\n          const exportedName =\n            exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportedName);\n          // $FlowIgnore\n          if (!isFrom && specifier.local) {\n            const { local } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(\n                specifier.start,\n                Errors.ExportBindingIsString,\n                local.value,\n                exportedName,\n              );\n            } else {\n              // check for keywords used as local names\n              this.checkReservedWord(local.name, local.start, true, false);\n              // check if export is defined\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        // Exported declarations\n        if (\n          node.declaration.type === \"FunctionDeclaration\" ||\n          node.declaration.type === \"ClassDeclaration\"\n        ) {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators =\n      this.state.decoratorStack[this.state.decoratorStack.length - 1];\n    // If node.declaration is a class, it will take all decorators in the current context.\n    // Thus we should throw if we see non-empty decorators here.\n    if (currentContextDecorators.length) {\n      throw this.raise(node.start, Errors.UnsupportedDecoratorExport);\n    }\n  }\n\n  checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(\n    node:\n      | N.Identifier\n      | N.StringLiteral\n      | N.ExportNamedDeclaration\n      | N.ExportSpecifier\n      | N.ExportDefaultSpecifier,\n    name: string,\n  ): void {\n    if (this.exportedIdentifiers.has(name)) {\n      this.raise(\n        node.start,\n        name === \"default\"\n          ? Errors.DuplicateDefaultExport\n          : Errors.DuplicateExport,\n        name,\n      );\n    }\n    this.exportedIdentifiers.add(name);\n  }\n\n  // Parses a comma-separated list of module exports.\n\n  parseExportSpecifiers(isInTypeExport: boolean): Array<N.ExportSpecifier> {\n    const nodes = [];\n    let first = true;\n\n    // export { x, y as z } [from '...']\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      const isString = this.match(tt.string);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(\n        this.parseExportSpecifier(\n          node,\n          isString,\n          isInTypeExport,\n          isMaybeTypeOnly,\n        ),\n      );\n    }\n\n    return nodes;\n  }\n\n  parseExportSpecifier(\n    node: any,\n    isString: boolean,\n    /* eslint-disable no-unused-vars -- used in TypeScript parser */\n    isInTypeExport: boolean,\n    isMaybeTypeOnly: boolean,\n    /* eslint-enable no-unused-vars */\n  ): N.ExportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleExportName\n  parseModuleExportName(): N.StringLiteral | N.Identifier {\n    if (this.match(tt.string)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(\n          result.start,\n          Errors.ModuleExportNameHasLoneSurrogate,\n          surrogate[0].charCodeAt(0).toString(16),\n        );\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n\n  // Parses import declaration.\n  // https://tc39.es/ecma262/#prod-ImportDeclaration\n\n  parseImport(node: N.Node): N.AnyImport {\n    // import '...'\n    node.specifiers = [];\n    if (!this.match(tt.string)) {\n      // check if we have a default import like\n      // import React from \"react\";\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      /* we are checking if we do not have a default import, then it is obvious that we need named imports\n       * import { get } from \"axios\";\n       * but if we do have a default import\n       * we need to check if we have a comma after that and\n       * that is where this `|| this.eat` condition comes into play\n       */\n      const parseNext = !hasDefault || this.eat(tt.comma);\n      // if we do have to parse the next set of specifiers, we first check for star imports\n      // import React, * from \"react\";\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      // now we check if we need to parse the next imports\n      // but only if they are not importing * (everything)\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(tt._from);\n    }\n    node.source = this.parseImportSource();\n    // https://github.com/tc39/proposal-import-assertions\n    // parse module import assertions if the next token is `assert` or ignore\n    // and finish the ImportDeclaration node.\n    const assertions = this.maybeParseImportAssertions();\n    if (assertions) {\n      node.assertions = assertions;\n    } else if (!process.env.BABEL_8_BREAKING) {\n      const attributes = this.maybeParseModuleAttributes();\n      if (attributes) {\n        node.attributes = attributes;\n      }\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource(): N.StringLiteral {\n    if (!this.match(tt.string)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  // eslint-disable-next-line no-unused-vars\n  shouldParseDefaultImport(node: N.ImportDeclaration): boolean {\n    return tokenIsIdentifier(this.state.type);\n  }\n\n  parseImportSpecifierLocal(\n    node: N.ImportDeclaration,\n    specifier: N.Node,\n    type: string,\n    contextDescription: string,\n  ): void {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  /**\n   * parse assert entries\n   *\n   * @see {@link https://tc39.es/proposal-import-assertions/#prod-AssertEntries |AssertEntries}\n   * @returns {N.ImportAttribute[]}\n   * @memberof StatementParser\n   */\n  parseAssertEntries(): N.ImportAttribute[] {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(tt.braceR)) {\n        break;\n      }\n\n      const node = this.startNode<N.ImportAttribute>();\n\n      // parse AssertionKey : IdentifierName, StringLiteral\n      const keyName = this.state.value;\n      // check if we already have an entry for an attribute\n      // if a duplicate entry is found, throw an error\n      // for now this logic will come into play only when someone declares `type` twice\n      if (attrNames.has(keyName)) {\n        this.raise(\n          this.state.start,\n          Errors.ModuleAttributesWithDuplicateKeys,\n          keyName,\n        );\n      }\n      attrNames.add(keyName);\n      if (this.match(tt.string)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(tt.colon);\n\n      if (!this.match(tt.string)) {\n        throw this.unexpected(\n          this.state.start,\n          Errors.ModuleAttributeInvalidValue,\n        );\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode<N.ImportAttribute>(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  /**\n   * parse module attributes\n   * @deprecated It will be removed in Babel 8\n   * @returns\n   * @memberof StatementParser\n   */\n  maybeParseModuleAttributes() {\n    if (this.match(tt._with) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(\n          node.key.start,\n          Errors.ModuleAttributeDifferentFromType,\n          node.key.name,\n        );\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(\n          node.key.start,\n          Errors.ModuleAttributesWithDuplicateKeys,\n          node.key.name,\n        );\n      }\n      attributes.add(node.key.name);\n      this.expect(tt.colon);\n      if (!this.match(tt.string)) {\n        throw this.unexpected(\n          this.state.start,\n          Errors.ModuleAttributeInvalidValue,\n        );\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    // [no LineTerminator here] AssertClause\n    if (this.isContextual(tt._assert) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next(); // eat `assert`\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n    // https://tc39.es/proposal-import-assertions/#prod-AssertClause\n    this.eat(tt.braceL);\n    const attrs = this.parseAssertEntries();\n    this.eat(tt.braceR);\n\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node: N.ImportDeclaration): boolean {\n    if (this.shouldParseDefaultImport(node)) {\n      // import defaultObj, { x, y as z } from '...'\n      this.parseImportSpecifierLocal(\n        node,\n        this.startNode(),\n        \"ImportDefaultSpecifier\",\n        \"default import specifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node: N.ImportDeclaration): boolean {\n    if (this.match(tt.star)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(tt._as);\n\n      this.parseImportSpecifierLocal(\n        node,\n        specifier,\n        \"ImportNamespaceSpecifier\",\n        \"import namespace specifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node: N.ImportDeclaration) {\n    let first = true;\n    this.expect(tt.braceL);\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        // Detect an attempt to deep destructure\n        if (this.eat(tt.colon)) {\n          throw this.raise(this.state.start, Errors.DestructureNamedImport);\n        }\n\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n\n      const specifier = this.startNode();\n      const importedIsString = this.match(tt.string);\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        node.importKind === \"type\" || node.importKind === \"typeof\",\n        isMaybeTypeOnly,\n      );\n      node.specifiers.push(importSpecifier);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportSpecifier\n  parseImportSpecifier(\n    specifier: any,\n    importedIsString: boolean,\n    /* eslint-disable no-unused-vars -- used in TypeScript and Flow parser */\n    isInTypeOnlyImport: boolean,\n    isMaybeTypeOnly: boolean,\n    /* eslint-enable no-unused-vars */\n  ): N.ImportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const { imported } = specifier;\n      if (importedIsString) {\n        throw this.raise(\n          specifier.start,\n          Errors.ImportBindingIsString,\n          imported.value,\n        );\n      }\n      this.checkReservedWord(imported.name, specifier.start, true, true);\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    this.checkLVal(specifier.local, \"import specifier\", BIND_LEXICAL);\n    return this.finishNode(specifier, \"ImportSpecifier\");\n  }\n\n  // This is used in flow and typescript plugin\n  // Determine whether a parameter is a this param\n  isThisParam(\n    param: N.Pattern | N.Identifier | N.TSParameterProperty,\n  ): boolean {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\n", "// @flow\n\nimport type { Options } from \"../options\";\nimport type { File /*::, JSXOpeningElement */ } from \"../types\";\nimport type { PluginList } from \"../plugin-utils\";\nimport { getOptions } from \"../options\";\nimport StatementParser from \"./statement\";\nimport ScopeHandler from \"../util/scope\";\n\nexport type PluginsMap = Map<string, { [string]: any }>;\n\nexport default class Parser extends StatementParser {\n  // Forward-declaration so typescript plugin can override jsx plugin\n  /*::\n  +jsxParseOpeningElementAfterName: (\n    node: JSXOpeningElement,\n  ) => JSXOpeningElement;\n  */\n\n  constructor(options: ?Options, input: string) {\n    options = getOptions(options);\n    super(options, input);\n\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  // This can be overwritten, for example, by the TypeScript plugin.\n  getScopeHandler(): Class<ScopeHandler<*>> {\n    return ScopeHandler;\n  }\n\n  parse(): File {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n}\n\nfunction pluginsMap(plugins: PluginList): PluginsMap {\n  const pluginMap: PluginsMap = new Map();\n  for (const plugin of plugins) {\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n  return pluginMap;\n}\n", "// @flow\n\nimport { type Options } from \"./options\";\nimport {\n  hasPlugin,\n  validatePlugins,\n  mixinPluginNames,\n  mixinPlugins,\n  type PluginList,\n} from \"./plugin-utils\";\nimport Parser from \"./parser\";\n\nimport { getExportedToken, tt as internalTokenTypes } from \"./tokenizer/types\";\nimport \"./tokenizer/context\";\n\nimport type { Expression, File } from \"./types\";\n\nexport function parse(input: string, options?: Options): File {\n  if (options?.sourceType === \"unambiguous\") {\n    options = {\n      ...options,\n    };\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        // Top level await introduces code which can be both a valid script and\n        // a valid module, but which produces different ASTs:\n        //    await\n        //    0\n        // can be parsed either as an AwaitExpression, or as two ExpressionStatements.\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch {}\n      } else {\n        // This is both a valid module and a valid script, but\n        // we parse it as a script by default\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\n\nexport function parseExpression(input: string, options?: Options): Expression {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\n\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\n\nexport const tokTypes = generateExportedTokenTypes(internalTokenTypes);\n\nfunction getParser(options: ?Options, input: string): Parser {\n  let cls = Parser;\n  if (options?.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache: { [key: string]: Class<Parser> } = {};\n\n/** Get a Parser class with plugins applied. */\nfunction getParserClass(pluginsFromOptions: PluginList): Class<Parser> {\n  const pluginList = mixinPluginNames.filter(name =>\n    hasPlugin(pluginsFromOptions, name),\n  );\n\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache[key] = cls;\n  }\n  return cls;\n}\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   \u201Csources\u201D entry.  This value is prepended to the individual\n    //   entries in the \u201Csource\u201D field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   \u201CsourceRoot\u201D, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n", "/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n", "// This entry is the \"full-build\" that includes both the runtime\n// and the compiler, and supports on-the-fly compilation of the template option.\nimport { initDev } from './dev'\nimport { compile, CompilerOptions, CompilerError } from '@vue/compiler-dom'\nimport { registerRuntimeCompiler, RenderFunction, warn } from '@vue/runtime-dom'\nimport * as runtimeDom from '@vue/runtime-dom'\nimport { isString, NOOP, generateCodeFrame, extend } from '@vue/shared'\nimport { InternalRenderFunction } from 'packages/runtime-core/src/component'\n\nif (__DEV__) {\n  console.log('111111111111111')\n  initDev()\n}\n\nconst compileCache: Record<string, RenderFunction> = Object.create(null)\n\nfunction compileToFunction(\n  template: string | HTMLElement,\n  options?: CompilerOptions\n): RenderFunction {\n  if (!isString(template)) {\n    if (template.nodeType) {\n      template = template.innerHTML\n    } else {\n      __DEV__ && warn(`invalid template option: `, template)\n      return NOOP\n    }\n  }\n\n  const key = template\n  const cached = compileCache[key]\n  if (cached) {\n    return cached\n  }\n\n  if (template[0] === '#') {\n    const el = document.querySelector(template)\n    if (__DEV__ && !el) {\n      warn(`Template element not found or is empty: ${template}`)\n    }\n    // __UNSAFE__\n    // Reason: potential execution of JS expressions in in-DOM template.\n    // The user must make sure the in-DOM template is trusted. If it's rendered\n    // by the server, the template should not contain any user data.\n    template = el ? el.innerHTML : ``\n  }\n\n  const { code } = compile(\n    template,\n    extend(\n      {\n        hoistStatic: true,\n        onError: __DEV__ ? onError : undefined,\n        onWarn: __DEV__ ? e => onError(e, true) : NOOP\n      } as CompilerOptions,\n      options\n    )\n  )\n\n  function onError(err: CompilerError, asWarning = false) {\n    const message = asWarning\n      ? err.message\n      : `Template compilation error: ${err.message}`\n    const codeFrame =\n      err.loc &&\n      generateCodeFrame(\n        template as string,\n        err.loc.start.offset,\n        err.loc.end.offset\n      )\n    warn(codeFrame ? `${message}\\n${codeFrame}` : message)\n  }\n\n  // The wildcard import results in a huge object with every export\n  // with keys that cannot be mangled, and can be quite heavy size-wise.\n  // In the global build we know `Vue` is available globally so we can avoid\n  // the wildcard object.\n  const render = (\n    __GLOBAL__ ? new Function(code)() : new Function('Vue', code)(runtimeDom)\n  ) as RenderFunction\n\n  // mark the function as runtime compiled\n  ;(render as InternalRenderFunction)._rc = true\n\n  return (compileCache[key] = render)\n}\n\nregisterRuntimeCompiler(compileToFunction)\n\nexport { compileToFunction as compile }\nexport * from '@vue/runtime-dom'\n", "// using literal strings instead of numbers so that it's easier to inspect\n// debugger events\n\nexport const enum TrackOpTypes {\n  GET = 'get',\n  HAS = 'has',\n  ITERATE = 'iterate'\n}\n\nexport const enum TriggerOpTypes {\n  SET = 'set',\n  ADD = 'add',\n  DELETE = 'delete',\n  CLEAR = 'clear'\n}\n", "/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nexport function makeMap(\n  str: string,\n  expectsLowerCase?: boolean\n): (key: string) => boolean {\n  const map: Record<string, boolean> = Object.create(null)\n  const list: Array<string> = str.split(',')\n  for (let i = 0; i < list.length; i++) {\n    map[list[i]] = true\n  }\n  return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val]\n}\n", "/**\n * Patch flags are optimization hints generated by the compiler.\n * when a block with dynamicChildren is encountered during diff, the algorithm\n * enters \"optimized mode\". In this mode, we know that the vdom is produced by\n * a render function generated by the compiler, so the algorithm only needs to\n * handle updates explicitly marked by these patch flags.\n *\n * Patch flags can be combined using the | bitwise operator and can be checked\n * using the & operator, e.g.\n *\n * ```js\n * const flag = TEXT | CLASS\n * if (flag & TEXT) { ... }\n * ```\n *\n * Check the `patchElement` function in '../../runtime-core/src/renderer.ts' to see how the\n * flags are handled during diff.\n */\nexport const enum PatchFlags {\n  /**\n   * Indicates an element with dynamic textContent (children fast path)\n   */\n  TEXT = 1,\n\n  /**\n   * Indicates an element with dynamic class binding.\n   */\n  CLASS = 1 << 1,\n\n  /**\n   * Indicates an element with dynamic style\n   * The compiler pre-compiles static string styles into static objects\n   * + detects and hoists inline static objects\n   * e.g. `style=\"color: red\"` and `:style=\"{ color: 'red' }\"` both get hoisted\n   * as:\n   * ```js\n   * const style = { color: 'red' }\n   * render() { return e('div', { style }) }\n   * ```\n   */\n  STYLE = 1 << 2,\n\n  /**\n   * Indicates an element that has non-class/style dynamic props.\n   * Can also be on a component that has any dynamic props (includes\n   * class/style). when this flag is present, the vnode also has a dynamicProps\n   * array that contains the keys of the props that may change so the runtime\n   * can diff them faster (without having to worry about removed props)\n   */\n  PROPS = 1 << 3,\n\n  /**\n   * Indicates an element with props with dynamic keys. When keys change, a full\n   * diff is always needed to remove the old key. This flag is mutually\n   * exclusive with CLASS, STYLE and PROPS.\n   */\n  FULL_PROPS = 1 << 4,\n\n  /**\n   * Indicates an element with event listeners (which need to be attached\n   * during hydration)\n   */\n  HYDRATE_EVENTS = 1 << 5,\n\n  /**\n   * Indicates a fragment whose children order doesn't change.\n   */\n  STABLE_FRAGMENT = 1 << 6,\n\n  /**\n   * Indicates a fragment with keyed or partially keyed children\n   */\n  KEYED_FRAGMENT = 1 << 7,\n\n  /**\n   * Indicates a fragment with unkeyed children.\n   */\n  UNKEYED_FRAGMENT = 1 << 8,\n\n  /**\n   * Indicates an element that only needs non-props patching, e.g. ref or\n   * directives (onVnodeXXX hooks). since every patched vnode checks for refs\n   * and onVnodeXXX hooks, it simply marks the vnode so that a parent block\n   * will track it.\n   */\n  NEED_PATCH = 1 << 9,\n\n  /**\n   * Indicates a component with dynamic slots (e.g. slot that references a v-for\n   * iterated value, or dynamic slot names).\n   * Components with this flag are always force updated.\n   */\n  DYNAMIC_SLOTS = 1 << 10,\n\n  /**\n   * Indicates a fragment that was created only because the user has placed\n   * comments at the root level of a template. This is a dev-only flag since\n   * comments are stripped in production.\n   */\n  DEV_ROOT_FRAGMENT = 1 << 11,\n\n  /**\n   * SPECIAL FLAGS -------------------------------------------------------------\n   * Special flags are negative integers. They are never matched against using\n   * bitwise operators (bitwise matching should only happen in branches where\n   * patchFlag > 0), and are mutually exclusive. When checking for a special\n   * flag, simply check patchFlag === FLAG.\n   */\n\n  /**\n   * Indicates a hoisted static vnode. This is a hint for hydration to skip\n   * the entire sub tree since static content never needs to be updated.\n   */\n  HOISTED = -1,\n  /**\n   * A special flag that indicates that the diffing algorithm should bail out\n   * of optimized mode. For example, on block fragments created by renderSlot()\n   * when encountering non-compiler generated slots (i.e. manually written\n   * render functions, which should always be fully diffed)\n   * OR manually cloneVNodes\n   */\n  BAIL = -2\n}\n\n/**\n * dev only flag -> name mapping\n */\nexport const PatchFlagNames = {\n  [PatchFlags.TEXT]: `TEXT`,\n  [PatchFlags.CLASS]: `CLASS`,\n  [PatchFlags.STYLE]: `STYLE`,\n  [PatchFlags.PROPS]: `PROPS`,\n  [PatchFlags.FULL_PROPS]: `FULL_PROPS`,\n  [PatchFlags.HYDRATE_EVENTS]: `HYDRATE_EVENTS`,\n  [PatchFlags.STABLE_FRAGMENT]: `STABLE_FRAGMENT`,\n  [PatchFlags.KEYED_FRAGMENT]: `KEYED_FRAGMENT`,\n  [PatchFlags.UNKEYED_FRAGMENT]: `UNKEYED_FRAGMENT`,\n  [PatchFlags.NEED_PATCH]: `NEED_PATCH`,\n  [PatchFlags.DYNAMIC_SLOTS]: `DYNAMIC_SLOTS`,\n  [PatchFlags.DEV_ROOT_FRAGMENT]: `DEV_ROOT_FRAGMENT`,\n  [PatchFlags.HOISTED]: `HOISTED`,\n  [PatchFlags.BAIL]: `BAIL`\n}\n", "export const enum SlotFlags {\n  /**\n   * Stable slots that only reference slot props or context state. The slot\n   * can fully capture its own dependencies so when passed down the parent won't\n   * need to force the child to update.\n   */\n  STABLE = 1,\n  /**\n   * Slots that reference scope variables (v-for or an outer slot prop), or\n   * has conditional structure (v-if, v-for). The parent will need to force\n   * the child to update because the slot does not fully capture its dependencies.\n   */\n  DYNAMIC = 2,\n  /**\n   * `<slot/>` being forwarded into a child component. Whether the parent needs\n   * to update the child is dependent on what kind of slots the parent itself\n   * received. This has to be refined at runtime, when the child's vnode\n   * is being created (in `normalizeChildren`)\n   */\n  FORWARDED = 3\n}\n\n/**\n * Dev only\n */\nexport const slotFlagsText = {\n  [SlotFlags.STABLE]: 'STABLE',\n  [SlotFlags.DYNAMIC]: 'DYNAMIC',\n  [SlotFlags.FORWARDED]: 'FORWARDED'\n}\n", "import { makeMap } from './makeMap'\n\nconst GLOBALS_WHITE_LISTED =\n  'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n  'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n  'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt'\n\nexport const isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED)\n", "const range: number = 2\n\nexport function generateCodeFrame(\n  source: string,\n  start = 0,\n  end = source.length\n): string {\n  // Split the content into individual lines but capture the newline sequence\n  // that separated each line. This is important because the actual sequence is\n  // needed to properly take into account the full line length for offset\n  // comparison\n  let lines = source.split(/(\\r?\\n)/)\n\n  // Separate the lines and newline sequences into separate arrays for easier referencing\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1)\n  lines = lines.filter((_, idx) => idx % 2 === 0)\n\n  let count = 0\n  const res: string[] = []\n  for (let i = 0; i < lines.length; i++) {\n    count +=\n      lines[i].length +\n      ((newlineSequences[i] && newlineSequences[i].length) || 0)\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length) continue\n        const line = j + 1\n        res.push(\n          `${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${\n            lines[j]\n          }`\n        )\n        const lineLength = lines[j].length\n        const newLineSeqLength =\n          (newlineSequences[j] && newlineSequences[j].length) || 0\n\n        if (j === i) {\n          // push underline\n          const pad = start - (count - (lineLength + newLineSeqLength))\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          )\n          res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length))\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1)\n            res.push(`   |  ` + '^'.repeat(length))\n          }\n\n          count += lineLength + newLineSeqLength\n        }\n      }\n      break\n    }\n  }\n  return res.join('\\n')\n}\n", "import { makeMap } from './makeMap'\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`\nexport const isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs)\n\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nexport const isBooleanAttr = /*#__PURE__*/ makeMap(\n  specialBooleanAttrs +\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n    `loop,open,required,reversed,scoped,seamless,` +\n    `checked,muted,multiple,selected`\n)\n\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nexport function includeBooleanAttr(value: unknown): boolean {\n  return !!value || value === ''\n}\n\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/\nconst attrValidationCache: Record<string, boolean> = {}\n\nexport function isSSRSafeAttrName(name: string): boolean {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name]\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name)\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`)\n  }\n  return (attrValidationCache[name] = !isUnsafe)\n}\n\nexport const propsToAttrMap: Record<string, string | undefined> = {\n  acceptCharset: 'accept-charset',\n  className: 'class',\n  htmlFor: 'for',\n  httpEquiv: 'http-equiv'\n}\n\n/**\n * CSS properties that accept plain numbers\n */\nexport const isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(\n  `animation-iteration-count,border-image-outset,border-image-slice,` +\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\n    // SVG\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width`\n)\n\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nexport const isKnownHtmlAttr = /*#__PURE__*/ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,` +\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\n    `value,width,wrap`\n)\n\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nexport const isKnownSvgAttr = /*#__PURE__*/ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\n    `color-interpolation-filters,color-profile,color-rendering,` +\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n)\n", "import { isArray, isString, isObject, hyphenate } from './'\nimport { isNoUnitNumericStyleProp } from './domAttrConfig'\n\nexport type NormalizedStyle = Record<string, string | number>\n\nexport function normalizeStyle(\n  value: unknown\n): NormalizedStyle | string | undefined {\n  if (isArray(value)) {\n    const res: NormalizedStyle = {}\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      const normalized = isString(item)\n        ? parseStringStyle(item)\n        : (normalizeStyle(item) as NormalizedStyle)\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key]\n        }\n      }\n    }\n    return res\n  } else if (isString(value)) {\n    return value\n  } else if (isObject(value)) {\n    return value\n  }\n}\n\nconst listDelimiterRE = /;(?![^(]*\\))/g\nconst propertyDelimiterRE = /:(.+)/\n\nexport function parseStringStyle(cssText: string): NormalizedStyle {\n  const ret: NormalizedStyle = {}\n  cssText.split(listDelimiterRE).forEach(item => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE)\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim())\n    }\n  })\n  return ret\n}\n\nexport function stringifyStyle(\n  styles: NormalizedStyle | string | undefined\n): string {\n  let ret = ''\n  if (!styles || isString(styles)) {\n    return ret\n  }\n  for (const key in styles) {\n    const value = styles[key]\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key)\n    if (\n      isString(value) ||\n      (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))\n    ) {\n      // only render valid values\n      ret += `${normalizedKey}:${value};`\n    }\n  }\n  return ret\n}\n\nexport function normalizeClass(value: unknown): string {\n  let res = ''\n  if (isString(value)) {\n    res = value\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i])\n      if (normalized) {\n        res += normalized + ' '\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + ' '\n      }\n    }\n  }\n  return res.trim()\n}\n\nexport function normalizeProps(props: Record<string, any> | null) {\n  if (!props) return null\n  let { class: klass, style } = props\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass)\n  }\n  if (style) {\n    props.style = normalizeStyle(style)\n  }\n  return props\n}\n", "// These tag configs are shared between compiler-dom and runtime-dom, so they\n// must be extracted in shared to avoid creating a dependency between the two.\nimport { makeMap } from './makeMap'\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS =\n  'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n  'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n  'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n  'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n  'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n  'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n  'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n  'option,output,progress,select,textarea,details,dialog,menu,' +\n  'summary,template,blockquote,iframe,tfoot'\n\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS =\n  'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n  'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n  'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n  'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n  'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n  'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n  'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n  'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n  'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n  'text,textPath,title,tspan,unknown,use,view'\n\nconst VOID_TAGS =\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr'\n\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\n */\nexport const isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS)\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\n */\nexport const isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS)\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `__DEV__` flag.\n */\nexport const isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS)\n", "import { isArray, isDate, isObject } from './'\n\nfunction looseCompareArrays(a: any[], b: any[]) {\n  if (a.length !== b.length) return false\n  let equal = true\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i])\n  }\n  return equal\n}\n\nexport function looseEqual(a: any, b: any): boolean {\n  if (a === b) return true\n  let aValidType = isDate(a)\n  let bValidType = isDate(b)\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false\n  }\n  aValidType = isArray(a)\n  bValidType = isArray(b)\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false\n  }\n  aValidType = isObject(a)\n  bValidType = isObject(b)\n  if (aValidType || bValidType) {\n    /* istanbul ignore if: this if will probably never be called */\n    if (!aValidType || !bValidType) {\n      return false\n    }\n    const aKeysCount = Object.keys(a).length\n    const bKeysCount = Object.keys(b).length\n    if (aKeysCount !== bKeysCount) {\n      return false\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key)\n      const bHasKey = b.hasOwnProperty(key)\n      if (\n        (aHasKey && !bHasKey) ||\n        (!aHasKey && bHasKey) ||\n        !looseEqual(a[key], b[key])\n      ) {\n        return false\n      }\n    }\n  }\n  return String(a) === String(b)\n}\n\nexport function looseIndexOf(arr: any[], val: any): number {\n  return arr.findIndex(item => looseEqual(item, val))\n}\n", "import {\n  isArray,\n  isMap,\n  isObject,\n  isFunction,\n  isPlainObject,\n  isSet,\n  objectToString,\n  isString\n} from './index'\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nexport const toDisplayString = (val: unknown): string => {\n  return isString(val)\n    ? val\n    : val == null\n    ? ''\n    : isArray(val) ||\n      (isObject(val) &&\n        (val.toString === objectToString || !isFunction(val.toString)))\n    ? JSON.stringify(val, replacer, 2)\n    : String(val)\n}\n\nconst replacer = (_key: string, val: any): any => {\n  // can't use isRef here since @vue/shared has no deps\n  if (val && val.__v_isRef) {\n    return replacer(_key, val.value)\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n        ;(entries as any)[`${key} =>`] = val\n        return entries\n      }, {})\n    }\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()]\n    }\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val)\n  }\n  return val\n}\n", "import { makeMap } from './makeMap'\n\nexport { makeMap }\nexport * from './patchFlags'\nexport * from './shapeFlags'\nexport * from './slotFlags'\nexport * from './globalsWhitelist'\nexport * from './codeframe'\nexport * from './normalizeProp'\nexport * from './domTagConfig'\nexport * from './domAttrConfig'\nexport * from './escapeHtml'\nexport * from './looseEqual'\nexport * from './toDisplayString'\nexport * from './typeUtils'\n\nexport const EMPTY_OBJ: { readonly [key: string]: any } = __DEV__\n  ? Object.freeze({})\n  : {}\nexport const EMPTY_ARR = __DEV__ ? Object.freeze([]) : []\n\nexport const NOOP = () => {}\n\n/**\n * Always return false.\n */\nexport const NO = () => false\n\nconst onRE = /^on[^a-z]/\nexport const isOn = (key: string) => onRE.test(key)\n\nexport const isModelListener = (key: string) => key.startsWith('onUpdate:')\n\nexport const extend = Object.assign\n\nexport const remove = <T>(arr: T[], el: T) => {\n  const i = arr.indexOf(el)\n  if (i > -1) {\n    arr.splice(i, 1)\n  }\n}\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (\n  val: object,\n  key: string | symbol\n): key is keyof typeof val => hasOwnProperty.call(val, key)\n\nexport const isArray = Array.isArray\nexport const isMap = (val: unknown): val is Map<any, any> =>\n  toTypeString(val) === '[object Map]'\nexport const isSet = (val: unknown): val is Set<any> =>\n  toTypeString(val) === '[object Set]'\n\nexport const isDate = (val: unknown): val is Date => val instanceof Date\nexport const isFunction = (val: unknown): val is Function =>\n  typeof val === 'function'\nexport const isString = (val: unknown): val is string => typeof val === 'string'\nexport const isSymbol = (val: unknown): val is symbol => typeof val === 'symbol'\nexport const isObject = (val: unknown): val is Record<any, any> =>\n  val !== null && typeof val === 'object'\n\nexport const isPromise = <T = any>(val: unknown): val is Promise<T> => {\n  return isObject(val) && isFunction(val.then) && isFunction(val.catch)\n}\n\nexport const objectToString = Object.prototype.toString\nexport const toTypeString = (value: unknown): string =>\n  objectToString.call(value)\n\nexport const toRawType = (value: unknown): string => {\n  // extract \"RawType\" from strings like \"[object RawType]\"\n  return toTypeString(value).slice(8, -1)\n}\n\nexport const isPlainObject = (val: unknown): val is object =>\n  toTypeString(val) === '[object Object]'\n\nexport const isIntegerKey = (key: unknown) =>\n  isString(key) &&\n  key !== 'NaN' &&\n  key[0] !== '-' &&\n  '' + parseInt(key, 10) === key\n\nexport const isReservedProp = /*#__PURE__*/ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  ',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted'\n)\n\nexport const isBuiltInDirective = /*#__PURE__*/ makeMap(\n  'bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo'\n)\n\nconst cacheStringFunction = <T extends (str: string) => string>(fn: T): T => {\n  const cache: Record<string, string> = Object.create(null)\n  return ((str: string) => {\n    const hit = cache[str]\n    return hit || (cache[str] = fn(str))\n  }) as any\n}\n\nconst camelizeRE = /-(\\w)/g\n/**\n * @private\n */\nexport const camelize = cacheStringFunction((str: string): string => {\n  return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''))\n})\n\nconst hyphenateRE = /\\B([A-Z])/g\n/**\n * @private\n */\nexport const hyphenate = cacheStringFunction((str: string) =>\n  str.replace(hyphenateRE, '-$1').toLowerCase()\n)\n\n/**\n * @private\n */\nexport const capitalize = cacheStringFunction(\n  (str: string) => str.charAt(0).toUpperCase() + str.slice(1)\n)\n\n/**\n * @private\n */\nexport const toHandlerKey = cacheStringFunction((str: string) =>\n  str ? `on${capitalize(str)}` : ``\n)\n\n// compare whether a value has changed, accounting for NaN.\nexport const hasChanged = (value: any, oldValue: any): boolean =>\n  !Object.is(value, oldValue)\n\nexport const invokeArrayFns = (fns: Function[], arg?: any) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg)\n  }\n}\n\nexport const def = (obj: object, key: string | symbol, value: any) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  })\n}\n\nexport const toNumber = (val: any): any => {\n  const n = parseFloat(val)\n  return isNaN(n) ? val : n\n}\n\nlet _globalThis: any\nexport const getGlobalThis = (): any => {\n  return (\n    _globalThis ||\n    (_globalThis =\n      typeof globalThis !== 'undefined'\n        ? globalThis\n        : typeof self !== 'undefined'\n        ? self\n        : typeof window !== 'undefined'\n        ? window\n        : typeof global !== 'undefined'\n        ? global\n        : {})\n  )\n}\n", "export function warn(msg: string, ...args: any[]) {\n  console.warn(`[Vue warn] ${msg}`, ...args)\n}\n", "import { ReactiveEffect } from './effect'\nimport { warn } from './warning'\n\nlet activeEffectScope: EffectScope | undefined\n\nexport class EffectScope {\n  active = true\n  effects: ReactiveEffect[] = []\n  cleanups: (() => void)[] = []\n\n  parent: EffectScope | undefined\n  scopes: EffectScope[] | undefined\n  /**\n   * track a child scope's index in its parent's scopes array for optimized\n   * removal\n   */\n  private index: number | undefined\n\n  constructor(detached = false) {\n    if (!detached && activeEffectScope) {\n      this.parent = activeEffectScope\n      this.index =\n        (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n          this\n        ) - 1\n    }\n  }\n\n  run<T>(fn: () => T): T | undefined {\n    if (this.active) {\n      try {\n        activeEffectScope = this\n        return fn()\n      } finally {\n        activeEffectScope = this.parent\n      }\n    } else if (__DEV__) {\n      warn(`cannot run an inactive effect scope.`)\n    }\n  }\n\n  on() {\n    activeEffectScope = this\n  }\n\n  off() {\n    activeEffectScope = this.parent\n  }\n\n  stop(fromParent?: boolean) {\n    if (this.active) {\n      let i, l\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop()\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]()\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true)\n        }\n      }\n      // nested scope, dereference from parent to avoid memory leaks\n      if (this.parent && !fromParent) {\n        // optimized O(1) removal\n        const last = this.parent.scopes!.pop()\n        if (last && last !== this) {\n          this.parent.scopes![this.index!] = last\n          last.index = this.index!\n        }\n      }\n      this.active = false\n    }\n  }\n}\n\nexport function effectScope(detached?: boolean) {\n  return new EffectScope(detached)\n}\n\nexport function recordEffectScope(\n  effect: ReactiveEffect,\n  scope: EffectScope | undefined = activeEffectScope\n) {\n  if (scope && scope.active) {\n    scope.effects.push(effect)\n  }\n}\n\nexport function getCurrentScope() {\n  return activeEffectScope\n}\n\nexport function onScopeDispose(fn: () => void) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn)\n  } else if (__DEV__) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope` +\n        ` to be associated with.`\n    )\n  }\n}\n", "import { ReactiveEffect, trackOpBit } from './effect'\n\nexport type Dep = Set<ReactiveEffect> & TrackedMarkers\n\n/**\n * wasTracked and newTracked maintain the status for several levels of effect\n * tracking recursion. One bit per level is used to define whether the dependency\n * was/is tracked.\n */\ntype TrackedMarkers = {\n  /**\n   * wasTracked\n   */\n  w: number\n  /**\n   * newTracked\n   */\n  n: number\n}\n\nexport const createDep = (effects?: ReactiveEffect[]): Dep => {\n  const dep = new Set<ReactiveEffect>(effects) as Dep\n  dep.w = 0\n  dep.n = 0\n  return dep\n}\n\nexport const wasTracked = (dep: Dep): boolean => (dep.w & trackOpBit) > 0\n\nexport const newTracked = (dep: Dep): boolean => (dep.n & trackOpBit) > 0\n\nexport const initDepMarkers = ({ deps }: ReactiveEffect) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit // set was tracked\n    }\n  }\n}\n\nexport const finalizeDepMarkers = (effect: ReactiveEffect) => {\n  const { deps } = effect\n  if (deps.length) {\n    let ptr = 0\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i]\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect)\n      } else {\n        deps[ptr++] = dep\n      }\n      // clear bits\n      dep.w &= ~trackOpBit\n      dep.n &= ~trackOpBit\n    }\n    deps.length = ptr\n  }\n}\n", "import { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { extend, isArray, isIntegerKey, isMap } from '@vue/shared'\nimport { EffectScope, recordEffectScope } from './effectScope'\nimport {\n  createDep,\n  Dep,\n  finalizeDepMarkers,\n  initDepMarkers,\n  newTracked,\n  wasTracked\n} from './dep'\nimport { ComputedRefImpl } from './computed'\n\n// The main WeakMap that stores {target -> key -> dep} connections.\n// Conceptually, it's easier to think of a dependency as a Dep class\n// which maintains a Set of subscribers, but we simply store them as\n// raw Sets to reduce memory overhead.\ntype KeyToDepMap = Map<any, Dep>\nconst targetMap = new WeakMap<any, KeyToDepMap>()\n\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0\n\nexport let trackOpBit = 1\n\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30\n\nexport type EffectScheduler = (...args: any[]) => any\n\nexport type DebuggerEvent = {\n  effect: ReactiveEffect\n} & DebuggerEventExtraInfo\n\nexport type DebuggerEventExtraInfo = {\n  target: object\n  type: TrackOpTypes | TriggerOpTypes\n  key: any\n  newValue?: any\n  oldValue?: any\n  oldTarget?: Map<any, any> | Set<any>\n}\n\nexport let activeEffect: ReactiveEffect | undefined\n\nexport const ITERATE_KEY = Symbol(__DEV__ ? 'iterate' : '')\nexport const MAP_KEY_ITERATE_KEY = Symbol(__DEV__ ? 'Map key iterate' : '')\n\nexport class ReactiveEffect<T = any> {\n  active = true\n  deps: Dep[] = []\n  parent: ReactiveEffect | undefined = undefined\n\n  /**\n   * Can be attached after creation\n   * @internal\n   */\n  computed?: ComputedRefImpl<T>\n  /**\n   * @internal\n   */\n  allowRecurse?: boolean\n\n  onStop?: () => void\n  // dev only\n  onTrack?: (event: DebuggerEvent) => void\n  // dev only\n  onTrigger?: (event: DebuggerEvent) => void\n\n  constructor(\n    public fn: () => T,\n    public scheduler: EffectScheduler | null = null,\n    scope?: EffectScope\n  ) {\n    recordEffectScope(this, scope)\n  }\n\n  run() {\n    if (!this.active) {\n      return this.fn()\n    }\n    let parent: ReactiveEffect | undefined = activeEffect\n    let lastShouldTrack = shouldTrack\n    while (parent) {\n      if (parent === this) {\n        return\n      }\n      parent = parent.parent\n    }\n    try {\n      this.parent = activeEffect\n      activeEffect = this\n      shouldTrack = true\n\n      trackOpBit = 1 << ++effectTrackDepth\n\n      if (effectTrackDepth <= maxMarkerBits) {\n        initDepMarkers(this)\n      } else {\n        cleanupEffect(this)\n      }\n      return this.fn()\n    } finally {\n      if (effectTrackDepth <= maxMarkerBits) {\n        finalizeDepMarkers(this)\n      }\n\n      trackOpBit = 1 << --effectTrackDepth\n\n      activeEffect = this.parent\n      shouldTrack = lastShouldTrack\n      this.parent = undefined\n    }\n  }\n\n  stop() {\n    if (this.active) {\n      cleanupEffect(this)\n      if (this.onStop) {\n        this.onStop()\n      }\n      this.active = false\n    }\n  }\n}\n\nfunction cleanupEffect(effect: ReactiveEffect) {\n  const { deps } = effect\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect)\n    }\n    deps.length = 0\n  }\n}\n\nexport interface DebuggerOptions {\n  onTrack?: (event: DebuggerEvent) => void\n  onTrigger?: (event: DebuggerEvent) => void\n}\n\nexport interface ReactiveEffectOptions extends DebuggerOptions {\n  lazy?: boolean\n  scheduler?: EffectScheduler\n  scope?: EffectScope\n  allowRecurse?: boolean\n  onStop?: () => void\n}\n\nexport interface ReactiveEffectRunner<T = any> {\n  (): T\n  effect: ReactiveEffect\n}\n\nexport function effect<T = any>(\n  fn: () => T,\n  options?: ReactiveEffectOptions\n): ReactiveEffectRunner {\n  if ((fn as ReactiveEffectRunner).effect) {\n    fn = (fn as ReactiveEffectRunner).effect.fn\n  }\n\n  const _effect = new ReactiveEffect(fn)\n  if (options) {\n    extend(_effect, options)\n    if (options.scope) recordEffectScope(_effect, options.scope)\n  }\n  if (!options || !options.lazy) {\n    _effect.run()\n  }\n  const runner = _effect.run.bind(_effect) as ReactiveEffectRunner\n  runner.effect = _effect\n  return runner\n}\n\nexport function stop(runner: ReactiveEffectRunner) {\n  runner.effect.stop()\n}\n\nexport let shouldTrack = true\nconst trackStack: boolean[] = []\n\nexport function pauseTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = false\n}\n\nexport function enableTracking() {\n  trackStack.push(shouldTrack)\n  shouldTrack = true\n}\n\nexport function resetTracking() {\n  const last = trackStack.pop()\n  shouldTrack = last === undefined ? true : last\n}\n\nexport function track(target: object, type: TrackOpTypes, key: unknown) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target)\n    if (!depsMap) {\n      targetMap.set(target, (depsMap = new Map()))\n    }\n    let dep = depsMap.get(key)\n    if (!dep) {\n      depsMap.set(key, (dep = createDep()))\n    }\n\n    const eventInfo = __DEV__\n      ? { effect: activeEffect, target, type, key }\n      : undefined\n\n    trackEffects(dep, eventInfo)\n  }\n}\n\nexport function trackEffects(\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\n) {\n  let shouldTrack = false\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit // set newly tracked\n      shouldTrack = !wasTracked(dep)\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect!)\n  }\n\n  if (shouldTrack) {\n    dep.add(activeEffect!)\n    activeEffect!.deps.push(dep)\n    if (__DEV__ && activeEffect!.onTrack) {\n      activeEffect!.onTrack(\n        Object.assign(\n          {\n            effect: activeEffect!\n          },\n          debuggerEventExtraInfo\n        )\n      )\n    }\n  }\n}\n\nexport function trigger(\n  target: object,\n  type: TriggerOpTypes,\n  key?: unknown,\n  newValue?: unknown,\n  oldValue?: unknown,\n  oldTarget?: Map<unknown, unknown> | Set<unknown>\n) {\n  const depsMap = targetMap.get(target)\n  if (!depsMap) {\n    // never been tracked\n    return\n  }\n\n  let deps: (Dep | undefined)[] = []\n  if (type === TriggerOpTypes.CLEAR) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = [...depsMap.values()]\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= (newValue as number)) {\n        deps.push(dep)\n      }\n    })\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key))\n    }\n\n    // also run for iteration key on ADD | DELETE | Map.SET\n    switch (type) {\n      case TriggerOpTypes.ADD:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'))\n        }\n        break\n      case TriggerOpTypes.DELETE:\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY))\n          }\n        }\n        break\n      case TriggerOpTypes.SET:\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY))\n        }\n        break\n    }\n  }\n\n  const eventInfo = __DEV__\n    ? { target, type, key, newValue, oldValue, oldTarget }\n    : undefined\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (__DEV__) {\n        triggerEffects(deps[0], eventInfo)\n      } else {\n        triggerEffects(deps[0])\n      }\n    }\n  } else {\n    const effects: ReactiveEffect[] = []\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep)\n      }\n    }\n    if (__DEV__) {\n      triggerEffects(createDep(effects), eventInfo)\n    } else {\n      triggerEffects(createDep(effects))\n    }\n  }\n}\n\nexport function triggerEffects(\n  dep: Dep | ReactiveEffect[],\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo\n) {\n  // spread into array for stabilization\n  for (const effect of isArray(dep) ? dep : [...dep]) {\n    if (effect !== activeEffect || effect.allowRecurse) {\n      if (__DEV__ && effect.onTrigger) {\n        effect.onTrigger(extend({ effect }, debuggerEventExtraInfo))\n      }\n      if (effect.scheduler) {\n        effect.scheduler()\n      } else {\n        effect.run()\n      }\n    }\n  }\n}\n", "import {\n  reactive,\n  readonly,\n  toRaw,\n  ReactiveFlags,\n  Target,\n  readonlyMap,\n  reactiveMap,\n  shallowReactiveMap,\n  shallowReadonlyMap,\n  isReadonly,\n  isShallow\n} from './reactive'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport {\n  track,\n  trigger,\n  ITERATE_KEY,\n  pauseTracking,\n  resetTracking\n} from './effect'\nimport {\n  isObject,\n  hasOwn,\n  isSymbol,\n  hasChanged,\n  isArray,\n  isIntegerKey,\n  extend,\n  makeMap\n} from '@vue/shared'\nimport { isRef } from './ref'\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`)\n\nconst builtInSymbols = new Set(\n  Object.getOwnPropertyNames(Symbol)\n    .map(key => (Symbol as any)[key])\n    .filter(isSymbol)\n)\n\nconst get = /*#__PURE__*/ createGetter()\nconst shallowGet = /*#__PURE__*/ createGetter(false, true)\nconst readonlyGet = /*#__PURE__*/ createGetter(true)\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true)\n\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations()\n\nfunction createArrayInstrumentations() {\n  const instrumentations: Record<string, Function> = {}\n  // instrument identity-sensitive Array methods to account for possible reactive\n  // values\n  ;(['includes', 'indexOf', 'lastIndexOf'] as const).forEach(key => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      const arr = toRaw(this) as any\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, TrackOpTypes.GET, i + '')\n      }\n      // we run the method using the original args first (which may be reactive)\n      const res = arr[key](...args)\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key](...args.map(toRaw))\n      } else {\n        return res\n      }\n    }\n  })\n  // instrument length-altering mutation methods to avoid length being tracked\n  // which leads to infinite loops in some cases (#2137)\n  ;(['push', 'pop', 'shift', 'unshift', 'splice'] as const).forEach(key => {\n    instrumentations[key] = function (this: unknown[], ...args: unknown[]) {\n      pauseTracking()\n      const res = (toRaw(this) as any)[key].apply(this, args)\n      resetTracking()\n      return res\n    }\n  })\n  return instrumentations\n}\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target: Target, key: string | symbol, receiver: object) {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.IS_SHALLOW) {\n      return shallow\n    } else if (\n      key === ReactiveFlags.RAW &&\n      receiver ===\n        (isReadonly\n          ? shallow\n            ? shallowReadonlyMap\n            : readonlyMap\n          : shallow\n          ? shallowReactiveMap\n          : reactiveMap\n        ).get(target)\n    ) {\n      return target\n    }\n\n    const targetIsArray = isArray(target)\n\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver)\n    }\n\n    const res = Reflect.get(target, key, receiver)\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res\n    }\n\n    if (!isReadonly) {\n      track(target, TrackOpTypes.GET, key)\n    }\n\n    if (shallow) {\n      return res\n    }\n\n    if (isRef(res)) {\n      // ref unwrapping - does not apply for Array + integer key.\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key)\n      return shouldUnwrap ? res.value : res\n    }\n\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res)\n    }\n\n    return res\n  }\n}\n\nconst set = /*#__PURE__*/ createSetter()\nconst shallowSet = /*#__PURE__*/ createSetter(true)\n\nfunction createSetter(shallow = false) {\n  return function set(\n    target: object,\n    key: string | symbol,\n    value: unknown,\n    receiver: object\n  ): boolean {\n    let oldValue = (target as any)[key]\n    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n      return false\n    }\n    if (!shallow && !isReadonly(value)) {\n      if (!isShallow(value)) {\n        value = toRaw(value)\n        oldValue = toRaw(oldValue)\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value\n        return true\n      }\n    } else {\n      // in shallow mode, objects are set as-is regardless of reactive or not\n    }\n\n    const hadKey =\n      isArray(target) && isIntegerKey(key)\n        ? Number(key) < target.length\n        : hasOwn(target, key)\n    const result = Reflect.set(target, key, value, receiver)\n    // don't trigger if target is something up in the prototype chain of original\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, TriggerOpTypes.ADD, key, value)\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n      }\n    }\n    return result\n  }\n}\n\nfunction deleteProperty(target: object, key: string | symbol): boolean {\n  const hadKey = hasOwn(target, key)\n  const oldValue = (target as any)[key]\n  const result = Reflect.deleteProperty(target, key)\n  if (result && hadKey) {\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\n  }\n  return result\n}\n\nfunction has(target: object, key: string | symbol): boolean {\n  const result = Reflect.has(target, key)\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, TrackOpTypes.HAS, key)\n  }\n  return result\n}\n\nfunction ownKeys(target: object): (string | symbol)[] {\n  track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' : ITERATE_KEY)\n  return Reflect.ownKeys(target)\n}\n\nexport const mutableHandlers: ProxyHandler<object> = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n\nexport const readonlyHandlers: ProxyHandler<object> = {\n  get: readonlyGet,\n  set(target, key) {\n    if (__DEV__) {\n      console.warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      )\n    }\n    return true\n  },\n  deleteProperty(target, key) {\n    if (__DEV__) {\n      console.warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      )\n    }\n    return true\n  }\n}\n\nexport const shallowReactiveHandlers = /*#__PURE__*/ extend(\n  {},\n  mutableHandlers,\n  {\n    get: shallowGet,\n    set: shallowSet\n  }\n)\n\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nexport const shallowReadonlyHandlers = /*#__PURE__*/ extend(\n  {},\n  readonlyHandlers,\n  {\n    get: shallowReadonlyGet\n  }\n)\n", "import { toRaw, ReactiveFlags, toReactive, toReadonly } from './reactive'\nimport { track, trigger, ITERATE_KEY, MAP_KEY_ITERATE_KEY } from './effect'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { capitalize, hasOwn, hasChanged, toRawType, isMap } from '@vue/shared'\n\nexport type CollectionTypes = IterableCollections | WeakCollections\n\ntype IterableCollections = Map<any, any> | Set<any>\ntype WeakCollections = WeakMap<any, any> | WeakSet<any>\ntype MapTypes = Map<any, any> | WeakMap<any, any>\ntype SetTypes = Set<any> | WeakSet<any>\n\nconst toShallow = <T extends unknown>(value: T): T => value\n\nconst getProto = <T extends CollectionTypes>(v: T): any =>\n  Reflect.getPrototypeOf(v)\n\nfunction get(\n  target: MapTypes,\n  key: unknown,\n  isReadonly = false,\n  isShallow = false\n) {\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = (target as any)[ReactiveFlags.RAW]\n  const rawTarget = toRaw(target)\n  const rawKey = toRaw(key)\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, TrackOpTypes.GET, key)\n  }\n  !isReadonly && track(rawTarget, TrackOpTypes.GET, rawKey)\n  const { has } = getProto(rawTarget)\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key))\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey))\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key)\n  }\n}\n\nfunction has(this: CollectionTypes, key: unknown, isReadonly = false): boolean {\n  const target = (this as any)[ReactiveFlags.RAW]\n  const rawTarget = toRaw(target)\n  const rawKey = toRaw(key)\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, TrackOpTypes.HAS, key)\n  }\n  !isReadonly && track(rawTarget, TrackOpTypes.HAS, rawKey)\n  return key === rawKey\n    ? target.has(key)\n    : target.has(key) || target.has(rawKey)\n}\n\nfunction size(target: IterableCollections, isReadonly = false) {\n  target = (target as any)[ReactiveFlags.RAW]\n  !isReadonly && track(toRaw(target), TrackOpTypes.ITERATE, ITERATE_KEY)\n  return Reflect.get(target, 'size', target)\n}\n\nfunction add(this: SetTypes, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const proto = getProto(target)\n  const hadKey = proto.has.call(target, value)\n  if (!hadKey) {\n    target.add(value)\n    trigger(target, TriggerOpTypes.ADD, value, value)\n  }\n  return this\n}\n\nfunction set(this: MapTypes, key: unknown, value: unknown) {\n  value = toRaw(value)\n  const target = toRaw(this)\n  const { has, get } = getProto(target)\n\n  let hadKey = has.call(target, key)\n  if (!hadKey) {\n    key = toRaw(key)\n    hadKey = has.call(target, key)\n  } else if (__DEV__) {\n    checkIdentityKeys(target, has, key)\n  }\n\n  const oldValue = get.call(target, key)\n  target.set(key, value)\n  if (!hadKey) {\n    trigger(target, TriggerOpTypes.ADD, key, value)\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, TriggerOpTypes.SET, key, value, oldValue)\n  }\n  return this\n}\n\nfunction deleteEntry(this: CollectionTypes, key: unknown) {\n  const target = toRaw(this)\n  const { has, get } = getProto(target)\n  let hadKey = has.call(target, key)\n  if (!hadKey) {\n    key = toRaw(key)\n    hadKey = has.call(target, key)\n  } else if (__DEV__) {\n    checkIdentityKeys(target, has, key)\n  }\n\n  const oldValue = get ? get.call(target, key) : undefined\n  // forward the operation before queueing reactions\n  const result = target.delete(key)\n  if (hadKey) {\n    trigger(target, TriggerOpTypes.DELETE, key, undefined, oldValue)\n  }\n  return result\n}\n\nfunction clear(this: IterableCollections) {\n  const target = toRaw(this)\n  const hadItems = target.size !== 0\n  const oldTarget = __DEV__\n    ? isMap(target)\n      ? new Map(target)\n      : new Set(target)\n    : undefined\n  // forward the operation before queueing reactions\n  const result = target.clear()\n  if (hadItems) {\n    trigger(target, TriggerOpTypes.CLEAR, undefined, undefined, oldTarget)\n  }\n  return result\n}\n\nfunction createForEach(isReadonly: boolean, isShallow: boolean) {\n  return function forEach(\n    this: IterableCollections,\n    callback: Function,\n    thisArg?: unknown\n  ) {\n    const observed = this as any\n    const target = observed[ReactiveFlags.RAW]\n    const rawTarget = toRaw(target)\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\n    !isReadonly && track(rawTarget, TrackOpTypes.ITERATE, ITERATE_KEY)\n    return target.forEach((value: unknown, key: unknown) => {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed)\n    })\n  }\n}\n\ninterface Iterable {\n  [Symbol.iterator](): Iterator\n}\n\ninterface Iterator {\n  next(value?: any): IterationResult\n}\n\ninterface IterationResult {\n  value: any\n  done: boolean\n}\n\nfunction createIterableMethod(\n  method: string | symbol,\n  isReadonly: boolean,\n  isShallow: boolean\n) {\n  return function (\n    this: IterableCollections,\n    ...args: unknown[]\n  ): Iterable & Iterator {\n    const target = (this as any)[ReactiveFlags.RAW]\n    const rawTarget = toRaw(target)\n    const targetIsMap = isMap(rawTarget)\n    const isPair =\n      method === 'entries' || (method === Symbol.iterator && targetIsMap)\n    const isKeyOnly = method === 'keys' && targetIsMap\n    const innerIterator = target[method](...args)\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive\n    !isReadonly &&\n      track(\n        rawTarget,\n        TrackOpTypes.ITERATE,\n        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n      )\n    // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next()\n        return done\n          ? { value, done }\n          : {\n              value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n              done\n            }\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this\n      }\n    }\n  }\n}\n\nfunction createReadonlyMethod(type: TriggerOpTypes): Function {\n  return function (this: CollectionTypes, ...args: unknown[]) {\n    if (__DEV__) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``\n      console.warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      )\n    }\n    return type === TriggerOpTypes.DELETE ? false : this\n  }\n}\n\nfunction createInstrumentations() {\n  const mutableInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  }\n\n  const shallowInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, false, true)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections)\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  }\n\n  const readonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, false)\n  }\n\n  const shallowReadonlyInstrumentations: Record<string, Function> = {\n    get(this: MapTypes, key: unknown) {\n      return get(this, key, true, true)\n    },\n    get size() {\n      return size(this as unknown as IterableCollections, true)\n    },\n    has(this: MapTypes, key: unknown) {\n      return has.call(this, key, true)\n    },\n    add: createReadonlyMethod(TriggerOpTypes.ADD),\n    set: createReadonlyMethod(TriggerOpTypes.SET),\n    delete: createReadonlyMethod(TriggerOpTypes.DELETE),\n    clear: createReadonlyMethod(TriggerOpTypes.CLEAR),\n    forEach: createForEach(true, true)\n  }\n\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator]\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations[method as string] = createIterableMethod(\n      method,\n      false,\n      false\n    )\n    readonlyInstrumentations[method as string] = createIterableMethod(\n      method,\n      true,\n      false\n    )\n    shallowInstrumentations[method as string] = createIterableMethod(\n      method,\n      false,\n      true\n    )\n    shallowReadonlyInstrumentations[method as string] = createIterableMethod(\n      method,\n      true,\n      true\n    )\n  })\n\n  return [\n    mutableInstrumentations,\n    readonlyInstrumentations,\n    shallowInstrumentations,\n    shallowReadonlyInstrumentations\n  ]\n}\n\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* #__PURE__*/ createInstrumentations()\n\nfunction createInstrumentationGetter(isReadonly: boolean, shallow: boolean) {\n  const instrumentations = shallow\n    ? isReadonly\n      ? shallowReadonlyInstrumentations\n      : shallowInstrumentations\n    : isReadonly\n    ? readonlyInstrumentations\n    : mutableInstrumentations\n\n  return (\n    target: CollectionTypes,\n    key: string | symbol,\n    receiver: CollectionTypes\n  ) => {\n    if (key === ReactiveFlags.IS_REACTIVE) {\n      return !isReadonly\n    } else if (key === ReactiveFlags.IS_READONLY) {\n      return isReadonly\n    } else if (key === ReactiveFlags.RAW) {\n      return target\n    }\n\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target\n        ? instrumentations\n        : target,\n      key,\n      receiver\n    )\n  }\n}\n\nexport const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n}\n\nexport const shallowCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n}\n\nexport const readonlyCollectionHandlers: ProxyHandler<CollectionTypes> = {\n  get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n}\n\nexport const shallowReadonlyCollectionHandlers: ProxyHandler<CollectionTypes> =\n  {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n  }\n\nfunction checkIdentityKeys(\n  target: CollectionTypes,\n  has: (key: unknown) => boolean,\n  key: unknown\n) {\n  const rawKey = toRaw(key)\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target)\n    console.warn(\n      `Reactive ${type} contains both the raw and reactive ` +\n        `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n        `which can lead to inconsistencies. ` +\n        `Avoid differentiating between the raw and reactive versions ` +\n        `of an object and only use the reactive version if possible.`\n    )\n  }\n}\n", "import { isObject, toRawType, def } from '@vue/shared'\nimport {\n  mutableHandlers,\n  readonlyHandlers,\n  shallowReactiveHandlers,\n  shallowReadonlyHandlers\n} from './baseHandlers'\nimport {\n  mutableCollectionHandlers,\n  readonlyCollectionHandlers,\n  shallowCollectionHandlers,\n  shallowReadonlyCollectionHandlers\n} from './collectionHandlers'\nimport { UnwrapRefSimple, Ref } from './ref'\n\nexport const enum ReactiveFlags {\n  SKIP = '__v_skip',\n  IS_REACTIVE = '__v_isReactive',\n  IS_READONLY = '__v_isReadonly',\n  IS_SHALLOW = '__v_isShallow',\n  RAW = '__v_raw'\n}\n\nexport interface Target {\n  [ReactiveFlags.SKIP]?: boolean\n  [ReactiveFlags.IS_REACTIVE]?: boolean\n  [ReactiveFlags.IS_READONLY]?: boolean\n  [ReactiveFlags.IS_SHALLOW]?: boolean\n  [ReactiveFlags.RAW]?: any\n}\n\nexport const reactiveMap = new WeakMap<Target, any>()\nexport const shallowReactiveMap = new WeakMap<Target, any>()\nexport const readonlyMap = new WeakMap<Target, any>()\nexport const shallowReadonlyMap = new WeakMap<Target, any>()\n\nconst enum TargetType {\n  INVALID = 0,\n  COMMON = 1,\n  COLLECTION = 2\n}\n\nfunction targetTypeMap(rawType: string) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return TargetType.COMMON\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return TargetType.COLLECTION\n    default:\n      return TargetType.INVALID\n  }\n}\n\nfunction getTargetType(value: Target) {\n  return value[ReactiveFlags.SKIP] || !Object.isExtensible(value)\n    ? TargetType.INVALID\n    : targetTypeMap(toRawType(value))\n}\n\n// only unwrap nested ref\nexport type UnwrapNestedRefs<T> = T extends Ref ? T : UnwrapRefSimple<T>\n\n/**\n * Creates a reactive copy of the original object.\n *\n * The reactive conversion is \"deep\"\u2014it affects all nested properties. In the\n * ES2015 Proxy based implementation, the returned proxy is **not** equal to the\n * original object. It is recommended to work exclusively with the reactive\n * proxy and avoid relying on the original object.\n *\n * A reactive object also automatically unwraps refs contained in it, so you\n * don't need to use `.value` when accessing and mutating their value:\n *\n * ```js\n * const count = ref(0)\n * const obj = reactive({\n *   count\n * })\n *\n * obj.count++\n * obj.count // -> 1\n * count.value // -> 1\n * ```\n */\nexport function reactive<T extends object>(target: T): UnwrapNestedRefs<T>\nexport function reactive(target: object) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (isReadonly(target)) {\n    return target\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  )\n}\n\nexport declare const ShallowReactiveMarker: unique symbol\n\nexport type ShallowReactive<T> = T & { [ShallowReactiveMarker]?: true }\n\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nexport function shallowReactive<T extends object>(\n  target: T\n): ShallowReactive<T> {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  )\n}\n\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null\ntype Builtin = Primitive | Function | Date | Error | RegExp\nexport type DeepReadonly<T> = T extends Builtin\n  ? T\n  : T extends Map<infer K, infer V>\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends ReadonlyMap<infer K, infer V>\n  ? ReadonlyMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends WeakMap<infer K, infer V>\n  ? WeakMap<DeepReadonly<K>, DeepReadonly<V>>\n  : T extends Set<infer U>\n  ? ReadonlySet<DeepReadonly<U>>\n  : T extends ReadonlySet<infer U>\n  ? ReadonlySet<DeepReadonly<U>>\n  : T extends WeakSet<infer U>\n  ? WeakSet<DeepReadonly<U>>\n  : T extends Promise<infer U>\n  ? Promise<DeepReadonly<U>>\n  : T extends Ref<infer U>\n  ? Readonly<Ref<DeepReadonly<U>>>\n  : T extends {}\n  ? { readonly [K in keyof T]: DeepReadonly<T[K]> }\n  : Readonly<T>\n\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nexport function readonly<T extends object>(\n  target: T\n): DeepReadonly<UnwrapNestedRefs<T>> {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  )\n}\n\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nexport function shallowReadonly<T extends object>(target: T): Readonly<T> {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  )\n}\n\nfunction createReactiveObject(\n  target: Target,\n  isReadonly: boolean,\n  baseHandlers: ProxyHandler<any>,\n  collectionHandlers: ProxyHandler<any>,\n  proxyMap: WeakMap<Target, any>\n) {\n  if (!isObject(target)) {\n    if (__DEV__) {\n      console.warn(`value cannot be made reactive: ${String(target)}`)\n    }\n    return target\n  }\n  // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n  if (\n    target[ReactiveFlags.RAW] &&\n    !(isReadonly && target[ReactiveFlags.IS_REACTIVE])\n  ) {\n    return target\n  }\n  // target already has corresponding Proxy\n  const existingProxy = proxyMap.get(target)\n  if (existingProxy) {\n    return existingProxy\n  }\n  // only a whitelist of value types can be observed.\n  const targetType = getTargetType(target)\n  if (targetType === TargetType.INVALID) {\n    return target\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers\n  )\n  proxyMap.set(target, proxy)\n  return proxy\n}\n\nexport function isReactive(value: unknown): boolean {\n  if (isReadonly(value)) {\n    return isReactive((value as Target)[ReactiveFlags.RAW])\n  }\n  return !!(value && (value as Target)[ReactiveFlags.IS_REACTIVE])\n}\n\nexport function isReadonly(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_READONLY])\n}\n\nexport function isShallow(value: unknown): boolean {\n  return !!(value && (value as Target)[ReactiveFlags.IS_SHALLOW])\n}\n\nexport function isProxy(value: unknown): boolean {\n  return isReactive(value) || isReadonly(value)\n}\n\nexport function toRaw<T>(observed: T): T {\n  const raw = observed && (observed as Target)[ReactiveFlags.RAW]\n  return raw ? toRaw(raw) : observed\n}\n\nexport function markRaw<T extends object>(value: T): T {\n  def(value, ReactiveFlags.SKIP, true)\n  return value\n}\n\nexport const toReactive = <T extends unknown>(value: T): T =>\n  isObject(value) ? reactive(value) : value\n\nexport const toReadonly = <T extends unknown>(value: T): T =>\n  isObject(value) ? readonly(value as Record<any, any>) : value\n", "import {\n  activeEffect,\n  shouldTrack,\n  trackEffects,\n  triggerEffects\n} from './effect'\nimport { TrackOpTypes, TriggerOpTypes } from './operations'\nimport { isArray, hasChanged, IfAny } from '@vue/shared'\nimport { isProxy, toRaw, isReactive, toReactive } from './reactive'\nimport type { ShallowReactiveMarker } from './reactive'\nimport { CollectionTypes } from './collectionHandlers'\nimport { createDep, Dep } from './dep'\n\ndeclare const RefSymbol: unique symbol\n\nexport interface Ref<T = any> {\n  value: T\n  /**\n   * Type differentiator only.\n   * We need this to be in public d.ts but don't want it to show up in IDE\n   * autocomplete, so we use a private Symbol instead.\n   */\n  [RefSymbol]: true\n}\n\ntype RefBase<T> = {\n  dep?: Dep\n  value: T\n}\n\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    if (__DEV__) {\n      trackEffects(ref.dep || (ref.dep = createDep()), {\n        target: ref,\n        type: TrackOpTypes.GET,\n        key: 'value'\n      })\n    } else {\n      trackEffects(ref.dep || (ref.dep = createDep()))\n    }\n  }\n}\n\nexport function triggerRefValue(ref: RefBase<any>, newVal?: any) {\n  ref = toRaw(ref)\n  if (ref.dep) {\n    if (__DEV__) {\n      triggerEffects(ref.dep, {\n        target: ref,\n        type: TriggerOpTypes.SET,\n        key: 'value',\n        newValue: newVal\n      })\n    } else {\n      triggerEffects(ref.dep)\n    }\n  }\n}\n\nexport function isRef<T>(r: Ref<T> | unknown): r is Ref<T>\nexport function isRef(r: any): r is Ref {\n  return !!(r && r.__v_isRef === true)\n}\n\nexport function ref<T extends object>(\n  value: T\n): [T] extends [Ref] ? T : Ref<UnwrapRef<T>>\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n\ndeclare const ShallowRefMarker: unique symbol\n\nexport type ShallowRef<T = any> = Ref<T> & { [ShallowRefMarker]?: true }\n\nexport function shallowRef<T extends object>(\n  value: T\n): T extends Ref ? T : ShallowRef<T>\nexport function shallowRef<T>(value: T): ShallowRef<T>\nexport function shallowRef<T = any>(): ShallowRef<T | undefined>\nexport function shallowRef(value?: unknown) {\n  return createRef(value, true)\n}\n\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(value: T, public readonly __v_isShallow: boolean) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    newVal = this.__v_isShallow ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = this.__v_isShallow ? newVal : toReactive(newVal)\n      triggerRefValue(this, newVal)\n    }\n  }\n}\n\nexport function triggerRef(ref: Ref) {\n  triggerRefValue(ref, __DEV__ ? ref.value : void 0)\n}\n\nexport function unref<T>(ref: T | Ref<T>): T {\n  return isRef(ref) ? (ref.value as any) : ref\n}\n\nconst shallowUnwrapHandlers: ProxyHandler<any> = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key]\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value\n      return true\n    } else {\n      return Reflect.set(target, key, value, receiver)\n    }\n  }\n}\n\nexport function proxyRefs<T extends object>(\n  objectWithRefs: T\n): ShallowUnwrapRef<T> {\n  return isReactive(objectWithRefs)\n    ? objectWithRefs\n    : new Proxy(objectWithRefs, shallowUnwrapHandlers)\n}\n\nexport type CustomRefFactory<T> = (\n  track: () => void,\n  trigger: () => void\n) => {\n  get: () => T\n  set: (value: T) => void\n}\n\nclass CustomRefImpl<T> {\n  public dep?: Dep = undefined\n\n  private readonly _get: ReturnType<CustomRefFactory<T>>['get']\n  private readonly _set: ReturnType<CustomRefFactory<T>>['set']\n\n  public readonly __v_isRef = true\n\n  constructor(factory: CustomRefFactory<T>) {\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    )\n    this._get = get\n    this._set = set\n  }\n\n  get value() {\n    return this._get()\n  }\n\n  set value(newVal) {\n    this._set(newVal)\n  }\n}\n\nexport function customRef<T>(factory: CustomRefFactory<T>): Ref<T> {\n  return new CustomRefImpl(factory) as any\n}\n\nexport type ToRefs<T = any> = {\n  [K in keyof T]: ToRef<T[K]>\n}\nexport function toRefs<T extends object>(object: T): ToRefs<T> {\n  if (__DEV__ && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`)\n  }\n  const ret: any = isArray(object) ? new Array(object.length) : {}\n  for (const key in object) {\n    ret[key] = toRef(object, key)\n  }\n  return ret\n}\n\nclass ObjectRefImpl<T extends object, K extends keyof T> {\n  public readonly __v_isRef = true\n\n  constructor(\n    private readonly _object: T,\n    private readonly _key: K,\n    private readonly _defaultValue?: T[K]\n  ) {}\n\n  get value() {\n    const val = this._object[this._key]\n    return val === undefined ? (this._defaultValue as T[K]) : val\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal\n  }\n}\n\nexport type ToRef<T> = IfAny<T, Ref<T>, [T] extends [Ref] ? T : Ref<T>>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K\n): ToRef<T[K]>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n  defaultValue: T[K]\n): ToRef<Exclude<T[K], undefined>>\n\nexport function toRef<T extends object, K extends keyof T>(\n  object: T,\n  key: K,\n  defaultValue?: T[K]\n): ToRef<T[K]> {\n  const val = object[key]\n  return isRef(val)\n    ? val\n    : (new ObjectRefImpl(object, key, defaultValue) as any)\n}\n\n// corner case when use narrows type\n// Ex. type RelativePath = string & { __brand: unknown }\n// RelativePath extends object -> true\ntype BaseTypes = string | number | boolean\n\n/**\n * This is a special exported interface for other packages to declare\n * additional types that should bail out for ref unwrapping. For example\n * \\@vue/runtime-dom can declare it like so in its d.ts:\n *\n * ``` ts\n * declare module '@vue/reactivity' {\n *   export interface RefUnwrapBailTypes {\n *     runtimeDOMBailTypes: Node | Window\n *   }\n * }\n * ```\n *\n * Note that api-extractor somehow refuses to include `declare module`\n * augmentations in its generated d.ts, so we have to manually append them\n * to the final generated d.ts in our build process.\n */\nexport interface RefUnwrapBailTypes {}\n\nexport type ShallowUnwrapRef<T> = {\n  [K in keyof T]: T[K] extends Ref<infer V>\n    ? V\n    : // if `V` is `unknown` that means it does not extend `Ref` and is undefined\n    T[K] extends Ref<infer V> | undefined\n    ? unknown extends V\n      ? undefined\n      : V | undefined\n    : T[K]\n}\n\nexport type UnwrapRef<T> = T extends ShallowRef<infer V>\n  ? V\n  : T extends Ref<infer V>\n  ? UnwrapRefSimple<V>\n  : UnwrapRefSimple<T>\n\nexport type UnwrapRefSimple<T> = T extends\n  | Function\n  | CollectionTypes\n  | BaseTypes\n  | Ref\n  | RefUnwrapBailTypes[keyof RefUnwrapBailTypes]\n  ? T\n  : T extends Array<any>\n  ? { [K in keyof T]: UnwrapRefSimple<T[K]> }\n  : T extends object & { [ShallowReactiveMarker]?: never }\n  ? {\n      [P in keyof T]: P extends symbol ? T[P] : UnwrapRef<T[P]>\n    }\n  : T\n", "import { DebuggerOptions, ReactiveEffect } from './effect'\nimport { Ref, trackRefValue, triggerRefValue } from './ref'\nimport { isFunction, NOOP } from '@vue/shared'\nimport { ReactiveFlags, toRaw } from './reactive'\nimport { Dep } from './dep'\n\ndeclare const ComputedRefSymbol: unique symbol\n\nexport interface ComputedRef<T = any> extends WritableComputedRef<T> {\n  readonly value: T\n  [ComputedRefSymbol]: true\n}\n\nexport interface WritableComputedRef<T> extends Ref<T> {\n  readonly effect: ReactiveEffect<T>\n}\n\nexport type ComputedGetter<T> = (...args: any[]) => T\nexport type ComputedSetter<T> = (v: T) => void\n\nexport interface WritableComputedOptions<T> {\n  get: ComputedGetter<T>\n  set: ComputedSetter<T>\n}\n\nexport class ComputedRefImpl<T> {\n  public dep?: Dep = undefined\n\n  private _value!: T\n  public readonly effect: ReactiveEffect<T>\n\n  public readonly __v_isRef = true\n  public readonly [ReactiveFlags.IS_READONLY]: boolean\n\n  public _dirty = true\n  public _cacheable: boolean\n\n  constructor(\n    getter: ComputedGetter<T>,\n    private readonly _setter: ComputedSetter<T>,\n    isReadonly: boolean,\n    isSSR: boolean\n  ) {\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true\n        triggerRefValue(this)\n      }\n    })\n    this.effect.computed = this\n    this.effect.active = this._cacheable = !isSSR\n    this[ReactiveFlags.IS_READONLY] = isReadonly\n  }\n\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    const self = toRaw(this)\n    trackRefValue(self)\n    if (self._dirty || !self._cacheable) {\n      self._dirty = false\n      self._value = self.effect.run()!\n    }\n    return self._value\n  }\n\n  set value(newValue: T) {\n    this._setter(newValue)\n  }\n}\n\nexport function computed<T>(\n  getter: ComputedGetter<T>,\n  debugOptions?: DebuggerOptions\n): ComputedRef<T>\nexport function computed<T>(\n  options: WritableComputedOptions<T>,\n  debugOptions?: DebuggerOptions\n): WritableComputedRef<T>\nexport function computed<T>(\n  getterOrOptions: ComputedGetter<T> | WritableComputedOptions<T>,\n  debugOptions?: DebuggerOptions,\n  isSSR = false\n) {\n  let getter: ComputedGetter<T>\n  let setter: ComputedSetter<T>\n\n  const onlyGetter = isFunction(getterOrOptions)\n  if (onlyGetter) {\n    getter = getterOrOptions\n    setter = __DEV__\n      ? () => {\n          console.warn('Write operation failed: computed value is readonly')\n        }\n      : NOOP\n  } else {\n    getter = getterOrOptions.get\n    setter = getterOrOptions.set\n  }\n\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR)\n\n  if (__DEV__ && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack\n    cRef.effect.onTrigger = debugOptions.onTrigger\n  }\n\n  return cRef as any\n}\n", "import { VNode } from './vnode'\nimport {\n  Data,\n  ComponentInternalInstance,\n  ConcreteComponent,\n  formatComponentName\n} from './component'\nimport { isString, isFunction } from '@vue/shared'\nimport { toRaw, isRef, pauseTracking, resetTracking } from '@vue/reactivity'\nimport { callWithErrorHandling, ErrorCodes } from './errorHandling'\n\ntype ComponentVNode = VNode & {\n  type: ConcreteComponent\n}\n\nconst stack: VNode[] = []\n\ntype TraceEntry = {\n  vnode: ComponentVNode\n  recurseCount: number\n}\n\ntype ComponentTraceStack = TraceEntry[]\n\nexport function pushWarningContext(vnode: VNode) {\n  stack.push(vnode)\n}\n\nexport function popWarningContext() {\n  stack.pop()\n}\n\nexport function warn(msg: string, ...args: any[]) {\n  // avoid props formatting or warn handler tracking deps that might be mutated\n  // during patch, leading to infinite recursion.\n  pauseTracking()\n\n  const instance = stack.length ? stack[stack.length - 1].component : null\n  const appWarnHandler = instance && instance.appContext.config.warnHandler\n  const trace = getComponentTrace()\n\n  if (appWarnHandler) {\n    callWithErrorHandling(\n      appWarnHandler,\n      instance,\n      ErrorCodes.APP_WARN_HANDLER,\n      [\n        msg + args.join(''),\n        instance && instance.proxy,\n        trace\n          .map(\n            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`\n          )\n          .join('\\n'),\n        trace\n      ]\n    )\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args]\n    /* istanbul ignore if */\n    if (\n      trace.length &&\n      // avoid spamming console during tests\n      !__TEST__\n    ) {\n      warnArgs.push(`\\n`, ...formatTrace(trace))\n    }\n    console.warn(...warnArgs)\n  }\n\n  resetTracking()\n}\n\nexport function getComponentTrace(): ComponentTraceStack {\n  let currentVNode: VNode | null = stack[stack.length - 1]\n  if (!currentVNode) {\n    return []\n  }\n\n  // we can't just use the stack because it will be incomplete during updates\n  // that did not start from the root. Re-construct the parent chain using\n  // instance parent pointers.\n  const normalizedStack: ComponentTraceStack = []\n\n  while (currentVNode) {\n    const last = normalizedStack[0]\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode as ComponentVNode,\n        recurseCount: 0\n      })\n    }\n    const parentInstance: ComponentInternalInstance | null =\n      currentVNode.component && currentVNode.component.parent\n    currentVNode = parentInstance && parentInstance.vnode\n  }\n\n  return normalizedStack\n}\n\n/* istanbul ignore next */\nfunction formatTrace(trace: ComponentTraceStack): any[] {\n  const logs: any[] = []\n  trace.forEach((entry, i) => {\n    logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry))\n  })\n  return logs\n}\n\nfunction formatTraceEntry({ vnode, recurseCount }: TraceEntry): any[] {\n  const postfix =\n    recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``\n  const isRoot = vnode.component ? vnode.component.parent == null : false\n  const open = ` at <${formatComponentName(\n    vnode.component,\n    vnode.type,\n    isRoot\n  )}`\n  const close = `>` + postfix\n  return vnode.props\n    ? [open, ...formatProps(vnode.props), close]\n    : [open + close]\n}\n\n/* istanbul ignore next */\nfunction formatProps(props: Data): any[] {\n  const res: any[] = []\n  const keys = Object.keys(props)\n  keys.slice(0, 3).forEach(key => {\n    res.push(...formatProp(key, props[key]))\n  })\n  if (keys.length > 3) {\n    res.push(` ...`)\n  }\n  return res\n}\n\nfunction formatProp(key: string, value: unknown): any[]\nfunction formatProp(key: string, value: unknown, raw: true): any\n/* istanbul ignore next */\nfunction formatProp(key: string, value: unknown, raw?: boolean): any {\n  if (isString(value)) {\n    value = JSON.stringify(value)\n    return raw ? value : [`${key}=${value}`]\n  } else if (\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    value == null\n  ) {\n    return raw ? value : [`${key}=${value}`]\n  } else if (isRef(value)) {\n    value = formatProp(key, toRaw(value.value), true)\n    return raw ? value : [`${key}=Ref<`, value, `>`]\n  } else if (isFunction(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`]\n  } else {\n    value = toRaw(value)\n    return raw ? value : [`${key}=`, value]\n  }\n}\n", "import { VNode } from './vnode'\nimport { ComponentInternalInstance, LifecycleHooks } from './component'\nimport { warn, pushWarningContext, popWarningContext } from './warning'\nimport { isPromise, isFunction } from '@vue/shared'\n\n// contexts where user provided function may be executed, in addition to\n// lifecycle hooks.\nexport const enum ErrorCodes {\n  SETUP_FUNCTION,\n  RENDER_FUNCTION,\n  WATCH_GETTER,\n  WATCH_CALLBACK,\n  WATCH_CLEANUP,\n  NATIVE_EVENT_HANDLER,\n  COMPONENT_EVENT_HANDLER,\n  VNODE_HOOK,\n  DIRECTIVE_HOOK,\n  TRANSITION_HOOK,\n  APP_ERROR_HANDLER,\n  APP_WARN_HANDLER,\n  FUNCTION_REF,\n  ASYNC_COMPONENT_LOADER,\n  SCHEDULER\n}\n\nexport const ErrorTypeStrings: Record<number | string, string> = {\n  [LifecycleHooks.SERVER_PREFETCH]: 'serverPrefetch hook',\n  [LifecycleHooks.BEFORE_CREATE]: 'beforeCreate hook',\n  [LifecycleHooks.CREATED]: 'created hook',\n  [LifecycleHooks.BEFORE_MOUNT]: 'beforeMount hook',\n  [LifecycleHooks.MOUNTED]: 'mounted hook',\n  [LifecycleHooks.BEFORE_UPDATE]: 'beforeUpdate hook',\n  [LifecycleHooks.UPDATED]: 'updated',\n  [LifecycleHooks.BEFORE_UNMOUNT]: 'beforeUnmount hook',\n  [LifecycleHooks.UNMOUNTED]: 'unmounted hook',\n  [LifecycleHooks.ACTIVATED]: 'activated hook',\n  [LifecycleHooks.DEACTIVATED]: 'deactivated hook',\n  [LifecycleHooks.ERROR_CAPTURED]: 'errorCaptured hook',\n  [LifecycleHooks.RENDER_TRACKED]: 'renderTracked hook',\n  [LifecycleHooks.RENDER_TRIGGERED]: 'renderTriggered hook',\n  [ErrorCodes.SETUP_FUNCTION]: 'setup function',\n  [ErrorCodes.RENDER_FUNCTION]: 'render function',\n  [ErrorCodes.WATCH_GETTER]: 'watcher getter',\n  [ErrorCodes.WATCH_CALLBACK]: 'watcher callback',\n  [ErrorCodes.WATCH_CLEANUP]: 'watcher cleanup function',\n  [ErrorCodes.NATIVE_EVENT_HANDLER]: 'native event handler',\n  [ErrorCodes.COMPONENT_EVENT_HANDLER]: 'component event handler',\n  [ErrorCodes.VNODE_HOOK]: 'vnode hook',\n  [ErrorCodes.DIRECTIVE_HOOK]: 'directive hook',\n  [ErrorCodes.TRANSITION_HOOK]: 'transition hook',\n  [ErrorCodes.APP_ERROR_HANDLER]: 'app errorHandler',\n  [ErrorCodes.APP_WARN_HANDLER]: 'app warnHandler',\n  [ErrorCodes.FUNCTION_REF]: 'ref function',\n  [ErrorCodes.ASYNC_COMPONENT_LOADER]: 'async component loader',\n  [ErrorCodes.SCHEDULER]:\n    'scheduler flush. This is likely a Vue internals bug. ' +\n    'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\n}\n\nexport type ErrorTypes = LifecycleHooks | ErrorCodes\n\nexport function callWithErrorHandling(\n  fn: Function,\n  instance: ComponentInternalInstance | null,\n  type: ErrorTypes,\n  args?: unknown[]\n) {\n  let res\n  try {\n    res = args ? fn(...args) : fn()\n  } catch (err) {\n    handleError(err, instance, type)\n  }\n  return res\n}\n\nexport function callWithAsyncErrorHandling(\n  fn: Function | Function[],\n  instance: ComponentInternalInstance | null,\n  type: ErrorTypes,\n  args?: unknown[]\n): any[] {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args)\n    if (res && isPromise(res)) {\n      res.catch(err => {\n        handleError(err, instance, type)\n      })\n    }\n    return res\n  }\n\n  const values = []\n  for (let i = 0; i < fn.length; i++) {\n    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args))\n  }\n  return values\n}\n\nexport function handleError(\n  err: unknown,\n  instance: ComponentInternalInstance | null,\n  type: ErrorTypes,\n  throwInDev = true\n) {\n  const contextVNode = instance ? instance.vnode : null\n  if (instance) {\n    let cur = instance.parent\n    // the exposed instance is the render proxy to keep it consistent with 2.x\n    const exposedInstance = instance.proxy\n    // in production the hook receives only the error code\n    const errorInfo = __DEV__ ? ErrorTypeStrings[type] : type\n    while (cur) {\n      const errorCapturedHooks = cur.ec\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (\n            errorCapturedHooks[i](err, exposedInstance, errorInfo) === false\n          ) {\n            return\n          }\n        }\n      }\n      cur = cur.parent\n    }\n    // app-level handling\n    const appErrorHandler = instance.appContext.config.errorHandler\n    if (appErrorHandler) {\n      callWithErrorHandling(\n        appErrorHandler,\n        null,\n        ErrorCodes.APP_ERROR_HANDLER,\n        [err, exposedInstance, errorInfo]\n      )\n      return\n    }\n  }\n  logError(err, type, contextVNode, throwInDev)\n}\n\nfunction logError(\n  err: unknown,\n  type: ErrorTypes,\n  contextVNode: VNode | null,\n  throwInDev = true\n) {\n  if (__DEV__) {\n    const info = ErrorTypeStrings[type]\n    if (contextVNode) {\n      pushWarningContext(contextVNode)\n    }\n    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`)\n    if (contextVNode) {\n      popWarningContext()\n    }\n    // crash in dev by default so it's more noticeable\n    if (throwInDev) {\n      throw err\n    } else if (!__TEST__) {\n      console.error(err)\n    }\n  } else {\n    // recover in prod to reduce the impact on end-user\n    console.error(err)\n  }\n}\n", "import { ErrorCodes, callWithErrorHandling } from './errorHandling'\nimport { isArray, NOOP } from '@vue/shared'\nimport { ComponentInternalInstance, getComponentName } from './component'\nimport { warn } from './warning'\n\nexport interface SchedulerJob extends Function {\n  id?: number\n  active?: boolean\n  computed?: boolean\n  /**\n   * Indicates whether the effect is allowed to recursively trigger itself\n   * when managed by the scheduler.\n   *\n   * By default, a job cannot trigger itself because some built-in method calls,\n   * e.g. Array.prototype.push actually performs reads as well (#1740) which\n   * can lead to confusing infinite loops.\n   * The allowed cases are component update functions and watch callbacks.\n   * Component update functions may update child component props, which in turn\n   * trigger flush: \"pre\" watch callbacks that mutates state that the parent\n   * relies on (#1801). Watch callbacks doesn't track its dependencies so if it\n   * triggers itself again, it's likely intentional and it is the user's\n   * responsibility to perform recursive state mutation that eventually\n   * stabilizes (#1727).\n   */\n  allowRecurse?: boolean\n  /**\n   * Attached by renderer.ts when setting up a component's render effect\n   * Used to obtain component information when reporting max recursive updates.\n   * dev only.\n   */\n  ownerInstance?: ComponentInternalInstance\n}\n\nexport type SchedulerJobs = SchedulerJob | SchedulerJob[]\n\nlet isFlushing = false\nlet isFlushPending = false\n\nconst queue: SchedulerJob[] = []\nlet flushIndex = 0\n\nconst pendingPreFlushCbs: SchedulerJob[] = []\nlet activePreFlushCbs: SchedulerJob[] | null = null\nlet preFlushIndex = 0\n\nconst pendingPostFlushCbs: SchedulerJob[] = []\nlet activePostFlushCbs: SchedulerJob[] | null = null\nlet postFlushIndex = 0\n\nconst resolvedPromise: Promise<any> = Promise.resolve()\nlet currentFlushPromise: Promise<void> | null = null\n\nlet currentPreFlushParentJob: SchedulerJob | null = null\n\nconst RECURSION_LIMIT = 100\ntype CountMap = Map<SchedulerJob, number>\n\nexport function nextTick<T = void>(\n  this: T,\n  fn?: (this: T) => void\n): Promise<void> {\n  const p = currentFlushPromise || resolvedPromise\n  return fn ? p.then(this ? fn.bind(this) : fn) : p\n}\n\n// #2768\n// Use binary-search to find a suitable position in the queue,\n// so that the queue maintains the increasing order of job's id,\n// which can prevent the job from being skipped and also can avoid repeated patching.\nfunction findInsertionIndex(id: number) {\n  // the start index should be `flushIndex + 1`\n  let start = flushIndex + 1\n  let end = queue.length\n\n  while (start < end) {\n    const middle = (start + end) >>> 1\n    const middleJobId = getId(queue[middle])\n    middleJobId < id ? (start = middle + 1) : (end = middle)\n  }\n\n  return start\n}\n\nexport function queueJob(job: SchedulerJob) {\n  // the dedupe search uses the startIndex argument of Array.includes()\n  // by default the search index includes the current job that is being run\n  // so it cannot recursively trigger itself again.\n  // if the job is a watch() callback, the search will start with a +1 index to\n  // allow it recursively trigger itself - it is the user's responsibility to\n  // ensure it doesn't end up in an infinite loop.\n  if (\n    (!queue.length ||\n      !queue.includes(\n        job,\n        isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex\n      )) &&\n    job !== currentPreFlushParentJob\n  ) {\n    if (job.id == null) {\n      queue.push(job)\n    } else {\n      queue.splice(findInsertionIndex(job.id), 0, job)\n    }\n    queueFlush()\n  }\n}\n\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true\n    currentFlushPromise = resolvedPromise.then(flushJobs)\n  }\n}\n\nexport function invalidateJob(job: SchedulerJob) {\n  const i = queue.indexOf(job)\n  if (i > flushIndex) {\n    queue.splice(i, 1)\n  }\n}\n\nfunction queueCb(\n  cb: SchedulerJobs,\n  activeQueue: SchedulerJob[] | null,\n  pendingQueue: SchedulerJob[],\n  index: number\n) {\n  if (!isArray(cb)) {\n    if (\n      !activeQueue ||\n      !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)\n    ) {\n      pendingQueue.push(cb)\n    }\n  } else {\n    // if cb is an array, it is a component lifecycle hook which can only be\n    // triggered by a job, which is already deduped in the main queue, so\n    // we can skip duplicate check here to improve perf\n    pendingQueue.push(...cb)\n  }\n  queueFlush()\n}\n\nexport function queuePreFlushCb(cb: SchedulerJob) {\n  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)\n}\n\nexport function queuePostFlushCb(cb: SchedulerJobs) {\n  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)\n}\n\nexport function flushPreFlushCbs(\n  seen?: CountMap,\n  parentJob: SchedulerJob | null = null\n) {\n  if (pendingPreFlushCbs.length) {\n    currentPreFlushParentJob = parentJob\n    activePreFlushCbs = [...new Set(pendingPreFlushCbs)]\n    pendingPreFlushCbs.length = 0\n    if (__DEV__) {\n      seen = seen || new Map()\n    }\n    for (\n      preFlushIndex = 0;\n      preFlushIndex < activePreFlushCbs.length;\n      preFlushIndex++\n    ) {\n      if (\n        __DEV__ &&\n        checkRecursiveUpdates(seen!, activePreFlushCbs[preFlushIndex])\n      ) {\n        continue\n      }\n      activePreFlushCbs[preFlushIndex]()\n    }\n    activePreFlushCbs = null\n    preFlushIndex = 0\n    currentPreFlushParentJob = null\n    // recursively flush until it drains\n    flushPreFlushCbs(seen, parentJob)\n  }\n}\n\nexport function flushPostFlushCbs(seen?: CountMap) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)]\n    pendingPostFlushCbs.length = 0\n\n    // #1947 already has active queue, nested flushPostFlushCbs call\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped)\n      return\n    }\n\n    activePostFlushCbs = deduped\n    if (__DEV__) {\n      seen = seen || new Map()\n    }\n\n    activePostFlushCbs.sort((a, b) => getId(a) - getId(b))\n\n    for (\n      postFlushIndex = 0;\n      postFlushIndex < activePostFlushCbs.length;\n      postFlushIndex++\n    ) {\n      if (\n        __DEV__ &&\n        checkRecursiveUpdates(seen!, activePostFlushCbs[postFlushIndex])\n      ) {\n        continue\n      }\n      activePostFlushCbs[postFlushIndex]()\n    }\n    activePostFlushCbs = null\n    postFlushIndex = 0\n  }\n}\n\nconst getId = (job: SchedulerJob): number =>\n  job.id == null ? Infinity : job.id\n\nfunction flushJobs(seen?: CountMap) {\n  isFlushPending = false\n  isFlushing = true\n  if (__DEV__) {\n    seen = seen || new Map()\n  }\n\n  flushPreFlushCbs(seen)\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child so its render effect will have smaller\n  //    priority number)\n  // 2. If a component is unmounted during a parent component's update,\n  //    its update can be skipped.\n  queue.sort((a, b) => getId(a) - getId(b))\n\n  // conditional usage of checkRecursiveUpdate must be determined out of\n  // try ... catch block since Rollup by default de-optimizes treeshaking\n  // inside try-catch. This can leave all warning code unshaked. Although\n  // they would get eventually shaken by a minifier like terser, some minifiers\n  // would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)\n  const check = __DEV__\n    ? (job: SchedulerJob) => checkRecursiveUpdates(seen!, job)\n    : NOOP\n\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex]\n      if (job && job.active !== false) {\n        if (__DEV__ && check(job)) {\n          continue\n        }\n        // console.log(`running:`, job.id)\n        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER)\n      }\n    }\n  } finally {\n    flushIndex = 0\n    queue.length = 0\n\n    flushPostFlushCbs(seen)\n\n    isFlushing = false\n    currentFlushPromise = null\n    // some postFlushCb queued jobs!\n    // keep flushing until it drains.\n    if (\n      queue.length ||\n      pendingPreFlushCbs.length ||\n      pendingPostFlushCbs.length\n    ) {\n      flushJobs(seen)\n    }\n  }\n}\n\nfunction checkRecursiveUpdates(seen: CountMap, fn: SchedulerJob) {\n  if (!seen.has(fn)) {\n    seen.set(fn, 1)\n  } else {\n    const count = seen.get(fn)!\n    if (count > RECURSION_LIMIT) {\n      const instance = fn.ownerInstance\n      const componentName = instance && getComponentName(instance.type)\n      warn(\n        `Maximum recursive updates exceeded${\n          componentName ? ` in component <${componentName}>` : ``\n        }. ` +\n          `This means you have a reactive effect that is mutating its own ` +\n          `dependencies and thus recursively triggering itself. Possible sources ` +\n          `include component template, render function, updated hook or ` +\n          `watcher source function.`\n      )\n      return true\n    } else {\n      seen.set(fn, count + 1)\n    }\n  }\n}\n", "/* eslint-disable no-restricted-globals */\nimport {\n  ConcreteComponent,\n  ComponentInternalInstance,\n  ComponentOptions,\n  InternalRenderFunction,\n  ClassComponent,\n  isClassComponent\n} from './component'\nimport { queueJob, queuePostFlushCb } from './scheduler'\nimport { extend, getGlobalThis } from '@vue/shared'\n\ntype HMRComponent = ComponentOptions | ClassComponent\n\nexport let isHmrUpdating = false\n\nexport const hmrDirtyComponents = new Set<ConcreteComponent>()\n\nexport interface HMRRuntime {\n  createRecord: typeof createRecord\n  rerender: typeof rerender\n  reload: typeof reload\n}\n\n// Expose the HMR runtime on the global object\n// This makes it entirely tree-shakable without polluting the exports and makes\n// it easier to be used in toolings like vue-loader\n// Note: for a component to be eligible for HMR it also needs the __hmrId option\n// to be set so that its instances can be registered / removed.\nif (__DEV__) {\n  getGlobalThis().__VUE_HMR_RUNTIME__ = {\n    createRecord: tryWrap(createRecord),\n    rerender: tryWrap(rerender),\n    reload: tryWrap(reload)\n  } as HMRRuntime\n}\n\nconst map: Map<\n  string,\n  {\n    // the initial component definition is recorded on import - this allows us\n    // to apply hot updates to the component even when there are no actively\n    // rendered instance.\n    initialDef: ComponentOptions\n    instances: Set<ComponentInternalInstance>\n  }\n> = new Map()\n\nexport function registerHMR(instance: ComponentInternalInstance) {\n  const id = instance.type.__hmrId!\n  let record = map.get(id)\n  if (!record) {\n    createRecord(id, instance.type as HMRComponent)\n    record = map.get(id)!\n  }\n  record.instances.add(instance)\n}\n\nexport function unregisterHMR(instance: ComponentInternalInstance) {\n  map.get(instance.type.__hmrId!)!.instances.delete(instance)\n}\n\nfunction createRecord(id: string, initialDef: HMRComponent): boolean {\n  if (map.has(id)) {\n    return false\n  }\n  map.set(id, {\n    initialDef: normalizeClassComponent(initialDef),\n    instances: new Set()\n  })\n  return true\n}\n\nfunction normalizeClassComponent(component: HMRComponent): ComponentOptions {\n  return isClassComponent(component) ? component.__vccOpts : component\n}\n\nfunction rerender(id: string, newRender?: Function) {\n  const record = map.get(id)\n  if (!record) {\n    return\n  }\n\n  // update initial record (for not-yet-rendered component)\n  record.initialDef.render = newRender\n\n  // Create a snapshot which avoids the set being mutated during updates\n  ;[...record.instances].forEach(instance => {\n    if (newRender) {\n      instance.render = newRender as InternalRenderFunction\n      normalizeClassComponent(instance.type as HMRComponent).render = newRender\n    }\n    instance.renderCache = []\n    // this flag forces child components with slot content to update\n    isHmrUpdating = true\n    instance.update()\n    isHmrUpdating = false\n  })\n}\n\nfunction reload(id: string, newComp: HMRComponent) {\n  const record = map.get(id)\n  if (!record) return\n\n  newComp = normalizeClassComponent(newComp)\n  // update initial def (for not-yet-rendered components)\n  updateComponentDef(record.initialDef, newComp)\n\n  // create a snapshot which avoids the set being mutated during updates\n  const instances = [...record.instances]\n\n  for (const instance of instances) {\n    const oldComp = normalizeClassComponent(instance.type as HMRComponent)\n\n    if (!hmrDirtyComponents.has(oldComp)) {\n      // 1. Update existing comp definition to match new one\n      if (oldComp !== record.initialDef) {\n        updateComponentDef(oldComp, newComp)\n      }\n      // 2. mark definition dirty. This forces the renderer to replace the\n      // component on patch.\n      hmrDirtyComponents.add(oldComp)\n    }\n\n    // 3. invalidate options resolution cache\n    instance.appContext.optionsCache.delete(instance.type as any)\n\n    // 4. actually update\n    if (instance.ceReload) {\n      // custom element\n      hmrDirtyComponents.add(oldComp)\n      instance.ceReload((newComp as any).styles)\n      hmrDirtyComponents.delete(oldComp)\n    } else if (instance.parent) {\n      // 4. Force the parent instance to re-render. This will cause all updated\n      // components to be unmounted and re-mounted. Queue the update so that we\n      // don't end up forcing the same parent to re-render multiple times.\n      queueJob(instance.parent.update)\n      // instance is the inner component of an async custom element\n      // invoke to reset styles\n      if (\n        (instance.parent.type as ComponentOptions).__asyncLoader &&\n        instance.parent.ceReload\n      ) {\n        instance.parent.ceReload((newComp as any).styles)\n      }\n    } else if (instance.appContext.reload) {\n      // root instance mounted via createApp() has a reload method\n      instance.appContext.reload()\n    } else if (typeof window !== 'undefined') {\n      // root instance inside tree created via raw render(). Force reload.\n      window.location.reload()\n    } else {\n      console.warn(\n        '[HMR] Root or manually mounted instance modified. Full reload required.'\n      )\n    }\n  }\n\n  // 5. make sure to cleanup dirty hmr components after update\n  queuePostFlushCb(() => {\n    for (const instance of instances) {\n      hmrDirtyComponents.delete(\n        normalizeClassComponent(instance.type as HMRComponent)\n      )\n    }\n  })\n}\n\nfunction updateComponentDef(\n  oldComp: ComponentOptions,\n  newComp: ComponentOptions\n) {\n  extend(oldComp, newComp)\n  for (const key in oldComp) {\n    if (key !== '__file' && !(key in newComp)) {\n      delete (oldComp as any)[key]\n    }\n  }\n}\n\nfunction tryWrap(fn: (id: string, arg: any) => any): Function {\n  return (id: string, arg: any) => {\n    try {\n      return fn(id, arg)\n    } catch (e: any) {\n      console.error(e)\n      console.warn(\n        `[HMR] Something went wrong during Vue component hot-reload. ` +\n          `Full reload required.`\n      )\n    }\n  }\n}\n", "import { App } from './apiCreateApp'\nimport { Fragment, Text, Comment, Static } from './vnode'\nimport { ComponentInternalInstance } from './component'\n\ninterface AppRecord {\n  id: number\n  app: App\n  version: string\n  types: Record<string, string | Symbol>\n}\n\nconst enum DevtoolsHooks {\n  APP_INIT = 'app:init',\n  APP_UNMOUNT = 'app:unmount',\n  COMPONENT_UPDATED = 'component:updated',\n  COMPONENT_ADDED = 'component:added',\n  COMPONENT_REMOVED = 'component:removed',\n  COMPONENT_EMIT = 'component:emit',\n  PERFORMANCE_START = 'perf:start',\n  PERFORMANCE_END = 'perf:end'\n}\n\ninterface DevtoolsHook {\n  enabled?: boolean\n  emit: (event: string, ...payload: any[]) => void\n  on: (event: string, handler: Function) => void\n  once: (event: string, handler: Function) => void\n  off: (event: string, handler: Function) => void\n  appRecords: AppRecord[]\n}\n\nexport let devtools: DevtoolsHook\n\nlet buffer: { event: string; args: any[] }[] = []\n\nlet devtoolsNotInstalled = false\n\nfunction emit(event: string, ...args: any[]) {\n  if (devtools) {\n    devtools.emit(event, ...args)\n  } else if (!devtoolsNotInstalled) {\n    buffer.push({ event, args })\n  }\n}\n\nexport function setDevtoolsHook(hook: DevtoolsHook, target: any) {\n  devtools = hook\n  if (devtools) {\n    devtools.enabled = true\n    buffer.forEach(({ event, args }) => devtools.emit(event, ...args))\n    buffer = []\n  } else if (\n    // handle late devtools injection - only do this if we are in an actual\n    // browser environment to avoid the timer handle stalling test runner exit\n    // (#4815)\n    // eslint-disable-next-line no-restricted-globals\n    typeof window !== 'undefined' &&\n    // some envs mock window but not fully\n    window.HTMLElement &&\n    // also exclude jsdom\n    !window.navigator?.userAgent?.includes('jsdom')\n  ) {\n    const replay = (target.__VUE_DEVTOOLS_HOOK_REPLAY__ =\n      target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [])\n    replay.push((newHook: DevtoolsHook) => {\n      setDevtoolsHook(newHook, target)\n    })\n    // clear buffer after 3s - the user probably doesn't have devtools installed\n    // at all, and keeping the buffer will cause memory leaks (#4738)\n    setTimeout(() => {\n      if (!devtools) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null\n        devtoolsNotInstalled = true\n        buffer = []\n      }\n    }, 3000)\n  } else {\n    // non-browser env, assume not installed\n    devtoolsNotInstalled = true\n    buffer = []\n  }\n}\n\nexport function devtoolsInitApp(app: App, version: string) {\n  emit(DevtoolsHooks.APP_INIT, app, version, {\n    Fragment,\n    Text,\n    Comment,\n    Static\n  })\n}\n\nexport function devtoolsUnmountApp(app: App) {\n  emit(DevtoolsHooks.APP_UNMOUNT, app)\n}\n\nexport const devtoolsComponentAdded = /*#__PURE__*/ createDevtoolsComponentHook(\n  DevtoolsHooks.COMPONENT_ADDED\n)\n\nexport const devtoolsComponentUpdated =\n  /*#__PURE__*/ createDevtoolsComponentHook(DevtoolsHooks.COMPONENT_UPDATED)\n\nexport const devtoolsComponentRemoved =\n  /*#__PURE__*/ createDevtoolsComponentHook(DevtoolsHooks.COMPONENT_REMOVED)\n\nfunction createDevtoolsComponentHook(hook: DevtoolsHooks) {\n  return (component: ComponentInternalInstance) => {\n    emit(\n      hook,\n      component.appContext.app,\n      component.uid,\n      component.parent ? component.parent.uid : undefined,\n      component\n    )\n  }\n}\n\nexport const devtoolsPerfStart = /*#__PURE__*/ createDevtoolsPerformanceHook(\n  DevtoolsHooks.PERFORMANCE_START\n)\n\nexport const devtoolsPerfEnd = /*#__PURE__*/ createDevtoolsPerformanceHook(\n  DevtoolsHooks.PERFORMANCE_END\n)\n\nfunction createDevtoolsPerformanceHook(hook: DevtoolsHooks) {\n  return (component: ComponentInternalInstance, type: string, time: number) => {\n    emit(hook, component.appContext.app, component.uid, component, type, time)\n  }\n}\n\nexport function devtoolsComponentEmit(\n  component: ComponentInternalInstance,\n  event: string,\n  params: any[]\n) {\n  emit(\n    DevtoolsHooks.COMPONENT_EMIT,\n    component.appContext.app,\n    component,\n    event,\n    params\n  )\n}\n", "import { extend, hasOwn, isArray, isFunction } from '@vue/shared'\nimport {\n  Component,\n  ComponentInternalInstance,\n  ComponentOptions,\n  formatComponentName,\n  getComponentName,\n  getCurrentInstance,\n  isRuntimeOnly\n} from '../component'\nimport { warn } from '../warning'\n\nexport const enum DeprecationTypes {\n  GLOBAL_MOUNT = 'GLOBAL_MOUNT',\n  GLOBAL_MOUNT_CONTAINER = 'GLOBAL_MOUNT_CONTAINER',\n  GLOBAL_EXTEND = 'GLOBAL_EXTEND',\n  GLOBAL_PROTOTYPE = 'GLOBAL_PROTOTYPE',\n  GLOBAL_SET = 'GLOBAL_SET',\n  GLOBAL_DELETE = 'GLOBAL_DELETE',\n  GLOBAL_OBSERVABLE = 'GLOBAL_OBSERVABLE',\n  GLOBAL_PRIVATE_UTIL = 'GLOBAL_PRIVATE_UTIL',\n\n  CONFIG_SILENT = 'CONFIG_SILENT',\n  CONFIG_DEVTOOLS = 'CONFIG_DEVTOOLS',\n  CONFIG_KEY_CODES = 'CONFIG_KEY_CODES',\n  CONFIG_PRODUCTION_TIP = 'CONFIG_PRODUCTION_TIP',\n  CONFIG_IGNORED_ELEMENTS = 'CONFIG_IGNORED_ELEMENTS',\n  CONFIG_WHITESPACE = 'CONFIG_WHITESPACE',\n  CONFIG_OPTION_MERGE_STRATS = 'CONFIG_OPTION_MERGE_STRATS',\n\n  INSTANCE_SET = 'INSTANCE_SET',\n  INSTANCE_DELETE = 'INSTANCE_DELETE',\n  INSTANCE_DESTROY = 'INSTANCE_DESTROY',\n  INSTANCE_EVENT_EMITTER = 'INSTANCE_EVENT_EMITTER',\n  INSTANCE_EVENT_HOOKS = 'INSTANCE_EVENT_HOOKS',\n  INSTANCE_CHILDREN = 'INSTANCE_CHILDREN',\n  INSTANCE_LISTENERS = 'INSTANCE_LISTENERS',\n  INSTANCE_SCOPED_SLOTS = 'INSTANCE_SCOPED_SLOTS',\n  INSTANCE_ATTRS_CLASS_STYLE = 'INSTANCE_ATTRS_CLASS_STYLE',\n\n  OPTIONS_DATA_FN = 'OPTIONS_DATA_FN',\n  OPTIONS_DATA_MERGE = 'OPTIONS_DATA_MERGE',\n  OPTIONS_BEFORE_DESTROY = 'OPTIONS_BEFORE_DESTROY',\n  OPTIONS_DESTROYED = 'OPTIONS_DESTROYED',\n\n  WATCH_ARRAY = 'WATCH_ARRAY',\n  PROPS_DEFAULT_THIS = 'PROPS_DEFAULT_THIS',\n\n  V_ON_KEYCODE_MODIFIER = 'V_ON_KEYCODE_MODIFIER',\n  CUSTOM_DIR = 'CUSTOM_DIR',\n\n  ATTR_FALSE_VALUE = 'ATTR_FALSE_VALUE',\n  ATTR_ENUMERATED_COERCION = 'ATTR_ENUMERATED_COERCION',\n\n  TRANSITION_CLASSES = 'TRANSITION_CLASSES',\n  TRANSITION_GROUP_ROOT = 'TRANSITION_GROUP_ROOT',\n\n  COMPONENT_ASYNC = 'COMPONENT_ASYNC',\n  COMPONENT_FUNCTIONAL = 'COMPONENT_FUNCTIONAL',\n  COMPONENT_V_MODEL = 'COMPONENT_V_MODEL',\n\n  RENDER_FUNCTION = 'RENDER_FUNCTION',\n\n  FILTERS = 'FILTERS',\n\n  PRIVATE_APIS = 'PRIVATE_APIS'\n}\n\ntype DeprecationData = {\n  message: string | ((...args: any[]) => string)\n  link?: string\n}\n\nexport const deprecationData: Record<DeprecationTypes, DeprecationData> = {\n  [DeprecationTypes.GLOBAL_MOUNT]: {\n    message:\n      `The global app bootstrapping API has changed: vm.$mount() and the \"el\" ` +\n      `option have been removed. Use createApp(RootComponent).mount() instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#mounting-app-instance`\n  },\n\n  [DeprecationTypes.GLOBAL_MOUNT_CONTAINER]: {\n    message:\n      `Vue detected directives on the mount container. ` +\n      `In Vue 3, the container is no longer considered part of the template ` +\n      `and will not be processed/replaced.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/mount-changes.html`\n  },\n\n  [DeprecationTypes.GLOBAL_EXTEND]: {\n    message:\n      `Vue.extend() has been removed in Vue 3. ` +\n      `Use defineComponent() instead.`,\n    link: `https://vuejs.org/api/general.html#definecomponent`\n  },\n\n  [DeprecationTypes.GLOBAL_PROTOTYPE]: {\n    message:\n      `Vue.prototype is no longer available in Vue 3. ` +\n      `Use app.config.globalProperties instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#vue-prototype-replaced-by-config-globalproperties`\n  },\n\n  [DeprecationTypes.GLOBAL_SET]: {\n    message:\n      `Vue.set() has been removed as it is no longer needed in Vue 3. ` +\n      `Simply use native JavaScript mutations.`\n  },\n\n  [DeprecationTypes.GLOBAL_DELETE]: {\n    message:\n      `Vue.delete() has been removed as it is no longer needed in Vue 3. ` +\n      `Simply use native JavaScript mutations.`\n  },\n\n  [DeprecationTypes.GLOBAL_OBSERVABLE]: {\n    message:\n      `Vue.observable() has been removed. ` +\n      `Use \\`import { reactive } from \"vue\"\\` from Composition API instead.`,\n    link: `https://vuejs.org/api/reactivity-core.html#reactive`\n  },\n\n  [DeprecationTypes.GLOBAL_PRIVATE_UTIL]: {\n    message:\n      `Vue.util has been removed. Please refactor to avoid its usage ` +\n      `since it was an internal API even in Vue 2.`\n  },\n\n  [DeprecationTypes.CONFIG_SILENT]: {\n    message:\n      `config.silent has been removed because it is not good practice to ` +\n      `intentionally suppress warnings. You can use your browser console's ` +\n      `filter features to focus on relevant messages.`\n  },\n\n  [DeprecationTypes.CONFIG_DEVTOOLS]: {\n    message:\n      `config.devtools has been removed. To enable devtools for ` +\n      `production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.`,\n    link: `https://github.com/vuejs/core/tree/main/packages/vue#bundler-build-feature-flags`\n  },\n\n  [DeprecationTypes.CONFIG_KEY_CODES]: {\n    message:\n      `config.keyCodes has been removed. ` +\n      `In Vue 3, you can directly use the kebab-case key names as v-on modifiers.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html`\n  },\n\n  [DeprecationTypes.CONFIG_PRODUCTION_TIP]: {\n    message: `config.productionTip has been removed.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-productiontip-removed`\n  },\n\n  [DeprecationTypes.CONFIG_IGNORED_ELEMENTS]: {\n    message: () => {\n      let msg = `config.ignoredElements has been removed.`\n      if (isRuntimeOnly()) {\n        msg += ` Pass the \"isCustomElement\" option to @vue/compiler-dom instead.`\n      } else {\n        msg += ` Use config.isCustomElement instead.`\n      }\n      return msg\n    },\n    link: `https://v3-migration.vuejs.org/breaking-changes/global-api.html#config-ignoredelements-is-now-config-iscustomelement`\n  },\n\n  [DeprecationTypes.CONFIG_WHITESPACE]: {\n    // this warning is only relevant in the full build when using runtime\n    // compilation, so it's put in the runtime compatConfig list.\n    message:\n      `Vue 3 compiler's whitespace option will default to \"condense\" instead of ` +\n      `\"preserve\". To suppress this warning, provide an explicit value for ` +\n      `\\`config.compilerOptions.whitespace\\`.`\n  },\n\n  [DeprecationTypes.CONFIG_OPTION_MERGE_STRATS]: {\n    message:\n      `config.optionMergeStrategies no longer exposes internal strategies. ` +\n      `Use custom merge functions instead.`\n  },\n\n  [DeprecationTypes.INSTANCE_SET]: {\n    message:\n      `vm.$set() has been removed as it is no longer needed in Vue 3. ` +\n      `Simply use native JavaScript mutations.`\n  },\n\n  [DeprecationTypes.INSTANCE_DELETE]: {\n    message:\n      `vm.$delete() has been removed as it is no longer needed in Vue 3. ` +\n      `Simply use native JavaScript mutations.`\n  },\n\n  [DeprecationTypes.INSTANCE_DESTROY]: {\n    message: `vm.$destroy() has been removed. Use app.unmount() instead.`,\n    link: `https://vuejs.org/api/application.html#app-unmount`\n  },\n\n  [DeprecationTypes.INSTANCE_EVENT_EMITTER]: {\n    message:\n      `vm.$on/$once/$off() have been removed. ` +\n      `Use an external event emitter library instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/events-api.html`\n  },\n\n  [DeprecationTypes.INSTANCE_EVENT_HOOKS]: {\n    message: event =>\n      `\"${event}\" lifecycle events are no longer supported. From templates, ` +\n      `use the \"vnode\" prefix instead of \"hook:\". For example, @${event} ` +\n      `should be changed to @vnode-${event.slice(5)}. ` +\n      `From JavaScript, use Composition API to dynamically register lifecycle ` +\n      `hooks.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/vnode-lifecycle-events.html`\n  },\n\n  [DeprecationTypes.INSTANCE_CHILDREN]: {\n    message:\n      `vm.$children has been removed. Consider refactoring your logic ` +\n      `to avoid relying on direct access to child components.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/children.html`\n  },\n\n  [DeprecationTypes.INSTANCE_LISTENERS]: {\n    message:\n      `vm.$listeners has been removed. In Vue 3, parent v-on listeners are ` +\n      `included in vm.$attrs and it is no longer necessary to separately use ` +\n      `v-on=\"$listeners\" if you are already using v-bind=\"$attrs\". ` +\n      `(Note: the Vue 3 behavior only applies if this compat config is disabled)`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/listeners-removed.html`\n  },\n\n  [DeprecationTypes.INSTANCE_SCOPED_SLOTS]: {\n    message: `vm.$scopedSlots has been removed. Use vm.$slots instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/slots-unification.html`\n  },\n\n  [DeprecationTypes.INSTANCE_ATTRS_CLASS_STYLE]: {\n    message: componentName =>\n      `Component <${\n        componentName || 'Anonymous'\n      }> has \\`inheritAttrs: false\\` but is ` +\n      `relying on class/style fallthrough from parent. In Vue 3, class/style ` +\n      `are now included in $attrs and will no longer fallthrough when ` +\n      `inheritAttrs is false. If you are already using v-bind=\"$attrs\" on ` +\n      `component root it should render the same end result. ` +\n      `If you are binding $attrs to a non-root element and expecting ` +\n      `class/style to fallthrough on root, you will need to now manually bind ` +\n      `them on root via :class=\"$attrs.class\".`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/attrs-includes-class-style.html`\n  },\n\n  [DeprecationTypes.OPTIONS_DATA_FN]: {\n    message:\n      `The \"data\" option can no longer be a plain object. ` +\n      `Always use a function.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/data-option.html`\n  },\n\n  [DeprecationTypes.OPTIONS_DATA_MERGE]: {\n    message: (key: string) =>\n      `Detected conflicting key \"${key}\" when merging data option values. ` +\n      `In Vue 3, data keys are merged shallowly and will override one another.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/data-option.html#mixin-merge-behavior-change`\n  },\n\n  [DeprecationTypes.OPTIONS_BEFORE_DESTROY]: {\n    message: `\\`beforeDestroy\\` has been renamed to \\`beforeUnmount\\`.`\n  },\n\n  [DeprecationTypes.OPTIONS_DESTROYED]: {\n    message: `\\`destroyed\\` has been renamed to \\`unmounted\\`.`\n  },\n\n  [DeprecationTypes.WATCH_ARRAY]: {\n    message:\n      `\"watch\" option or vm.$watch on an array value will no longer ` +\n      `trigger on array mutation unless the \"deep\" option is specified. ` +\n      `If current usage is intended, you can disable the compat behavior and ` +\n      `suppress this warning with:` +\n      `\\n\\n  configureCompat({ ${DeprecationTypes.WATCH_ARRAY}: false })\\n`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/watch.html`\n  },\n\n  [DeprecationTypes.PROPS_DEFAULT_THIS]: {\n    message: (key: string) =>\n      `props default value function no longer has access to \"this\". The compat ` +\n      `build only offers access to this.$options.` +\n      `(found in prop \"${key}\")`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/props-default-this.html`\n  },\n\n  [DeprecationTypes.CUSTOM_DIR]: {\n    message: (legacyHook: string, newHook: string) =>\n      `Custom directive hook \"${legacyHook}\" has been removed. ` +\n      `Use \"${newHook}\" instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/custom-directives.html`\n  },\n\n  [DeprecationTypes.V_ON_KEYCODE_MODIFIER]: {\n    message:\n      `Using keyCode as v-on modifier is no longer supported. ` +\n      `Use kebab-case key name modifiers instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/keycode-modifiers.html`\n  },\n\n  [DeprecationTypes.ATTR_FALSE_VALUE]: {\n    message: (name: string) =>\n      `Attribute \"${name}\" with v-bind value \\`false\\` will render ` +\n      `${name}=\"false\" instead of removing it in Vue 3. To remove the attribute, ` +\n      `use \\`null\\` or \\`undefined\\` instead. If the usage is intended, ` +\n      `you can disable the compat behavior and suppress this warning with:` +\n      `\\n\\n  configureCompat({ ${DeprecationTypes.ATTR_FALSE_VALUE}: false })\\n`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/attribute-coercion.html`\n  },\n\n  [DeprecationTypes.ATTR_ENUMERATED_COERCION]: {\n    message: (name: string, value: any, coerced: string) =>\n      `Enumerated attribute \"${name}\" with v-bind value \\`${value}\\` will ` +\n      `${\n        value === null ? `be removed` : `render the value as-is`\n      } instead of coercing the value to \"${coerced}\" in Vue 3. ` +\n      `Always use explicit \"true\" or \"false\" values for enumerated attributes. ` +\n      `If the usage is intended, ` +\n      `you can disable the compat behavior and suppress this warning with:` +\n      `\\n\\n  configureCompat({ ${DeprecationTypes.ATTR_ENUMERATED_COERCION}: false })\\n`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/attribute-coercion.html`\n  },\n\n  [DeprecationTypes.TRANSITION_CLASSES]: {\n    message: `` // this feature cannot be runtime-detected\n  },\n\n  [DeprecationTypes.TRANSITION_GROUP_ROOT]: {\n    message:\n      `<TransitionGroup> no longer renders a root <span> element by ` +\n      `default if no \"tag\" prop is specified. If you do not rely on the span ` +\n      `for styling, you can disable the compat behavior and suppress this ` +\n      `warning with:` +\n      `\\n\\n  configureCompat({ ${DeprecationTypes.TRANSITION_GROUP_ROOT}: false })\\n`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/transition-group.html`\n  },\n\n  [DeprecationTypes.COMPONENT_ASYNC]: {\n    message: (comp: any) => {\n      const name = getComponentName(comp)\n      return (\n        `Async component${\n          name ? ` <${name}>` : `s`\n        } should be explicitly created via \\`defineAsyncComponent()\\` ` +\n        `in Vue 3. Plain functions will be treated as functional components in ` +\n        `non-compat build. If you have already migrated all async component ` +\n        `usage and intend to use plain functions for functional components, ` +\n        `you can disable the compat behavior and suppress this ` +\n        `warning with:` +\n        `\\n\\n  configureCompat({ ${DeprecationTypes.COMPONENT_ASYNC}: false })\\n`\n      )\n    },\n    link: `https://v3-migration.vuejs.org/breaking-changes/async-components.html`\n  },\n\n  [DeprecationTypes.COMPONENT_FUNCTIONAL]: {\n    message: (comp: any) => {\n      const name = getComponentName(comp)\n      return (\n        `Functional component${\n          name ? ` <${name}>` : `s`\n        } should be defined as a plain function in Vue 3. The \"functional\" ` +\n        `option has been removed. NOTE: Before migrating to use plain ` +\n        `functions for functional components, first make sure that all async ` +\n        `components usage have been migrated and its compat behavior has ` +\n        `been disabled.`\n      )\n    },\n    link: `https://v3-migration.vuejs.org/breaking-changes/functional-components.html`\n  },\n\n  [DeprecationTypes.COMPONENT_V_MODEL]: {\n    message: (comp: ComponentOptions) => {\n      const configMsg =\n        `opt-in to ` +\n        `Vue 3 behavior on a per-component basis with \\`compatConfig: { ${DeprecationTypes.COMPONENT_V_MODEL}: false }\\`.`\n      if (\n        comp.props &&\n        (isArray(comp.props)\n          ? comp.props.includes('modelValue')\n          : hasOwn(comp.props, 'modelValue'))\n      ) {\n        return (\n          `Component declares \"modelValue\" prop, which is Vue 3 usage, but ` +\n          `is running under Vue 2 compat v-model behavior. You can ${configMsg}`\n        )\n      }\n      return (\n        `v-model usage on component has changed in Vue 3. Component that expects ` +\n        `to work with v-model should now use the \"modelValue\" prop and emit the ` +\n        `\"update:modelValue\" event. You can update the usage and then ${configMsg}`\n      )\n    },\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\n  },\n\n  [DeprecationTypes.RENDER_FUNCTION]: {\n    message:\n      `Vue 3's render function API has changed. ` +\n      `You can opt-in to the new API with:` +\n      `\\n\\n  configureCompat({ ${DeprecationTypes.RENDER_FUNCTION}: false })\\n` +\n      `\\n  (This can also be done per-component via the \"compatConfig\" option.)`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/render-function-api.html`\n  },\n\n  [DeprecationTypes.FILTERS]: {\n    message:\n      `filters have been removed in Vue 3. ` +\n      `The \"|\" symbol will be treated as native JavaScript bitwise OR operator. ` +\n      `Use method calls or computed properties instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\n  },\n\n  [DeprecationTypes.PRIVATE_APIS]: {\n    message: name =>\n      `\"${name}\" is a Vue 2 private API that no longer exists in Vue 3. ` +\n      `If you are seeing this warning only due to a dependency, you can ` +\n      `suppress this warning via { PRIVATE_APIS: 'suppress-warning' }.`\n  }\n}\n\nconst instanceWarned: Record<string, true> = Object.create(null)\nconst warnCount: Record<string, number> = Object.create(null)\n\n// test only\nlet warningEnabled = true\n\nexport function toggleDeprecationWarning(flag: boolean) {\n  warningEnabled = flag\n}\n\nexport function warnDeprecation(\n  key: DeprecationTypes,\n  instance: ComponentInternalInstance | null,\n  ...args: any[]\n) {\n  if (!__DEV__) {\n    return\n  }\n  if (__TEST__ && !warningEnabled) {\n    return\n  }\n\n  instance = instance || getCurrentInstance()\n\n  // check user config\n  const config = getCompatConfigForKey(key, instance)\n  if (config === 'suppress-warning') {\n    return\n  }\n\n  const dupKey = key + args.join('')\n  let compId: string | number | null =\n    instance && formatComponentName(instance, instance.type)\n  if (compId === 'Anonymous' && instance) {\n    compId = instance.uid\n  }\n\n  // skip if the same warning is emitted for the same component type\n  const componentDupKey = dupKey + compId\n  if (!__TEST__ && componentDupKey in instanceWarned) {\n    return\n  }\n  instanceWarned[componentDupKey] = true\n\n  // same warning, but different component. skip the long message and just\n  // log the key and count.\n  if (!__TEST__ && dupKey in warnCount) {\n    warn(`(deprecation ${key}) (${++warnCount[dupKey] + 1})`)\n    return\n  }\n\n  warnCount[dupKey] = 0\n\n  const { message, link } = deprecationData[key]\n  warn(\n    `(deprecation ${key}) ${\n      typeof message === 'function' ? message(...args) : message\n    }${link ? `\\n  Details: ${link}` : ``}`\n  )\n  if (!isCompatEnabled(key, instance, true)) {\n    console.error(\n      `^ The above deprecation's compat behavior is disabled and will likely ` +\n        `lead to runtime errors.`\n    )\n  }\n}\n\nexport type CompatConfig = Partial<\n  Record<DeprecationTypes, boolean | 'suppress-warning'>\n> & {\n  MODE?: 2 | 3 | ((comp: Component | null) => 2 | 3)\n}\n\nexport const globalCompatConfig: CompatConfig = {\n  MODE: 2\n}\n\nexport function configureCompat(config: CompatConfig) {\n  if (__DEV__) {\n    validateCompatConfig(config)\n  }\n  extend(globalCompatConfig, config)\n}\n\nconst seenConfigObjects = /*#__PURE__*/ new WeakSet<CompatConfig>()\nconst warnedInvalidKeys: Record<string, boolean> = {}\n\n// dev only\nexport function validateCompatConfig(\n  config: CompatConfig,\n  instance?: ComponentInternalInstance\n) {\n  if (seenConfigObjects.has(config)) {\n    return\n  }\n  seenConfigObjects.add(config)\n\n  for (const key of Object.keys(config)) {\n    if (\n      key !== 'MODE' &&\n      !(key in deprecationData) &&\n      !(key in warnedInvalidKeys)\n    ) {\n      if (key.startsWith('COMPILER_')) {\n        if (isRuntimeOnly()) {\n          warn(\n            `Deprecation config \"${key}\" is compiler-specific and you are ` +\n              `running a runtime-only build of Vue. This deprecation should be ` +\n              `configured via compiler options in your build setup instead.\\n` +\n              `Details: https://v3-migration.vuejs.org/breaking-changes/migration-build.html`\n          )\n        }\n      } else {\n        warn(`Invalid deprecation config \"${key}\".`)\n      }\n      warnedInvalidKeys[key] = true\n    }\n  }\n\n  if (instance && config[DeprecationTypes.OPTIONS_DATA_MERGE] != null) {\n    warn(\n      `Deprecation config \"${DeprecationTypes.OPTIONS_DATA_MERGE}\" can only be configured globally.`\n    )\n  }\n}\n\nexport function getCompatConfigForKey(\n  key: DeprecationTypes | 'MODE',\n  instance: ComponentInternalInstance | null\n) {\n  const instanceConfig =\n    instance && (instance.type as ComponentOptions).compatConfig\n  if (instanceConfig && key in instanceConfig) {\n    return instanceConfig[key]\n  }\n  return globalCompatConfig[key]\n}\n\nexport function isCompatEnabled(\n  key: DeprecationTypes,\n  instance: ComponentInternalInstance | null,\n  enableForBuiltIn = false\n): boolean {\n  // skip compat for built-in components\n  if (!enableForBuiltIn && instance && instance.type.__isBuiltIn) {\n    return false\n  }\n\n  const rawMode = getCompatConfigForKey('MODE', instance) || 2\n  const val = getCompatConfigForKey(key, instance)\n\n  const mode = isFunction(rawMode)\n    ? rawMode(instance && instance.type)\n    : rawMode\n\n  if (mode === 2) {\n    return val !== false\n  } else {\n    return val === true || val === 'suppress-warning'\n  }\n}\n\n/**\n * Use this for features that are completely removed in non-compat build.\n */\nexport function assertCompatEnabled(\n  key: DeprecationTypes,\n  instance: ComponentInternalInstance | null,\n  ...args: any[]\n) {\n  if (!isCompatEnabled(key, instance)) {\n    throw new Error(`${key} compat has been disabled.`)\n  } else if (__DEV__) {\n    warnDeprecation(key, instance, ...args)\n  }\n}\n\n/**\n * Use this for features where legacy usage is still possible, but will likely\n * lead to runtime error if compat is disabled. (warn in all cases)\n */\nexport function softAssertCompatEnabled(\n  key: DeprecationTypes,\n  instance: ComponentInternalInstance | null,\n  ...args: any[]\n) {\n  if (__DEV__) {\n    warnDeprecation(key, instance, ...args)\n  }\n  return isCompatEnabled(key, instance)\n}\n\n/**\n * Use this for features with the same syntax but with mutually exclusive\n * behavior in 2 vs 3. Only warn if compat is enabled.\n * e.g. render function\n */\nexport function checkCompatEnabled(\n  key: DeprecationTypes,\n  instance: ComponentInternalInstance | null,\n  ...args: any[]\n) {\n  const enabled = isCompatEnabled(key, instance)\n  if (__DEV__ && enabled) {\n    warnDeprecation(key, instance, ...args)\n  }\n  return enabled\n}\n\n// run tests in v3 mode by default\nif (__TEST__) {\n  configureCompat({\n    MODE: 3\n  })\n}\n", "import {\n  camelize,\n  EMPTY_OBJ,\n  toHandlerKey,\n  extend,\n  hasOwn,\n  hyphenate,\n  isArray,\n  isFunction,\n  isOn,\n  toNumber,\n  UnionToIntersection\n} from '@vue/shared'\nimport {\n  ComponentInternalInstance,\n  ComponentOptions,\n  ConcreteComponent,\n  formatComponentName\n} from './component'\nimport { callWithAsyncErrorHandling, ErrorCodes } from './errorHandling'\nimport { warn } from './warning'\nimport { devtoolsComponentEmit } from './devtools'\nimport { AppContext } from './apiCreateApp'\nimport { emit as compatInstanceEmit } from './compat/instanceEventEmitter'\nimport {\n  compatModelEventPrefix,\n  compatModelEmit\n} from './compat/componentVModel'\n\nexport type ObjectEmitsOptions = Record<\n  string,\n  ((...args: any[]) => any) | null\n>\n\nexport type EmitsOptions = ObjectEmitsOptions | string[]\n\nexport type EmitsToProps<T extends EmitsOptions> = T extends string[]\n  ? {\n      [K in string & `on${Capitalize<T[number]>}`]?: (...args: any[]) => any\n    }\n  : T extends ObjectEmitsOptions\n  ? {\n      [K in string &\n        `on${Capitalize<string & keyof T>}`]?: K extends `on${infer C}`\n        ? T[Uncapitalize<C>] extends null\n          ? (...args: any[]) => any\n          : (\n              ...args: T[Uncapitalize<C>] extends (...args: infer P) => any\n                ? P\n                : never\n            ) => any\n        : never\n    }\n  : {}\n\nexport type EmitFn<\n  Options = ObjectEmitsOptions,\n  Event extends keyof Options = keyof Options\n> = Options extends Array<infer V>\n  ? (event: V, ...args: any[]) => void\n  : {} extends Options // if the emit is empty object (usually the default value for emit) should be converted to function\n  ? (event: string, ...args: any[]) => void\n  : UnionToIntersection<\n      {\n        [key in Event]: Options[key] extends (...args: infer Args) => any\n          ? (event: key, ...args: Args) => void\n          : (event: key, ...args: any[]) => void\n      }[Event]\n    >\n\nexport function emit(\n  instance: ComponentInternalInstance,\n  event: string,\n  ...rawArgs: any[]\n) {\n  const props = instance.vnode.props || EMPTY_OBJ\n\n  if (__DEV__) {\n    const {\n      emitsOptions,\n      propsOptions: [propsOptions]\n    } = instance\n    if (emitsOptions) {\n      if (\n        !(event in emitsOptions) &&\n        !(\n          __COMPAT__ &&\n          (event.startsWith('hook:') ||\n            event.startsWith(compatModelEventPrefix))\n        )\n      ) {\n        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {\n          warn(\n            `Component emitted event \"${event}\" but it is neither declared in ` +\n              `the emits option nor as an \"${toHandlerKey(event)}\" prop.`\n          )\n        }\n      } else {\n        const validator = emitsOptions[event]\n        if (isFunction(validator)) {\n          const isValid = validator(...rawArgs)\n          if (!isValid) {\n            warn(\n              `Invalid event arguments: event validation failed for event \"${event}\".`\n            )\n          }\n        }\n      }\n    }\n  }\n\n  let args = rawArgs\n  const isModelListener = event.startsWith('update:')\n\n  // for v-model update:xxx events, apply modifiers on args\n  const modelArg = isModelListener && event.slice(7)\n  if (modelArg && modelArg in props) {\n    const modifiersKey = `${\n      modelArg === 'modelValue' ? 'model' : modelArg\n    }Modifiers`\n    const { number, trim } = props[modifiersKey] || EMPTY_OBJ\n    if (trim) {\n      args = rawArgs.map(a => a.trim())\n    } else if (number) {\n      args = rawArgs.map(toNumber)\n    }\n  }\n\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n    devtoolsComponentEmit(instance, event, args)\n  }\n\n  if (__DEV__) {\n    const lowerCaseEvent = event.toLowerCase()\n    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {\n      warn(\n        `Event \"${lowerCaseEvent}\" is emitted in component ` +\n          `${formatComponentName(\n            instance,\n            instance.type\n          )} but the handler is registered for \"${event}\". ` +\n          `Note that HTML attributes are case-insensitive and you cannot use ` +\n          `v-on to listen to camelCase events when using in-DOM templates. ` +\n          `You should probably use \"${hyphenate(event)}\" instead of \"${event}\".`\n      )\n    }\n  }\n\n  let handlerName\n  let handler =\n    props[(handlerName = toHandlerKey(event))] ||\n    // also try camelCase event handler (#2249)\n    props[(handlerName = toHandlerKey(camelize(event)))]\n  // for v-model update:xxx events, also trigger kebab-case equivalent\n  // for props passed via kebab-case\n  if (!handler && isModelListener) {\n    handler = props[(handlerName = toHandlerKey(hyphenate(event)))]\n  }\n\n  if (handler) {\n    callWithAsyncErrorHandling(\n      handler,\n      instance,\n      ErrorCodes.COMPONENT_EVENT_HANDLER,\n      args\n    )\n  }\n\n  const onceHandler = props[handlerName + `Once`]\n  if (onceHandler) {\n    if (!instance.emitted) {\n      instance.emitted = {} as Record<any, boolean>\n    } else if (instance.emitted[handlerName]) {\n      return\n    }\n    instance.emitted[handlerName] = true\n    callWithAsyncErrorHandling(\n      onceHandler,\n      instance,\n      ErrorCodes.COMPONENT_EVENT_HANDLER,\n      args\n    )\n  }\n\n  if (__COMPAT__) {\n    compatModelEmit(instance, event, args)\n    return compatInstanceEmit(instance, event, args)\n  }\n}\n\nexport function normalizeEmitsOptions(\n  comp: ConcreteComponent,\n  appContext: AppContext,\n  asMixin = false\n): ObjectEmitsOptions | null {\n  const cache = appContext.emitsCache\n  const cached = cache.get(comp)\n  if (cached !== undefined) {\n    return cached\n  }\n\n  const raw = comp.emits\n  let normalized: ObjectEmitsOptions = {}\n\n  // apply mixin/extends props\n  let hasExtends = false\n  if (__FEATURE_OPTIONS_API__ && !isFunction(comp)) {\n    const extendEmits = (raw: ComponentOptions) => {\n      const normalizedFromExtend = normalizeEmitsOptions(raw, appContext, true)\n      if (normalizedFromExtend) {\n        hasExtends = true\n        extend(normalized, normalizedFromExtend)\n      }\n    }\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits)\n    }\n    if (comp.extends) {\n      extendEmits(comp.extends)\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits)\n    }\n  }\n\n  if (!raw && !hasExtends) {\n    cache.set(comp, null)\n    return null\n  }\n\n  if (isArray(raw)) {\n    raw.forEach(key => (normalized[key] = null))\n  } else {\n    extend(normalized, raw)\n  }\n\n  cache.set(comp, normalized)\n  return normalized\n}\n\n// Check if an incoming prop key is a declared emit event listener.\n// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are\n// both considered matched listeners.\nexport function isEmitListener(\n  options: ObjectEmitsOptions | null,\n  key: string\n): boolean {\n  if (!options || !isOn(key)) {\n    return false\n  }\n\n  if (__COMPAT__ && key.startsWith(compatModelEventPrefix)) {\n    return true\n  }\n\n  key = key.slice(2).replace(/Once$/, '')\n  return (\n    hasOwn(options, key[0].toLowerCase() + key.slice(1)) ||\n    hasOwn(options, hyphenate(key)) ||\n    hasOwn(options, key)\n  )\n}\n", "import { ComponentInternalInstance } from './component'\nimport { devtoolsComponentUpdated } from './devtools'\nimport { setBlockTracking } from './vnode'\n\n/**\n * mark the current rendering instance for asset resolution (e.g.\n * resolveComponent, resolveDirective) during render\n */\nexport let currentRenderingInstance: ComponentInternalInstance | null = null\nexport let currentScopeId: string | null = null\n\n/**\n * Note: rendering calls maybe nested. The function returns the parent rendering\n * instance if present, which should be restored after the render is done:\n *\n * ```js\n * const prev = setCurrentRenderingInstance(i)\n * // ...render\n * setCurrentRenderingInstance(prev)\n * ```\n */\nexport function setCurrentRenderingInstance(\n  instance: ComponentInternalInstance | null\n): ComponentInternalInstance | null {\n  const prev = currentRenderingInstance\n  currentRenderingInstance = instance\n  currentScopeId = (instance && instance.type.__scopeId) || null\n  // v2 pre-compiled components uses _scopeId instead of __scopeId\n  if (__COMPAT__ && !currentScopeId) {\n    currentScopeId = (instance && (instance.type as any)._scopeId) || null\n  }\n  return prev\n}\n\n/**\n * Set scope id when creating hoisted vnodes.\n * @private compiler helper\n */\nexport function pushScopeId(id: string | null) {\n  currentScopeId = id\n}\n\n/**\n * Technically we no longer need this after 3.0.8 but we need to keep the same\n * API for backwards compat w/ code generated by compilers.\n * @private\n */\nexport function popScopeId() {\n  currentScopeId = null\n}\n\n/**\n * Only for backwards compat\n * @private\n */\nexport const withScopeId = (_id: string) => withCtx\n\nexport type ContextualRenderFn = {\n  (...args: any[]): any\n  _n: boolean /* already normalized */\n  _c: boolean /* compiled */\n  _d: boolean /* disableTracking */\n  _ns: boolean /* nonScoped */\n}\n\n/**\n * Wrap a slot function to memoize current rendering instance\n * @private compiler helper\n */\nexport function withCtx(\n  fn: Function,\n  ctx: ComponentInternalInstance | null = currentRenderingInstance,\n  isNonScopedSlot?: boolean // __COMPAT__ only\n) {\n  if (!ctx) return fn\n\n  // already normalized\n  if ((fn as ContextualRenderFn)._n) {\n    return fn\n  }\n\n  const renderFnWithContext: ContextualRenderFn = (...args: any[]) => {\n    // If a user calls a compiled slot inside a template expression (#1745), it\n    // can mess up block tracking, so by default we disable block tracking and\n    // force bail out when invoking a compiled slot (indicated by the ._d flag).\n    // This isn't necessary if rendering a compiled `<slot>`, so we flip the\n    // ._d flag off when invoking the wrapped fn inside `renderSlot`.\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1)\n    }\n    const prevInstance = setCurrentRenderingInstance(ctx)\n    const res = fn(...args)\n    setCurrentRenderingInstance(prevInstance)\n    if (renderFnWithContext._d) {\n      setBlockTracking(1)\n    }\n\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n      devtoolsComponentUpdated(ctx)\n    }\n\n    return res\n  }\n\n  // mark normalized to avoid duplicated wrapping\n  renderFnWithContext._n = true\n  // mark this as compiled by default\n  // this is used in vnode.ts -> normalizeChildren() to set the slot\n  // rendering flag.\n  renderFnWithContext._c = true\n  // disable block tracking by default\n  renderFnWithContext._d = true\n  // compat build only flag to distinguish scoped slots from non-scoped ones\n  if (__COMPAT__ && isNonScopedSlot) {\n    renderFnWithContext._ns = true\n  }\n  return renderFnWithContext\n}\n", "import {\n  ComponentInternalInstance,\n  FunctionalComponent,\n  Data,\n  getComponentName\n} from './component'\nimport {\n  VNode,\n  normalizeVNode,\n  createVNode,\n  Comment,\n  cloneVNode,\n  VNodeArrayChildren,\n  isVNode,\n  blockStack\n} from './vnode'\nimport { handleError, ErrorCodes } from './errorHandling'\nimport { PatchFlags, ShapeFlags, isOn, isModelListener } from '@vue/shared'\nimport { warn } from './warning'\nimport { isHmrUpdating } from './hmr'\nimport { NormalizedProps } from './componentProps'\nimport { isEmitListener } from './componentEmits'\nimport { setCurrentRenderingInstance } from './componentRenderContext'\nimport {\n  DeprecationTypes,\n  isCompatEnabled,\n  warnDeprecation\n} from './compat/compatConfig'\n\n/**\n * dev only flag to track whether $attrs was used during render.\n * If $attrs was used during render then the warning for failed attrs\n * fallthrough can be suppressed.\n */\nlet accessedAttrs: boolean = false\n\nexport function markAttrsAccessed() {\n  accessedAttrs = true\n}\n\nexport function renderComponentRoot(\n  instance: ComponentInternalInstance\n): VNode {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    props,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs\n  } = instance\n\n  let result\n  let fallthroughAttrs\n  const prev = setCurrentRenderingInstance(instance)\n  if (__DEV__) {\n    accessedAttrs = false\n  }\n\n  try {\n    if (vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n      // withProxy is a proxy with a different `has` trap only for\n      // runtime-compiled render functions using `with` block.\n      const proxyToUse = withProxy || proxy\n      result = normalizeVNode(\n        render!.call(\n          proxyToUse,\n          proxyToUse!,\n          renderCache,\n          props,\n          setupState,\n          data,\n          ctx\n        )\n      )\n      fallthroughAttrs = attrs\n    } else {\n      // functional\n      const render = Component as FunctionalComponent\n      // in dev, mark attrs accessed if optional props (attrs === props)\n      if (__DEV__ && attrs === props) {\n        markAttrsAccessed()\n      }\n      result = normalizeVNode(\n        render.length > 1\n          ? render(\n              props,\n              __DEV__\n                ? {\n                    get attrs() {\n                      markAttrsAccessed()\n                      return attrs\n                    },\n                    slots,\n                    emit\n                  }\n                : { attrs, slots, emit }\n            )\n          : render(props, null as any /* we know it doesn't need it */)\n      )\n      fallthroughAttrs = Component.props\n        ? attrs\n        : getFunctionalFallthrough(attrs)\n    }\n  } catch (err) {\n    blockStack.length = 0\n    handleError(err, instance, ErrorCodes.RENDER_FUNCTION)\n    result = createVNode(Comment)\n  }\n\n  // attr merging\n  // in dev mode, comments are preserved, and it's possible for a template\n  // to have comments along side the root element which makes it a fragment\n  let root = result\n  let setRoot: ((root: VNode) => void) | undefined = undefined\n  if (\n    __DEV__ &&\n    result.patchFlag > 0 &&\n    result.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT\n  ) {\n    ;[root, setRoot] = getChildRoot(result)\n  }\n\n  if (fallthroughAttrs && inheritAttrs !== false) {\n    const keys = Object.keys(fallthroughAttrs)\n    const { shapeFlag } = root\n    if (keys.length) {\n      if (shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.COMPONENT)) {\n        if (propsOptions && keys.some(isModelListener)) {\n          // If a v-model listener (onUpdate:xxx) has a corresponding declared\n          // prop, it indicates this component expects to handle v-model and\n          // it should not fallthrough.\n          // related: #1543, #1643, #1989\n          fallthroughAttrs = filterModelListeners(\n            fallthroughAttrs,\n            propsOptions\n          )\n        }\n        root = cloneVNode(root, fallthroughAttrs)\n      } else if (__DEV__ && !accessedAttrs && root.type !== Comment) {\n        const allAttrs = Object.keys(attrs)\n        const eventAttrs: string[] = []\n        const extraAttrs: string[] = []\n        for (let i = 0, l = allAttrs.length; i < l; i++) {\n          const key = allAttrs[i]\n          if (isOn(key)) {\n            // ignore v-model handlers when they fail to fallthrough\n            if (!isModelListener(key)) {\n              // remove `on`, lowercase first letter to reflect event casing\n              // accurately\n              eventAttrs.push(key[2].toLowerCase() + key.slice(3))\n            }\n          } else {\n            extraAttrs.push(key)\n          }\n        }\n        if (extraAttrs.length) {\n          warn(\n            `Extraneous non-props attributes (` +\n              `${extraAttrs.join(', ')}) ` +\n              `were passed to component but could not be automatically inherited ` +\n              `because component renders fragment or text root nodes.`\n          )\n        }\n        if (eventAttrs.length) {\n          warn(\n            `Extraneous non-emits event listeners (` +\n              `${eventAttrs.join(', ')}) ` +\n              `were passed to component but could not be automatically inherited ` +\n              `because component renders fragment or text root nodes. ` +\n              `If the listener is intended to be a component custom event listener only, ` +\n              `declare it using the \"emits\" option.`\n          )\n        }\n      }\n    }\n  }\n\n  if (\n    __COMPAT__ &&\n    isCompatEnabled(DeprecationTypes.INSTANCE_ATTRS_CLASS_STYLE, instance) &&\n    vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT &&\n    root.shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.COMPONENT)\n  ) {\n    const { class: cls, style } = vnode.props || {}\n    if (cls || style) {\n      if (__DEV__ && inheritAttrs === false) {\n        warnDeprecation(\n          DeprecationTypes.INSTANCE_ATTRS_CLASS_STYLE,\n          instance,\n          getComponentName(instance.type)\n        )\n      }\n      root = cloneVNode(root, {\n        class: cls,\n        style: style\n      })\n    }\n  }\n\n  // inherit directives\n  if (vnode.dirs) {\n    if (__DEV__ && !isElementRoot(root)) {\n      warn(\n        `Runtime directive used on component with non-element root node. ` +\n          `The directives will not function as intended.`\n      )\n    }\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs\n  }\n  // inherit transition data\n  if (vnode.transition) {\n    if (__DEV__ && !isElementRoot(root)) {\n      warn(\n        `Component inside <Transition> renders non-element root node ` +\n          `that cannot be animated.`\n      )\n    }\n    root.transition = vnode.transition\n  }\n\n  if (__DEV__ && setRoot) {\n    setRoot(root)\n  } else {\n    result = root\n  }\n\n  setCurrentRenderingInstance(prev)\n  return result\n}\n\n/**\n * dev only\n * In dev mode, template root level comments are rendered, which turns the\n * template into a fragment root, but we need to locate the single element\n * root for attrs and scope id processing.\n */\nconst getChildRoot = (\n  vnode: VNode\n): [VNode, ((root: VNode) => void) | undefined] => {\n  const rawChildren = vnode.children as VNodeArrayChildren\n  const dynamicChildren = vnode.dynamicChildren\n  const childRoot = filterSingleRoot(rawChildren)\n  if (!childRoot) {\n    return [vnode, undefined]\n  }\n  const index = rawChildren.indexOf(childRoot)\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1\n  const setRoot = (updatedRoot: VNode) => {\n    rawChildren[index] = updatedRoot\n    if (dynamicChildren) {\n      if (dynamicIndex > -1) {\n        dynamicChildren[dynamicIndex] = updatedRoot\n      } else if (updatedRoot.patchFlag > 0) {\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot]\n      }\n    }\n  }\n  return [normalizeVNode(childRoot), setRoot]\n}\n\nexport function filterSingleRoot(\n  children: VNodeArrayChildren\n): VNode | undefined {\n  let singleRoot\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    if (isVNode(child)) {\n      // ignore user comment\n      if (child.type !== Comment || child.children === 'v-if') {\n        if (singleRoot) {\n          // has more than 1 non-comment child, return now\n          return\n        } else {\n          singleRoot = child\n        }\n      }\n    } else {\n      return\n    }\n  }\n  return singleRoot\n}\n\nconst getFunctionalFallthrough = (attrs: Data): Data | undefined => {\n  let res: Data | undefined\n  for (const key in attrs) {\n    if (key === 'class' || key === 'style' || isOn(key)) {\n      ;(res || (res = {}))[key] = attrs[key]\n    }\n  }\n  return res\n}\n\nconst filterModelListeners = (attrs: Data, props: NormalizedProps): Data => {\n  const res: Data = {}\n  for (const key in attrs) {\n    if (!isModelListener(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key]\n    }\n  }\n  return res\n}\n\nconst isElementRoot = (vnode: VNode) => {\n  return (\n    vnode.shapeFlag & (ShapeFlags.COMPONENT | ShapeFlags.ELEMENT) ||\n    vnode.type === Comment // potential v-if branch switch\n  )\n}\n\nexport function shouldUpdateComponent(\n  prevVNode: VNode,\n  nextVNode: VNode,\n  optimized?: boolean\n): boolean {\n  const { props: prevProps, children: prevChildren, component } = prevVNode\n  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode\n  const emits = component!.emitsOptions\n\n  // Parent component's render function was hot-updated. Since this may have\n  // caused the child component's slots content to have changed, we need to\n  // force the child to update as well.\n  if (__DEV__ && (prevChildren || nextChildren) && isHmrUpdating) {\n    return true\n  }\n\n  // force child update for runtime directive or transition on component vnode.\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true\n  }\n\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & PatchFlags.DYNAMIC_SLOTS) {\n      // slot content that references values that might have changed,\n      // e.g. in a v-for\n      return true\n    }\n    if (patchFlag & PatchFlags.FULL_PROPS) {\n      if (!prevProps) {\n        return !!nextProps\n      }\n      // presence of this flag indicates props are always non-null\n      return hasPropsChanged(prevProps, nextProps!, emits)\n    } else if (patchFlag & PatchFlags.PROPS) {\n      const dynamicProps = nextVNode.dynamicProps!\n      for (let i = 0; i < dynamicProps.length; i++) {\n        const key = dynamicProps[i]\n        if (\n          nextProps![key] !== prevProps![key] &&\n          !isEmitListener(emits, key)\n        ) {\n          return true\n        }\n      }\n    }\n  } else {\n    // this path is only taken by manually written render functions\n    // so presence of any children leads to a forced update\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !(nextChildren as any).$stable) {\n        return true\n      }\n    }\n    if (prevProps === nextProps) {\n      return false\n    }\n    if (!prevProps) {\n      return !!nextProps\n    }\n    if (!nextProps) {\n      return true\n    }\n    return hasPropsChanged(prevProps, nextProps, emits)\n  }\n\n  return false\n}\n\nfunction hasPropsChanged(\n  prevProps: Data,\n  nextProps: Data,\n  emitsOptions: ComponentInternalInstance['emitsOptions']\n): boolean {\n  const nextKeys = Object.keys(nextProps)\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true\n  }\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i]\n    if (\n      nextProps[key] !== prevProps[key] &&\n      !isEmitListener(emitsOptions, key)\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function updateHOCHostEl(\n  { vnode, parent }: ComponentInternalInstance,\n  el: typeof vnode.el // HostNode\n) {\n  while (parent && parent.subTree === vnode) {\n    ;(vnode = parent.vnode).el = el\n    parent = parent.parent\n  }\n}\n", "import { isFunction } from '@vue/shared'\nimport { currentInstance } from './component'\nimport { currentRenderingInstance } from './componentRenderContext'\nimport { warn } from './warning'\n\nexport interface InjectionKey<T> extends Symbol {}\n\nexport function provide<T>(key: InjectionKey<T> | string | number, value: T) {\n  if (!currentInstance) {\n    if (__DEV__) {\n      warn(`provide() can only be used inside setup().`)\n    }\n  } else {\n    let provides = currentInstance.provides\n    // by default an instance inherits its parent's provides object\n    // but when it needs to provide values of its own, it creates its\n    // own provides object using parent provides object as prototype.\n    // this way in `inject` we can simply look up injections from direct\n    // parent and let the prototype chain do the work.\n    const parentProvides =\n      currentInstance.parent && currentInstance.parent.provides\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides)\n    }\n    // TS doesn't allow symbol as index type\n    provides[key as string] = value\n  }\n}\n\nexport function inject<T>(key: InjectionKey<T> | string): T | undefined\nexport function inject<T>(\n  key: InjectionKey<T> | string,\n  defaultValue: T,\n  treatDefaultAsFactory?: false\n): T\nexport function inject<T>(\n  key: InjectionKey<T> | string,\n  defaultValue: T | (() => T),\n  treatDefaultAsFactory: true\n): T\nexport function inject(\n  key: InjectionKey<any> | string,\n  defaultValue?: unknown,\n  treatDefaultAsFactory = false\n) {\n  // fallback to `currentRenderingInstance` so that this can be called in\n  // a functional component\n  const instance = currentInstance || currentRenderingInstance\n  if (instance) {\n    // #2400\n    // to support `app.use` plugins,\n    // fallback to appContext's `provides` if the instance is at root\n    const provides =\n      instance.parent == null\n        ? instance.vnode.appContext && instance.vnode.appContext.provides\n        : instance.parent.provides\n\n    if (provides && (key as string | symbol) in provides) {\n      // TS doesn't allow symbol as index type\n      return provides[key as string]\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && isFunction(defaultValue)\n        ? defaultValue.call(instance.proxy)\n        : defaultValue\n    } else if (__DEV__) {\n      warn(`injection \"${String(key)}\" not found.`)\n    }\n  } else if (__DEV__) {\n    warn(`inject() can only be used inside setup() or functional components.`)\n  }\n}\n", "import {\n  isRef,\n  isShallow,\n  Ref,\n  ComputedRef,\n  ReactiveEffect,\n  isReactive,\n  ReactiveFlags,\n  EffectScheduler,\n  DebuggerOptions\n} from '@vue/reactivity'\nimport { SchedulerJob, queuePreFlushCb } from './scheduler'\nimport {\n  EMPTY_OBJ,\n  isObject,\n  isArray,\n  isFunction,\n  isString,\n  hasChanged,\n  NOOP,\n  remove,\n  isMap,\n  isSet,\n  isPlainObject\n} from '@vue/shared'\nimport {\n  currentInstance,\n  ComponentInternalInstance,\n  isInSSRComponentSetup,\n  setCurrentInstance,\n  unsetCurrentInstance\n} from './component'\nimport {\n  ErrorCodes,\n  callWithErrorHandling,\n  callWithAsyncErrorHandling\n} from './errorHandling'\nimport { queuePostRenderEffect } from './renderer'\nimport { warn } from './warning'\nimport { DeprecationTypes } from './compat/compatConfig'\nimport { checkCompatEnabled, isCompatEnabled } from './compat/compatConfig'\nimport { ObjectWatchOptionItem } from './componentOptions'\n\nexport type WatchEffect = (onCleanup: OnCleanup) => void\n\nexport type WatchSource<T = any> = Ref<T> | ComputedRef<T> | (() => T)\n\nexport type WatchCallback<V = any, OV = any> = (\n  value: V,\n  oldValue: OV,\n  onCleanup: OnCleanup\n) => any\n\ntype MapSources<T, Immediate> = {\n  [K in keyof T]: T[K] extends WatchSource<infer V>\n    ? Immediate extends true\n      ? V | undefined\n      : V\n    : T[K] extends object\n    ? Immediate extends true\n      ? T[K] | undefined\n      : T[K]\n    : never\n}\n\ntype OnCleanup = (cleanupFn: () => void) => void\n\nexport interface WatchOptionsBase extends DebuggerOptions {\n  flush?: 'pre' | 'post' | 'sync'\n}\n\nexport interface WatchOptions<Immediate = boolean> extends WatchOptionsBase {\n  immediate?: Immediate\n  deep?: boolean\n}\n\nexport type WatchStopHandle = () => void\n\n// Simple effect.\nexport function watchEffect(\n  effect: WatchEffect,\n  options?: WatchOptionsBase\n): WatchStopHandle {\n  return doWatch(effect, null, options)\n}\n\nexport function watchPostEffect(\n  effect: WatchEffect,\n  options?: DebuggerOptions\n) {\n  return doWatch(\n    effect,\n    null,\n    (__DEV__\n      ? Object.assign(options || {}, { flush: 'post' })\n      : { flush: 'post' }) as WatchOptionsBase\n  )\n}\n\nexport function watchSyncEffect(\n  effect: WatchEffect,\n  options?: DebuggerOptions\n) {\n  return doWatch(\n    effect,\n    null,\n    (__DEV__\n      ? Object.assign(options || {}, { flush: 'sync' })\n      : { flush: 'sync' }) as WatchOptionsBase\n  )\n}\n\n// initial value for watchers to trigger on undefined initial values\nconst INITIAL_WATCHER_VALUE = {}\n\ntype MultiWatchSources = (WatchSource<unknown> | object)[]\n\n// overload: array of multiple sources + cb\nexport function watch<\n  T extends MultiWatchSources,\n  Immediate extends Readonly<boolean> = false\n>(\n  sources: [...T],\n  cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle\n\n// overload: multiple sources w/ `as const`\n// watch([foo, bar] as const, () => {})\n// somehow [...T] breaks when the type is readonly\nexport function watch<\n  T extends Readonly<MultiWatchSources>,\n  Immediate extends Readonly<boolean> = false\n>(\n  source: T,\n  cb: WatchCallback<MapSources<T, false>, MapSources<T, Immediate>>,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle\n\n// overload: single source + cb\nexport function watch<T, Immediate extends Readonly<boolean> = false>(\n  source: WatchSource<T>,\n  cb: WatchCallback<T, Immediate extends true ? T | undefined : T>,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle\n\n// overload: watching reactive object w/ cb\nexport function watch<\n  T extends object,\n  Immediate extends Readonly<boolean> = false\n>(\n  source: T,\n  cb: WatchCallback<T, Immediate extends true ? T | undefined : T>,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle\n\n// implementation\nexport function watch<T = any, Immediate extends Readonly<boolean> = false>(\n  source: T | WatchSource<T>,\n  cb: any,\n  options?: WatchOptions<Immediate>\n): WatchStopHandle {\n  if (__DEV__ && !isFunction(cb)) {\n    warn(\n      `\\`watch(fn, options?)\\` signature has been moved to a separate API. ` +\n        `Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only ` +\n        `supports \\`watch(source, cb, options?) signature.`\n    )\n  }\n  return doWatch(source as any, cb, options)\n}\n\nfunction doWatch(\n  source: WatchSource | WatchSource[] | WatchEffect | object,\n  cb: WatchCallback | null,\n  { immediate, deep, flush, onTrack, onTrigger }: WatchOptions = EMPTY_OBJ\n): WatchStopHandle {\n  if (__DEV__ && !cb) {\n    if (immediate !== undefined) {\n      warn(\n        `watch() \"immediate\" option is only respected when using the ` +\n          `watch(source, callback, options?) signature.`\n      )\n    }\n    if (deep !== undefined) {\n      warn(\n        `watch() \"deep\" option is only respected when using the ` +\n          `watch(source, callback, options?) signature.`\n      )\n    }\n  }\n\n  const warnInvalidSource = (s: unknown) => {\n    warn(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, ` +\n        `a reactive object, or an array of these types.`\n    )\n  }\n\n  const instance = currentInstance\n  let getter: () => any\n  let forceTrigger = false\n  let isMultiSource = false\n\n  if (isRef(source)) {\n    getter = () => source.value\n    forceTrigger = isShallow(source)\n  } else if (isReactive(source)) {\n    getter = () => source\n    deep = true\n  } else if (isArray(source)) {\n    isMultiSource = true\n    forceTrigger = source.some(isReactive)\n    getter = () =>\n      source.map(s => {\n        if (isRef(s)) {\n          return s.value\n        } else if (isReactive(s)) {\n          return traverse(s)\n        } else if (isFunction(s)) {\n          return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)\n        } else {\n          __DEV__ && warnInvalidSource(s)\n        }\n      })\n  } else if (isFunction(source)) {\n    if (cb) {\n      // getter with cb\n      getter = () =>\n        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)\n    } else {\n      // no cb -> simple effect\n      getter = () => {\n        if (instance && instance.isUnmounted) {\n          return\n        }\n        if (cleanup) {\n          cleanup()\n        }\n        return callWithAsyncErrorHandling(\n          source,\n          instance,\n          ErrorCodes.WATCH_CALLBACK,\n          [onCleanup]\n        )\n      }\n    }\n  } else {\n    getter = NOOP\n    __DEV__ && warnInvalidSource(source)\n  }\n\n  // 2.x array mutation watch compat\n  if (__COMPAT__ && cb && !deep) {\n    const baseGetter = getter\n    getter = () => {\n      const val = baseGetter()\n      if (\n        isArray(val) &&\n        checkCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance)\n      ) {\n        traverse(val)\n      }\n      return val\n    }\n  }\n\n  if (cb && deep) {\n    const baseGetter = getter\n    getter = () => traverse(baseGetter())\n  }\n\n  let cleanup: () => void\n  let onCleanup: OnCleanup = (fn: () => void) => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, instance, ErrorCodes.WATCH_CLEANUP)\n    }\n  }\n\n  // in SSR there is no need to setup an actual effect, and it should be noop\n  // unless it's eager\n  if (__SSR__ && isInSSRComponentSetup) {\n    // we will also not call the invalidate callback (+ runner is not set up)\n    onCleanup = NOOP\n    if (!cb) {\n      getter()\n    } else if (immediate) {\n      callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\n        getter(),\n        isMultiSource ? [] : undefined,\n        onCleanup\n      ])\n    }\n    return NOOP\n  }\n\n  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE\n  const job: SchedulerJob = () => {\n    if (!effect.active) {\n      return\n    }\n    if (cb) {\n      // watch(source, cb)\n      const newValue = effect.run()\n      if (\n        deep ||\n        forceTrigger ||\n        (isMultiSource\n          ? (newValue as any[]).some((v, i) =>\n              hasChanged(v, (oldValue as any[])[i])\n            )\n          : hasChanged(newValue, oldValue)) ||\n        (__COMPAT__ &&\n          isArray(newValue) &&\n          isCompatEnabled(DeprecationTypes.WATCH_ARRAY, instance))\n      ) {\n        // cleanup before running cb again\n        if (cleanup) {\n          cleanup()\n        }\n        callWithAsyncErrorHandling(cb, instance, ErrorCodes.WATCH_CALLBACK, [\n          newValue,\n          // pass undefined as the old value when it's changed for the first time\n          oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,\n          onCleanup\n        ])\n        oldValue = newValue\n      }\n    } else {\n      // watchEffect\n      effect.run()\n    }\n  }\n\n  // important: mark the job as a watcher callback so that scheduler knows\n  // it is allowed to self-trigger (#1727)\n  job.allowRecurse = !!cb\n\n  let scheduler: EffectScheduler\n  if (flush === 'sync') {\n    scheduler = job as any // the scheduler function gets called directly\n  } else if (flush === 'post') {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense)\n  } else {\n    // default: 'pre'\n    scheduler = () => {\n      if (!instance || instance.isMounted) {\n        queuePreFlushCb(job)\n      } else {\n        // with 'pre' option, the first call must happen before\n        // the component is mounted so it is called synchronously.\n        job()\n      }\n    }\n  }\n\n  const effect = new ReactiveEffect(getter, scheduler)\n\n  if (__DEV__) {\n    effect.onTrack = onTrack\n    effect.onTrigger = onTrigger\n  }\n\n  // initial run\n  if (cb) {\n    if (immediate) {\n      job()\n    } else {\n      oldValue = effect.run()\n    }\n  } else if (flush === 'post') {\n    queuePostRenderEffect(\n      effect.run.bind(effect),\n      instance && instance.suspense\n    )\n  } else {\n    effect.run()\n  }\n\n  return () => {\n    effect.stop()\n    if (instance && instance.scope) {\n      remove(instance.scope.effects!, effect)\n    }\n  }\n}\n\n// this.$watch\nexport function instanceWatch(\n  this: ComponentInternalInstance,\n  source: string | Function,\n  value: WatchCallback | ObjectWatchOptionItem,\n  options?: WatchOptions\n): WatchStopHandle {\n  const publicThis = this.proxy as any\n  const getter = isString(source)\n    ? source.includes('.')\n      ? createPathGetter(publicThis, source)\n      : () => publicThis[source]\n    : source.bind(publicThis, publicThis)\n  let cb\n  if (isFunction(value)) {\n    cb = value\n  } else {\n    cb = value.handler as Function\n    options = value\n  }\n  const cur = currentInstance\n  setCurrentInstance(this)\n  const res = doWatch(getter, cb.bind(publicThis), options)\n  if (cur) {\n    setCurrentInstance(cur)\n  } else {\n    unsetCurrentInstance()\n  }\n  return res\n}\n\nexport function createPathGetter(ctx: any, path: string) {\n  const segments = path.split('.')\n  return () => {\n    let cur = ctx\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]]\n    }\n    return cur\n  }\n}\n\nexport function traverse(value: unknown, seen?: Set<unknown>) {\n  if (!isObject(value) || (value as any)[ReactiveFlags.SKIP]) {\n    return value\n  }\n  seen = seen || new Set()\n  if (seen.has(value)) {\n    return value\n  }\n  seen.add(value)\n  if (isRef(value)) {\n    traverse(value.value, seen)\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], seen)\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v: any) => {\n      traverse(v, seen)\n    })\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse((value as any)[key], seen)\n    }\n  }\n  return value\n}\n", "import {\n  getCurrentInstance,\n  SetupContext,\n  ComponentInternalInstance,\n  ComponentOptions\n} from '../component'\nimport {\n  cloneVNode,\n  Comment,\n  isSameVNodeType,\n  VNode,\n  VNodeArrayChildren,\n  Fragment\n} from '../vnode'\nimport { warn } from '../warning'\nimport { isKeepAlive } from './KeepAlive'\nimport { toRaw } from '@vue/reactivity'\nimport { callWithAsyncErrorHandling, ErrorCodes } from '../errorHandling'\nimport { ShapeFlags, PatchFlags } from '@vue/shared'\nimport { onBeforeUnmount, onMounted } from '../apiLifecycle'\nimport { RendererElement } from '../renderer'\n\nexport interface BaseTransitionProps<HostElement = RendererElement> {\n  mode?: 'in-out' | 'out-in' | 'default'\n  appear?: boolean\n\n  // If true, indicates this is a transition that doesn't actually insert/remove\n  // the element, but toggles the show / hidden status instead.\n  // The transition hooks are injected, but will be skipped by the renderer.\n  // Instead, a custom directive can control the transition by calling the\n  // injected hooks (e.g. v-show).\n  persisted?: boolean\n\n  // Hooks. Using camel case for easier usage in render functions & JSX.\n  // In templates these can be written as @before-enter=\"xxx\" as prop names\n  // are camelized.\n  onBeforeEnter?: (el: HostElement) => void\n  onEnter?: (el: HostElement, done: () => void) => void\n  onAfterEnter?: (el: HostElement) => void\n  onEnterCancelled?: (el: HostElement) => void\n  // leave\n  onBeforeLeave?: (el: HostElement) => void\n  onLeave?: (el: HostElement, done: () => void) => void\n  onAfterLeave?: (el: HostElement) => void\n  onLeaveCancelled?: (el: HostElement) => void // only fired in persisted mode\n  // appear\n  onBeforeAppear?: (el: HostElement) => void\n  onAppear?: (el: HostElement, done: () => void) => void\n  onAfterAppear?: (el: HostElement) => void\n  onAppearCancelled?: (el: HostElement) => void\n}\n\nexport interface TransitionHooks<\n  HostElement extends RendererElement = RendererElement\n> {\n  mode: BaseTransitionProps['mode']\n  persisted: boolean\n  beforeEnter(el: HostElement): void\n  enter(el: HostElement): void\n  leave(el: HostElement, remove: () => void): void\n  clone(vnode: VNode): TransitionHooks<HostElement>\n  // optional\n  afterLeave?(): void\n  delayLeave?(\n    el: HostElement,\n    earlyRemove: () => void,\n    delayedLeave: () => void\n  ): void\n  delayedLeave?(): void\n}\n\nexport type TransitionHookCaller = (\n  hook: ((el: any) => void) | Array<(el: any) => void> | undefined,\n  args?: any[]\n) => void\n\nexport type PendingCallback = (cancelled?: boolean) => void\n\nexport interface TransitionState {\n  isMounted: boolean\n  isLeaving: boolean\n  isUnmounting: boolean\n  // Track pending leave callbacks for children of the same key.\n  // This is used to force remove leaving a child when a new copy is entering.\n  leavingVNodes: Map<any, Record<string, VNode>>\n}\n\nexport interface TransitionElement {\n  // in persisted mode (e.g. v-show), the same element is toggled, so the\n  // pending enter/leave callbacks may need to be cancelled if the state is toggled\n  // before it finishes.\n  _enterCb?: PendingCallback\n  _leaveCb?: PendingCallback\n}\n\nexport function useTransitionState(): TransitionState {\n  const state: TransitionState = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: new Map()\n  }\n  onMounted(() => {\n    state.isMounted = true\n  })\n  onBeforeUnmount(() => {\n    state.isUnmounting = true\n  })\n  return state\n}\n\nconst TransitionHookValidator = [Function, Array]\n\nconst BaseTransitionImpl: ComponentOptions = {\n  name: `BaseTransition`,\n\n  props: {\n    mode: String,\n    appear: Boolean,\n    persisted: Boolean,\n    // enter\n    onBeforeEnter: TransitionHookValidator,\n    onEnter: TransitionHookValidator,\n    onAfterEnter: TransitionHookValidator,\n    onEnterCancelled: TransitionHookValidator,\n    // leave\n    onBeforeLeave: TransitionHookValidator,\n    onLeave: TransitionHookValidator,\n    onAfterLeave: TransitionHookValidator,\n    onLeaveCancelled: TransitionHookValidator,\n    // appear\n    onBeforeAppear: TransitionHookValidator,\n    onAppear: TransitionHookValidator,\n    onAfterAppear: TransitionHookValidator,\n    onAppearCancelled: TransitionHookValidator\n  },\n\n  setup(props: BaseTransitionProps, { slots }: SetupContext) {\n    const instance = getCurrentInstance()!\n    const state = useTransitionState()\n\n    let prevTransitionKey: any\n\n    return () => {\n      const children =\n        slots.default && getTransitionRawChildren(slots.default(), true)\n      if (!children || !children.length) {\n        return\n      }\n\n      // warn multiple elements\n      if (__DEV__ && children.length > 1) {\n        warn(\n          '<transition> can only be used on a single element or component. Use ' +\n            '<transition-group> for lists.'\n        )\n      }\n\n      // there's no need to track reactivity for these props so use the raw\n      // props for a bit better perf\n      const rawProps = toRaw(props)\n      const { mode } = rawProps\n      // check mode\n      if (\n        __DEV__ &&\n        mode &&\n        mode !== 'in-out' && mode !== 'out-in' && mode !== 'default'\n      ) {\n        warn(`invalid <transition> mode: ${mode}`)\n      }\n\n      // at this point children has a guaranteed length of 1.\n      const child = children[0]\n      if (state.isLeaving) {\n        return emptyPlaceholder(child)\n      }\n\n      // in the case of <transition><keep-alive/></transition>, we need to\n      // compare the type of the kept-alive children.\n      const innerChild = getKeepAliveChild(child)\n      if (!innerChild) {\n        return emptyPlaceholder(child)\n      }\n\n      const enterHooks = resolveTransitionHooks(\n        innerChild,\n        rawProps,\n        state,\n        instance\n      )\n      setTransitionHooks(innerChild, enterHooks)\n\n      const oldChild = instance.subTree\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild)\n\n      let transitionKeyChanged = false\n      const { getTransitionKey } = innerChild.type as any\n      if (getTransitionKey) {\n        const key = getTransitionKey()\n        if (prevTransitionKey === undefined) {\n          prevTransitionKey = key\n        } else if (key !== prevTransitionKey) {\n          prevTransitionKey = key\n          transitionKeyChanged = true\n        }\n      }\n\n      // handle mode\n      if (\n        oldInnerChild &&\n        oldInnerChild.type !== Comment &&\n        (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)\n      ) {\n        const leavingHooks = resolveTransitionHooks(\n          oldInnerChild,\n          rawProps,\n          state,\n          instance\n        )\n        // update old tree's hooks in case of dynamic transition\n        setTransitionHooks(oldInnerChild, leavingHooks)\n        // switching between different views\n        if (mode === 'out-in') {\n          state.isLeaving = true\n          // return placeholder node and queue update when leave finishes\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false\n            instance.update()\n          }\n          return emptyPlaceholder(child)\n        } else if (mode === 'in-out' && innerChild.type !== Comment) {\n          leavingHooks.delayLeave = (\n            el: TransitionElement,\n            earlyRemove,\n            delayedLeave\n          ) => {\n            const leavingVNodesCache = getLeavingNodesForType(\n              state,\n              oldInnerChild\n            )\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild\n            // early removal callback\n            el._leaveCb = () => {\n              earlyRemove()\n              el._leaveCb = undefined\n              delete enterHooks.delayedLeave\n            }\n            enterHooks.delayedLeave = delayedLeave\n          }\n        }\n      }\n\n      return child\n    }\n  }\n}\n\nif (__COMPAT__) {\n  BaseTransitionImpl.__isBuiltIn = true\n}\n\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\nexport const BaseTransition = BaseTransitionImpl as any as {\n  new (): {\n    $props: BaseTransitionProps<any>\n  }\n}\n\nfunction getLeavingNodesForType(\n  state: TransitionState,\n  vnode: VNode\n): Record<string, VNode> {\n  const { leavingVNodes } = state\n  let leavingVNodesCache = leavingVNodes.get(vnode.type)!\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = Object.create(null)\n    leavingVNodes.set(vnode.type, leavingVNodesCache)\n  }\n  return leavingVNodesCache\n}\n\n// The transition hooks are attached to the vnode as vnode.transition\n// and will be called at appropriate timing in the renderer.\nexport function resolveTransitionHooks(\n  vnode: VNode,\n  props: BaseTransitionProps<any>,\n  state: TransitionState,\n  instance: ComponentInternalInstance\n): TransitionHooks {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props\n  const key = String(vnode.key)\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode)\n\n  const callHook: TransitionHookCaller = (hook, args) => {\n    hook &&\n      callWithAsyncErrorHandling(\n        hook,\n        instance,\n        ErrorCodes.TRANSITION_HOOK,\n        args\n      )\n  }\n\n  const hooks: TransitionHooks<TransitionElement> = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter\n        } else {\n          return\n        }\n      }\n      // for same element (v-show)\n      if (el._leaveCb) {\n        el._leaveCb(true /* cancelled */)\n      }\n      // for toggled element with same key (v-if)\n      const leavingVNode = leavingVNodesCache[key]\n      if (\n        leavingVNode &&\n        isSameVNodeType(vnode, leavingVNode) &&\n        leavingVNode.el!._leaveCb\n      ) {\n        // force early removal (not cancelled)\n        leavingVNode.el!._leaveCb()\n      }\n      callHook(hook, [el])\n    },\n\n    enter(el) {\n      let hook = onEnter\n      let afterHook = onAfterEnter\n      let cancelHook = onEnterCancelled\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter\n          afterHook = onAfterAppear || onAfterEnter\n          cancelHook = onAppearCancelled || onEnterCancelled\n        } else {\n          return\n        }\n      }\n      let called = false\n      const done = (el._enterCb = (cancelled?) => {\n        if (called) return\n        called = true\n        if (cancelled) {\n          callHook(cancelHook, [el])\n        } else {\n          callHook(afterHook, [el])\n        }\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave()\n        }\n        el._enterCb = undefined\n      })\n      if (hook) {\n        hook(el, done)\n        if (hook.length <= 1) {\n          done()\n        }\n      } else {\n        done()\n      }\n    },\n\n    leave(el, remove) {\n      const key = String(vnode.key)\n      if (el._enterCb) {\n        el._enterCb(true /* cancelled */)\n      }\n      if (state.isUnmounting) {\n        return remove()\n      }\n      callHook(onBeforeLeave, [el])\n      let called = false\n      const done = (el._leaveCb = (cancelled?) => {\n        if (called) return\n        called = true\n        remove()\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el])\n        } else {\n          callHook(onAfterLeave, [el])\n        }\n        el._leaveCb = undefined\n        if (leavingVNodesCache[key] === vnode) {\n          delete leavingVNodesCache[key]\n        }\n      })\n      leavingVNodesCache[key] = vnode\n      if (onLeave) {\n        onLeave(el, done)\n        if (onLeave.length <= 1) {\n          done()\n        }\n      } else {\n        done()\n      }\n    },\n\n    clone(vnode) {\n      return resolveTransitionHooks(vnode, props, state, instance)\n    }\n  }\n\n  return hooks\n}\n\n// the placeholder really only handles one special case: KeepAlive\n// in the case of a KeepAlive in a leave phase we need to return a KeepAlive\n// placeholder with empty content to avoid the KeepAlive instance from being\n// unmounted.\nfunction emptyPlaceholder(vnode: VNode): VNode | undefined {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode)\n    vnode.children = null\n    return vnode\n  }\n}\n\nfunction getKeepAliveChild(vnode: VNode): VNode | undefined {\n  return isKeepAlive(vnode)\n    ? vnode.children\n      ? ((vnode.children as VNodeArrayChildren)[0] as VNode)\n      : undefined\n    : vnode\n}\n\nexport function setTransitionHooks(vnode: VNode, hooks: TransitionHooks) {\n  if (vnode.shapeFlag & ShapeFlags.COMPONENT && vnode.component) {\n    setTransitionHooks(vnode.component.subTree, hooks)\n  } else if (__FEATURE_SUSPENSE__ && vnode.shapeFlag & ShapeFlags.SUSPENSE) {\n    vnode.ssContent!.transition = hooks.clone(vnode.ssContent!)\n    vnode.ssFallback!.transition = hooks.clone(vnode.ssFallback!)\n  } else {\n    vnode.transition = hooks\n  }\n}\n\nexport function getTransitionRawChildren(\n  children: VNode[],\n  keepComment: boolean = false\n): VNode[] {\n  let ret: VNode[] = []\n  let keyedFragmentCount = 0\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    // handle fragment children case, e.g. v-for\n    if (child.type === Fragment) {\n      if (child.patchFlag & PatchFlags.KEYED_FRAGMENT) keyedFragmentCount++\n      ret = ret.concat(\n        getTransitionRawChildren(child.children as VNode[], keepComment)\n      )\n    }\n    // comment placeholders should be skipped, e.g. v-if\n    else if (keepComment || child.type !== Comment) {\n      ret.push(child)\n    }\n  }\n  // #1126 if a transition children list contains multiple sub fragments, these\n  // fragments will be merged into a flat children array. Since each v-for\n  // fragment may contain different static bindings inside, we need to de-op\n  // these children to force full diffs to ensure correct behavior.\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = PatchFlags.BAIL\n    }\n  }\n  return ret\n}\n", "import {\n  ComputedOptions,\n  MethodOptions,\n  ComponentOptionsWithoutProps,\n  ComponentOptionsWithArrayProps,\n  ComponentOptionsWithObjectProps,\n  ComponentOptionsMixin,\n  RenderFunction,\n  ComponentOptionsBase\n} from './componentOptions'\nimport {\n  SetupContext,\n  AllowedComponentProps,\n  ComponentCustomProps\n} from './component'\nimport {\n  ExtractPropTypes,\n  ComponentPropsOptions,\n  ExtractDefaultPropTypes\n} from './componentProps'\nimport { EmitsOptions, EmitsToProps } from './componentEmits'\nimport { isFunction } from '@vue/shared'\nimport { VNodeProps } from './vnode'\nimport {\n  CreateComponentPublicInstance,\n  ComponentPublicInstanceConstructor\n} from './componentPublicInstance'\n\nexport type PublicProps = VNodeProps &\n  AllowedComponentProps &\n  ComponentCustomProps\n\nexport type DefineComponent<\n  PropsOrPropOptions = {},\n  RawBindings = {},\n  D = {},\n  C extends ComputedOptions = ComputedOptions,\n  M extends MethodOptions = MethodOptions,\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = {},\n  EE extends string = string,\n  PP = PublicProps,\n  Props = Readonly<\n    PropsOrPropOptions extends ComponentPropsOptions\n      ? ExtractPropTypes<PropsOrPropOptions>\n      : PropsOrPropOptions\n  > &\n    ({} extends E ? {} : EmitsToProps<E>),\n  Defaults = ExtractDefaultPropTypes<PropsOrPropOptions>\n> = ComponentPublicInstanceConstructor<\n  CreateComponentPublicInstance<\n    Props,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    PP & Props,\n    Defaults,\n    true\n  > &\n    Props\n> &\n  ComponentOptionsBase<\n    Props,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    EE,\n    Defaults\n  > &\n  PP\n\n// defineComponent is a utility that is primarily used for type inference\n// when declaring components. Type inference is provided in the component\n// options (provided as the argument). The returned value has artificial types\n// for TSX / manual render function / IDE support.\n\n// overload 1: direct setup function\n// (uses user defined props interface)\nexport function defineComponent<Props, RawBindings = object>(\n  setup: (\n    props: Readonly<Props>,\n    ctx: SetupContext\n  ) => RawBindings | RenderFunction\n): DefineComponent<Props, RawBindings>\n\n// overload 2: object format with no props\n// (uses user defined props interface)\n// return type is for Vetur and TSX support\nexport function defineComponent<\n  Props = {},\n  RawBindings = {},\n  D = {},\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = EmitsOptions,\n  EE extends string = string\n>(\n  options: ComponentOptionsWithoutProps<\n    Props,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    EE\n  >\n): DefineComponent<Props, RawBindings, D, C, M, Mixin, Extends, E, EE>\n\n// overload 3: object format with array props declaration\n// props inferred as { [key in PropNames]?: any }\n// return type is for Vetur and TSX support\nexport function defineComponent<\n  PropNames extends string,\n  RawBindings,\n  D,\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = Record<string, any>,\n  EE extends string = string\n>(\n  options: ComponentOptionsWithArrayProps<\n    PropNames,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    EE\n  >\n): DefineComponent<\n  Readonly<{ [key in PropNames]?: any }>,\n  RawBindings,\n  D,\n  C,\n  M,\n  Mixin,\n  Extends,\n  E,\n  EE\n>\n\n// overload 4: object format with object props declaration\n// see `ExtractPropTypes` in ./componentProps.ts\nexport function defineComponent<\n  // the Readonly constraint allows TS to treat the type of { required: true }\n  // as constant instead of boolean.\n  PropsOptions extends Readonly<ComponentPropsOptions>,\n  RawBindings,\n  D,\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = Record<string, any>,\n  EE extends string = string\n>(\n  options: ComponentOptionsWithObjectProps<\n    PropsOptions,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    EE\n  >\n): DefineComponent<PropsOptions, RawBindings, D, C, M, Mixin, Extends, E, EE>\n\n// implementation, close to no-op\nexport function defineComponent(options: unknown) {\n  return isFunction(options) ? { setup: options, name: options.name } : options\n}\n", "import {\n  Component,\n  ConcreteComponent,\n  currentInstance,\n  ComponentInternalInstance,\n  isInSSRComponentSetup,\n  ComponentOptions\n} from './component'\nimport { isFunction, isObject } from '@vue/shared'\nimport { ComponentPublicInstance } from './componentPublicInstance'\nimport { createVNode, VNode } from './vnode'\nimport { defineComponent } from './apiDefineComponent'\nimport { warn } from './warning'\nimport { ref } from '@vue/reactivity'\nimport { handleError, ErrorCodes } from './errorHandling'\nimport { isKeepAlive } from './components/KeepAlive'\nimport { queueJob } from './scheduler'\n\nexport type AsyncComponentResolveResult<T = Component> = T | { default: T } // es modules\n\nexport type AsyncComponentLoader<T = any> = () => Promise<\n  AsyncComponentResolveResult<T>\n>\n\nexport interface AsyncComponentOptions<T = any> {\n  loader: AsyncComponentLoader<T>\n  loadingComponent?: Component\n  errorComponent?: Component\n  delay?: number\n  timeout?: number\n  suspensible?: boolean\n  onError?: (\n    error: Error,\n    retry: () => void,\n    fail: () => void,\n    attempts: number\n  ) => any\n}\n\nexport const isAsyncWrapper = (i: ComponentInternalInstance | VNode): boolean =>\n  !!(i.type as ComponentOptions).__asyncLoader\n\nexport function defineAsyncComponent<\n  T extends Component = { new (): ComponentPublicInstance }\n>(source: AsyncComponentLoader<T> | AsyncComponentOptions<T>): T {\n  if (isFunction(source)) {\n    source = { loader: source }\n  }\n\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout, // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source\n\n  let pendingRequest: Promise<ConcreteComponent> | null = null\n  let resolvedComp: ConcreteComponent | undefined\n\n  let retries = 0\n  const retry = () => {\n    retries++\n    pendingRequest = null\n    return load()\n  }\n\n  const load = (): Promise<ConcreteComponent> => {\n    let thisRequest: Promise<ConcreteComponent>\n    return (\n      pendingRequest ||\n      (thisRequest = pendingRequest =\n        loader()\n          .catch(err => {\n            err = err instanceof Error ? err : new Error(String(err))\n            if (userOnError) {\n              return new Promise((resolve, reject) => {\n                const userRetry = () => resolve(retry())\n                const userFail = () => reject(err)\n                userOnError(err, userRetry, userFail, retries + 1)\n              })\n            } else {\n              throw err\n            }\n          })\n          .then((comp: any) => {\n            if (thisRequest !== pendingRequest && pendingRequest) {\n              return pendingRequest\n            }\n            if (__DEV__ && !comp) {\n              warn(\n                `Async component loader resolved to undefined. ` +\n                  `If you are using retry(), make sure to return its return value.`\n              )\n            }\n            // interop module default\n            if (\n              comp &&\n              (comp.__esModule || comp[Symbol.toStringTag] === 'Module')\n            ) {\n              comp = comp.default\n            }\n            if (__DEV__ && comp && !isObject(comp) && !isFunction(comp)) {\n              throw new Error(`Invalid async component load result: ${comp}`)\n            }\n            resolvedComp = comp\n            return comp\n          }))\n    )\n  }\n\n  return defineComponent({\n    name: 'AsyncComponentWrapper',\n\n    __asyncLoader: load,\n\n    get __asyncResolved() {\n      return resolvedComp\n    },\n\n    setup() {\n      const instance = currentInstance!\n\n      // already resolved\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp!, instance)\n      }\n\n      const onError = (err: Error) => {\n        pendingRequest = null\n        handleError(\n          err,\n          instance,\n          ErrorCodes.ASYNC_COMPONENT_LOADER,\n          !errorComponent /* do not throw in dev if user provided error component */\n        )\n      }\n\n      // suspense-controlled or SSR.\n      if (\n        (__FEATURE_SUSPENSE__ && suspensible && instance.suspense) ||\n        (__SSR__ && isInSSRComponentSetup)\n      ) {\n        return load()\n          .then(comp => {\n            return () => createInnerComp(comp, instance)\n          })\n          .catch(err => {\n            onError(err)\n            return () =>\n              errorComponent\n                ? createVNode(errorComponent as ConcreteComponent, {\n                    error: err\n                  })\n                : null\n          })\n      }\n\n      const loaded = ref(false)\n      const error = ref()\n      const delayed = ref(!!delay)\n\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false\n        }, delay)\n      }\n\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(\n              `Async component timed out after ${timeout}ms.`\n            )\n            onError(err)\n            error.value = err\n          }\n        }, timeout)\n      }\n\n      load()\n        .then(() => {\n          loaded.value = true\n          if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n            // parent is keep-alive, force update so the loaded component's\n            // name is taken into account\n            queueJob(instance.parent.update)\n          }\n        })\n        .catch(err => {\n          onError(err)\n          error.value = err\n        })\n\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance)\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent as ConcreteComponent, {\n            error: error.value\n          })\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent as ConcreteComponent)\n        }\n      }\n    }\n  }) as T\n}\n\nfunction createInnerComp(\n  comp: ConcreteComponent,\n  { vnode: { ref, props, children } }: ComponentInternalInstance\n) {\n  const vnode = createVNode(comp, props, children)\n  // ensure inner component inherits the async wrapper's ref owner\n  vnode.ref = ref\n  return vnode\n}\n", "import {\n  ConcreteComponent,\n  getCurrentInstance,\n  SetupContext,\n  ComponentInternalInstance,\n  LifecycleHooks,\n  currentInstance,\n  getComponentName,\n  ComponentOptions\n} from '../component'\nimport {\n  VNode,\n  cloneVNode,\n  isVNode,\n  VNodeProps,\n  invokeVNodeHook\n} from '../vnode'\nimport { warn } from '../warning'\nimport {\n  onBeforeUnmount,\n  injectHook,\n  onUnmounted,\n  onMounted,\n  onUpdated\n} from '../apiLifecycle'\nimport {\n  isString,\n  isArray,\n  ShapeFlags,\n  remove,\n  invokeArrayFns\n} from '@vue/shared'\nimport { watch } from '../apiWatch'\nimport {\n  RendererInternals,\n  queuePostRenderEffect,\n  MoveType,\n  RendererElement,\n  RendererNode\n} from '../renderer'\nimport { setTransitionHooks } from './BaseTransition'\nimport { ComponentRenderContext } from '../componentPublicInstance'\nimport { devtoolsComponentAdded } from '../devtools'\nimport { isAsyncWrapper } from '../apiAsyncComponent'\n\ntype MatchPattern = string | RegExp | (string | RegExp)[]\n\nexport interface KeepAliveProps {\n  include?: MatchPattern\n  exclude?: MatchPattern\n  max?: number | string\n}\n\ntype CacheKey = string | number | symbol | ConcreteComponent\ntype Cache = Map<CacheKey, VNode>\ntype Keys = Set<CacheKey>\n\nexport interface KeepAliveContext extends ComponentRenderContext {\n  renderer: RendererInternals\n  activate: (\n    vnode: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    isSVG: boolean,\n    optimized: boolean\n  ) => void\n  deactivate: (vnode: VNode) => void\n}\n\nexport const isKeepAlive = (vnode: VNode): boolean =>\n  (vnode.type as any).__isKeepAlive\n\nconst KeepAliveImpl: ComponentOptions = {\n  name: `KeepAlive`,\n\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n\n  setup(props: KeepAliveProps, { slots }: SetupContext) {\n    const instance = getCurrentInstance()!\n    // KeepAlive communicates with the instantiated renderer via the\n    // ctx where the renderer passes in its internals,\n    // and the KeepAlive instance exposes activate/deactivate implementations.\n    // The whole point of this is to avoid importing KeepAlive directly in the\n    // renderer to facilitate tree-shaking.\n    const sharedContext = instance.ctx as KeepAliveContext\n\n    // if the internal renderer is not registered, it indicates that this is server-side rendering,\n    // for KeepAlive, we just need to render its children\n    if (!sharedContext.renderer) {\n      return slots.default\n    }\n\n    const cache: Cache = new Map()\n    const keys: Keys = new Set()\n    let current: VNode | null = null\n\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n      ;(instance as any).__v_cache = cache\n    }\n\n    const parentSuspense = instance.suspense\n\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: { createElement }\n      }\n    } = sharedContext\n    const storageContainer = createElement('div')\n\n    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {\n      const instance = vnode.component!\n      move(vnode, container, anchor, MoveType.ENTER, parentSuspense)\n      // in case props have changed\n      patch(\n        instance.vnode,\n        vnode,\n        container,\n        anchor,\n        instance,\n        parentSuspense,\n        isSVG,\n        vnode.slotScopeIds,\n        optimized\n      )\n      queuePostRenderEffect(() => {\n        instance.isDeactivated = false\n        if (instance.a) {\n          invokeArrayFns(instance.a)\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode)\n        }\n      }, parentSuspense)\n\n      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n        // Update components tree\n        devtoolsComponentAdded(instance)\n      }\n    }\n\n    sharedContext.deactivate = (vnode: VNode) => {\n      const instance = vnode.component!\n      move(vnode, storageContainer, null, MoveType.LEAVE, parentSuspense)\n      queuePostRenderEffect(() => {\n        if (instance.da) {\n          invokeArrayFns(instance.da)\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance.parent, vnode)\n        }\n        instance.isDeactivated = true\n      }, parentSuspense)\n\n      if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n        // Update components tree\n        devtoolsComponentAdded(instance)\n      }\n    }\n\n    function unmount(vnode: VNode) {\n      // reset the shapeFlag so it can be properly unmounted\n      resetShapeFlag(vnode)\n      _unmount(vnode, instance, parentSuspense, true)\n    }\n\n    function pruneCache(filter?: (name: string) => boolean) {\n      cache.forEach((vnode, key) => {\n        const name = getComponentName(vnode.type as ConcreteComponent)\n        if (name && (!filter || !filter(name))) {\n          pruneCacheEntry(key)\n        }\n      })\n    }\n\n    function pruneCacheEntry(key: CacheKey) {\n      const cached = cache.get(key) as VNode\n      if (!current || cached.type !== current.type) {\n        unmount(cached)\n      } else if (current) {\n        // current active instance should no longer be kept-alive.\n        // we can't unmount it now but it might be later, so reset its flag now.\n        resetShapeFlag(current)\n      }\n      cache.delete(key)\n      keys.delete(key)\n    }\n\n    // prune cache on include/exclude prop change\n    watch(\n      () => [props.include, props.exclude],\n      ([include, exclude]) => {\n        include && pruneCache(name => matches(include, name))\n        exclude && pruneCache(name => !matches(exclude, name))\n      },\n      // prune post-render after `current` has been updated\n      { flush: 'post', deep: true }\n    )\n\n    // cache sub tree after render\n    let pendingCacheKey: CacheKey | null = null\n    const cacheSubtree = () => {\n      // fix #1621, the pendingCacheKey could be 0\n      if (pendingCacheKey != null) {\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree))\n      }\n    }\n    onMounted(cacheSubtree)\n    onUpdated(cacheSubtree)\n\n    onBeforeUnmount(() => {\n      cache.forEach(cached => {\n        const { subTree, suspense } = instance\n        const vnode = getInnerChild(subTree)\n        if (cached.type === vnode.type) {\n          // current instance will be unmounted as part of keep-alive's unmount\n          resetShapeFlag(vnode)\n          // but invoke its deactivated hook here\n          const da = vnode.component!.da\n          da && queuePostRenderEffect(da, suspense)\n          return\n        }\n        unmount(cached)\n      })\n    })\n\n    return () => {\n      pendingCacheKey = null\n\n      if (!slots.default) {\n        return null\n      }\n\n      const children = slots.default()\n      const rawVNode = children[0]\n      if (children.length > 1) {\n        if (__DEV__) {\n          warn(`KeepAlive should contain exactly one component child.`)\n        }\n        current = null\n        return children\n      } else if (\n        !isVNode(rawVNode) ||\n        (!(rawVNode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT) &&\n          !(rawVNode.shapeFlag & ShapeFlags.SUSPENSE))\n      ) {\n        current = null\n        return rawVNode\n      }\n\n      let vnode = getInnerChild(rawVNode)\n      const comp = vnode.type as ConcreteComponent\n\n      // for async components, name check should be based in its loaded\n      // inner component if available\n      const name = getComponentName(\n        isAsyncWrapper(vnode)\n          ? (vnode.type as ComponentOptions).__asyncResolved || {}\n          : comp\n      )\n\n      const { include, exclude, max } = props\n\n      if (\n        (include && (!name || !matches(include, name))) ||\n        (exclude && name && matches(exclude, name))\n      ) {\n        current = vnode\n        return rawVNode\n      }\n\n      const key = vnode.key == null ? comp : vnode.key\n      const cachedVNode = cache.get(key)\n\n      // clone vnode if it's reused because we are going to mutate it\n      if (vnode.el) {\n        vnode = cloneVNode(vnode)\n        if (rawVNode.shapeFlag & ShapeFlags.SUSPENSE) {\n          rawVNode.ssContent = vnode\n        }\n      }\n      // #1513 it's possible for the returned vnode to be cloned due to attr\n      // fallthrough or scopeId, so the vnode here may not be the final vnode\n      // that is mounted. Instead of caching it directly, we store the pending\n      // key and cache `instance.subTree` (the normalized vnode) in\n      // beforeMount/beforeUpdate hooks.\n      pendingCacheKey = key\n\n      if (cachedVNode) {\n        // copy over mounted state\n        vnode.el = cachedVNode.el\n        vnode.component = cachedVNode.component\n        if (vnode.transition) {\n          // recursively update transition hooks on subTree\n          setTransitionHooks(vnode, vnode.transition!)\n        }\n        // avoid vnode being mounted as fresh\n        vnode.shapeFlag |= ShapeFlags.COMPONENT_KEPT_ALIVE\n        // make this key the freshest\n        keys.delete(key)\n        keys.add(key)\n      } else {\n        keys.add(key)\n        // prune oldest entry\n        if (max && keys.size > parseInt(max as string, 10)) {\n          pruneCacheEntry(keys.values().next().value)\n        }\n      }\n      // avoid vnode being unmounted\n      vnode.shapeFlag |= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\n\n      current = vnode\n      return rawVNode\n    }\n  }\n}\n\nif (__COMPAT__) {\n  KeepAliveImpl.__isBuildIn = true\n}\n\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\nexport const KeepAlive = KeepAliveImpl as any as {\n  __isKeepAlive: true\n  new (): {\n    $props: VNodeProps & KeepAliveProps\n  }\n}\n\nfunction matches(pattern: MatchPattern, name: string): boolean {\n  if (isArray(pattern)) {\n    return pattern.some((p: string | RegExp) => matches(p, name))\n  } else if (isString(pattern)) {\n    return pattern.split(',').includes(name)\n  } else if (pattern.test) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nexport function onActivated(\n  hook: Function,\n  target?: ComponentInternalInstance | null\n) {\n  registerKeepAliveHook(hook, LifecycleHooks.ACTIVATED, target)\n}\n\nexport function onDeactivated(\n  hook: Function,\n  target?: ComponentInternalInstance | null\n) {\n  registerKeepAliveHook(hook, LifecycleHooks.DEACTIVATED, target)\n}\n\nfunction registerKeepAliveHook(\n  hook: Function & { __wdc?: Function },\n  type: LifecycleHooks,\n  target: ComponentInternalInstance | null = currentInstance\n) {\n  // cache the deactivate branch check wrapper for injected hooks so the same\n  // hook can be properly deduped by the scheduler. \"__wdc\" stands for \"with\n  // deactivation check\".\n  const wrappedHook =\n    hook.__wdc ||\n    (hook.__wdc = () => {\n      // only fire the hook if the target instance is NOT in a deactivated branch.\n      let current: ComponentInternalInstance | null = target\n      while (current) {\n        if (current.isDeactivated) {\n          return\n        }\n        current = current.parent\n      }\n      return hook()\n    })\n  injectHook(type, wrappedHook, target)\n  // In addition to registering it on the target instance, we walk up the parent\n  // chain and register it on all ancestor instances that are keep-alive roots.\n  // This avoids the need to walk the entire component tree when invoking these\n  // hooks, and more importantly, avoids the need to track child components in\n  // arrays.\n  if (target) {\n    let current = target.parent\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current)\n      }\n      current = current.parent\n    }\n  }\n}\n\nfunction injectToKeepAliveRoot(\n  hook: Function & { __weh?: Function },\n  type: LifecycleHooks,\n  target: ComponentInternalInstance,\n  keepAliveRoot: ComponentInternalInstance\n) {\n  // injectHook wraps the original for error handling, so make sure to remove\n  // the wrapped version.\n  const injected = injectHook(type, hook, keepAliveRoot, true /* prepend */)\n  onUnmounted(() => {\n    remove(keepAliveRoot[type]!, injected)\n  }, target)\n}\n\nfunction resetShapeFlag(vnode: VNode) {\n  let shapeFlag = vnode.shapeFlag\n  if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {\n    shapeFlag -= ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE\n  }\n  if (shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {\n    shapeFlag -= ShapeFlags.COMPONENT_KEPT_ALIVE\n  }\n  vnode.shapeFlag = shapeFlag\n}\n\nfunction getInnerChild(vnode: VNode) {\n  return vnode.shapeFlag & ShapeFlags.SUSPENSE ? vnode.ssContent! : vnode\n}\n", "import {\n  ComponentInternalInstance,\n  currentInstance,\n  isInSSRComponentSetup,\n  LifecycleHooks,\n  setCurrentInstance,\n  unsetCurrentInstance\n} from './component'\nimport { ComponentPublicInstance } from './componentPublicInstance'\nimport { callWithAsyncErrorHandling, ErrorTypeStrings } from './errorHandling'\nimport { warn } from './warning'\nimport { toHandlerKey } from '@vue/shared'\nimport { DebuggerEvent, pauseTracking, resetTracking } from '@vue/reactivity'\n\nexport { onActivated, onDeactivated } from './components/KeepAlive'\n\nexport function injectHook(\n  type: LifecycleHooks,\n  hook: Function & { __weh?: Function },\n  target: ComponentInternalInstance | null = currentInstance,\n  prepend: boolean = false\n): Function | undefined {\n  if (target) {\n    const hooks = target[type] || (target[type] = [])\n    // cache the error handling wrapper for injected hooks so the same hook\n    // can be properly deduped by the scheduler. \"__weh\" stands for \"with error\n    // handling\".\n    const wrappedHook =\n      hook.__weh ||\n      (hook.__weh = (...args: unknown[]) => {\n        if (target.isUnmounted) {\n          return\n        }\n        // disable tracking inside all lifecycle hooks\n        // since they can potentially be called inside effects.\n        pauseTracking()\n        // Set currentInstance during hook invocation.\n        // This assumes the hook does not synchronously trigger other hooks, which\n        // can only be false when the user does something really funky.\n        setCurrentInstance(target)\n        const res = callWithAsyncErrorHandling(hook, target, type, args)\n        unsetCurrentInstance()\n        resetTracking()\n        return res\n      })\n    if (prepend) {\n      hooks.unshift(wrappedHook)\n    } else {\n      hooks.push(wrappedHook)\n    }\n    return wrappedHook\n  } else if (__DEV__) {\n    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ''))\n    warn(\n      `${apiName} is called when there is no active component instance to be ` +\n        `associated with. ` +\n        `Lifecycle injection APIs can only be used during execution of setup().` +\n        (__FEATURE_SUSPENSE__\n          ? ` If you are using async setup(), make sure to register lifecycle ` +\n            `hooks before the first await statement.`\n          : ``)\n    )\n  }\n}\n\nexport const createHook =\n  <T extends Function = () => any>(lifecycle: LifecycleHooks) =>\n  (hook: T, target: ComponentInternalInstance | null = currentInstance) =>\n    // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\n    (!isInSSRComponentSetup || lifecycle === LifecycleHooks.SERVER_PREFETCH) &&\n    injectHook(lifecycle, hook, target)\n\nexport const onBeforeMount = createHook(LifecycleHooks.BEFORE_MOUNT)\nexport const onMounted = createHook(LifecycleHooks.MOUNTED)\nexport const onBeforeUpdate = createHook(LifecycleHooks.BEFORE_UPDATE)\nexport const onUpdated = createHook(LifecycleHooks.UPDATED)\nexport const onBeforeUnmount = createHook(LifecycleHooks.BEFORE_UNMOUNT)\nexport const onUnmounted = createHook(LifecycleHooks.UNMOUNTED)\nexport const onServerPrefetch = createHook(LifecycleHooks.SERVER_PREFETCH)\n\nexport type DebuggerHook = (e: DebuggerEvent) => void\nexport const onRenderTriggered = createHook<DebuggerHook>(\n  LifecycleHooks.RENDER_TRIGGERED\n)\nexport const onRenderTracked = createHook<DebuggerHook>(\n  LifecycleHooks.RENDER_TRACKED\n)\n\nexport type ErrorCapturedHook<TError = unknown> = (\n  err: TError,\n  instance: ComponentPublicInstance | null,\n  info: string\n) => boolean | void\n\nexport function onErrorCaptured<TError = Error>(\n  hook: ErrorCapturedHook<TError>,\n  target: ComponentInternalInstance | null = currentInstance\n) {\n  injectHook(LifecycleHooks.ERROR_CAPTURED, hook, target)\n}\n", "import {\n  ComponentInternalInstance,\n  Data,\n  SetupContext,\n  ComponentInternalOptions,\n  Component,\n  ConcreteComponent,\n  InternalRenderFunction,\n  LifecycleHooks\n} from './component'\nimport {\n  isFunction,\n  extend,\n  isString,\n  isObject,\n  isArray,\n  NOOP,\n  isPromise,\n  LooseRequired,\n  UnionToIntersection\n} from '@vue/shared'\nimport { isRef, Ref } from '@vue/reactivity'\nimport { computed } from './apiComputed'\nimport {\n  watch,\n  WatchOptions,\n  WatchCallback,\n  createPathGetter\n} from './apiWatch'\nimport { provide, inject } from './apiInject'\nimport {\n  onBeforeMount,\n  onMounted,\n  onBeforeUpdate,\n  onUpdated,\n  onErrorCaptured,\n  onRenderTracked,\n  onBeforeUnmount,\n  onUnmounted,\n  onActivated,\n  onDeactivated,\n  onRenderTriggered,\n  DebuggerHook,\n  ErrorCapturedHook,\n  onServerPrefetch\n} from './apiLifecycle'\nimport {\n  reactive,\n  ComputedGetter,\n  WritableComputedOptions\n} from '@vue/reactivity'\nimport {\n  ComponentObjectPropsOptions,\n  ExtractPropTypes,\n  ExtractDefaultPropTypes\n} from './componentProps'\nimport { EmitsOptions, EmitsToProps } from './componentEmits'\nimport { Directive } from './directives'\nimport {\n  CreateComponentPublicInstance,\n  ComponentPublicInstance\n} from './componentPublicInstance'\nimport { warn } from './warning'\nimport { VNodeChild } from './vnode'\nimport { callWithAsyncErrorHandling } from './errorHandling'\nimport { deepMergeData } from './compat/data'\nimport { DeprecationTypes } from './compat/compatConfig'\nimport {\n  CompatConfig,\n  isCompatEnabled,\n  softAssertCompatEnabled\n} from './compat/compatConfig'\nimport { OptionMergeFunction } from './apiCreateApp'\n\n/**\n * Interface for declaring custom options.\n *\n * @example\n * ```ts\n * declare module '@vue/runtime-core' {\n *   interface ComponentCustomOptions {\n *     beforeRouteUpdate?(\n *       to: Route,\n *       from: Route,\n *       next: () => void\n *     ): void\n *   }\n * }\n * ```\n */\nexport interface ComponentCustomOptions {}\n\nexport type RenderFunction = () => VNodeChild\n\ntype ExtractOptionProp<T> = T extends ComponentOptionsBase<\n  infer P, // Props\n  any, // RawBindings\n  any, // D\n  any, // C\n  any, // M\n  any, // Mixin\n  any, // Extends\n  any // EmitsOptions\n>\n  ? unknown extends P\n    ? {}\n    : P\n  : {}\n\nexport interface ComponentOptionsBase<\n  Props,\n  RawBindings,\n  D,\n  C extends ComputedOptions,\n  M extends MethodOptions,\n  Mixin extends ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin,\n  E extends EmitsOptions,\n  EE extends string = string,\n  Defaults = {}\n> extends LegacyOptions<Props, D, C, M, Mixin, Extends>,\n    ComponentInternalOptions,\n    ComponentCustomOptions {\n  setup?: (\n    this: void,\n    props: Readonly<\n      LooseRequired<\n        Props &\n          UnionToIntersection<ExtractOptionProp<Mixin>> &\n          UnionToIntersection<ExtractOptionProp<Extends>>\n      >\n    >,\n    ctx: SetupContext<E>\n  ) => Promise<RawBindings> | RawBindings | RenderFunction | void\n  name?: string\n  template?: string | object // can be a direct DOM node\n  // Note: we are intentionally using the signature-less `Function` type here\n  // since any type with signature will cause the whole inference to fail when\n  // the return expression contains reference to `this`.\n  // Luckily `render()` doesn't need any arguments nor does it care about return\n  // type.\n  render?: Function\n  components?: Record<string, Component>\n  directives?: Record<string, Directive>\n  inheritAttrs?: boolean\n  emits?: (E | EE[]) & ThisType<void>\n  // TODO infer public instance type based on exposed keys\n  expose?: string[]\n  serverPrefetch?(): Promise<any>\n\n  // Runtime compiler only -----------------------------------------------------\n  compilerOptions?: RuntimeCompilerOptions\n\n  // Internal ------------------------------------------------------------------\n\n  /**\n   * SSR only. This is produced by compiler-ssr and attached in compiler-sfc\n   * not user facing, so the typing is lax and for test only.\n   * @internal\n   */\n  ssrRender?: (\n    ctx: any,\n    push: (item: any) => void,\n    parentInstance: ComponentInternalInstance,\n    attrs: Data | undefined,\n    // for compiler-optimized bindings\n    $props: ComponentInternalInstance['props'],\n    $setup: ComponentInternalInstance['setupState'],\n    $data: ComponentInternalInstance['data'],\n    $options: ComponentInternalInstance['ctx']\n  ) => void\n\n  /**\n   * Only generated by compiler-sfc to mark a ssr render function inlined and\n   * returned from setup()\n   * @internal\n   */\n  __ssrInlineRender?: boolean\n\n  /**\n   * marker for AsyncComponentWrapper\n   * @internal\n   */\n  __asyncLoader?: () => Promise<ConcreteComponent>\n  /**\n   * the inner component resolved by the AsyncComponentWrapper\n   * @internal\n   */\n  __asyncResolved?: ConcreteComponent\n\n  // Type differentiators ------------------------------------------------------\n\n  // Note these are internal but need to be exposed in d.ts for type inference\n  // to work!\n\n  // type-only differentiator to separate OptionWithoutProps from a constructor\n  // type returned by defineComponent() or FunctionalComponent\n  call?: (this: unknown, ...args: unknown[]) => never\n  // type-only differentiators for built-in Vnode types\n  __isFragment?: never\n  __isTeleport?: never\n  __isSuspense?: never\n\n  __defaults?: Defaults\n}\n\n/**\n * Subset of compiler options that makes sense for the runtime.\n */\nexport interface RuntimeCompilerOptions {\n  isCustomElement?: (tag: string) => boolean\n  whitespace?: 'preserve' | 'condense'\n  comments?: boolean\n  delimiters?: [string, string]\n}\n\nexport type ComponentOptionsWithoutProps<\n  Props = {},\n  RawBindings = {},\n  D = {},\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = EmitsOptions,\n  EE extends string = string,\n  PE = Props & EmitsToProps<E>\n> = ComponentOptionsBase<\n  PE,\n  RawBindings,\n  D,\n  C,\n  M,\n  Mixin,\n  Extends,\n  E,\n  EE,\n  {}\n> & {\n  props?: undefined\n} & ThisType<\n    CreateComponentPublicInstance<PE, RawBindings, D, C, M, Mixin, Extends, E>\n  >\n\nexport type ComponentOptionsWithArrayProps<\n  PropNames extends string = string,\n  RawBindings = {},\n  D = {},\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = EmitsOptions,\n  EE extends string = string,\n  Props = Readonly<{ [key in PropNames]?: any }> & EmitsToProps<E>\n> = ComponentOptionsBase<\n  Props,\n  RawBindings,\n  D,\n  C,\n  M,\n  Mixin,\n  Extends,\n  E,\n  EE,\n  {}\n> & {\n  props: PropNames[]\n} & ThisType<\n    CreateComponentPublicInstance<\n      Props,\n      RawBindings,\n      D,\n      C,\n      M,\n      Mixin,\n      Extends,\n      E\n    >\n  >\n\nexport type ComponentOptionsWithObjectProps<\n  PropsOptions = ComponentObjectPropsOptions,\n  RawBindings = {},\n  D = {},\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = EmitsOptions,\n  EE extends string = string,\n  Props = Readonly<ExtractPropTypes<PropsOptions>> & EmitsToProps<E>,\n  Defaults = ExtractDefaultPropTypes<PropsOptions>\n> = ComponentOptionsBase<\n  Props,\n  RawBindings,\n  D,\n  C,\n  M,\n  Mixin,\n  Extends,\n  E,\n  EE,\n  Defaults\n> & {\n  props: PropsOptions & ThisType<void>\n} & ThisType<\n    CreateComponentPublicInstance<\n      Props,\n      RawBindings,\n      D,\n      C,\n      M,\n      Mixin,\n      Extends,\n      E,\n      Props,\n      Defaults,\n      false\n    >\n  >\n\nexport type ComponentOptions<\n  Props = {},\n  RawBindings = any,\n  D = any,\n  C extends ComputedOptions = any,\n  M extends MethodOptions = any,\n  Mixin extends ComponentOptionsMixin = any,\n  Extends extends ComponentOptionsMixin = any,\n  E extends EmitsOptions = any\n> = ComponentOptionsBase<Props, RawBindings, D, C, M, Mixin, Extends, E> &\n  ThisType<\n    CreateComponentPublicInstance<\n      {},\n      RawBindings,\n      D,\n      C,\n      M,\n      Mixin,\n      Extends,\n      E,\n      Readonly<Props>\n    >\n  >\n\nexport type ComponentOptionsMixin = ComponentOptionsBase<\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type ComputedOptions = Record<\n  string,\n  ComputedGetter<any> | WritableComputedOptions<any>\n>\n\nexport interface MethodOptions {\n  [key: string]: Function\n}\n\nexport type ExtractComputedReturns<T extends any> = {\n  [key in keyof T]: T[key] extends { get: (...args: any[]) => infer TReturn }\n    ? TReturn\n    : T[key] extends (...args: any[]) => infer TReturn\n    ? TReturn\n    : never\n}\n\nexport type ObjectWatchOptionItem = {\n  handler: WatchCallback | string\n} & WatchOptions\n\ntype WatchOptionItem = string | WatchCallback | ObjectWatchOptionItem\n\ntype ComponentWatchOptionItem = WatchOptionItem | WatchOptionItem[]\n\ntype ComponentWatchOptions = Record<string, ComponentWatchOptionItem>\n\ntype ComponentInjectOptions = string[] | ObjectInjectOptions\n\ntype ObjectInjectOptions = Record<\n  string | symbol,\n  string | symbol | { from?: string | symbol; default?: unknown }\n>\n\ninterface LegacyOptions<\n  Props,\n  D,\n  C extends ComputedOptions,\n  M extends MethodOptions,\n  Mixin extends ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin\n> {\n  compatConfig?: CompatConfig\n\n  // allow any custom options\n  [key: string]: any\n\n  // state\n  // Limitation: we cannot expose RawBindings on the `this` context for data\n  // since that leads to some sort of circular inference and breaks ThisType\n  // for the entire component.\n  data?: (\n    this: CreateComponentPublicInstance<\n      Props,\n      {},\n      {},\n      {},\n      MethodOptions,\n      Mixin,\n      Extends\n    >,\n    vm: CreateComponentPublicInstance<\n      Props,\n      {},\n      {},\n      {},\n      MethodOptions,\n      Mixin,\n      Extends\n    >\n  ) => D\n  computed?: C\n  methods?: M\n  watch?: ComponentWatchOptions\n  provide?: Data | Function\n  inject?: ComponentInjectOptions\n\n  // assets\n  filters?: Record<string, Function>\n\n  // composition\n  mixins?: Mixin[]\n  extends?: Extends\n\n  // lifecycle\n  beforeCreate?(): void\n  created?(): void\n  beforeMount?(): void\n  mounted?(): void\n  beforeUpdate?(): void\n  updated?(): void\n  activated?(): void\n  deactivated?(): void\n  /** @deprecated use `beforeUnmount` instead */\n  beforeDestroy?(): void\n  beforeUnmount?(): void\n  /** @deprecated use `unmounted` instead */\n  destroyed?(): void\n  unmounted?(): void\n  renderTracked?: DebuggerHook\n  renderTriggered?: DebuggerHook\n  errorCaptured?: ErrorCapturedHook\n\n  /**\n   * runtime compile only\n   * @deprecated use `compilerOptions.delimiters` instead.\n   */\n  delimiters?: [string, string]\n\n  /**\n   * #3468\n   *\n   * type-only, used to assist Mixin's type inference,\n   * typescript will try to simplify the inferred `Mixin` type,\n   * with the `__differenciator`, typescript won't be able to combine different mixins,\n   * because the `__differenciator` will be different\n   */\n  __differentiator?: keyof D | keyof C | keyof M\n}\n\ntype MergedHook<T = () => void> = T | T[]\n\nexport type MergedComponentOptions = ComponentOptions &\n  MergedComponentOptionsOverride\n\nexport type MergedComponentOptionsOverride = {\n  beforeCreate?: MergedHook\n  created?: MergedHook\n  beforeMount?: MergedHook\n  mounted?: MergedHook\n  beforeUpdate?: MergedHook\n  updated?: MergedHook\n  activated?: MergedHook\n  deactivated?: MergedHook\n  /** @deprecated use `beforeUnmount` instead */\n  beforeDestroy?: MergedHook\n  beforeUnmount?: MergedHook\n  /** @deprecated use `unmounted` instead */\n  destroyed?: MergedHook\n  unmounted?: MergedHook\n  renderTracked?: MergedHook<DebuggerHook>\n  renderTriggered?: MergedHook<DebuggerHook>\n  errorCaptured?: MergedHook<ErrorCapturedHook>\n}\n\nexport type OptionTypesKeys = 'P' | 'B' | 'D' | 'C' | 'M' | 'Defaults'\n\nexport type OptionTypesType<\n  P = {},\n  B = {},\n  D = {},\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Defaults = {}\n> = {\n  P: P\n  B: B\n  D: D\n  C: C\n  M: M\n  Defaults: Defaults\n}\n\nconst enum OptionTypes {\n  PROPS = 'Props',\n  DATA = 'Data',\n  COMPUTED = 'Computed',\n  METHODS = 'Methods',\n  INJECT = 'Inject'\n}\n\nfunction createDuplicateChecker() {\n  const cache = Object.create(null)\n  return (type: OptionTypes, key: string) => {\n    if (cache[key]) {\n      warn(`${type} property \"${key}\" is already defined in ${cache[key]}.`)\n    } else {\n      cache[key] = type\n    }\n  }\n}\n\nexport let shouldCacheAccess = true\n\nexport function applyOptions(instance: ComponentInternalInstance) {\n  const options = resolveMergedOptions(instance)\n  const publicThis = instance.proxy! as any\n  const ctx = instance.ctx\n\n  // do not cache property access on public proxy during state initialization\n  shouldCacheAccess = false\n\n  // call beforeCreate first before accessing other options since\n  // the hook may mutate resolved options (#2791)\n  if (options.beforeCreate) {\n    debugger\n    callHook(options.beforeCreate, instance, LifecycleHooks.BEFORE_CREATE)\n  }\n\n  const {\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // lifecycle\n    created,\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured,\n    serverPrefetch,\n    // public API\n    expose,\n    inheritAttrs,\n    // assets\n    components,\n    directives,\n    filters\n  } = options\n\n  const checkDuplicateProperties = __DEV__ ? createDuplicateChecker() : null\n\n  if (__DEV__) {\n    const [propsOptions] = instance.propsOptions\n    if (propsOptions) {\n      for (const key in propsOptions) {\n        checkDuplicateProperties!(OptionTypes.PROPS, key)\n      }\n    }\n  }\n\n  // options initialization order (to be consistent with Vue 2):\n  // - props (already done outside of this function)\n  // - inject\n  // - methods\n  // - data (deferred since it relies on `this` access)\n  // - computed\n  // - watch (deferred since it relies on `this` access)\n\n  if (injectOptions) {\n    resolveInjections(\n      injectOptions,\n      ctx,\n      checkDuplicateProperties,\n      instance.appContext.config.unwrapInjectedRef\n    )\n  }\n\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = (methods as MethodOptions)[key]\n      if (isFunction(methodHandler)) {\n        // In dev mode, we use the `createRenderContext` function to define\n        // methods to the proxy target, and those are read-only but\n        // reconfigurable, so it needs to be redefined here\n        if (__DEV__) {\n          Object.defineProperty(ctx, key, {\n            value: methodHandler.bind(publicThis),\n            configurable: true,\n            enumerable: true,\n            writable: true\n          })\n        } else {\n          ctx[key] = methodHandler.bind(publicThis)\n        }\n        if (__DEV__) {\n          checkDuplicateProperties!(OptionTypes.METHODS, key)\n        }\n      } else if (__DEV__) {\n        warn(\n          `Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. ` +\n            `Did you reference the function correctly?`\n        )\n      }\n    }\n  }\n\n  if (dataOptions) {\n    if (__DEV__ && !isFunction(dataOptions)) {\n      warn(\n        `The data option must be a function. ` +\n          `Plain object usage is no longer supported.`\n      )\n    }\n    const data = dataOptions.call(publicThis, publicThis)\n    if (__DEV__ && isPromise(data)) {\n      warn(\n        `data() returned a Promise - note data() cannot be async; If you ` +\n          `intend to perform data fetching before component renders, use ` +\n          `async setup() + <Suspense>.`\n      )\n    }\n    if (!isObject(data)) {\n      __DEV__ && warn(`data() should return an object.`)\n    } else {\n      instance.data = reactive(data)\n      if (__DEV__) {\n        for (const key in data) {\n          checkDuplicateProperties!(OptionTypes.DATA, key)\n          // expose data on ctx during dev\n          if (key[0] !== '$' && key[0] !== '_') {\n            Object.defineProperty(ctx, key, {\n              configurable: true,\n              enumerable: true,\n              get: () => data[key],\n              set: NOOP\n            })\n          }\n        }\n      }\n    }\n  }\n\n  // state initialization complete at this point - start caching access\n  shouldCacheAccess = true\n\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = (computedOptions as ComputedOptions)[key]\n      const get = isFunction(opt)\n        ? opt.bind(publicThis, publicThis)\n        : isFunction(opt.get)\n        ? opt.get.bind(publicThis, publicThis)\n        : NOOP\n      if (__DEV__ && get === NOOP) {\n        warn(`Computed property \"${key}\" has no getter.`)\n      }\n      const set =\n        !isFunction(opt) && isFunction(opt.set)\n          ? opt.set.bind(publicThis)\n          : __DEV__\n          ? () => {\n              warn(\n                `Write operation failed: computed property \"${key}\" is readonly.`\n              )\n            }\n          : NOOP\n      const c = computed({\n        get,\n        set\n      })\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: v => (c.value = v)\n      })\n      if (__DEV__) {\n        checkDuplicateProperties!(OptionTypes.COMPUTED, key)\n      }\n    }\n  }\n\n  if (watchOptions) {\n    for (const key in watchOptions) {\n      createWatcher(watchOptions[key], ctx, publicThis, key)\n    }\n  }\n\n  if (provideOptions) {\n    const provides = isFunction(provideOptions)\n      ? provideOptions.call(publicThis)\n      : provideOptions\n    Reflect.ownKeys(provides).forEach(key => {\n      provide(key, provides[key])\n    })\n  }\n\n  if (created) {\n    callHook(created, instance, LifecycleHooks.CREATED)\n  }\n\n  function registerLifecycleHook(\n    register: Function,\n    hook?: Function | Function[]\n  ) {\n    if (isArray(hook)) {\n      hook.forEach(_hook => register(_hook.bind(publicThis)))\n    } else if (hook) {\n      register((hook as Function).bind(publicThis))\n    }\n  }\n\n  registerLifecycleHook(onBeforeMount, beforeMount)\n  registerLifecycleHook(onMounted, mounted)\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate)\n  registerLifecycleHook(onUpdated, updated)\n  registerLifecycleHook(onActivated, activated)\n  registerLifecycleHook(onDeactivated, deactivated)\n  registerLifecycleHook(onErrorCaptured, errorCaptured)\n  registerLifecycleHook(onRenderTracked, renderTracked)\n  registerLifecycleHook(onRenderTriggered, renderTriggered)\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount)\n  registerLifecycleHook(onUnmounted, unmounted)\n  registerLifecycleHook(onServerPrefetch, serverPrefetch)\n\n  if (__COMPAT__) {\n    if (\n      beforeDestroy &&\n      softAssertCompatEnabled(DeprecationTypes.OPTIONS_BEFORE_DESTROY, instance)\n    ) {\n      registerLifecycleHook(onBeforeUnmount, beforeDestroy)\n    }\n    if (\n      destroyed &&\n      softAssertCompatEnabled(DeprecationTypes.OPTIONS_DESTROYED, instance)\n    ) {\n      registerLifecycleHook(onUnmounted, destroyed)\n    }\n  }\n\n  if (isArray(expose)) {\n    if (expose.length) {\n      const exposed = instance.exposed || (instance.exposed = {})\n      expose.forEach(key => {\n        Object.defineProperty(exposed, key, {\n          get: () => publicThis[key],\n          set: val => (publicThis[key] = val)\n        })\n      })\n    } else if (!instance.exposed) {\n      instance.exposed = {}\n    }\n  }\n\n  // options that are handled when creating the instance but also need to be\n  // applied from mixins\n  if (render && instance.render === NOOP) {\n    instance.render = render as InternalRenderFunction\n  }\n  if (inheritAttrs != null) {\n    instance.inheritAttrs = inheritAttrs\n  }\n\n  // asset options.\n  if (components) instance.components = components as any\n  if (directives) instance.directives = directives\n  if (\n    __COMPAT__ &&\n    filters &&\n    isCompatEnabled(DeprecationTypes.FILTERS, instance)\n  ) {\n    instance.filters = filters\n  }\n}\n\nexport function resolveInjections(\n  injectOptions: ComponentInjectOptions,\n  ctx: any,\n  checkDuplicateProperties = NOOP as any,\n  unwrapRef = false\n) {\n  if (isArray(injectOptions)) {\n    injectOptions = normalizeInject(injectOptions)!\n  }\n  for (const key in injectOptions) {\n    const opt = (injectOptions as ObjectInjectOptions)[key]\n    let injected: unknown\n    if (isObject(opt)) {\n      if ('default' in opt) {\n        injected = inject(\n          opt.from || key,\n          opt.default,\n          true /* treat default function as factory */\n        )\n      } else {\n        injected = inject(opt.from || key)\n      }\n    } else {\n      injected = inject(opt)\n    }\n    if (isRef(injected)) {\n      // TODO remove the check in 3.3\n      if (unwrapRef) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          get: () => (injected as Ref).value,\n          set: v => ((injected as Ref).value = v)\n        })\n      } else {\n        if (__DEV__) {\n          warn(\n            `injected property \"${key}\" is a ref and will be auto-unwrapped ` +\n              `and no longer needs \\`.value\\` in the next minor release. ` +\n              `To opt-in to the new behavior now, ` +\n              `set \\`app.config.unwrapInjectedRef = true\\` (this config is ` +\n              `temporary and will not be needed in the future.)`\n          )\n        }\n        ctx[key] = injected\n      }\n    } else {\n      ctx[key] = injected\n    }\n    if (__DEV__) {\n      checkDuplicateProperties!(OptionTypes.INJECT, key)\n    }\n  }\n}\n\nfunction callHook(\n  hook: Function,\n  instance: ComponentInternalInstance,\n  type: LifecycleHooks\n) {\n  callWithAsyncErrorHandling(\n    isArray(hook)\n      ? hook.map(h => h.bind(instance.proxy!))\n      : hook.bind(instance.proxy!),\n    instance,\n    type\n  )\n}\n\nexport function createWatcher(\n  raw: ComponentWatchOptionItem,\n  ctx: Data,\n  publicThis: ComponentPublicInstance,\n  key: string\n) {\n  const getter = key.includes('.')\n    ? createPathGetter(publicThis, key)\n    : () => (publicThis as any)[key]\n  if (isString(raw)) {\n    const handler = ctx[raw]\n    if (isFunction(handler)) {\n      watch(getter, handler as WatchCallback)\n    } else if (__DEV__) {\n      warn(`Invalid watch handler specified by key \"${raw}\"`, handler)\n    }\n  } else if (isFunction(raw)) {\n    watch(getter, raw.bind(publicThis))\n  } else if (isObject(raw)) {\n    if (isArray(raw)) {\n      raw.forEach(r => createWatcher(r, ctx, publicThis, key))\n    } else {\n      const handler = isFunction(raw.handler)\n        ? raw.handler.bind(publicThis)\n        : (ctx[raw.handler] as WatchCallback)\n      if (isFunction(handler)) {\n        watch(getter, handler, raw)\n      } else if (__DEV__) {\n        warn(`Invalid watch handler specified by key \"${raw.handler}\"`, handler)\n      }\n    }\n  } else if (__DEV__) {\n    warn(`Invalid watch option: \"${key}\"`, raw)\n  }\n}\n\n/**\n * Resolve merged options and cache it on the component.\n * This is done only once per-component since the merging does not involve\n * instances.\n */\nexport function resolveMergedOptions(\n  instance: ComponentInternalInstance\n): MergedComponentOptions {\n  const base = instance.type as ComponentOptions\n  const { mixins, extends: extendsOptions } = base\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: { optionMergeStrategies }\n  } = instance.appContext\n  const cached = cache.get(base)\n\n  let resolved: MergedComponentOptions\n\n  if (cached) {\n    resolved = cached\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    if (\n      __COMPAT__ &&\n      isCompatEnabled(DeprecationTypes.PRIVATE_APIS, instance)\n    ) {\n      resolved = extend({}, base) as MergedComponentOptions\n      resolved.parent = instance.parent && instance.parent.proxy\n      resolved.propsData = instance.vnode.props\n    } else {\n      resolved = base as MergedComponentOptions\n    }\n  } else {\n    resolved = {}\n    if (globalMixins.length) {\n      globalMixins.forEach(m =>\n        mergeOptions(resolved, m, optionMergeStrategies, true)\n      )\n    }\n    mergeOptions(resolved, base, optionMergeStrategies)\n  }\n\n  cache.set(base, resolved)\n  return resolved\n}\n\nexport function mergeOptions(\n  to: any,\n  from: any,\n  strats: Record<string, OptionMergeFunction>,\n  asMixin = false\n) {\n  if (__COMPAT__ && isFunction(from)) {\n    from = from.options\n  }\n\n  const { mixins, extends: extendsOptions } = from\n\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true)\n  }\n  if (mixins) {\n    mixins.forEach((m: ComponentOptionsMixin) =>\n      mergeOptions(to, m, strats, true)\n    )\n  }\n\n  for (const key in from) {\n    if (asMixin && key === 'expose') {\n      __DEV__ &&\n        warn(\n          `\"expose\" option is ignored when declared in mixins or extends. ` +\n            `It should only be declared in the base component itself.`\n        )\n    } else {\n      const strat = internalOptionMergeStrats[key] || (strats && strats[key])\n      to[key] = strat ? strat(to[key], from[key]) : from[key]\n    }\n  }\n  return to\n}\n\nexport const internalOptionMergeStrats: Record<string, Function> = {\n  data: mergeDataFn,\n  props: mergeObjectOptions, // TODO\n  emits: mergeObjectOptions, // TODO\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n}\n\nif (__COMPAT__) {\n  internalOptionMergeStrats.filters = mergeObjectOptions\n}\n\nfunction mergeDataFn(to: any, from: any) {\n  if (!from) {\n    return to\n  }\n  if (!to) {\n    return from\n  }\n  return function mergedDataFn(this: ComponentPublicInstance) {\n    return (\n      __COMPAT__ && isCompatEnabled(DeprecationTypes.OPTIONS_DATA_MERGE, null)\n        ? deepMergeData\n        : extend\n    )(\n      isFunction(to) ? to.call(this, this) : to,\n      isFunction(from) ? from.call(this, this) : from\n    )\n  }\n}\n\nfunction mergeInject(\n  to: ComponentInjectOptions | undefined,\n  from: ComponentInjectOptions\n) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from))\n}\n\nfunction normalizeInject(\n  raw: ComponentInjectOptions | undefined\n): ObjectInjectOptions | undefined {\n  if (isArray(raw)) {\n    const res: ObjectInjectOptions = {}\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i]\n    }\n    return res\n  }\n  return raw\n}\n\nfunction mergeAsArray<T = Function>(to: T[] | T | undefined, from: T | T[]) {\n  return to ? [...new Set([].concat(to as any, from as any))] : from\n}\n\nfunction mergeObjectOptions(to: Object | undefined, from: Object | undefined) {\n  return to ? extend(extend(Object.create(null), to), from) : from\n}\n\nfunction mergeWatchOptions(\n  to: ComponentWatchOptions | undefined,\n  from: ComponentWatchOptions | undefined\n) {\n  if (!to) return from\n  if (!from) return to\n  const merged = extend(Object.create(null), to)\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key])\n  }\n  return merged\n}\n", "import {\n  toRaw,\n  shallowReactive,\n  trigger,\n  TriggerOpTypes\n} from '@vue/reactivity'\nimport {\n  EMPTY_OBJ,\n  camelize,\n  hyphenate,\n  capitalize,\n  isString,\n  isFunction,\n  isArray,\n  isObject,\n  hasOwn,\n  toRawType,\n  PatchFlags,\n  makeMap,\n  isReservedProp,\n  EMPTY_ARR,\n  def,\n  extend,\n  isOn,\n  IfAny\n} from '@vue/shared'\nimport { warn } from './warning'\nimport {\n  Data,\n  ComponentInternalInstance,\n  ComponentOptions,\n  ConcreteComponent,\n  setCurrentInstance,\n  unsetCurrentInstance\n} from './component'\nimport { isEmitListener } from './componentEmits'\nimport { InternalObjectKey } from './vnode'\nimport { AppContext } from './apiCreateApp'\nimport { createPropsDefaultThis } from './compat/props'\nimport { isCompatEnabled, softAssertCompatEnabled } from './compat/compatConfig'\nimport { DeprecationTypes } from './compat/compatConfig'\nimport { shouldSkipAttr } from './compat/attrsFallthrough'\n\nexport type ComponentPropsOptions<P = Data> =\n  | ComponentObjectPropsOptions<P>\n  | string[]\n\nexport type ComponentObjectPropsOptions<P = Data> = {\n  [K in keyof P]: Prop<P[K]> | null\n}\n\nexport type Prop<T, D = T> = PropOptions<T, D> | PropType<T>\n\ntype DefaultFactory<T> = (props: Data) => T | null | undefined\n\nexport interface PropOptions<T = any, D = T> {\n  type?: PropType<T> | true | null\n  required?: boolean\n  default?: D | DefaultFactory<D> | null | undefined | object\n  validator?(value: unknown): boolean\n}\n\nexport type PropType<T> = PropConstructor<T> | PropConstructor<T>[]\n\ntype PropConstructor<T = any> =\n  | { new (...args: any[]): T & {} }\n  | { (): T }\n  | PropMethod<T>\n\ntype PropMethod<T, TConstructor = any> = [T] extends [\n  ((...args: any) => any) | undefined\n] // if is function with args, allowing non-required functions\n  ? { new (): TConstructor; (): T; readonly prototype: TConstructor } // Create Function like constructor\n  : never\n\ntype RequiredKeys<T> = {\n  [K in keyof T]: T[K] extends\n    | { required: true }\n    | { default: any }\n    // don't mark Boolean props as undefined\n    | BooleanConstructor\n    | { type: BooleanConstructor }\n    ? T[K] extends { default: undefined | (() => undefined) }\n      ? never\n      : K\n    : never\n}[keyof T]\n\ntype OptionalKeys<T> = Exclude<keyof T, RequiredKeys<T>>\n\ntype DefaultKeys<T> = {\n  [K in keyof T]: T[K] extends\n    | { default: any }\n    // Boolean implicitly defaults to false\n    | BooleanConstructor\n    | { type: BooleanConstructor }\n    ? T[K] extends { type: BooleanConstructor; required: true } // not default if Boolean is marked as required\n      ? never\n      : K\n    : never\n}[keyof T]\n\ntype InferPropType<T> = [T] extends [null]\n  ? any // null & true would fail to infer\n  : [T] extends [{ type: null | true }]\n  ? any // As TS issue https://github.com/Microsoft/TypeScript/issues/14829 // somehow `ObjectConstructor` when inferred from { (): T } becomes `any` // `BooleanConstructor` when inferred from PropConstructor(with PropMethod) becomes `Boolean`\n  : [T] extends [ObjectConstructor | { type: ObjectConstructor }]\n  ? Record<string, any>\n  : [T] extends [BooleanConstructor | { type: BooleanConstructor }]\n  ? boolean\n  : [T] extends [DateConstructor | { type: DateConstructor }]\n  ? Date\n  : [T] extends [(infer U)[] | { type: (infer U)[] }]\n  ? U extends DateConstructor\n    ? Date | InferPropType<U>\n    : InferPropType<U>\n  : [T] extends [Prop<infer V, infer D>]\n  ? unknown extends V\n    ? IfAny<V, V, D>\n    : V\n  : T\n\nexport type ExtractPropTypes<O> = {\n  // use `keyof Pick<O, RequiredKeys<O>>` instead of `RequiredKeys<O>` to support IDE features\n  [K in keyof Pick<O, RequiredKeys<O>>]: InferPropType<O[K]>\n} & {\n  // use `keyof Pick<O, OptionalKeys<O>>` instead of `OptionalKeys<O>` to support IDE features\n  [K in keyof Pick<O, OptionalKeys<O>>]?: InferPropType<O[K]>\n}\n\nconst enum BooleanFlags {\n  shouldCast,\n  shouldCastTrue\n}\n\n// extract props which defined with default from prop options\nexport type ExtractDefaultPropTypes<O> = O extends object\n  ? { [K in DefaultKeys<O>]: InferPropType<O[K]> }\n  : {}\n\ntype NormalizedProp =\n  | null\n  | (PropOptions & {\n      [BooleanFlags.shouldCast]?: boolean\n      [BooleanFlags.shouldCastTrue]?: boolean\n    })\n\n// normalized value is a tuple of the actual normalized options\n// and an array of prop keys that need value casting (booleans and defaults)\nexport type NormalizedProps = Record<string, NormalizedProp>\nexport type NormalizedPropsOptions = [NormalizedProps, string[]] | []\n\nexport function initProps(\n  instance: ComponentInternalInstance,\n  rawProps: Data | null,\n  isStateful: number, // result of bitwise flag comparison\n  isSSR = false\n) {\n  const props: Data = {}\n  const attrs: Data = {}\n  def(attrs, InternalObjectKey, 1)\n\n  instance.propsDefaults = Object.create(null)\n\n  setFullProps(instance, rawProps, props, attrs)\n\n  // ensure all declared prop keys are present\n  for (const key in instance.propsOptions[0]) {\n    if (!(key in props)) {\n      props[key] = undefined\n    }\n  }\n\n  // validation\n  if (__DEV__) {\n    validateProps(rawProps || {}, props, instance)\n  }\n\n  if (isStateful) {\n    // stateful\n    instance.props = isSSR ? props : shallowReactive(props)\n  } else {\n    if (!instance.type.props) {\n      // functional w/ optional props, props === attrs\n      instance.props = attrs\n    } else {\n      // functional w/ declared props\n      instance.props = props\n    }\n  }\n  instance.attrs = attrs\n}\n\nexport function updateProps(\n  instance: ComponentInternalInstance,\n  rawProps: Data | null,\n  rawPrevProps: Data | null,\n  optimized: boolean\n) {\n  const {\n    props,\n    attrs,\n    vnode: { patchFlag }\n  } = instance\n  const rawCurrentProps = toRaw(props)\n  const [options] = instance.propsOptions\n  let hasAttrsChanged = false\n\n  if (\n    // always force full diff in dev\n    // - #1942 if hmr is enabled with sfc component\n    // - vite#872 non-sfc component used by sfc component\n    !(\n      __DEV__ &&\n      (instance.type.__hmrId ||\n        (instance.parent && instance.parent.type.__hmrId))\n    ) &&\n    (optimized || patchFlag > 0) &&\n    !(patchFlag & PatchFlags.FULL_PROPS)\n  ) {\n    if (patchFlag & PatchFlags.PROPS) {\n      // Compiler-generated props & no keys change, just set the updated\n      // the props.\n      const propsToUpdate = instance.vnode.dynamicProps!\n      for (let i = 0; i < propsToUpdate.length; i++) {\n        let key = propsToUpdate[i]\n        // PROPS flag guarantees rawProps to be non-null\n        const value = rawProps![key]\n        if (options) {\n          // attr / props separation was done on init and will be consistent\n          // in this code path, so just check if attrs have it.\n          if (hasOwn(attrs, key)) {\n            if (value !== attrs[key]) {\n              attrs[key] = value\n              hasAttrsChanged = true\n            }\n          } else {\n            const camelizedKey = camelize(key)\n            props[camelizedKey] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              camelizedKey,\n              value,\n              instance,\n              false /* isAbsent */\n            )\n          }\n        } else {\n          if (__COMPAT__) {\n            if (isOn(key) && key.endsWith('Native')) {\n              key = key.slice(0, -6) // remove Native postfix\n            } else if (shouldSkipAttr(key, instance)) {\n              continue\n            }\n          }\n          if (value !== attrs[key]) {\n            attrs[key] = value\n            hasAttrsChanged = true\n          }\n        }\n      }\n    }\n  } else {\n    // full props update.\n    if (setFullProps(instance, rawProps, props, attrs)) {\n      hasAttrsChanged = true\n    }\n    // in case of dynamic props, check if we need to delete keys from\n    // the props object\n    let kebabKey: string\n    for (const key in rawCurrentProps) {\n      if (\n        !rawProps ||\n        // for camelCase\n        (!hasOwn(rawProps, key) &&\n          // it's possible the original props was passed in as kebab-case\n          // and converted to camelCase (#955)\n          ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey)))\n      ) {\n        if (options) {\n          if (\n            rawPrevProps &&\n            // for camelCase\n            (rawPrevProps[key] !== undefined ||\n              // for kebab-case\n              rawPrevProps[kebabKey!] !== undefined)\n          ) {\n            props[key] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              key,\n              undefined,\n              instance,\n              true /* isAbsent */\n            )\n          }\n        } else {\n          delete props[key]\n        }\n      }\n    }\n    // in the case of functional component w/o props declaration, props and\n    // attrs point to the same object so it should already have been updated.\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (\n          !rawProps ||\n          (!hasOwn(rawProps, key) &&\n            (!__COMPAT__ || !hasOwn(rawProps, key + 'Native')))\n        ) {\n          delete attrs[key]\n          hasAttrsChanged = true\n        }\n      }\n    }\n  }\n\n  // trigger updates for $attrs in case it's used in component slots\n  if (hasAttrsChanged) {\n    trigger(instance, TriggerOpTypes.SET, '$attrs')\n  }\n\n  if (__DEV__) {\n    validateProps(rawProps || {}, props, instance)\n  }\n}\n\nfunction setFullProps(\n  instance: ComponentInternalInstance,\n  rawProps: Data | null,\n  props: Data,\n  attrs: Data\n) {\n  const [options, needCastKeys] = instance.propsOptions\n  let hasAttrsChanged = false\n  let rawCastValues: Data | undefined\n  if (rawProps) {\n    for (let key in rawProps) {\n      // key, ref are reserved and never passed down\n      if (isReservedProp(key)) {\n        continue\n      }\n\n      if (__COMPAT__) {\n        if (key.startsWith('onHook:')) {\n          softAssertCompatEnabled(\n            DeprecationTypes.INSTANCE_EVENT_HOOKS,\n            instance,\n            key.slice(2).toLowerCase()\n          )\n        }\n        if (key === 'inline-template') {\n          continue\n        }\n      }\n\n      const value = rawProps[key]\n      // prop option names are camelized during normalization, so to support\n      // kebab -> camel conversion here we need to camelize the key.\n      let camelKey\n      if (options && hasOwn(options, (camelKey = camelize(key)))) {\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n          props[camelKey] = value\n        } else {\n          ;(rawCastValues || (rawCastValues = {}))[camelKey] = value\n        }\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        // Any non-declared (either as a prop or an emitted event) props are put\n        // into a separate `attrs` object for spreading. Make sure to preserve\n        // original key casing\n        if (__COMPAT__) {\n          if (isOn(key) && key.endsWith('Native')) {\n            key = key.slice(0, -6) // remove Native postfix\n          } else if (shouldSkipAttr(key, instance)) {\n            continue\n          }\n        }\n        if (!(key in attrs) || value !== attrs[key]) {\n          attrs[key] = value\n          hasAttrsChanged = true\n        }\n      }\n    }\n  }\n\n  if (needCastKeys) {\n    const rawCurrentProps = toRaw(props)\n    const castValues = rawCastValues || EMPTY_OBJ\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i]\n      props[key] = resolvePropValue(\n        options!,\n        rawCurrentProps,\n        key,\n        castValues[key],\n        instance,\n        !hasOwn(castValues, key)\n      )\n    }\n  }\n\n  return hasAttrsChanged\n}\n\nfunction resolvePropValue(\n  options: NormalizedProps,\n  props: Data,\n  key: string,\n  value: unknown,\n  instance: ComponentInternalInstance,\n  isAbsent: boolean\n) {\n  const opt = options[key]\n  if (opt != null) {\n    const hasDefault = hasOwn(opt, 'default')\n    // default values\n    if (hasDefault && value === undefined) {\n      const defaultValue = opt.default\n      if (opt.type !== Function && isFunction(defaultValue)) {\n        const { propsDefaults } = instance\n        if (key in propsDefaults) {\n          value = propsDefaults[key]\n        } else {\n          setCurrentInstance(instance)\n          value = propsDefaults[key] = defaultValue.call(\n            __COMPAT__ &&\n              isCompatEnabled(DeprecationTypes.PROPS_DEFAULT_THIS, instance)\n              ? createPropsDefaultThis(instance, props, key)\n              : null,\n            props\n          )\n          unsetCurrentInstance()\n        }\n      } else {\n        value = defaultValue\n      }\n    }\n    // boolean casting\n    if (opt[BooleanFlags.shouldCast]) {\n      if (isAbsent && !hasDefault) {\n        value = false\n      } else if (\n        opt[BooleanFlags.shouldCastTrue] &&\n        (value === '' || value === hyphenate(key))\n      ) {\n        value = true\n      }\n    }\n  }\n  return value\n}\n\nexport function normalizePropsOptions(\n  comp: ConcreteComponent,\n  appContext: AppContext,\n  asMixin = false\n): NormalizedPropsOptions {\n  const cache = appContext.propsCache\n  const cached = cache.get(comp)\n  if (cached) {\n    return cached\n  }\n\n  const raw = comp.props\n  const normalized: NormalizedPropsOptions[0] = {}\n  const needCastKeys: NormalizedPropsOptions[1] = []\n\n  // apply mixin/extends props\n  let hasExtends = false\n  if (__FEATURE_OPTIONS_API__ && !isFunction(comp)) {\n    const extendProps = (raw: ComponentOptions) => {\n      if (__COMPAT__ && isFunction(raw)) {\n        raw = raw.options\n      }\n      hasExtends = true\n      const [props, keys] = normalizePropsOptions(raw, appContext, true)\n      extend(normalized, props)\n      if (keys) needCastKeys.push(...keys)\n    }\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps)\n    }\n    if (comp.extends) {\n      extendProps(comp.extends)\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps)\n    }\n  }\n\n  if (!raw && !hasExtends) {\n    cache.set(comp, EMPTY_ARR as any)\n    return EMPTY_ARR as any\n  }\n\n  if (isArray(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      if (__DEV__ && !isString(raw[i])) {\n        warn(`props must be strings when using array syntax.`, raw[i])\n      }\n      const normalizedKey = camelize(raw[i])\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = EMPTY_OBJ\n      }\n    }\n  } else if (raw) {\n    if (__DEV__ && !isObject(raw)) {\n      warn(`invalid props options`, raw)\n    }\n    for (const key in raw) {\n      const normalizedKey = camelize(key)\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key]\n        const prop: NormalizedProp = (normalized[normalizedKey] =\n          isArray(opt) || isFunction(opt) ? { type: opt } : opt)\n        if (prop) {\n          const booleanIndex = getTypeIndex(Boolean, prop.type)\n          const stringIndex = getTypeIndex(String, prop.type)\n          prop[BooleanFlags.shouldCast] = booleanIndex > -1\n          prop[BooleanFlags.shouldCastTrue] =\n            stringIndex < 0 || booleanIndex < stringIndex\n          // if the prop needs boolean casting or default value\n          if (booleanIndex > -1 || hasOwn(prop, 'default')) {\n            needCastKeys.push(normalizedKey)\n          }\n        }\n      }\n    }\n  }\n\n  const res: NormalizedPropsOptions = [normalized, needCastKeys]\n  cache.set(comp, res)\n  return res\n}\n\nfunction validatePropName(key: string) {\n  if (key[0] !== '$') {\n    return true\n  } else if (__DEV__) {\n    warn(`Invalid prop name: \"${key}\" is a reserved property.`)\n  }\n  return false\n}\n\n// use function string name to check type constructors\n// so that it works across vms / iframes.\nfunction getType(ctor: Prop<any>): string {\n  const match = ctor && ctor.toString().match(/^\\s*function (\\w+)/)\n  return match ? match[1] : ctor === null ? 'null' : ''\n}\n\nfunction isSameType(a: Prop<any>, b: Prop<any>): boolean {\n  return getType(a) === getType(b)\n}\n\nfunction getTypeIndex(\n  type: Prop<any>,\n  expectedTypes: PropType<any> | void | null | true\n): number {\n  if (isArray(expectedTypes)) {\n    return expectedTypes.findIndex(t => isSameType(t, type))\n  } else if (isFunction(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1\n  }\n  return -1\n}\n\n/**\n * dev only\n */\nfunction validateProps(\n  rawProps: Data,\n  props: Data,\n  instance: ComponentInternalInstance\n) {\n  const resolvedValues = toRaw(props)\n  const options = instance.propsOptions[0]\n  for (const key in options) {\n    let opt = options[key]\n    if (opt == null) continue\n    validateProp(\n      key,\n      resolvedValues[key],\n      opt,\n      !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key))\n    )\n  }\n}\n\n/**\n * dev only\n */\nfunction validateProp(\n  name: string,\n  value: unknown,\n  prop: PropOptions,\n  isAbsent: boolean\n) {\n  const { type, required, validator } = prop\n  // required!\n  if (required && isAbsent) {\n    warn('Missing required prop: \"' + name + '\"')\n    return\n  }\n  // missing but optional\n  if (value == null && !prop.required) {\n    return\n  }\n  // type check\n  if (type != null && type !== true) {\n    let isValid = false\n    const types = isArray(type) ? type : [type]\n    const expectedTypes = []\n    // value is valid as long as one of the specified types match\n    for (let i = 0; i < types.length && !isValid; i++) {\n      const { valid, expectedType } = assertType(value, types[i])\n      expectedTypes.push(expectedType || '')\n      isValid = valid\n    }\n    if (!isValid) {\n      warn(getInvalidTypeMessage(name, value, expectedTypes))\n      return\n    }\n  }\n  // custom validator\n  if (validator && !validator(value)) {\n    warn('Invalid prop: custom validator check failed for prop \"' + name + '\".')\n  }\n}\n\nconst isSimpleType = /*#__PURE__*/ makeMap(\n  'String,Number,Boolean,Function,Symbol,BigInt'\n)\n\ntype AssertionResult = {\n  valid: boolean\n  expectedType: string\n}\n\n/**\n * dev only\n */\nfunction assertType(value: unknown, type: PropConstructor): AssertionResult {\n  let valid\n  const expectedType = getType(type)\n  if (isSimpleType(expectedType)) {\n    const t = typeof value\n    valid = t === expectedType.toLowerCase()\n    // for primitive wrapper objects\n    if (!valid && t === 'object') {\n      valid = value instanceof type\n    }\n  } else if (expectedType === 'Object') {\n    valid = isObject(value)\n  } else if (expectedType === 'Array') {\n    valid = isArray(value)\n  } else if (expectedType === 'null') {\n    valid = value === null\n  } else {\n    valid = value instanceof type\n  }\n  return {\n    valid,\n    expectedType\n  }\n}\n\n/**\n * dev only\n */\nfunction getInvalidTypeMessage(\n  name: string,\n  value: unknown,\n  expectedTypes: string[]\n): string {\n  let message =\n    `Invalid prop: type check failed for prop \"${name}\".` +\n    ` Expected ${expectedTypes.map(capitalize).join(' | ')}`\n  const expectedType = expectedTypes[0]\n  const receivedType = toRawType(value)\n  const expectedValue = styleValue(value, expectedType)\n  const receivedValue = styleValue(value, receivedType)\n  // check if we need to specify expected value\n  if (\n    expectedTypes.length === 1 &&\n    isExplicable(expectedType) &&\n    !isBoolean(expectedType, receivedType)\n  ) {\n    message += ` with value ${expectedValue}`\n  }\n  message += `, got ${receivedType} `\n  // check if we need to specify received value\n  if (isExplicable(receivedType)) {\n    message += `with value ${receivedValue}.`\n  }\n  return message\n}\n\n/**\n * dev only\n */\nfunction styleValue(value: unknown, type: string): string {\n  if (type === 'String') {\n    return `\"${value}\"`\n  } else if (type === 'Number') {\n    return `${Number(value)}`\n  } else {\n    return `${value}`\n  }\n}\n\n/**\n * dev only\n */\nfunction isExplicable(type: string): boolean {\n  const explicitTypes = ['string', 'number', 'boolean']\n  return explicitTypes.some(elem => type.toLowerCase() === elem)\n}\n\n/**\n * dev only\n */\nfunction isBoolean(...args: string[]): boolean {\n  return args.some(elem => elem.toLowerCase() === 'boolean')\n}\n", "import { ComponentInternalInstance, currentInstance } from './component'\nimport {\n  VNode,\n  VNodeNormalizedChildren,\n  normalizeVNode,\n  VNodeChild,\n  InternalObjectKey\n} from './vnode'\nimport {\n  isArray,\n  isFunction,\n  EMPTY_OBJ,\n  ShapeFlags,\n  extend,\n  def,\n  SlotFlags\n} from '@vue/shared'\nimport { warn } from './warning'\nimport { isKeepAlive } from './components/KeepAlive'\nimport { ContextualRenderFn, withCtx } from './componentRenderContext'\nimport { isHmrUpdating } from './hmr'\nimport { DeprecationTypes, isCompatEnabled } from './compat/compatConfig'\nimport { toRaw } from '@vue/reactivity'\n\nexport type Slot = (...args: any[]) => VNode[]\n\nexport type InternalSlots = {\n  [name: string]: Slot | undefined\n}\n\nexport type Slots = Readonly<InternalSlots>\n\nexport type RawSlots = {\n  [name: string]: unknown\n  // manual render fn hint to skip forced children updates\n  $stable?: boolean\n  /**\n   * for tracking slot owner instance. This is attached during\n   * normalizeChildren when the component vnode is created.\n   * @internal\n   */\n  _ctx?: ComponentInternalInstance | null\n  /**\n   * indicates compiler generated slots\n   * we use a reserved property instead of a vnode patchFlag because the slots\n   * object may be directly passed down to a child component in a manual\n   * render function, and the optimization hint need to be on the slot object\n   * itself to be preserved.\n   * @internal\n   */\n  _?: SlotFlags\n}\n\nconst isInternalKey = (key: string) => key[0] === '_' || key === '$stable'\n\nconst normalizeSlotValue = (value: unknown): VNode[] =>\n  isArray(value)\n    ? value.map(normalizeVNode)\n    : [normalizeVNode(value as VNodeChild)]\n\nconst normalizeSlot = (\n  key: string,\n  rawSlot: Function,\n  ctx: ComponentInternalInstance | null | undefined\n): Slot => {\n  const normalized = withCtx((...args: any[]) => {\n    if (__DEV__ && currentInstance) {\n      warn(\n        `Slot \"${key}\" invoked outside of the render function: ` +\n          `this will not track dependencies used in the slot. ` +\n          `Invoke the slot function inside the render function instead.`\n      )\n    }\n    return normalizeSlotValue(rawSlot(...args))\n  }, ctx) as Slot\n  // NOT a compiled slot\n  ;(normalized as ContextualRenderFn)._c = false\n  return normalized\n}\n\nconst normalizeObjectSlots = (\n  rawSlots: RawSlots,\n  slots: InternalSlots,\n  instance: ComponentInternalInstance\n) => {\n  const ctx = rawSlots._ctx\n  for (const key in rawSlots) {\n    if (isInternalKey(key)) continue\n    const value = rawSlots[key]\n    if (isFunction(value)) {\n      slots[key] = normalizeSlot(key, value, ctx)\n    } else if (value != null) {\n      if (\n        __DEV__ &&\n        !(\n          __COMPAT__ &&\n          isCompatEnabled(DeprecationTypes.RENDER_FUNCTION, instance)\n        )\n      ) {\n        warn(\n          `Non-function value encountered for slot \"${key}\". ` +\n            `Prefer function slots for better performance.`\n        )\n      }\n      const normalized = normalizeSlotValue(value)\n      slots[key] = () => normalized\n    }\n  }\n}\n\nconst normalizeVNodeSlots = (\n  instance: ComponentInternalInstance,\n  children: VNodeNormalizedChildren\n) => {\n  if (\n    __DEV__ &&\n    !isKeepAlive(instance.vnode) &&\n    !(__COMPAT__ && isCompatEnabled(DeprecationTypes.RENDER_FUNCTION, instance))\n  ) {\n    warn(\n      `Non-function value encountered for default slot. ` +\n        `Prefer function slots for better performance.`\n    )\n  }\n  const normalized = normalizeSlotValue(children)\n  instance.slots.default = () => normalized\n}\n\nexport const initSlots = (\n  instance: ComponentInternalInstance,\n  children: VNodeNormalizedChildren\n) => {\n  if (instance.vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\n    const type = (children as RawSlots)._\n    if (type) {\n      // users can get the shallow readonly version of the slots object through `this.$slots`,\n      // we should avoid the proxy object polluting the slots of the internal instance\n      instance.slots = toRaw(children as InternalSlots)\n      // make compiler marker non-enumerable\n      def(children as InternalSlots, '_', type)\n    } else {\n      normalizeObjectSlots(\n        children as RawSlots,\n        (instance.slots = {}),\n        instance\n      )\n    }\n  } else {\n    instance.slots = {}\n    if (children) {\n      normalizeVNodeSlots(instance, children)\n    }\n  }\n  def(instance.slots, InternalObjectKey, 1)\n}\n\nexport const updateSlots = (\n  instance: ComponentInternalInstance,\n  children: VNodeNormalizedChildren,\n  optimized: boolean\n) => {\n  const { vnode, slots } = instance\n  let needDeletionCheck = true\n  let deletionComparisonTarget = EMPTY_OBJ\n  if (vnode.shapeFlag & ShapeFlags.SLOTS_CHILDREN) {\n    const type = (children as RawSlots)._\n    if (type) {\n      // compiled slots.\n      if (__DEV__ && isHmrUpdating) {\n        // Parent was HMR updated so slot content may have changed.\n        // force update slots and mark instance for hmr as well\n        extend(slots, children as Slots)\n      } else if (optimized && type === SlotFlags.STABLE) {\n        // compiled AND stable.\n        // no need to update, and skip stale slots removal.\n        needDeletionCheck = false\n      } else {\n        // compiled but dynamic (v-if/v-for on slots) - update slots, but skip\n        // normalization.\n        extend(slots, children as Slots)\n        // #2893\n        // when rendering the optimized slots by manually written render function,\n        // we need to delete the `slots._` flag if necessary to make subsequent updates reliable,\n        // i.e. let the `renderSlot` create the bailed Fragment\n        if (!optimized && type === SlotFlags.STABLE) {\n          delete slots._\n        }\n      }\n    } else {\n      needDeletionCheck = !(children as RawSlots).$stable\n      normalizeObjectSlots(children as RawSlots, slots, instance)\n    }\n    deletionComparisonTarget = children as RawSlots\n  } else if (children) {\n    // non slot object children (direct value) passed to a component\n    normalizeVNodeSlots(instance, children)\n    deletionComparisonTarget = { default: 1 }\n  }\n\n  // delete stale slots\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {\n        delete slots[key]\n      }\n    }\n  }\n}\n", "/**\nRuntime helper for applying directives to a vnode. Example usage:\n\nconst comp = resolveComponent('comp')\nconst foo = resolveDirective('foo')\nconst bar = resolveDirective('bar')\n\nreturn withDirectives(h(comp), [\n  [foo, this.x],\n  [bar, this.y]\n])\n*/\n\nimport { VNode } from './vnode'\nimport { isFunction, EMPTY_OBJ, isBuiltInDirective } from '@vue/shared'\nimport { warn } from './warning'\nimport { ComponentInternalInstance, Data } from './component'\nimport { currentRenderingInstance } from './componentRenderContext'\nimport { callWithAsyncErrorHandling, ErrorCodes } from './errorHandling'\nimport { ComponentPublicInstance } from './componentPublicInstance'\nimport { mapCompatDirectiveHook } from './compat/customDirective'\nimport { pauseTracking, resetTracking } from '@vue/reactivity'\nimport { traverse } from './apiWatch'\n\nexport interface DirectiveBinding<V = any> {\n  instance: ComponentPublicInstance | null\n  value: V\n  oldValue: V | null\n  arg?: string\n  modifiers: DirectiveModifiers\n  dir: ObjectDirective<any, V>\n}\n\nexport type DirectiveHook<T = any, Prev = VNode<any, T> | null, V = any> = (\n  el: T,\n  binding: DirectiveBinding<V>,\n  vnode: VNode<any, T>,\n  prevVNode: Prev\n) => void\n\nexport type SSRDirectiveHook = (\n  binding: DirectiveBinding,\n  vnode: VNode\n) => Data | undefined\n\nexport interface ObjectDirective<T = any, V = any> {\n  created?: DirectiveHook<T, null, V>\n  beforeMount?: DirectiveHook<T, null, V>\n  mounted?: DirectiveHook<T, null, V>\n  beforeUpdate?: DirectiveHook<T, VNode<any, T>, V>\n  updated?: DirectiveHook<T, VNode<any, T>, V>\n  beforeUnmount?: DirectiveHook<T, null, V>\n  unmounted?: DirectiveHook<T, null, V>\n  getSSRProps?: SSRDirectiveHook\n  deep?: boolean\n}\n\nexport type FunctionDirective<T = any, V = any> = DirectiveHook<T, any, V>\n\nexport type Directive<T = any, V = any> =\n  | ObjectDirective<T, V>\n  | FunctionDirective<T, V>\n\nexport type DirectiveModifiers = Record<string, boolean>\n\nexport function validateDirectiveName(name: string) {\n  if (isBuiltInDirective(name)) {\n    warn('Do not use built-in directive ids as custom directive id: ' + name)\n  }\n}\n\n// Directive, value, argument, modifiers\nexport type DirectiveArguments = Array<\n  | [Directive]\n  | [Directive, any]\n  | [Directive, any, string]\n  | [Directive, any, string, DirectiveModifiers]\n>\n\n/**\n * Adds directives to a VNode.\n */\nexport function withDirectives<T extends VNode>(\n  vnode: T,\n  directives: DirectiveArguments\n): T {\n  const internalInstance = currentRenderingInstance\n  if (internalInstance === null) {\n    __DEV__ && warn(`withDirectives can only be used inside render functions.`)\n    return vnode\n  }\n  const instance = internalInstance.proxy\n  const bindings: DirectiveBinding[] = vnode.dirs || (vnode.dirs = [])\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]\n    if (isFunction(dir)) {\n      dir = {\n        mounted: dir,\n        updated: dir\n      } as ObjectDirective\n    }\n    if (dir.deep) {\n      traverse(value)\n    }\n    bindings.push({\n      dir,\n      instance,\n      value,\n      oldValue: void 0,\n      arg,\n      modifiers\n    })\n  }\n  return vnode\n}\n\nexport function invokeDirectiveHook(\n  vnode: VNode,\n  prevVNode: VNode | null,\n  instance: ComponentInternalInstance | null,\n  name: keyof ObjectDirective\n) {\n  const bindings = vnode.dirs!\n  const oldBindings = prevVNode && prevVNode.dirs!\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i]\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value\n    }\n    let hook = binding.dir[name] as DirectiveHook | DirectiveHook[] | undefined\n    if (__COMPAT__ && !hook) {\n      hook = mapCompatDirectiveHook(name, binding.dir, instance)\n    }\n    if (hook) {\n      // disable tracking inside all lifecycle hooks\n      // since they can potentially be called inside effects.\n      pauseTracking()\n      callWithAsyncErrorHandling(hook, instance, ErrorCodes.DIRECTIVE_HOOK, [\n        vnode.el,\n        binding,\n        vnode,\n        prevVNode\n      ])\n      resetTracking()\n    }\n  }\n}\n", "import {\n  ConcreteComponent,\n  Data,\n  validateComponentName,\n  Component,\n  ComponentInternalInstance,\n  getExposeProxy\n} from './component'\nimport {\n  ComponentOptions,\n  MergedComponentOptions,\n  RuntimeCompilerOptions\n} from './componentOptions'\nimport { ComponentPublicInstance } from './componentPublicInstance'\nimport { Directive, validateDirectiveName } from './directives'\nimport { RootRenderFunction } from './renderer'\nimport { InjectionKey } from './apiInject'\nimport { warn } from './warning'\nimport { createVNode, cloneVNode, VNode } from './vnode'\nimport { RootHydrateFunction } from './hydration'\nimport { devtoolsInitApp, devtoolsUnmountApp } from './devtools'\nimport { isFunction, NO, isObject } from '@vue/shared'\nimport { version } from '.'\nimport { installAppCompatProperties } from './compat/global'\nimport { NormalizedPropsOptions } from './componentProps'\nimport { ObjectEmitsOptions } from './componentEmits'\n\nexport interface App<HostElement = any> {\n  version: string\n  config: AppConfig\n  use(plugin: Plugin, ...options: any[]): this\n  mixin(mixin: ComponentOptions): this\n  component(name: string): Component | undefined\n  component(name: string, component: Component): this\n  directive(name: string): Directive | undefined\n  directive(name: string, directive: Directive): this\n  mount(\n    rootContainer: HostElement | string,\n    isHydrate?: boolean,\n    isSVG?: boolean\n  ): ComponentPublicInstance\n  unmount(): void\n  provide<T>(key: InjectionKey<T> | string, value: T): this\n\n  // internal, but we need to expose these for the server-renderer and devtools\n  _uid: number\n  _component: ConcreteComponent\n  _props: Data | null\n  _container: HostElement | null\n  _context: AppContext\n  _instance: ComponentInternalInstance | null\n\n  /**\n   * v2 compat only\n   */\n  filter?(name: string): Function | undefined\n  filter?(name: string, filter: Function): this\n\n  /**\n   * @internal v3 compat only\n   */\n  _createRoot?(options: ComponentOptions): ComponentPublicInstance\n}\n\nexport type OptionMergeFunction = (to: unknown, from: unknown) => any\n\nexport interface AppConfig {\n  // @private\n  readonly isNativeTag?: (tag: string) => boolean\n\n  performance: boolean\n  optionMergeStrategies: Record<string, OptionMergeFunction>\n  globalProperties: Record<string, any>\n  errorHandler?: (\n    err: unknown,\n    instance: ComponentPublicInstance | null,\n    info: string\n  ) => void\n  warnHandler?: (\n    msg: string,\n    instance: ComponentPublicInstance | null,\n    trace: string\n  ) => void\n\n  /**\n   * Options to pass to `@vue/compiler-dom`.\n   * Only supported in runtime compiler build.\n   */\n  compilerOptions: RuntimeCompilerOptions\n\n  /**\n   * @deprecated use config.compilerOptions.isCustomElement\n   */\n  isCustomElement?: (tag: string) => boolean\n\n  /**\n   * Temporary config for opt-in to unwrap injected refs.\n   * TODO deprecate in 3.3\n   */\n  unwrapInjectedRef?: boolean\n}\n\nexport interface AppContext {\n  app: App // for devtools\n  config: AppConfig\n  mixins: ComponentOptions[]\n  components: Record<string, Component>\n  directives: Record<string, Directive>\n  provides: Record<string | symbol, any>\n\n  /**\n   * Cache for merged/normalized component options\n   * Each app instance has its own cache because app-level global mixins and\n   * optionMergeStrategies can affect merge behavior.\n   * @internal\n   */\n  optionsCache: WeakMap<ComponentOptions, MergedComponentOptions>\n  /**\n   * Cache for normalized props options\n   * @internal\n   */\n  propsCache: WeakMap<ConcreteComponent, NormalizedPropsOptions>\n  /**\n   * Cache for normalized emits options\n   * @internal\n   */\n  emitsCache: WeakMap<ConcreteComponent, ObjectEmitsOptions | null>\n  /**\n   * HMR only\n   * @internal\n   */\n  reload?: () => void\n  /**\n   * v2 compat only\n   * @internal\n   */\n  filters?: Record<string, Function>\n}\n\ntype PluginInstallFunction = (app: App, ...options: any[]) => any\n\nexport type Plugin =\n  | (PluginInstallFunction & { install?: PluginInstallFunction })\n  | {\n      install: PluginInstallFunction\n    }\n\nexport function createAppContext(): AppContext {\n  return {\n    app: null as any,\n    config: {\n      isNativeTag: NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: undefined,\n      warnHandler: undefined,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: Object.create(null),\n    optionsCache: new WeakMap(),\n    propsCache: new WeakMap(),\n    emitsCache: new WeakMap()\n  }\n}\n\nexport type CreateAppFunction<HostElement> = (\n  rootComponent: Component,\n  rootProps?: Data | null\n) => App<HostElement>\n\nlet uid = 0\n\nexport function createAppAPI<HostElement>(\n  render: RootRenderFunction,\n  hydrate?: RootHydrateFunction\n): CreateAppFunction<HostElement> {\n  return function createApp(rootComponent, rootProps = null) {\n    if (rootProps != null && !isObject(rootProps)) {\n      __DEV__ && warn(`root props passed to app.mount() must be an object.`)\n      rootProps = null\n    }\n\n    const context = createAppContext()\n    const installedPlugins = new Set()\n\n    let isMounted = false\n\n    const app: App = (context.app = {\n      _uid: uid++,\n      _component: rootComponent as ConcreteComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n\n      version,\n\n      get config() {\n        return context.config\n      },\n\n      set config(v) {\n        if (__DEV__) {\n          warn(\n            `app.config cannot be replaced. Modify individual options instead.`\n          )\n        }\n      },\n\n      use(plugin: Plugin, ...options: any[]) {\n        if (installedPlugins.has(plugin)) {\n          __DEV__ && warn(`Plugin has already been applied to target app.`)\n        } else if (plugin && isFunction(plugin.install)) {\n          installedPlugins.add(plugin)\n          plugin.install(app, ...options)\n        } else if (isFunction(plugin)) {\n          installedPlugins.add(plugin)\n          plugin(app, ...options)\n        } else if (__DEV__) {\n          warn(\n            `A plugin must either be a function or an object with an \"install\" ` +\n              `function.`\n          )\n        }\n        return app\n      },\n\n      mixin(mixin: ComponentOptions) {\n        if (__FEATURE_OPTIONS_API__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin)\n          } else if (__DEV__) {\n            warn(\n              'Mixin has already been applied to target app' +\n                (mixin.name ? `: ${mixin.name}` : '')\n            )\n          }\n        } else if (__DEV__) {\n          warn('Mixins are only available in builds supporting Options API')\n        }\n        return app\n      },\n\n      component(name: string, component?: Component): any {\n        if (__DEV__) {\n          validateComponentName(name, context.config)\n        }\n        if (!component) {\n          return context.components[name]\n        }\n        if (__DEV__ && context.components[name]) {\n          warn(`Component \"${name}\" has already been registered in target app.`)\n        }\n        context.components[name] = component\n        return app\n      },\n\n      directive(name: string, directive?: Directive) {\n        if (__DEV__) {\n          validateDirectiveName(name)\n        }\n\n        if (!directive) {\n          return context.directives[name] as any\n        }\n        if (__DEV__ && context.directives[name]) {\n          warn(`Directive \"${name}\" has already been registered in target app.`)\n        }\n        context.directives[name] = directive\n        return app\n      },\n\n      mount(\n        rootContainer: HostElement,\n        isHydrate?: boolean,\n        isSVG?: boolean\n      ): any {\n        if (!isMounted) {\n          const vnode = createVNode(\n            rootComponent as ConcreteComponent,\n            rootProps\n          )\n          // store app context on the root VNode.\n          // this will be set on the root instance on initial mount.\n          vnode.appContext = context\n\n          // HMR root reload\n          if (__DEV__) {\n            context.reload = () => {\n              render(cloneVNode(vnode), rootContainer, isSVG)\n            }\n          }\n\n          if (isHydrate && hydrate) {\n            hydrate(vnode as VNode<Node, Element>, rootContainer as any)\n          } else {\n            render(vnode, rootContainer, isSVG)\n          }\n          isMounted = true\n          app._container = rootContainer\n          // for devtools and telemetry\n          ;(rootContainer as any).__vue_app__ = app\n\n          if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n            app._instance = vnode.component\n            devtoolsInitApp(app, version)\n          }\n\n          return getExposeProxy(vnode.component!) || vnode.component!.proxy\n        } else if (__DEV__) {\n          warn(\n            `App has already been mounted.\\n` +\n              `If you want to remount the same app, move your app creation logic ` +\n              `into a factory function and create fresh app instances for each ` +\n              `mount - e.g. \\`const createMyApp = () => createApp(App)\\``\n          )\n        }\n      },\n\n      unmount() {\n        if (isMounted) {\n          render(null, app._container)\n          if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n            app._instance = null\n            devtoolsUnmountApp(app)\n          }\n          delete app._container.__vue_app__\n        } else if (__DEV__) {\n          warn(`Cannot unmount an app that is not mounted.`)\n        }\n      },\n\n      provide(key, value) {\n        if (__DEV__ && (key as string | symbol) in context.provides) {\n          warn(\n            `App already provides property with key \"${String(key)}\". ` +\n              `It will be overwritten with the new value.`\n          )\n        }\n        // TypeScript doesn't allow symbols as index type\n        // https://github.com/Microsoft/TypeScript/issues/24587\n        context.provides[key as string] = value\n\n        return app\n      }\n    })\n\n    if (__COMPAT__) {\n      installAppCompatProperties(app, context, render)\n    }\n\n    return app\n  }\n}\n", "import { SuspenseBoundary } from './components/Suspense'\nimport { VNode, VNodeNormalizedRef, VNodeNormalizedRefAtom } from './vnode'\nimport {\n  EMPTY_OBJ,\n  hasOwn,\n  isArray,\n  isFunction,\n  isString,\n  remove,\n  ShapeFlags\n} from '@vue/shared'\nimport { isAsyncWrapper } from './apiAsyncComponent'\nimport { getExposeProxy } from './component'\nimport { warn } from './warning'\nimport { isRef } from '@vue/reactivity'\nimport { callWithErrorHandling, ErrorCodes } from './errorHandling'\nimport { SchedulerJob } from './scheduler'\nimport { queuePostRenderEffect } from './renderer'\n\n/**\n * Function for handling a template ref\n */\nexport function setRef(\n  rawRef: VNodeNormalizedRef,\n  oldRawRef: VNodeNormalizedRef | null,\n  parentSuspense: SuspenseBoundary | null,\n  vnode: VNode,\n  isUnmount = false\n) {\n  if (isArray(rawRef)) {\n    rawRef.forEach((r, i) =>\n      setRef(\n        r,\n        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),\n        parentSuspense,\n        vnode,\n        isUnmount\n      )\n    )\n    return\n  }\n\n  if (isAsyncWrapper(vnode) && !isUnmount) {\n    // when mounting async components, nothing needs to be done,\n    // because the template ref is forwarded to inner component\n    return\n  }\n\n  const refValue =\n    vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\n      ? getExposeProxy(vnode.component!) || vnode.component!.proxy\n      : vnode.el\n  const value = isUnmount ? null : refValue\n\n  const { i: owner, r: ref } = rawRef\n  if (__DEV__ && !owner) {\n    warn(\n      `Missing ref owner context. ref cannot be used on hoisted vnodes. ` +\n        `A vnode with ref must be created inside the render function.`\n    )\n    return\n  }\n  const oldRef = oldRawRef && (oldRawRef as VNodeNormalizedRefAtom).r\n  const refs = owner.refs === EMPTY_OBJ ? (owner.refs = {}) : owner.refs\n  const setupState = owner.setupState\n\n  // dynamic ref changed. unset old ref\n  if (oldRef != null && oldRef !== ref) {\n    if (isString(oldRef)) {\n      refs[oldRef] = null\n      if (hasOwn(setupState, oldRef)) {\n        setupState[oldRef] = null\n      }\n    } else if (isRef(oldRef)) {\n      oldRef.value = null\n    }\n  }\n\n  if (isFunction(ref)) {\n    callWithErrorHandling(ref, owner, ErrorCodes.FUNCTION_REF, [value, refs])\n  } else {\n    const _isString = isString(ref)\n    const _isRef = isRef(ref)\n    if (_isString || _isRef) {\n      const doSet = () => {\n        if (rawRef.f) {\n          const existing = _isString ? refs[ref] : ref.value\n          if (isUnmount) {\n            isArray(existing) && remove(existing, refValue)\n          } else {\n            if (!isArray(existing)) {\n              if (_isString) {\n                refs[ref] = [refValue]\n              } else {\n                ref.value = [refValue]\n                if (rawRef.k) refs[rawRef.k] = ref.value\n              }\n            } else if (!existing.includes(refValue)) {\n              existing.push(refValue)\n            }\n          }\n        } else if (_isString) {\n          refs[ref] = value\n          if (hasOwn(setupState, ref)) {\n            setupState[ref] = value\n          }\n        } else if (isRef(ref)) {\n          ref.value = value\n          if (rawRef.k) refs[rawRef.k] = value\n        } else if (__DEV__) {\n          warn('Invalid template ref type:', ref, `(${typeof ref})`)\n        }\n      }\n      if (value) {\n        // #1789: for non-null values, set them after render\n        // null values means this is unmount and it should not overwrite another\n        // ref with the same key\n        ;(doSet as SchedulerJob).id = -1\n        queuePostRenderEffect(doSet, parentSuspense)\n      } else {\n        doSet()\n      }\n    } else if (__DEV__) {\n      warn('Invalid template ref type:', ref, `(${typeof ref})`)\n    }\n  }\n}\n", "import {\n  VNode,\n  normalizeVNode,\n  Text,\n  Comment,\n  Static,\n  Fragment,\n  VNodeHook,\n  createVNode,\n  createTextVNode,\n  invokeVNodeHook\n} from './vnode'\nimport { flushPostFlushCbs } from './scheduler'\nimport { ComponentInternalInstance } from './component'\nimport { invokeDirectiveHook } from './directives'\nimport { warn } from './warning'\nimport { PatchFlags, ShapeFlags, isReservedProp, isOn } from '@vue/shared'\nimport { RendererInternals } from './renderer'\nimport { setRef } from './rendererTemplateRef'\nimport {\n  SuspenseImpl,\n  SuspenseBoundary,\n  queueEffectWithSuspense\n} from './components/Suspense'\nimport { TeleportImpl, TeleportVNode } from './components/Teleport'\nimport { isAsyncWrapper } from './apiAsyncComponent'\n\nexport type RootHydrateFunction = (\n  vnode: VNode<Node, Element>,\n  container: Element | ShadowRoot\n) => void\n\nconst enum DOMNodeTypes {\n  ELEMENT = 1,\n  TEXT = 3,\n  COMMENT = 8\n}\n\nlet hasMismatch = false\n\nconst isSVGContainer = (container: Element) =>\n  /svg/.test(container.namespaceURI!) && container.tagName !== 'foreignObject'\n\nconst isComment = (node: Node): node is Comment =>\n  node.nodeType === DOMNodeTypes.COMMENT\n\n// Note: hydration is DOM-specific\n// But we have to place it in core due to tight coupling with core - splitting\n// it out creates a ton of unnecessary complexity.\n// Hydration also depends on some renderer internal logic which needs to be\n// passed in via arguments.\nexport function createHydrationFunctions(\n  rendererInternals: RendererInternals<Node, Element>\n) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: { patchProp, nextSibling, parentNode, remove, insert, createComment }\n  } = rendererInternals\n\n  const hydrate: RootHydrateFunction = (vnode, container) => {\n    if (!container.hasChildNodes()) {\n      __DEV__ &&\n        warn(\n          `Attempting to hydrate existing markup but container is empty. ` +\n            `Performing full mount instead.`\n        )\n      patch(null, vnode, container)\n      flushPostFlushCbs()\n      return\n    }\n    hasMismatch = false\n    hydrateNode(container.firstChild!, vnode, null, null, null)\n    flushPostFlushCbs()\n    if (hasMismatch && !__TEST__) {\n      // this error should show up in production\n      console.error(`Hydration completed but contains mismatches.`)\n    }\n  }\n\n  const hydrateNode = (\n    node: Node,\n    vnode: VNode,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    slotScopeIds: string[] | null,\n    optimized = false\n  ): Node | null => {\n    const isFragmentStart = isComment(node) && node.data === '['\n    const onMismatch = () =>\n      handleMismatch(\n        node,\n        vnode,\n        parentComponent,\n        parentSuspense,\n        slotScopeIds,\n        isFragmentStart\n      )\n\n    const { type, ref, shapeFlag } = vnode\n    const domType = node.nodeType\n    vnode.el = node\n\n    let nextNode: Node | null = null\n    switch (type) {\n      case Text:\n        if (domType !== DOMNodeTypes.TEXT) {\n          nextNode = onMismatch()\n        } else {\n          if ((node as Text).data !== vnode.children) {\n            hasMismatch = true\n            __DEV__ &&\n              warn(\n                `Hydration text mismatch:` +\n                  `\\n- Client: ${JSON.stringify((node as Text).data)}` +\n                  `\\n- Server: ${JSON.stringify(vnode.children)}`\n              )\n            ;(node as Text).data = vnode.children as string\n          }\n          nextNode = nextSibling(node)\n        }\n        break\n      case Comment:\n        if (domType !== DOMNodeTypes.COMMENT || isFragmentStart) {\n          nextNode = onMismatch()\n        } else {\n          nextNode = nextSibling(node)\n        }\n        break\n      case Static:\n        if (domType !== DOMNodeTypes.ELEMENT) {\n          nextNode = onMismatch()\n        } else {\n          // determine anchor, adopt content\n          nextNode = node\n          // if the static vnode has its content stripped during build,\n          // adopt it from the server-rendered HTML.\n          const needToAdoptContent = !(vnode.children as string).length\n          for (let i = 0; i < vnode.staticCount!; i++) {\n            if (needToAdoptContent)\n              vnode.children += (nextNode as Element).outerHTML\n            if (i === vnode.staticCount! - 1) {\n              vnode.anchor = nextNode\n            }\n            nextNode = nextSibling(nextNode)!\n          }\n          return nextNode\n        }\n        break\n      case Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch()\n        } else {\n          nextNode = hydrateFragment(\n            node as Comment,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            slotScopeIds,\n            optimized\n          )\n        }\n        break\n      default:\n        if (shapeFlag & ShapeFlags.ELEMENT) {\n          if (\n            domType !== DOMNodeTypes.ELEMENT ||\n            (vnode.type as string).toLowerCase() !==\n              (node as Element).tagName.toLowerCase()\n          ) {\n            nextNode = onMismatch()\n          } else {\n            nextNode = hydrateElement(\n              node as Element,\n              vnode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized\n            )\n          }\n        } else if (shapeFlag & ShapeFlags.COMPONENT) {\n          // when setting up the render effect, if the initial vnode already\n          // has .el set, the component will perform hydration instead of mount\n          // on its sub-tree.\n          vnode.slotScopeIds = slotScopeIds\n          const container = parentNode(node)!\n          mountComponent(\n            vnode,\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            isSVGContainer(container),\n            optimized\n          )\n\n          // component may be async, so in the case of fragments we cannot rely\n          // on component's rendered output to determine the end of the fragment\n          // instead, we do a lookahead to find the end anchor node.\n          nextNode = isFragmentStart\n            ? locateClosingAsyncAnchor(node)\n            : nextSibling(node)\n\n          // #3787\n          // if component is async, it may get moved / unmounted before its\n          // inner component is loaded, so we need to give it a placeholder\n          // vnode that matches its adopted DOM.\n          if (isAsyncWrapper(vnode)) {\n            let subTree\n            if (isFragmentStart) {\n              subTree = createVNode(Fragment)\n              subTree.anchor = nextNode\n                ? nextNode.previousSibling\n                : container.lastChild\n            } else {\n              subTree =\n                node.nodeType === 3 ? createTextVNode('') : createVNode('div')\n            }\n            subTree.el = node\n            vnode.component!.subTree = subTree\n          }\n        } else if (shapeFlag & ShapeFlags.TELEPORT) {\n          if (domType !== DOMNodeTypes.COMMENT) {\n            nextNode = onMismatch()\n          } else {\n            nextNode = (vnode.type as typeof TeleportImpl).hydrate(\n              node,\n              vnode as TeleportVNode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized,\n              rendererInternals,\n              hydrateChildren\n            )\n          }\n        } else if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\n          nextNode = (vnode.type as typeof SuspenseImpl).hydrate(\n            node,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            isSVGContainer(parentNode(node)!),\n            slotScopeIds,\n            optimized,\n            rendererInternals,\n            hydrateNode\n          )\n        } else if (__DEV__) {\n          warn('Invalid HostVNode type:', type, `(${typeof type})`)\n        }\n    }\n\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode)\n    }\n\n    return nextNode\n  }\n\n  const hydrateElement = (\n    el: Element,\n    vnode: VNode,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => {\n    optimized = optimized || !!vnode.dynamicChildren\n    const { type, props, patchFlag, shapeFlag, dirs } = vnode\n    // #4006 for form elements with non-string v-model value bindings\n    // e.g. <option :value=\"obj\">, <input type=\"checkbox\" :true-value=\"1\">\n    const forcePatchValue = (type === 'input' && dirs) || type === 'option'\n    // skip props & children if this is hoisted static nodes\n    // #5405 in dev, always hydrate children for HMR\n    if (__DEV__ || forcePatchValue || patchFlag !== PatchFlags.HOISTED) {\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'created')\n      }\n      // props\n      if (props) {\n        if (\n          forcePatchValue ||\n          !optimized ||\n          patchFlag & (PatchFlags.FULL_PROPS | PatchFlags.HYDRATE_EVENTS)\n        ) {\n          for (const key in props) {\n            if (\n              (forcePatchValue && key.endsWith('value')) ||\n              (isOn(key) && !isReservedProp(key))\n            ) {\n              patchProp(\n                el,\n                key,\n                null,\n                props[key],\n                false,\n                undefined,\n                parentComponent\n              )\n            }\n          }\n        } else if (props.onClick) {\n          // Fast path for click listeners (which is most often) to avoid\n          // iterating through props.\n          patchProp(\n            el,\n            'onClick',\n            null,\n            props.onClick,\n            false,\n            undefined,\n            parentComponent\n          )\n        }\n      }\n      // vnode / directive hooks\n      let vnodeHooks: VNodeHook | null | undefined\n      if ((vnodeHooks = props && props.onVnodeBeforeMount)) {\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode)\n      }\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount')\n      }\n      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {\n        queueEffectWithSuspense(() => {\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode)\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted')\n        }, parentSuspense)\n      }\n      // children\n      if (\n        shapeFlag & ShapeFlags.ARRAY_CHILDREN &&\n        // skip if element has innerHTML / textContent\n        !(props && (props.innerHTML || props.textContent))\n      ) {\n        let next = hydrateChildren(\n          el.firstChild,\n          vnode,\n          el,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        )\n        let hasWarned = false\n        while (next) {\n          hasMismatch = true\n          if (__DEV__ && !hasWarned) {\n            warn(\n              `Hydration children mismatch in <${vnode.type as string}>: ` +\n                `server rendered element contains more child nodes than client vdom.`\n            )\n            hasWarned = true\n          }\n          // The SSRed DOM contains more nodes than it should. Remove them.\n          const cur = next\n          next = next.nextSibling\n          remove(cur)\n        }\n      } else if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n        if (el.textContent !== vnode.children) {\n          hasMismatch = true\n          __DEV__ &&\n            warn(\n              `Hydration text content mismatch in <${\n                vnode.type as string\n              }>:\\n` +\n                `- Client: ${el.textContent}\\n` +\n                `- Server: ${vnode.children as string}`\n            )\n          el.textContent = vnode.children as string\n        }\n      }\n    }\n    return el.nextSibling\n  }\n\n  const hydrateChildren = (\n    node: Node | null,\n    parentVNode: VNode,\n    container: Element,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ): Node | null => {\n    optimized = optimized || !!parentVNode.dynamicChildren\n    const children = parentVNode.children as VNode[]\n    const l = children.length\n    let hasWarned = false\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized\n        ? children[i]\n        : (children[i] = normalizeVNode(children[i]))\n      if (node) {\n        node = hydrateNode(\n          node,\n          vnode,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        )\n      } else if (vnode.type === Text && !vnode.children) {\n        continue\n      } else {\n        hasMismatch = true\n        if (__DEV__ && !hasWarned) {\n          warn(\n            `Hydration children mismatch in <${container.tagName.toLowerCase()}>: ` +\n              `server rendered element contains fewer child nodes than client vdom.`\n          )\n          hasWarned = true\n        }\n        // the SSRed DOM didn't contain enough nodes. Mount the missing ones.\n        patch(\n          null,\n          vnode,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          isSVGContainer(container),\n          slotScopeIds\n        )\n      }\n    }\n    return node\n  }\n\n  const hydrateFragment = (\n    node: Comment,\n    vnode: VNode,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => {\n    const { slotScopeIds: fragmentSlotScopeIds } = vnode\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds\n        ? slotScopeIds.concat(fragmentSlotScopeIds)\n        : fragmentSlotScopeIds\n    }\n\n    const container = parentNode(node)!\n    const next = hydrateChildren(\n      nextSibling(node)!,\n      vnode,\n      container,\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      optimized\n    )\n    if (next && isComment(next) && next.data === ']') {\n      return nextSibling((vnode.anchor = next))\n    } else {\n      // fragment didn't hydrate successfully, since we didn't get a end anchor\n      // back. This should have led to node/children mismatch warnings.\n      hasMismatch = true\n      // since the anchor is missing, we need to create one and insert it\n      insert((vnode.anchor = createComment(`]`)), container, next)\n      return next\n    }\n  }\n\n  const handleMismatch = (\n    node: Node,\n    vnode: VNode,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    slotScopeIds: string[] | null,\n    isFragment: boolean\n  ): Node | null => {\n    hasMismatch = true\n    __DEV__ &&\n      warn(\n        `Hydration node mismatch:\\n- Client vnode:`,\n        vnode.type,\n        `\\n- Server rendered DOM:`,\n        node,\n        node.nodeType === DOMNodeTypes.TEXT\n          ? `(text)`\n          : isComment(node) && node.data === '['\n          ? `(start of fragment)`\n          : ``\n      )\n    vnode.el = null\n\n    if (isFragment) {\n      // remove excessive fragment nodes\n      const end = locateClosingAsyncAnchor(node)\n      while (true) {\n        const next = nextSibling(node)\n        if (next && next !== end) {\n          remove(next)\n        } else {\n          break\n        }\n      }\n    }\n\n    const next = nextSibling(node)\n    const container = parentNode(node)!\n    remove(node)\n\n    patch(\n      null,\n      vnode,\n      container,\n      next,\n      parentComponent,\n      parentSuspense,\n      isSVGContainer(container),\n      slotScopeIds\n    )\n    return next\n  }\n\n  const locateClosingAsyncAnchor = (node: Node | null): Node | null => {\n    let match = 0\n    while (node) {\n      node = nextSibling(node)\n      if (node && isComment(node)) {\n        if (node.data === '[') match++\n        if (node.data === ']') {\n          if (match === 0) {\n            return nextSibling(node)\n          } else {\n            match--\n          }\n        }\n      }\n    }\n    return node\n  }\n\n  return [hydrate, hydrateNode] as const\n}\n", "/* eslint-disable no-restricted-globals */\nimport { ComponentInternalInstance, formatComponentName } from './component'\nimport { devtoolsPerfEnd, devtoolsPerfStart } from './devtools'\n\nlet supported: boolean\nlet perf: Performance\n\nexport function startMeasure(\n  instance: ComponentInternalInstance,\n  type: string\n) {\n  if (instance.appContext.config.performance && isSupported()) {\n    perf.mark(`vue-${type}-${instance.uid}`)\n  }\n\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n    devtoolsPerfStart(instance, type, supported ? perf.now() : Date.now())\n  }\n}\n\nexport function endMeasure(instance: ComponentInternalInstance, type: string) {\n  if (instance.appContext.config.performance && isSupported()) {\n    const startTag = `vue-${type}-${instance.uid}`\n    const endTag = startTag + `:end`\n    perf.mark(endTag)\n    perf.measure(\n      `<${formatComponentName(instance, instance.type)}> ${type}`,\n      startTag,\n      endTag\n    )\n    perf.clearMarks(startTag)\n    perf.clearMarks(endTag)\n  }\n\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n    devtoolsPerfEnd(instance, type, supported ? perf.now() : Date.now())\n  }\n}\n\nfunction isSupported() {\n  if (supported !== undefined) {\n    return supported\n  }\n  if (typeof window !== 'undefined' && window.performance) {\n    supported = true\n    perf = window.performance\n  } else {\n    supported = false\n  }\n  return supported\n}\n", "import {\n  Text,\n  Fragment,\n  Comment,\n  cloneIfMounted,\n  normalizeVNode,\n  VNode,\n  VNodeArrayChildren,\n  createVNode,\n  isSameVNodeType,\n  Static,\n  VNodeHook,\n  VNodeProps,\n  invokeVNodeHook\n} from './vnode'\nimport {\n  ComponentInternalInstance,\n  ComponentOptions,\n  createComponentInstance,\n  Data,\n  setupComponent\n} from './component'\nimport {\n  filterSingleRoot,\n  renderComponentRoot,\n  shouldUpdateComponent,\n  updateHOCHostEl\n} from './componentRenderUtils'\nimport {\n  EMPTY_OBJ,\n  EMPTY_ARR,\n  isReservedProp,\n  PatchFlags,\n  ShapeFlags,\n  NOOP,\n  invokeArrayFns,\n  isArray,\n  getGlobalThis\n} from '@vue/shared'\nimport {\n  queueJob,\n  queuePostFlushCb,\n  flushPostFlushCbs,\n  invalidateJob,\n  flushPreFlushCbs,\n  SchedulerJob\n} from './scheduler'\nimport { pauseTracking, resetTracking, ReactiveEffect } from '@vue/reactivity'\nimport { updateProps } from './componentProps'\nimport { updateSlots } from './componentSlots'\nimport { pushWarningContext, popWarningContext, warn } from './warning'\nimport { createAppAPI, CreateAppFunction } from './apiCreateApp'\nimport { setRef } from './rendererTemplateRef'\nimport {\n  SuspenseBoundary,\n  queueEffectWithSuspense,\n  SuspenseImpl\n} from './components/Suspense'\nimport { TeleportImpl, TeleportVNode } from './components/Teleport'\nimport { isKeepAlive, KeepAliveContext } from './components/KeepAlive'\nimport { registerHMR, unregisterHMR, isHmrUpdating } from './hmr'\nimport { createHydrationFunctions, RootHydrateFunction } from './hydration'\nimport { invokeDirectiveHook } from './directives'\nimport { startMeasure, endMeasure } from './profiling'\nimport {\n  devtoolsComponentAdded,\n  devtoolsComponentRemoved,\n  devtoolsComponentUpdated,\n  setDevtoolsHook\n} from './devtools'\nimport { initFeatureFlags } from './featureFlags'\nimport { isAsyncWrapper } from './apiAsyncComponent'\nimport { isCompatEnabled } from './compat/compatConfig'\nimport { DeprecationTypes } from './compat/compatConfig'\n\nexport interface Renderer<HostElement = RendererElement> {\n  render: RootRenderFunction<HostElement>\n  createApp: CreateAppFunction<HostElement>\n}\n\nexport interface HydrationRenderer extends Renderer<Element | ShadowRoot> {\n  hydrate: RootHydrateFunction\n}\n\nexport type RootRenderFunction<HostElement = RendererElement> = (\n  vnode: VNode | null,\n  container: HostElement,\n  isSVG?: boolean\n) => void\n\nexport interface RendererOptions<\n  HostNode = RendererNode,\n  HostElement = RendererElement\n> {\n  patchProp(\n    el: HostElement,\n    key: string,\n    prevValue: any,\n    nextValue: any,\n    isSVG?: boolean,\n    prevChildren?: VNode<HostNode, HostElement>[],\n    parentComponent?: ComponentInternalInstance | null,\n    parentSuspense?: SuspenseBoundary | null,\n    unmountChildren?: UnmountChildrenFn\n  ): void\n  insert(el: HostNode, parent: HostElement, anchor?: HostNode | null): void\n  remove(el: HostNode): void\n  createElement(\n    type: string,\n    isSVG?: boolean,\n    isCustomizedBuiltIn?: string,\n    vnodeProps?: (VNodeProps & { [key: string]: any }) | null\n  ): HostElement\n  createText(text: string): HostNode\n  createComment(text: string): HostNode\n  setText(node: HostNode, text: string): void\n  setElementText(node: HostElement, text: string): void\n  parentNode(node: HostNode): HostElement | null\n  nextSibling(node: HostNode): HostNode | null\n  querySelector?(selector: string): HostElement | null\n  setScopeId?(el: HostElement, id: string): void\n  cloneNode?(node: HostNode): HostNode\n  insertStaticContent?(\n    content: string,\n    parent: HostElement,\n    anchor: HostNode | null,\n    isSVG: boolean,\n    start?: HostNode | null,\n    end?: HostNode | null\n  ): [HostNode, HostNode]\n}\n\n// Renderer Node can technically be any object in the context of core renderer\n// logic - they are never directly operated on and always passed to the node op\n// functions provided via options, so the internal constraint is really just\n// a generic object.\nexport interface RendererNode {\n  [key: string]: any\n}\n\nexport interface RendererElement extends RendererNode {}\n\n// An object exposing the internals of a renderer, passed to tree-shakeable\n// features so that they can be decoupled from this file. Keys are shortened\n// to optimize bundle size.\nexport interface RendererInternals<\n  HostNode = RendererNode,\n  HostElement = RendererElement\n> {\n  p: PatchFn\n  um: UnmountFn\n  r: RemoveFn\n  m: MoveFn\n  mt: MountComponentFn\n  mc: MountChildrenFn\n  pc: PatchChildrenFn\n  pbc: PatchBlockChildrenFn\n  n: NextFn\n  o: RendererOptions<HostNode, HostElement>\n}\n\n// These functions are created inside a closure and therefore their types cannot\n// be directly exported. In order to avoid maintaining function signatures in\n// two places, we declare them once here and use them inside the closure.\ntype PatchFn = (\n  n1: VNode | null, // null means this is a mount\n  n2: VNode,\n  container: RendererElement,\n  anchor?: RendererNode | null,\n  parentComponent?: ComponentInternalInstance | null,\n  parentSuspense?: SuspenseBoundary | null,\n  isSVG?: boolean,\n  slotScopeIds?: string[] | null,\n  optimized?: boolean\n) => void\n\ntype MountChildrenFn = (\n  children: VNodeArrayChildren,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  isSVG: boolean,\n  slotScopeIds: string[] | null,\n  optimized: boolean,\n  start?: number\n) => void\n\ntype PatchChildrenFn = (\n  n1: VNode | null,\n  n2: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  isSVG: boolean,\n  slotScopeIds: string[] | null,\n  optimized: boolean\n) => void\n\ntype PatchBlockChildrenFn = (\n  oldChildren: VNode[],\n  newChildren: VNode[],\n  fallbackContainer: RendererElement,\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  isSVG: boolean,\n  slotScopeIds: string[] | null\n) => void\n\ntype MoveFn = (\n  vnode: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  type: MoveType,\n  parentSuspense?: SuspenseBoundary | null\n) => void\n\ntype NextFn = (vnode: VNode) => RendererNode | null\n\ntype UnmountFn = (\n  vnode: VNode,\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  doRemove?: boolean,\n  optimized?: boolean\n) => void\n\ntype RemoveFn = (vnode: VNode) => void\n\ntype UnmountChildrenFn = (\n  children: VNode[],\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  doRemove?: boolean,\n  optimized?: boolean,\n  start?: number\n) => void\n\nexport type MountComponentFn = (\n  initialVNode: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  isSVG: boolean,\n  optimized: boolean\n) => void\n\ntype ProcessTextOrCommentFn = (\n  n1: VNode | null,\n  n2: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null\n) => void\n\nexport type SetupRenderEffectFn = (\n  instance: ComponentInternalInstance,\n  initialVNode: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  parentSuspense: SuspenseBoundary | null,\n  isSVG: boolean,\n  optimized: boolean\n) => void\n\nexport const enum MoveType {\n  ENTER,\n  LEAVE,\n  REORDER\n}\n\nexport const queuePostRenderEffect = __FEATURE_SUSPENSE__\n  ? queueEffectWithSuspense\n  : queuePostFlushCb\n\n/**\n * The createRenderer function accepts two generic arguments:\n * HostNode and HostElement, corresponding to Node and Element types in the\n * host environment. For example, for runtime-dom, HostNode would be the DOM\n * `Node` interface and HostElement would be the DOM `Element` interface.\n *\n * Custom renderers can pass in the platform specific types like this:\n *\n * ``` js\n * const { render, createApp } = createRenderer<Node, Element>({\n *   patchProp,\n *   ...nodeOps\n * })\n * ```\n */\nexport function createRenderer<\n  HostNode = RendererNode,\n  HostElement = RendererElement\n>(options: RendererOptions<HostNode, HostElement>) {\n  return baseCreateRenderer<HostNode, HostElement>(options)\n}\n\n// Separate API for creating hydration-enabled renderer.\n// Hydration logic is only used when calling this function, making it\n// tree-shakable.\nexport function createHydrationRenderer(\n  options: RendererOptions<Node, Element>\n) {\n  return baseCreateRenderer(options, createHydrationFunctions)\n}\n\n// overload 1: no hydration\nfunction baseCreateRenderer<\n  HostNode = RendererNode,\n  HostElement = RendererElement\n>(options: RendererOptions<HostNode, HostElement>): Renderer<HostElement>\n\n// overload 2: with hydration\nfunction baseCreateRenderer(\n  options: RendererOptions<Node, Element>,\n  createHydrationFns: typeof createHydrationFunctions\n): HydrationRenderer\n\n// implementation\nfunction baseCreateRenderer(\n  options: RendererOptions,\n  createHydrationFns?: typeof createHydrationFunctions\n): any {\n  // compile-time feature flags check\n  if (__ESM_BUNDLER__ && !__TEST__) {\n    initFeatureFlags()\n  }\n\n  const target = getGlobalThis()\n  target.__VUE__ = true\n  if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target)\n  }\n\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = NOOP,\n    cloneNode: hostCloneNode,\n    insertStaticContent: hostInsertStaticContent\n  } = options\n\n  // Note: functions inside this closure should use `const xxx = () => {}`\n  // style in order to prevent being inlined by minifiers.\n  const patch: PatchFn = (\n    n1,\n    n2,\n    container,\n    anchor = null,\n    parentComponent = null,\n    parentSuspense = null,\n    isSVG = false,\n    slotScopeIds = null,\n    optimized = __DEV__ && isHmrUpdating ? false : !!n2.dynamicChildren\n  ) => {\n    if (n1 === n2) {\n      return\n    }\n\n    // patching & not same type, unmount old tree\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1)\n      unmount(n1, parentComponent, parentSuspense, true)\n      n1 = null\n    }\n\n    if (n2.patchFlag === PatchFlags.BAIL) {\n      optimized = false\n      n2.dynamicChildren = null\n    }\n\n    const { type, ref, shapeFlag } = n2\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor)\n        break\n      case Comment:\n        processCommentNode(n1, n2, container, anchor)\n        break\n      case Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, isSVG)\n        } else if (__DEV__) {\n          patchStaticNode(n1, n2, container, isSVG)\n        }\n        break\n      case Fragment:\n        processFragment(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        break\n      default:\n        if (shapeFlag & ShapeFlags.ELEMENT) {\n          processElement(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        } else if (shapeFlag & ShapeFlags.COMPONENT) {\n          processComponent(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        } else if (shapeFlag & ShapeFlags.TELEPORT) {\n          ;(type as typeof TeleportImpl).process(\n            n1 as TeleportVNode,\n            n2 as TeleportVNode,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized,\n            internals\n          )\n        } else if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\n          ;(type as typeof SuspenseImpl).process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized,\n            internals\n          )\n        } else if (__DEV__) {\n          warn('Invalid VNode type:', type, `(${typeof type})`)\n        }\n    }\n\n    // set ref\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2)\n    }\n  }\n\n  const processText: ProcessTextOrCommentFn = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(\n        (n2.el = hostCreateText(n2.children as string)),\n        container,\n        anchor\n      )\n    } else {\n      const el = (n2.el = n1.el!)\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children as string)\n      }\n    }\n  }\n\n  const processCommentNode: ProcessTextOrCommentFn = (\n    n1,\n    n2,\n    container,\n    anchor\n  ) => {\n    if (n1 == null) {\n      hostInsert(\n        (n2.el = hostCreateComment((n2.children as string) || '')),\n        container,\n        anchor\n      )\n    } else {\n      // there's no support for dynamic comments\n      n2.el = n1.el\n    }\n  }\n\n  const mountStaticNode = (\n    n2: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    isSVG: boolean\n  ) => {\n    // static nodes are only present when used with compiler-dom/runtime-dom\n    // which guarantees presence of hostInsertStaticContent.\n    ;[n2.el, n2.anchor] = hostInsertStaticContent!(\n      n2.children as string,\n      container,\n      anchor,\n      isSVG,\n      n2.el,\n      n2.anchor\n    )\n  }\n\n  /**\n   * Dev / HMR only\n   */\n  const patchStaticNode = (\n    n1: VNode,\n    n2: VNode,\n    container: RendererElement,\n    isSVG: boolean\n  ) => {\n    // static nodes are only patched during dev for HMR\n    if (n2.children !== n1.children) {\n      const anchor = hostNextSibling(n1.anchor!)\n      // remove existing\n      removeStaticNode(n1)\n      // insert new\n      ;[n2.el, n2.anchor] = hostInsertStaticContent!(\n        n2.children as string,\n        container,\n        anchor,\n        isSVG\n      )\n    } else {\n      n2.el = n1.el\n      n2.anchor = n1.anchor\n    }\n  }\n\n  const moveStaticNode = (\n    { el, anchor }: VNode,\n    container: RendererElement,\n    nextSibling: RendererNode | null\n  ) => {\n    let next\n    while (el && el !== anchor) {\n      next = hostNextSibling(el)\n      hostInsert(el, container, nextSibling)\n      el = next\n    }\n    hostInsert(anchor!, container, nextSibling)\n  }\n\n  const removeStaticNode = ({ el, anchor }: VNode) => {\n    let next\n    while (el && el !== anchor) {\n      next = hostNextSibling(el)\n      hostRemove(el)\n      el = next\n    }\n    hostRemove(anchor!)\n  }\n\n  const processElement = (\n    n1: VNode | null,\n    n2: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => {\n    isSVG = isSVG || (n2.type as string) === 'svg'\n    if (n1 == null) {\n      mountElement(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      )\n    } else {\n      patchElement(\n        n1,\n        n2,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      )\n    }\n  }\n\n  const mountElement = (\n    vnode: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => {\n    let el: RendererElement\n    let vnodeHook: VNodeHook | undefined | null\n    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode\n    if (\n      !__DEV__ &&\n      vnode.el &&\n      hostCloneNode !== undefined &&\n      patchFlag === PatchFlags.HOISTED\n    ) {\n      // If a vnode has non-null el, it means it's being reused.\n      // Only static vnodes can be reused, so its mounted DOM nodes should be\n      // exactly the same, and we can simply do a clone here.\n      // only do this in production since cloned trees cannot be HMR updated.\n      el = vnode.el = hostCloneNode(vnode.el)\n    } else {\n      el = vnode.el = hostCreateElement(\n        vnode.type as string,\n        isSVG,\n        props && props.is,\n        props\n      )\n\n      // mount children first, since some props may rely on child content\n      // being already rendered, e.g. `<select value>`\n      if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n        hostSetElementText(el, vnode.children as string)\n      } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        mountChildren(\n          vnode.children as VNodeArrayChildren,\n          el,\n          null,\n          parentComponent,\n          parentSuspense,\n          isSVG && type !== 'foreignObject',\n          slotScopeIds,\n          optimized\n        )\n      }\n\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'created')\n      }\n      // props\n      if (props) {\n        for (const key in props) {\n          if (key !== 'value' && !isReservedProp(key)) {\n            hostPatchProp(\n              el,\n              key,\n              null,\n              props[key],\n              isSVG,\n              vnode.children as VNode[],\n              parentComponent,\n              parentSuspense,\n              unmountChildren\n            )\n          }\n        }\n        /**\n         * Special case for setting value on DOM elements:\n         * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)\n         * - it needs to be forced (#1471)\n         * #2353 proposes adding another renderer option to configure this, but\n         * the properties affects are so finite it is worth special casing it\n         * here to reduce the complexity. (Special casing it also should not\n         * affect non-DOM renderers)\n         */\n        if ('value' in props) {\n          hostPatchProp(el, 'value', null, props.value)\n        }\n        if ((vnodeHook = props.onVnodeBeforeMount)) {\n          invokeVNodeHook(vnodeHook, parentComponent, vnode)\n        }\n      }\n      // scopeId\n      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent)\n    }\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n      Object.defineProperty(el, '__vnode', {\n        value: vnode,\n        enumerable: false\n      })\n      Object.defineProperty(el, '__vueParentComponent', {\n        value: parentComponent,\n        enumerable: false\n      })\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, 'beforeMount')\n    }\n    // #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved\n    // #1689 For inside suspense + suspense resolved case, just call it\n    const needCallTransitionHooks =\n      (!parentSuspense || (parentSuspense && !parentSuspense.pendingBranch)) &&\n      transition &&\n      !transition.persisted\n    if (needCallTransitionHooks) {\n      transition!.beforeEnter(el)\n    }\n    hostInsert(el, container, anchor)\n    if (\n      (vnodeHook = props && props.onVnodeMounted) ||\n      needCallTransitionHooks ||\n      dirs\n    ) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode)\n        needCallTransitionHooks && transition!.enter(el)\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, 'mounted')\n      }, parentSuspense)\n    }\n  }\n\n  const setScopeId = (\n    el: RendererElement,\n    vnode: VNode,\n    scopeId: string | null,\n    slotScopeIds: string[] | null,\n    parentComponent: ComponentInternalInstance | null\n  ) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId)\n    }\n    if (slotScopeIds) {\n      for (let i = 0; i < slotScopeIds.length; i++) {\n        hostSetScopeId(el, slotScopeIds[i])\n      }\n    }\n    if (parentComponent) {\n      let subTree = parentComponent.subTree\n      if (\n        __DEV__ &&\n        subTree.patchFlag > 0 &&\n        subTree.patchFlag & PatchFlags.DEV_ROOT_FRAGMENT\n      ) {\n        subTree =\n          filterSingleRoot(subTree.children as VNodeArrayChildren) || subTree\n      }\n      if (vnode === subTree) {\n        const parentVNode = parentComponent.vnode\n        setScopeId(\n          el,\n          parentVNode,\n          parentVNode.scopeId,\n          parentVNode.slotScopeIds,\n          parentComponent.parent\n        )\n      }\n    }\n  }\n\n  const mountChildren: MountChildrenFn = (\n    children,\n    container,\n    anchor,\n    parentComponent,\n    parentSuspense,\n    isSVG,\n    slotScopeIds,\n    optimized,\n    start = 0\n  ) => {\n    for (let i = start; i < children.length; i++) {\n      const child = (children[i] = optimized\n        ? cloneIfMounted(children[i] as VNode)\n        : normalizeVNode(children[i]))\n      patch(\n        null,\n        child,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      )\n    }\n  }\n\n  const patchElement = (\n    n1: VNode,\n    n2: VNode,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => {\n    const el = (n2.el = n1.el!)\n    let { patchFlag, dynamicChildren, dirs } = n2\n    // #1426 take the old vnode's patch flag into account since user may clone a\n    // compiler-generated vnode, which de-opts to FULL_PROPS\n    patchFlag |= n1.patchFlag & PatchFlags.FULL_PROPS\n    const oldProps = n1.props || EMPTY_OBJ\n    const newProps = n2.props || EMPTY_OBJ\n    let vnodeHook: VNodeHook | undefined | null\n\n    // disable recurse in beforeUpdate hooks\n    parentComponent && toggleRecurse(parentComponent, false)\n    if ((vnodeHook = newProps.onVnodeBeforeUpdate)) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1)\n    }\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, 'beforeUpdate')\n    }\n    parentComponent && toggleRecurse(parentComponent, true)\n\n    if (__DEV__ && isHmrUpdating) {\n      // HMR updated, force full diff\n      patchFlag = 0\n      optimized = false\n      dynamicChildren = null\n    }\n\n    const areChildrenSVG = isSVG && n2.type !== 'foreignObject'\n    if (dynamicChildren) {\n      patchBlockChildren(\n        n1.dynamicChildren!,\n        dynamicChildren,\n        el,\n        parentComponent,\n        parentSuspense,\n        areChildrenSVG,\n        slotScopeIds\n      )\n      if (__DEV__ && parentComponent && parentComponent.type.__hmrId) {\n        traverseStaticChildren(n1, n2)\n      }\n    } else if (!optimized) {\n      // full diff\n      patchChildren(\n        n1,\n        n2,\n        el,\n        null,\n        parentComponent,\n        parentSuspense,\n        areChildrenSVG,\n        slotScopeIds,\n        false\n      )\n    }\n\n    if (patchFlag > 0) {\n      // the presence of a patchFlag means this element's render code was\n      // generated by the compiler and can take the fast path.\n      // in this path old node and new node are guaranteed to have the same shape\n      // (i.e. at the exact same position in the source template)\n      if (patchFlag & PatchFlags.FULL_PROPS) {\n        // element props contain dynamic keys, full diff needed\n        patchProps(\n          el,\n          n2,\n          oldProps,\n          newProps,\n          parentComponent,\n          parentSuspense,\n          isSVG\n        )\n      } else {\n        // class\n        // this flag is matched when the element has dynamic class bindings.\n        if (patchFlag & PatchFlags.CLASS) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, 'class', null, newProps.class, isSVG)\n          }\n        }\n\n        // style\n        // this flag is matched when the element has dynamic style bindings\n        if (patchFlag & PatchFlags.STYLE) {\n          hostPatchProp(el, 'style', oldProps.style, newProps.style, isSVG)\n        }\n\n        // props\n        // This flag is matched when the element has dynamic prop/attr bindings\n        // other than class and style. The keys of dynamic prop/attrs are saved for\n        // faster iteration.\n        // Note dynamic keys like :[foo]=\"bar\" will cause this optimization to\n        // bail out and go through a full diff because we need to unset the old key\n        if (patchFlag & PatchFlags.PROPS) {\n          // if the flag is present then dynamicProps must be non-null\n          const propsToUpdate = n2.dynamicProps!\n          for (let i = 0; i < propsToUpdate.length; i++) {\n            const key = propsToUpdate[i]\n            const prev = oldProps[key]\n            const next = newProps[key]\n            // #1471 force patch value\n            if (next !== prev || key === 'value') {\n              hostPatchProp(\n                el,\n                key,\n                prev,\n                next,\n                isSVG,\n                n1.children as VNode[],\n                parentComponent,\n                parentSuspense,\n                unmountChildren\n              )\n            }\n          }\n        }\n      }\n\n      // text\n      // This flag is matched when the element has only dynamic text children.\n      if (patchFlag & PatchFlags.TEXT) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children as string)\n        }\n      }\n    } else if (!optimized && dynamicChildren == null) {\n      // unoptimized, full diff\n      patchProps(\n        el,\n        n2,\n        oldProps,\n        newProps,\n        parentComponent,\n        parentSuspense,\n        isSVG\n      )\n    }\n\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1)\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, 'updated')\n      }, parentSuspense)\n    }\n  }\n\n  // The fast path for blocks.\n  const patchBlockChildren: PatchBlockChildrenFn = (\n    oldChildren,\n    newChildren,\n    fallbackContainer,\n    parentComponent,\n    parentSuspense,\n    isSVG,\n    slotScopeIds\n  ) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i]\n      const newVNode = newChildren[i]\n      // Determine the container (parent element) for the patch.\n      const container =\n        // oldVNode may be an errored async setup() component inside Suspense\n        // which will not have a mounted element\n        oldVNode.el &&\n        // - In the case of a Fragment, we need to provide the actual parent\n        // of the Fragment itself so it can move its children.\n        (oldVNode.type === Fragment ||\n          // - In the case of different nodes, there is going to be a replacement\n          // which also requires the correct parent container\n          !isSameVNodeType(oldVNode, newVNode) ||\n          // - In the case of a component, it could contain anything.\n          oldVNode.shapeFlag & (ShapeFlags.COMPONENT | ShapeFlags.TELEPORT))\n          ? hostParentNode(oldVNode.el)!\n          : // In other cases, the parent container is not actually used so we\n            // just pass the block element here to avoid a DOM parentNode call.\n            fallbackContainer\n      patch(\n        oldVNode,\n        newVNode,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        true\n      )\n    }\n  }\n\n  const patchProps = (\n    el: RendererElement,\n    vnode: VNode,\n    oldProps: Data,\n    newProps: Data,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean\n  ) => {\n    if (oldProps !== newProps) {\n      for (const key in newProps) {\n        // empty string is not valid prop\n        if (isReservedProp(key)) continue\n        const next = newProps[key]\n        const prev = oldProps[key]\n        // defer patching value\n        if (next !== prev && key !== 'value') {\n          hostPatchProp(\n            el,\n            key,\n            prev,\n            next,\n            isSVG,\n            vnode.children as VNode[],\n            parentComponent,\n            parentSuspense,\n            unmountChildren\n          )\n        }\n      }\n      if (oldProps !== EMPTY_OBJ) {\n        for (const key in oldProps) {\n          if (!isReservedProp(key) && !(key in newProps)) {\n            hostPatchProp(\n              el,\n              key,\n              oldProps[key],\n              null,\n              isSVG,\n              vnode.children as VNode[],\n              parentComponent,\n              parentSuspense,\n              unmountChildren\n            )\n          }\n        }\n      }\n      if ('value' in newProps) {\n        hostPatchProp(el, 'value', oldProps.value, newProps.value)\n      }\n    }\n  }\n\n  const processFragment = (\n    n1: VNode | null,\n    n2: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => {\n    const fragmentStartAnchor = (n2.el = n1 ? n1.el : hostCreateText(''))!\n    const fragmentEndAnchor = (n2.anchor = n1 ? n1.anchor : hostCreateText(''))!\n\n    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2\n\n    if (__DEV__ && isHmrUpdating) {\n      // HMR updated, force full diff\n      patchFlag = 0\n      optimized = false\n      dynamicChildren = null\n    }\n\n    // check if this is a slot fragment with :slotted scope ids\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds\n        ? slotScopeIds.concat(fragmentSlotScopeIds)\n        : fragmentSlotScopeIds\n    }\n\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor)\n      hostInsert(fragmentEndAnchor, container, anchor)\n      // a fragment can only have array children\n      // since they are either generated by the compiler, or implicitly created\n      // from arrays.\n      mountChildren(\n        n2.children as VNodeArrayChildren,\n        container,\n        fragmentEndAnchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      )\n    } else {\n      if (\n        patchFlag > 0 &&\n        patchFlag & PatchFlags.STABLE_FRAGMENT &&\n        dynamicChildren &&\n        // #2715 the previous fragment could've been a BAILed one as a result\n        // of renderSlot() with no valid children\n        n1.dynamicChildren\n      ) {\n        // a stable fragment (template root or <template v-for>) doesn't need to\n        // patch children order, but it may contain dynamicChildren.\n        patchBlockChildren(\n          n1.dynamicChildren,\n          dynamicChildren,\n          container,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds\n        )\n        if (__DEV__ && parentComponent && parentComponent.type.__hmrId) {\n          traverseStaticChildren(n1, n2)\n        } else if (\n          // #2080 if the stable fragment has a key, it's a <template v-for> that may\n          //  get moved around. Make sure all root level vnodes inherit el.\n          // #2134 or if it's a component root, it may also get moved around\n          // as the component is being moved.\n          n2.key != null ||\n          (parentComponent && n2 === parentComponent.subTree)\n        ) {\n          traverseStaticChildren(n1, n2, true /* shallow */)\n        }\n      } else {\n        // keyed / unkeyed, or manual fragments.\n        // for keyed & unkeyed, since they are compiler generated from v-for,\n        // each child is guaranteed to be a block so the fragment will never\n        // have dynamicChildren.\n        patchChildren(\n          n1,\n          n2,\n          container,\n          fragmentEndAnchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n      }\n    }\n  }\n\n  const processComponent = (\n    n1: VNode | null,\n    n2: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => {\n    n2.slotScopeIds = slotScopeIds\n    if (n1 == null) {\n      if (n2.shapeFlag & ShapeFlags.COMPONENT_KEPT_ALIVE) {\n        ;(parentComponent!.ctx as KeepAliveContext).activate(\n          n2,\n          container,\n          anchor,\n          isSVG,\n          optimized\n        )\n      } else {\n        mountComponent(\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          optimized\n        )\n      }\n    } else {\n      updateComponent(n1, n2, optimized)\n    }\n  }\n\n  const mountComponent: MountComponentFn = (\n    initialVNode,\n    container,\n    anchor,\n    parentComponent,\n    parentSuspense,\n    isSVG,\n    optimized\n  ) => {\n    // 2.x compat may pre-create the component instance before actually\n    // mounting\n    const compatMountInstance =\n      __COMPAT__ && initialVNode.isCompatRoot && initialVNode.component\n    const instance: ComponentInternalInstance =\n      compatMountInstance ||\n      (initialVNode.component = createComponentInstance(\n        initialVNode,\n        parentComponent,\n        parentSuspense\n      ))\n\n    if (__DEV__ && instance.type.__hmrId) {\n      registerHMR(instance)\n    }\n\n    if (__DEV__) {\n      pushWarningContext(initialVNode)\n      startMeasure(instance, `mount`)\n    }\n\n    // inject renderer internals for keepAlive\n    if (isKeepAlive(initialVNode)) {\n      ;(instance.ctx as KeepAliveContext).renderer = internals\n    }\n\n    // resolve props and slots for setup context\n    if (!(__COMPAT__ && compatMountInstance)) {\n      if (__DEV__) {\n        startMeasure(instance, `init`)\n      }\n      setupComponent(instance)\n      if (__DEV__) {\n        endMeasure(instance, `init`)\n      }\n    }\n\n    // setup() is async. This component relies on async logic to be resolved\n    // before proceeding\n    if (__FEATURE_SUSPENSE__ && instance.asyncDep) {\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect)\n\n      // Give it a placeholder if this is not hydration\n      // TODO handle self-defined fallback\n      if (!initialVNode.el) {\n        const placeholder = (instance.subTree = createVNode(Comment))\n        processCommentNode(null, placeholder, container!, anchor)\n      }\n      return\n    }\n\n    setupRenderEffect(\n      instance,\n      initialVNode,\n      container,\n      anchor,\n      parentSuspense,\n      isSVG,\n      optimized\n    )\n\n    if (__DEV__) {\n      popWarningContext()\n      endMeasure(instance, `mount`)\n    }\n  }\n\n  const updateComponent = (n1: VNode, n2: VNode, optimized: boolean) => {\n    const instance = (n2.component = n1.component)!\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (\n        __FEATURE_SUSPENSE__ &&\n        instance.asyncDep &&\n        !instance.asyncResolved\n      ) {\n        // async & still pending - just update props and slots\n        // since the component's reactive effect for render isn't set-up yet\n        if (__DEV__) {\n          pushWarningContext(n2)\n        }\n        updateComponentPreRender(instance, n2, optimized)\n        if (__DEV__) {\n          popWarningContext()\n        }\n        return\n      } else {\n        // normal update\n        instance.next = n2\n        // in case the child component is also queued, remove it to avoid\n        // double updating the same child component in the same flush.\n        invalidateJob(instance.update)\n        // instance.update is the reactive effect.\n        instance.update()\n      }\n    } else {\n      // no update needed. just copy over properties\n      n2.component = n1.component\n      n2.el = n1.el\n      instance.vnode = n2\n    }\n  }\n\n  const setupRenderEffect: SetupRenderEffectFn = (\n    instance,\n    initialVNode,\n    container,\n    anchor,\n    parentSuspense,\n    isSVG,\n    optimized\n  ) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        let vnodeHook: VNodeHook | null | undefined\n        const { el, props } = initialVNode\n        const { bm, m, parent } = instance\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode)\n\n        toggleRecurse(instance, false)\n        // beforeMount hook\n        if (bm) {\n          invokeArrayFns(bm)\n        }\n        // onVnodeBeforeMount\n        if (\n          !isAsyncWrapperVNode &&\n          (vnodeHook = props && props.onVnodeBeforeMount)\n        ) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode)\n        }\n        if (\n          __COMPAT__ &&\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\n        ) {\n          instance.emit('hook:beforeMount')\n        }\n        toggleRecurse(instance, true)\n\n        if (el && hydrateNode) {\n          // vnode has adopted host node - perform hydration instead of mount.\n          const hydrateSubTree = () => {\n            if (__DEV__) {\n              startMeasure(instance, `render`)\n            }\n            instance.subTree = renderComponentRoot(instance)\n            if (__DEV__) {\n              endMeasure(instance, `render`)\n            }\n            if (__DEV__) {\n              startMeasure(instance, `hydrate`)\n            }\n            hydrateNode!(\n              el as Node,\n              instance.subTree,\n              instance,\n              parentSuspense,\n              null\n            )\n            if (__DEV__) {\n              endMeasure(instance, `hydrate`)\n            }\n          }\n\n          if (isAsyncWrapperVNode) {\n            ;(initialVNode.type as ComponentOptions).__asyncLoader!().then(\n              // note: we are moving the render call into an async callback,\n              // which means it won't track dependencies - but it's ok because\n              // a server-rendered async wrapper is already in resolved state\n              // and it will never need to change.\n              () => !instance.isUnmounted && hydrateSubTree()\n            )\n          } else {\n            hydrateSubTree()\n          }\n        } else {\n          if (__DEV__) {\n            startMeasure(instance, `render`)\n          }\n          const subTree = (instance.subTree = renderComponentRoot(instance))\n          if (__DEV__) {\n            endMeasure(instance, `render`)\n          }\n          if (__DEV__) {\n            startMeasure(instance, `patch`)\n          }\n          patch(\n            null,\n            subTree,\n            container,\n            anchor,\n            instance,\n            parentSuspense,\n            isSVG\n          )\n          if (__DEV__) {\n            endMeasure(instance, `patch`)\n          }\n          initialVNode.el = subTree.el\n        }\n        // mounted hook\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense)\n        }\n        // onVnodeMounted\n        if (\n          !isAsyncWrapperVNode &&\n          (vnodeHook = props && props.onVnodeMounted)\n        ) {\n          const scopedInitialVNode = initialVNode\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook!, parent, scopedInitialVNode),\n            parentSuspense\n          )\n        }\n        if (\n          __COMPAT__ &&\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\n        ) {\n          queuePostRenderEffect(\n            () => instance.emit('hook:mounted'),\n            parentSuspense\n          )\n        }\n\n        // activated hook for keep-alive roots.\n        // #1742 activated hook must be accessed after first render\n        // since the hook may be injected by a child keep-alive\n        if (initialVNode.shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense)\n          if (\n            __COMPAT__ &&\n            isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\n          ) {\n            queuePostRenderEffect(\n              () => instance.emit('hook:activated'),\n              parentSuspense\n            )\n          }\n        }\n        instance.isMounted = true\n\n        if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n          devtoolsComponentAdded(instance)\n        }\n\n        // #2458: deference mount-only object parameters to prevent memleaks\n        initialVNode = container = anchor = null as any\n      } else {\n        // updateComponent\n        // This is triggered by mutation of component's own state (next: null)\n        // OR parent calling processComponent (next: VNode)\n        let { next, bu, u, parent, vnode } = instance\n        let originNext = next\n        let vnodeHook: VNodeHook | null | undefined\n        if (__DEV__) {\n          pushWarningContext(next || instance.vnode)\n        }\n\n        // Disallow component effect recursion during pre-lifecycle hooks.\n        toggleRecurse(instance, false)\n        if (next) {\n          next.el = vnode.el\n          updateComponentPreRender(instance, next, optimized)\n        } else {\n          next = vnode\n        }\n\n        // beforeUpdate hook\n        if (bu) {\n          invokeArrayFns(bu)\n        }\n        // onVnodeBeforeUpdate\n        if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode)\n        }\n        if (\n          __COMPAT__ &&\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\n        ) {\n          instance.emit('hook:beforeUpdate')\n        }\n        toggleRecurse(instance, true)\n\n        // render\n        if (__DEV__) {\n          startMeasure(instance, `render`)\n        }\n        const nextTree = renderComponentRoot(instance)\n        if (__DEV__) {\n          endMeasure(instance, `render`)\n        }\n        const prevTree = instance.subTree\n        instance.subTree = nextTree\n\n        if (__DEV__) {\n          startMeasure(instance, `patch`)\n        }\n        patch(\n          prevTree,\n          nextTree,\n          // parent may have changed if it's in a teleport\n          hostParentNode(prevTree.el!)!,\n          // anchor may have changed if it's in a fragment\n          getNextHostNode(prevTree),\n          instance,\n          parentSuspense,\n          isSVG\n        )\n        if (__DEV__) {\n          endMeasure(instance, `patch`)\n        }\n        next.el = nextTree.el\n        if (originNext === null) {\n          // self-triggered update. In case of HOC, update parent component\n          // vnode el. HOC is indicated by parent instance's subTree pointing\n          // to child component's vnode\n          updateHOCHostEl(instance, nextTree.el)\n        }\n        // updated hook\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense)\n        }\n        // onVnodeUpdated\n        if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook!, parent, next!, vnode),\n            parentSuspense\n          )\n        }\n        if (\n          __COMPAT__ &&\n          isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\n        ) {\n          queuePostRenderEffect(\n            () => instance.emit('hook:updated'),\n            parentSuspense\n          )\n        }\n\n        if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n          devtoolsComponentUpdated(instance)\n        }\n\n        if (__DEV__) {\n          popWarningContext()\n        }\n      }\n    }\n\n    // create reactive effect for rendering\n    const effect = (instance.effect = new ReactiveEffect(\n      componentUpdateFn,\n      () => queueJob(instance.update),\n      instance.scope // track it in component's effect scope\n    ))\n\n    const update = (instance.update = effect.run.bind(effect) as SchedulerJob)\n    update.id = instance.uid\n    // allowRecurse\n    // #1801, #2043 component render effects should allow recursive updates\n    toggleRecurse(instance, true)\n\n    if (__DEV__) {\n      effect.onTrack = instance.rtc\n        ? e => invokeArrayFns(instance.rtc!, e)\n        : void 0\n      effect.onTrigger = instance.rtg\n        ? e => invokeArrayFns(instance.rtg!, e)\n        : void 0\n      // @ts-ignore (for scheduler)\n      update.ownerInstance = instance\n    }\n\n    update()\n  }\n\n  const updateComponentPreRender = (\n    instance: ComponentInternalInstance,\n    nextVNode: VNode,\n    optimized: boolean\n  ) => {\n    nextVNode.component = instance\n    const prevProps = instance.vnode.props\n    instance.vnode = nextVNode\n    instance.next = null\n    updateProps(instance, nextVNode.props, prevProps, optimized)\n    updateSlots(instance, nextVNode.children, optimized)\n\n    pauseTracking()\n    // props update may have triggered pre-flush watchers.\n    // flush them before the render update.\n    flushPreFlushCbs(undefined, instance.update)\n    resetTracking()\n  }\n\n  const patchChildren: PatchChildrenFn = (\n    n1,\n    n2,\n    container,\n    anchor,\n    parentComponent,\n    parentSuspense,\n    isSVG,\n    slotScopeIds,\n    optimized = false\n  ) => {\n    const c1 = n1 && n1.children\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0\n    const c2 = n2.children\n\n    const { patchFlag, shapeFlag } = n2\n    // fast path\n    if (patchFlag > 0) {\n      if (patchFlag & PatchFlags.KEYED_FRAGMENT) {\n        // this could be either fully-keyed or mixed (some keyed some not)\n        // presence of patchFlag means children are guaranteed to be arrays\n        patchKeyedChildren(\n          c1 as VNode[],\n          c2 as VNodeArrayChildren,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        return\n      } else if (patchFlag & PatchFlags.UNKEYED_FRAGMENT) {\n        // unkeyed\n        patchUnkeyedChildren(\n          c1 as VNode[],\n          c2 as VNodeArrayChildren,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        return\n      }\n    }\n\n    // children has 3 possibilities: text, array or no children.\n    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {\n      // text children fast path\n      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        unmountChildren(c1 as VNode[], parentComponent, parentSuspense)\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2 as string)\n      }\n    } else {\n      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        // prev children was array\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n          // two arrays, cannot assume anything, do full diff\n          patchKeyedChildren(\n            c1 as VNode[],\n            c2 as VNodeArrayChildren,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        } else {\n          // no new children, just unmount old\n          unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)\n        }\n      } else {\n        // prev children was text OR null\n        // new children is array OR null\n        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {\n          hostSetElementText(container, '')\n        }\n        // mount new if array\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n          mountChildren(\n            c2 as VNodeArrayChildren,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        }\n      }\n    }\n  }\n\n  const patchUnkeyedChildren = (\n    c1: VNode[],\n    c2: VNodeArrayChildren,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => {\n    c1 = c1 || EMPTY_ARR\n    c2 = c2 || EMPTY_ARR\n    const oldLength = c1.length\n    const newLength = c2.length\n    const commonLength = Math.min(oldLength, newLength)\n    let i\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = (c2[i] = optimized\n        ? cloneIfMounted(c2[i] as VNode)\n        : normalizeVNode(c2[i]))\n      patch(\n        c1[i],\n        nextChild,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      )\n    }\n    if (oldLength > newLength) {\n      // remove old\n      unmountChildren(\n        c1,\n        parentComponent,\n        parentSuspense,\n        true,\n        false,\n        commonLength\n      )\n    } else {\n      // mount new\n      mountChildren(\n        c2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized,\n        commonLength\n      )\n    }\n  }\n\n  // can be all-keyed or mixed\n  const patchKeyedChildren = (\n    c1: VNode[],\n    c2: VNodeArrayChildren,\n    container: RendererElement,\n    parentAnchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => {\n    let i = 0\n    const l2 = c2.length\n    let e1 = c1.length - 1 // prev ending index\n    let e2 = l2 - 1 // next ending index\n\n    // 1. sync from start\n    // (a b) c\n    // (a b) d e\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i]\n      const n2 = (c2[i] = optimized\n        ? cloneIfMounted(c2[i] as VNode)\n        : normalizeVNode(c2[i]))\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n      } else {\n        break\n      }\n      i++\n    }\n\n    // 2. sync from end\n    // a (b c)\n    // d e (b c)\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1]\n      const n2 = (c2[e2] = optimized\n        ? cloneIfMounted(c2[e2] as VNode)\n        : normalizeVNode(c2[e2]))\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n      } else {\n        break\n      }\n      e1--\n      e2--\n    }\n\n    // 3. common sequence + mount\n    // (a b)\n    // (a b) c\n    // i = 2, e1 = 1, e2 = 2\n    // (a b)\n    // c (a b)\n    // i = 0, e1 = -1, e2 = 0\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1\n        const anchor = nextPos < l2 ? (c2[nextPos] as VNode).el : parentAnchor\n        while (i <= e2) {\n          patch(\n            null,\n            (c2[i] = optimized\n              ? cloneIfMounted(c2[i] as VNode)\n              : normalizeVNode(c2[i])),\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n          i++\n        }\n      }\n    }\n\n    // 4. common sequence + unmount\n    // (a b) c\n    // (a b)\n    // i = 2, e1 = 2, e2 = 1\n    // a (b c)\n    // (b c)\n    // i = 0, e1 = 0, e2 = -1\n    else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true)\n        i++\n      }\n    }\n\n    // 5. unknown sequence\n    // [i ... e1 + 1]: a b [c d e] f g\n    // [i ... e2 + 1]: a b [e d c h] f g\n    // i = 2, e1 = 4, e2 = 5\n    else {\n      const s1 = i // prev starting index\n      const s2 = i // next starting index\n\n      // 5.1 build key:index map for newChildren\n      const keyToNewIndexMap: Map<string | number | symbol, number> = new Map()\n      for (i = s2; i <= e2; i++) {\n        const nextChild = (c2[i] = optimized\n          ? cloneIfMounted(c2[i] as VNode)\n          : normalizeVNode(c2[i]))\n        if (nextChild.key != null) {\n          if (__DEV__ && keyToNewIndexMap.has(nextChild.key)) {\n            warn(\n              `Duplicate keys found during update:`,\n              JSON.stringify(nextChild.key),\n              `Make sure keys are unique.`\n            )\n          }\n          keyToNewIndexMap.set(nextChild.key, i)\n        }\n      }\n\n      // 5.2 loop through old children left to be patched and try to patch\n      // matching nodes & remove nodes that are no longer present\n      let j\n      let patched = 0\n      const toBePatched = e2 - s2 + 1\n      let moved = false\n      // used to track whether any node has moved\n      let maxNewIndexSoFar = 0\n      // works as Map<newIndex, oldIndex>\n      // Note that oldIndex is offset by +1\n      // and oldIndex = 0 is a special value indicating the new node has\n      // no corresponding old node.\n      // used for determining longest stable subsequence\n      const newIndexToOldIndexMap = new Array(toBePatched)\n      for (i = 0; i < toBePatched; i++) newIndexToOldIndexMap[i] = 0\n\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i]\n        if (patched >= toBePatched) {\n          // all new children have been patched so this can only be a removal\n          unmount(prevChild, parentComponent, parentSuspense, true)\n          continue\n        }\n        let newIndex\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key)\n        } else {\n          // key-less node, try to locate a key-less node of the same type\n          for (j = s2; j <= e2; j++) {\n            if (\n              newIndexToOldIndexMap[j - s2] === 0 &&\n              isSameVNodeType(prevChild, c2[j] as VNode)\n            ) {\n              newIndex = j\n              break\n            }\n          }\n        }\n        if (newIndex === undefined) {\n          unmount(prevChild, parentComponent, parentSuspense, true)\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex\n          } else {\n            moved = true\n          }\n          patch(\n            prevChild,\n            c2[newIndex] as VNode,\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n          patched++\n        }\n      }\n\n      // 5.3 move and mount\n      // generate longest stable subsequence only when nodes have moved\n      const increasingNewIndexSequence = moved\n        ? getSequence(newIndexToOldIndexMap)\n        : EMPTY_ARR\n      j = increasingNewIndexSequence.length - 1\n      // looping backwards so that we can use last patched node as anchor\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i\n        const nextChild = c2[nextIndex] as VNode\n        const anchor =\n          nextIndex + 1 < l2 ? (c2[nextIndex + 1] as VNode).el : parentAnchor\n        if (newIndexToOldIndexMap[i] === 0) {\n          // mount new\n          patch(\n            null,\n            nextChild,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        } else if (moved) {\n          // move if:\n          // There is no stable subsequence (e.g. a reverse)\n          // OR current node is not among the stable sequence\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, MoveType.REORDER)\n          } else {\n            j--\n          }\n        }\n      }\n    }\n  }\n\n  const move: MoveFn = (\n    vnode,\n    container,\n    anchor,\n    moveType,\n    parentSuspense = null\n  ) => {\n    const { el, type, transition, children, shapeFlag } = vnode\n    if (shapeFlag & ShapeFlags.COMPONENT) {\n      move(vnode.component!.subTree, container, anchor, moveType)\n      return\n    }\n\n    if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\n      vnode.suspense!.move(container, anchor, moveType)\n      return\n    }\n\n    if (shapeFlag & ShapeFlags.TELEPORT) {\n      ;(type as typeof TeleportImpl).move(vnode, container, anchor, internals)\n      return\n    }\n\n    if (type === Fragment) {\n      hostInsert(el!, container, anchor)\n      for (let i = 0; i < (children as VNode[]).length; i++) {\n        move((children as VNode[])[i], container, anchor, moveType)\n      }\n      hostInsert(vnode.anchor!, container, anchor)\n      return\n    }\n\n    if (type === Static) {\n      moveStaticNode(vnode, container, anchor)\n      return\n    }\n\n    // single nodes\n    const needTransition =\n      moveType !== MoveType.REORDER &&\n      shapeFlag & ShapeFlags.ELEMENT &&\n      transition\n    if (needTransition) {\n      if (moveType === MoveType.ENTER) {\n        transition!.beforeEnter(el!)\n        hostInsert(el!, container, anchor)\n        queuePostRenderEffect(() => transition!.enter(el!), parentSuspense)\n      } else {\n        const { leave, delayLeave, afterLeave } = transition!\n        const remove = () => hostInsert(el!, container, anchor)\n        const performLeave = () => {\n          leave(el!, () => {\n            remove()\n            afterLeave && afterLeave()\n          })\n        }\n        if (delayLeave) {\n          delayLeave(el!, remove, performLeave)\n        } else {\n          performLeave()\n        }\n      }\n    } else {\n      hostInsert(el!, container, anchor)\n    }\n  }\n\n  const unmount: UnmountFn = (\n    vnode,\n    parentComponent,\n    parentSuspense,\n    doRemove = false,\n    optimized = false\n  ) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs\n    } = vnode\n    // unset ref\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode, true)\n    }\n\n    if (shapeFlag & ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE) {\n      ;(parentComponent!.ctx as KeepAliveContext).deactivate(vnode)\n      return\n    }\n\n    const shouldInvokeDirs = shapeFlag & ShapeFlags.ELEMENT && dirs\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode)\n\n    let vnodeHook: VNodeHook | undefined | null\n    if (\n      shouldInvokeVnodeHook &&\n      (vnodeHook = props && props.onVnodeBeforeUnmount)\n    ) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode)\n    }\n\n    if (shapeFlag & ShapeFlags.COMPONENT) {\n      unmountComponent(vnode.component!, parentSuspense, doRemove)\n    } else {\n      if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\n        vnode.suspense!.unmount(parentSuspense, doRemove)\n        return\n      }\n\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, 'beforeUnmount')\n      }\n\n      if (shapeFlag & ShapeFlags.TELEPORT) {\n        ;(vnode.type as typeof TeleportImpl).remove(\n          vnode,\n          parentComponent,\n          parentSuspense,\n          optimized,\n          internals,\n          doRemove\n        )\n      } else if (\n        dynamicChildren &&\n        // #1153: fast path should not be taken for non-stable (v-for) fragments\n        (type !== Fragment ||\n          (patchFlag > 0 && patchFlag & PatchFlags.STABLE_FRAGMENT))\n      ) {\n        // fast path for block nodes: only need to unmount dynamic children.\n        unmountChildren(\n          dynamicChildren,\n          parentComponent,\n          parentSuspense,\n          false,\n          true\n        )\n      } else if (\n        (type === Fragment &&\n          patchFlag &\n            (PatchFlags.KEYED_FRAGMENT | PatchFlags.UNKEYED_FRAGMENT)) ||\n        (!optimized && shapeFlag & ShapeFlags.ARRAY_CHILDREN)\n      ) {\n        unmountChildren(children as VNode[], parentComponent, parentSuspense)\n      }\n\n      if (doRemove) {\n        remove(vnode)\n      }\n    }\n\n    if (\n      (shouldInvokeVnodeHook &&\n        (vnodeHook = props && props.onVnodeUnmounted)) ||\n      shouldInvokeDirs\n    ) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode)\n        shouldInvokeDirs &&\n          invokeDirectiveHook(vnode, null, parentComponent, 'unmounted')\n      }, parentSuspense)\n    }\n  }\n\n  const remove: RemoveFn = vnode => {\n    const { type, el, anchor, transition } = vnode\n    if (type === Fragment) {\n      removeFragment(el!, anchor!)\n      return\n    }\n\n    if (type === Static) {\n      removeStaticNode(vnode)\n      return\n    }\n\n    const performRemove = () => {\n      hostRemove(el!)\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave()\n      }\n    }\n\n    if (\n      vnode.shapeFlag & ShapeFlags.ELEMENT &&\n      transition &&\n      !transition.persisted\n    ) {\n      const { leave, delayLeave } = transition\n      const performLeave = () => leave(el!, performRemove)\n      if (delayLeave) {\n        delayLeave(vnode.el!, performRemove, performLeave)\n      } else {\n        performLeave()\n      }\n    } else {\n      performRemove()\n    }\n  }\n\n  const removeFragment = (cur: RendererNode, end: RendererNode) => {\n    // For fragments, directly remove all contained DOM nodes.\n    // (fragment child nodes cannot have transition)\n    let next\n    while (cur !== end) {\n      next = hostNextSibling(cur)!\n      hostRemove(cur)\n      cur = next\n    }\n    hostRemove(end)\n  }\n\n  const unmountComponent = (\n    instance: ComponentInternalInstance,\n    parentSuspense: SuspenseBoundary | null,\n    doRemove?: boolean\n  ) => {\n    if (__DEV__ && instance.type.__hmrId) {\n      unregisterHMR(instance)\n    }\n\n    const { bum, scope, update, subTree, um } = instance\n\n    // beforeUnmount hook\n    if (bum) {\n      invokeArrayFns(bum)\n    }\n\n    if (\n      __COMPAT__ &&\n      isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\n    ) {\n      instance.emit('hook:beforeDestroy')\n    }\n\n    // stop effects in component scope\n    scope.stop()\n\n    // update may be null if a component is unmounted before its async\n    // setup has resolved.\n    if (update) {\n      // so that scheduler will no longer invoke it\n      update.active = false\n      unmount(subTree, instance, parentSuspense, doRemove)\n    }\n    // unmounted hook\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense)\n    }\n    if (\n      __COMPAT__ &&\n      isCompatEnabled(DeprecationTypes.INSTANCE_EVENT_HOOKS, instance)\n    ) {\n      queuePostRenderEffect(\n        () => instance.emit('hook:destroyed'),\n        parentSuspense\n      )\n    }\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true\n    }, parentSuspense)\n\n    // A component with async dep inside a pending suspense is unmounted before\n    // its async dep resolves. This should remove the dep from the suspense, and\n    // cause the suspense to resolve immediately if that was the last dep.\n    if (\n      __FEATURE_SUSPENSE__ &&\n      parentSuspense &&\n      parentSuspense.pendingBranch &&\n      !parentSuspense.isUnmounted &&\n      instance.asyncDep &&\n      !instance.asyncResolved &&\n      instance.suspenseId === parentSuspense.pendingId\n    ) {\n      parentSuspense.deps--\n      if (parentSuspense.deps === 0) {\n        parentSuspense.resolve()\n      }\n    }\n\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n      devtoolsComponentRemoved(instance)\n    }\n  }\n\n  const unmountChildren: UnmountChildrenFn = (\n    children,\n    parentComponent,\n    parentSuspense,\n    doRemove = false,\n    optimized = false,\n    start = 0\n  ) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized)\n    }\n  }\n\n  const getNextHostNode: NextFn = vnode => {\n    if (vnode.shapeFlag & ShapeFlags.COMPONENT) {\n      return getNextHostNode(vnode.component!.subTree)\n    }\n    if (__FEATURE_SUSPENSE__ && vnode.shapeFlag & ShapeFlags.SUSPENSE) {\n      return vnode.suspense!.next()\n    }\n    return hostNextSibling((vnode.anchor || vnode.el)!)\n  }\n\n  const render: RootRenderFunction = (vnode, container, isSVG) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true)\n      }\n    } else {\n      patch(container._vnode || null, vnode, container, null, null, null, isSVG)\n    }\n    flushPostFlushCbs()\n    container._vnode = vnode\n  }\n\n  const internals: RendererInternals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  }\n\n  let hydrate: ReturnType<typeof createHydrationFunctions>[0] | undefined\n  let hydrateNode: ReturnType<typeof createHydrationFunctions>[1] | undefined\n  if (createHydrationFns) {\n    ;[hydrate, hydrateNode] = createHydrationFns(\n      internals as RendererInternals<Node, Element>\n    )\n  }\n\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  }\n}\n\nfunction toggleRecurse(\n  { effect, update }: ComponentInternalInstance,\n  allowed: boolean\n) {\n  effect.allowRecurse = update.allowRecurse = allowed\n}\n\n/**\n * #1156\n * When a component is HMR-enabled, we need to make sure that all static nodes\n * inside a block also inherit the DOM element from the previous tree so that\n * HMR updates (which are full updates) can retrieve the element for patching.\n *\n * #2080\n * Inside keyed `template` fragment static children, if a fragment is moved,\n * the children will always be moved. Therefore, in order to ensure correct move\n * position, el should be inherited from previous nodes.\n */\nexport function traverseStaticChildren(n1: VNode, n2: VNode, shallow = false) {\n  const ch1 = n1.children\n  const ch2 = n2.children\n  if (isArray(ch1) && isArray(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      // this is only called in the optimized path so array children are\n      // guaranteed to be vnodes\n      const c1 = ch1[i] as VNode\n      let c2 = ch2[i] as VNode\n      if (c2.shapeFlag & ShapeFlags.ELEMENT && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === PatchFlags.HYDRATE_EVENTS) {\n          c2 = ch2[i] = cloneIfMounted(ch2[i] as VNode)\n          c2.el = c1.el\n        }\n        if (!shallow) traverseStaticChildren(c1, c2)\n      }\n      // also inherit for comment nodes, but not placeholders (e.g. v-if which\n      // would have received .el during block patch)\n      if (__DEV__ && c2.type === Comment && !c2.el) {\n        c2.el = c1.el\n      }\n    }\n  }\n}\n\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction getSequence(arr: number[]): number[] {\n  const p = arr.slice()\n  const result = [0]\n  let i, j, u, v, c\n  const len = arr.length\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i]\n    if (arrI !== 0) {\n      j = result[result.length - 1]\n      if (arr[j] < arrI) {\n        p[i] = j\n        result.push(i)\n        continue\n      }\n      u = 0\n      v = result.length - 1\n      while (u < v) {\n        c = (u + v) >> 1\n        if (arr[result[c]] < arrI) {\n          u = c + 1\n        } else {\n          v = c\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1]\n        }\n        result[u] = i\n      }\n    }\n  }\n  u = result.length\n  v = result[u - 1]\n  while (u-- > 0) {\n    result[u] = v\n    v = p[v]\n  }\n  return result\n}\n", "import {\n  VNode,\n  normalizeVNode,\n  VNodeProps,\n  isSameVNodeType,\n  openBlock,\n  closeBlock,\n  currentBlock,\n  Comment,\n  createVNode,\n  isBlockTreeEnabled\n} from '../vnode'\nimport { isFunction, isArray, ShapeFlags, toNumber } from '@vue/shared'\nimport { ComponentInternalInstance, handleSetupResult } from '../component'\nimport { Slots } from '../componentSlots'\nimport {\n  RendererInternals,\n  MoveType,\n  SetupRenderEffectFn,\n  RendererNode,\n  RendererElement\n} from '../renderer'\nimport { queuePostFlushCb } from '../scheduler'\nimport { filterSingleRoot, updateHOCHostEl } from '../componentRenderUtils'\nimport { pushWarningContext, popWarningContext, warn } from '../warning'\nimport { handleError, ErrorCodes } from '../errorHandling'\n\nexport interface SuspenseProps {\n  onResolve?: () => void\n  onPending?: () => void\n  onFallback?: () => void\n  timeout?: string | number\n}\n\nexport const isSuspense = (type: any): boolean => type.__isSuspense\n\n// Suspense exposes a component-like API, and is treated like a component\n// in the compiler, but internally it's a special built-in type that hooks\n// directly into the renderer.\nexport const SuspenseImpl = {\n  name: 'Suspense',\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n  process(\n    n1: VNode | null,\n    n2: VNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean,\n    // platform-specific impl passed from renderer\n    rendererInternals: RendererInternals\n  ) {\n    if (n1 == null) {\n      mountSuspense(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        isSVG,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      )\n    } else {\n      patchSuspense(\n        n1,\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        isSVG,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      )\n    }\n  },\n  hydrate: hydrateSuspense,\n  create: createSuspenseBoundary,\n  normalize: normalizeSuspenseChildren\n}\n\n// Force-casted public typing for h and TSX props inference\nexport const Suspense = (__FEATURE_SUSPENSE__ ? SuspenseImpl : null) as any as {\n  __isSuspense: true\n  new (): { $props: VNodeProps & SuspenseProps }\n}\n\nfunction triggerEvent(\n  vnode: VNode,\n  name: 'onResolve' | 'onPending' | 'onFallback'\n) {\n  const eventListener = vnode.props && vnode.props[name]\n  if (isFunction(eventListener)) {\n    eventListener()\n  }\n}\n\nfunction mountSuspense(\n  vnode: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  isSVG: boolean,\n  slotScopeIds: string[] | null,\n  optimized: boolean,\n  rendererInternals: RendererInternals\n) {\n  const {\n    p: patch,\n    o: { createElement }\n  } = rendererInternals\n  const hiddenContainer = createElement('div')\n  const suspense = (vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    container,\n    hiddenContainer,\n    anchor,\n    isSVG,\n    slotScopeIds,\n    optimized,\n    rendererInternals\n  ))\n\n  // start mounting the content subtree in an off-dom container\n  patch(\n    null,\n    (suspense.pendingBranch = vnode.ssContent!),\n    hiddenContainer,\n    null,\n    parentComponent,\n    suspense,\n    isSVG,\n    slotScopeIds\n  )\n  // now check if we have encountered any async deps\n  if (suspense.deps > 0) {\n    // has async\n    // invoke @fallback event\n    triggerEvent(vnode, 'onPending')\n    triggerEvent(vnode, 'onFallback')\n\n    // mount the fallback tree\n    patch(\n      null,\n      vnode.ssFallback!,\n      container,\n      anchor,\n      parentComponent,\n      null, // fallback tree will not have suspense context\n      isSVG,\n      slotScopeIds\n    )\n    setActiveBranch(suspense, vnode.ssFallback!)\n  } else {\n    // Suspense has no async deps. Just resolve.\n    suspense.resolve()\n  }\n}\n\nfunction patchSuspense(\n  n1: VNode,\n  n2: VNode,\n  container: RendererElement,\n  anchor: RendererNode | null,\n  parentComponent: ComponentInternalInstance | null,\n  isSVG: boolean,\n  slotScopeIds: string[] | null,\n  optimized: boolean,\n  { p: patch, um: unmount, o: { createElement } }: RendererInternals\n) {\n  const suspense = (n2.suspense = n1.suspense)!\n  suspense.vnode = n2\n  n2.el = n1.el\n  const newBranch = n2.ssContent!\n  const newFallback = n2.ssFallback!\n\n  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch\n    if (isSameVNodeType(newBranch, pendingBranch)) {\n      // same root type but content may have changed.\n      patch(\n        pendingBranch,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      )\n      if (suspense.deps <= 0) {\n        suspense.resolve()\n      } else if (isInFallback) {\n        patch(\n          activeBranch,\n          newFallback,\n          container,\n          anchor,\n          parentComponent,\n          null, // fallback tree will not have suspense context\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        setActiveBranch(suspense, newFallback)\n      }\n    } else {\n      // toggled before pending tree is resolved\n      suspense.pendingId++\n      if (isHydrating) {\n        // if toggled before hydration is finished, the current DOM tree is\n        // no longer valid. set it as the active branch so it will be unmounted\n        // when resolved\n        suspense.isHydrating = false\n        suspense.activeBranch = pendingBranch\n      } else {\n        unmount(pendingBranch, parentComponent, suspense)\n      }\n      // increment pending ID. this is used to invalidate async callbacks\n      // reset suspense state\n      suspense.deps = 0\n      // discard effects from pending branch\n      suspense.effects.length = 0\n      // discard previous container\n      suspense.hiddenContainer = createElement('div')\n\n      if (isInFallback) {\n        // already in fallback state\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        if (suspense.deps <= 0) {\n          suspense.resolve()\n        } else {\n          patch(\n            activeBranch,\n            newFallback,\n            container,\n            anchor,\n            parentComponent,\n            null, // fallback tree will not have suspense context\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n          setActiveBranch(suspense, newFallback)\n        }\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n        // toggled \"back\" to current active branch\n        patch(\n          activeBranch,\n          newBranch,\n          container,\n          anchor,\n          parentComponent,\n          suspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        // force resolve\n        suspense.resolve(true)\n      } else {\n        // switched to a 3rd branch\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        if (suspense.deps <= 0) {\n          suspense.resolve()\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n      // root did not change, just normal patch\n      patch(\n        activeBranch,\n        newBranch,\n        container,\n        anchor,\n        parentComponent,\n        suspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      )\n      setActiveBranch(suspense, newBranch)\n    } else {\n      // root node toggled\n      // invoke @pending event\n      triggerEvent(n2, 'onPending')\n      // mount pending branch in off-dom container\n      suspense.pendingBranch = newBranch\n      suspense.pendingId++\n      patch(\n        null,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        isSVG,\n        slotScopeIds,\n        optimized\n      )\n      if (suspense.deps <= 0) {\n        // incoming branch has no async deps, resolve now.\n        suspense.resolve()\n      } else {\n        const { timeout, pendingId } = suspense\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback)\n            }\n          }, timeout)\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback)\n        }\n      }\n    }\n  }\n}\n\nexport interface SuspenseBoundary {\n  vnode: VNode<RendererNode, RendererElement, SuspenseProps>\n  parent: SuspenseBoundary | null\n  parentComponent: ComponentInternalInstance | null\n  isSVG: boolean\n  container: RendererElement\n  hiddenContainer: RendererElement\n  anchor: RendererNode | null\n  activeBranch: VNode | null\n  pendingBranch: VNode | null\n  deps: number\n  pendingId: number\n  timeout: number\n  isInFallback: boolean\n  isHydrating: boolean\n  isUnmounted: boolean\n  effects: Function[]\n  resolve(force?: boolean): void\n  fallback(fallbackVNode: VNode): void\n  move(\n    container: RendererElement,\n    anchor: RendererNode | null,\n    type: MoveType\n  ): void\n  next(): RendererNode | null\n  registerDep(\n    instance: ComponentInternalInstance,\n    setupRenderEffect: SetupRenderEffectFn\n  ): void\n  unmount(parentSuspense: SuspenseBoundary | null, doRemove?: boolean): void\n}\n\nlet hasWarned = false\n\nfunction createSuspenseBoundary(\n  vnode: VNode,\n  parent: SuspenseBoundary | null,\n  parentComponent: ComponentInternalInstance | null,\n  container: RendererElement,\n  hiddenContainer: RendererElement,\n  anchor: RendererNode | null,\n  isSVG: boolean,\n  slotScopeIds: string[] | null,\n  optimized: boolean,\n  rendererInternals: RendererInternals,\n  isHydrating = false\n): SuspenseBoundary {\n  /* istanbul ignore if */\n  if (__DEV__ && !__TEST__ && !hasWarned) {\n    hasWarned = true\n    // @ts-ignore `console.info` cannot be null error\n    console[console.info ? 'info' : 'log'](\n      `<Suspense> is an experimental feature and its API will likely change.`\n    )\n  }\n\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: { parentNode, remove }\n  } = rendererInternals\n\n  const timeout = toNumber(vnode.props && vnode.props.timeout)\n  const suspense: SuspenseBoundary = {\n    vnode,\n    parent,\n    parentComponent,\n    isSVG,\n    container,\n    hiddenContainer,\n    anchor,\n    deps: 0,\n    pendingId: 0,\n    timeout: typeof timeout === 'number' ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: true,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n\n    resolve(resume = false) {\n      if (__DEV__) {\n        if (!resume && !suspense.pendingBranch) {\n          throw new Error(\n            `suspense.resolve() is called without a pending branch.`\n          )\n        }\n        if (suspense.isUnmounted) {\n          throw new Error(\n            `suspense.resolve() is called on an already unmounted suspense boundary.`\n          )\n        }\n      }\n      const {\n        vnode,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent,\n        container\n      } = suspense\n\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false\n      } else if (!resume) {\n        const delayEnter =\n          activeBranch &&\n          pendingBranch!.transition &&\n          pendingBranch!.transition.mode === 'out-in'\n        if (delayEnter) {\n          activeBranch!.transition!.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(pendingBranch!, container, anchor, MoveType.ENTER)\n            }\n          }\n        }\n        // this is initial anchor on mount\n        let { anchor } = suspense\n        // unmount current active tree\n        if (activeBranch) {\n          // if the fallback tree was mounted, it may have been moved\n          // as part of a parent suspense. get the latest anchor for insertion\n          anchor = next(activeBranch)\n          unmount(activeBranch, parentComponent, suspense, true)\n        }\n        if (!delayEnter) {\n          // move content from off-dom container to actual container\n          move(pendingBranch!, container, anchor, MoveType.ENTER)\n        }\n      }\n\n      setActiveBranch(suspense, pendingBranch!)\n      suspense.pendingBranch = null\n      suspense.isInFallback = false\n\n      // flush buffered effects\n      // check if there is a pending parent suspense\n      let parent = suspense.parent\n      let hasUnresolvedAncestor = false\n      while (parent) {\n        if (parent.pendingBranch) {\n          // found a pending parent suspense, merge buffered post jobs\n          // into that parent\n          parent.effects.push(...effects)\n          hasUnresolvedAncestor = true\n          break\n        }\n        parent = parent.parent\n      }\n      // no pending parent suspense, flush all jobs\n      if (!hasUnresolvedAncestor) {\n        queuePostFlushCb(effects)\n      }\n      suspense.effects = []\n\n      // invoke @resolve event\n      triggerEvent(vnode, 'onResolve')\n    },\n\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return\n      }\n\n      const { vnode, activeBranch, parentComponent, container, isSVG } =\n        suspense\n\n      // invoke @fallback event\n      triggerEvent(vnode, 'onFallback')\n\n      const anchor = next(activeBranch!)\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return\n        }\n        // mount the fallback tree\n        patch(\n          null,\n          fallbackVNode,\n          container,\n          anchor,\n          parentComponent,\n          null, // fallback tree will not have suspense context\n          isSVG,\n          slotScopeIds,\n          optimized\n        )\n        setActiveBranch(suspense, fallbackVNode)\n      }\n\n      const delayEnter =\n        fallbackVNode.transition && fallbackVNode.transition.mode === 'out-in'\n      if (delayEnter) {\n        activeBranch!.transition!.afterLeave = mountFallback\n      }\n      suspense.isInFallback = true\n\n      // unmount current active branch\n      unmount(\n        activeBranch!,\n        parentComponent,\n        null, // no suspense so unmount hooks fire now\n        true // shouldRemove\n      )\n\n      if (!delayEnter) {\n        mountFallback()\n      }\n    },\n\n    move(container, anchor, type) {\n      suspense.activeBranch &&\n        move(suspense.activeBranch, container, anchor, type)\n      suspense.container = container\n    },\n\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch)\n    },\n\n    registerDep(instance, setupRenderEffect) {\n      const isInPendingSuspense = !!suspense.pendingBranch\n      if (isInPendingSuspense) {\n        suspense.deps++\n      }\n      const hydratedEl = instance.vnode.el\n      instance\n        .asyncDep!.catch(err => {\n          handleError(err, instance, ErrorCodes.SETUP_FUNCTION)\n        })\n        .then(asyncSetupResult => {\n          // retry when the setup() promise resolves.\n          // component may have been unmounted before resolve.\n          if (\n            instance.isUnmounted ||\n            suspense.isUnmounted ||\n            suspense.pendingId !== instance.suspenseId\n          ) {\n            return\n          }\n          // retry from this component\n          instance.asyncResolved = true\n          const { vnode } = instance\n          if (__DEV__) {\n            pushWarningContext(vnode)\n          }\n          handleSetupResult(instance, asyncSetupResult, false)\n          if (hydratedEl) {\n            // vnode may have been replaced if an update happened before the\n            // async dep is resolved.\n            vnode.el = hydratedEl\n          }\n          const placeholder = !hydratedEl && instance.subTree.el\n          setupRenderEffect(\n            instance,\n            vnode,\n            // component may have been moved before resolve.\n            // if this is not a hydration, instance.subTree will be the comment\n            // placeholder.\n            parentNode(hydratedEl || instance.subTree.el!)!,\n            // anchor will not be used if this is hydration, so only need to\n            // consider the comment placeholder case.\n            hydratedEl ? null : next(instance.subTree),\n            suspense,\n            isSVG,\n            optimized\n          )\n          if (placeholder) {\n            remove(placeholder)\n          }\n          updateHOCHostEl(instance, vnode.el)\n          if (__DEV__) {\n            popWarningContext()\n          }\n          // only decrease deps count if suspense is not already resolved\n          if (isInPendingSuspense && --suspense.deps === 0) {\n            suspense.resolve()\n          }\n        })\n    },\n\n    unmount(parentSuspense, doRemove) {\n      suspense.isUnmounted = true\n      if (suspense.activeBranch) {\n        unmount(\n          suspense.activeBranch,\n          parentComponent,\n          parentSuspense,\n          doRemove\n        )\n      }\n      if (suspense.pendingBranch) {\n        unmount(\n          suspense.pendingBranch,\n          parentComponent,\n          parentSuspense,\n          doRemove\n        )\n      }\n    }\n  }\n\n  return suspense\n}\n\nfunction hydrateSuspense(\n  node: Node,\n  vnode: VNode,\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  isSVG: boolean,\n  slotScopeIds: string[] | null,\n  optimized: boolean,\n  rendererInternals: RendererInternals,\n  hydrateNode: (\n    node: Node,\n    vnode: VNode,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => Node | null\n): Node | null {\n  /* eslint-disable no-restricted-globals */\n  const suspense = (vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    node.parentNode!,\n    document.createElement('div'),\n    null,\n    isSVG,\n    slotScopeIds,\n    optimized,\n    rendererInternals,\n    true /* hydrating */\n  ))\n  // there are two possible scenarios for server-rendered suspense:\n  // - success: ssr content should be fully resolved\n  // - failure: ssr content should be the fallback branch.\n  // however, on the client we don't really know if it has failed or not\n  // attempt to hydrate the DOM assuming it has succeeded, but we still\n  // need to construct a suspense boundary first\n  const result = hydrateNode(\n    node,\n    (suspense.pendingBranch = vnode.ssContent!),\n    parentComponent,\n    suspense,\n    slotScopeIds,\n    optimized\n  )\n  if (suspense.deps === 0) {\n    suspense.resolve()\n  }\n  return result\n  /* eslint-enable no-restricted-globals */\n}\n\nfunction normalizeSuspenseChildren(vnode: VNode) {\n  const { shapeFlag, children } = vnode\n  const isSlotChildren = shapeFlag & ShapeFlags.SLOTS_CHILDREN\n  vnode.ssContent = normalizeSuspenseSlot(\n    isSlotChildren ? (children as Slots).default : children\n  )\n  vnode.ssFallback = isSlotChildren\n    ? normalizeSuspenseSlot((children as Slots).fallback)\n    : createVNode(Comment)\n}\n\nfunction normalizeSuspenseSlot(s: any) {\n  let block: VNode[] | null | undefined\n  if (isFunction(s)) {\n    const trackBlock = isBlockTreeEnabled && s._c\n    if (trackBlock) {\n      // disableTracking: false\n      // allow block tracking for compiled slots\n      // (see ./componentRenderContext.ts)\n      s._d = false\n      openBlock()\n    }\n    s = s()\n    if (trackBlock) {\n      s._d = true\n      block = currentBlock\n      closeBlock()\n    }\n  }\n  if (isArray(s)) {\n    const singleChild = filterSingleRoot(s)\n    if (__DEV__ && !singleChild) {\n      warn(`<Suspense> slots expect a single root node.`)\n    }\n    s = singleChild\n  }\n  s = normalizeVNode(s)\n  if (block && !s.dynamicChildren) {\n    s.dynamicChildren = block.filter(c => c !== s)\n  }\n  return s\n}\n\nexport function queueEffectWithSuspense(\n  fn: Function | Function[],\n  suspense: SuspenseBoundary | null\n): void {\n  if (suspense && suspense.pendingBranch) {\n    if (isArray(fn)) {\n      suspense.effects.push(...fn)\n    } else {\n      suspense.effects.push(fn)\n    }\n  } else {\n    queuePostFlushCb(fn)\n  }\n}\n\nfunction setActiveBranch(suspense: SuspenseBoundary, branch: VNode) {\n  suspense.activeBranch = branch\n  const { vnode, parentComponent } = suspense\n  const el = (vnode.el = branch.el)\n  // in case suspense is the root node of a component,\n  // recursively update the HOC el\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el\n    updateHOCHostEl(parentComponent, el)\n  }\n}\n", "import { ComponentInternalInstance } from '../component'\nimport { SuspenseBoundary } from './Suspense'\nimport {\n  RendererInternals,\n  MoveType,\n  RendererElement,\n  RendererNode,\n  RendererOptions,\n  traverseStaticChildren\n} from '../renderer'\nimport { VNode, VNodeArrayChildren, VNodeProps } from '../vnode'\nimport { isString, ShapeFlags } from '@vue/shared'\nimport { warn } from '../warning'\nimport { isHmrUpdating } from '../hmr'\n\nexport type TeleportVNode = VNode<RendererNode, RendererElement, TeleportProps>\n\nexport interface TeleportProps {\n  to: string | RendererElement | null | undefined\n  disabled?: boolean\n}\n\nexport const isTeleport = (type: any): boolean => type.__isTeleport\n\nconst isTeleportDisabled = (props: VNode['props']): boolean =>\n  props && (props.disabled || props.disabled === '')\n\nconst isTargetSVG = (target: RendererElement): boolean =>\n  typeof SVGElement !== 'undefined' && target instanceof SVGElement\n\nconst resolveTarget = <T = RendererElement>(\n  props: TeleportProps | null,\n  select: RendererOptions['querySelector']\n): T | null => {\n  const targetSelector = props && props.to\n  if (isString(targetSelector)) {\n    if (!select) {\n      __DEV__ &&\n        warn(\n          `Current renderer does not support string target for Teleports. ` +\n            `(missing querySelector renderer option)`\n        )\n      return null\n    } else {\n      const target = select(targetSelector)\n      if (!target) {\n        __DEV__ &&\n          warn(\n            `Failed to locate Teleport target with selector \"${targetSelector}\". ` +\n              `Note the target element must exist before the component is mounted - ` +\n              `i.e. the target cannot be rendered by the component itself, and ` +\n              `ideally should be outside of the entire Vue component tree.`\n          )\n      }\n      return target as any\n    }\n  } else {\n    if (__DEV__ && !targetSelector && !isTeleportDisabled(props)) {\n      warn(`Invalid Teleport target: ${targetSelector}`)\n    }\n    return targetSelector as any\n  }\n}\n\nexport const TeleportImpl = {\n  __isTeleport: true,\n  process(\n    n1: TeleportVNode | null,\n    n2: TeleportVNode,\n    container: RendererElement,\n    anchor: RendererNode | null,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    isSVG: boolean,\n    slotScopeIds: string[] | null,\n    optimized: boolean,\n    internals: RendererInternals\n  ) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: { insert, querySelector, createText, createComment }\n    } = internals\n\n    const disabled = isTeleportDisabled(n2.props)\n    let { shapeFlag, children, dynamicChildren } = n2\n\n    // #3302\n    // HMR updated, force full diff\n    if (__DEV__ && isHmrUpdating) {\n      optimized = false\n      dynamicChildren = null\n    }\n\n    if (n1 == null) {\n      // insert anchors in the main view\n      const placeholder = (n2.el = __DEV__\n        ? createComment('teleport start')\n        : createText(''))\n      const mainAnchor = (n2.anchor = __DEV__\n        ? createComment('teleport end')\n        : createText(''))\n      insert(placeholder, container, anchor)\n      insert(mainAnchor, container, anchor)\n      const target = (n2.target = resolveTarget(n2.props, querySelector))\n      const targetAnchor = (n2.targetAnchor = createText(''))\n      if (target) {\n        insert(targetAnchor, target)\n        // #2652 we could be teleporting from a non-SVG tree into an SVG tree\n        isSVG = isSVG || isTargetSVG(target)\n      } else if (__DEV__ && !disabled) {\n        warn('Invalid Teleport target on mount:', target, `(${typeof target})`)\n      }\n\n      const mount = (container: RendererElement, anchor: RendererNode) => {\n        // Teleport *always* has Array children. This is enforced in both the\n        // compiler and vnode children normalization.\n        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n          mountChildren(\n            children as VNodeArrayChildren,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            isSVG,\n            slotScopeIds,\n            optimized\n          )\n        }\n      }\n\n      if (disabled) {\n        mount(container, mainAnchor)\n      } else if (target) {\n        mount(target, targetAnchor)\n      }\n    } else {\n      // update content\n      n2.el = n1.el\n      const mainAnchor = (n2.anchor = n1.anchor)!\n      const target = (n2.target = n1.target)!\n      const targetAnchor = (n2.targetAnchor = n1.targetAnchor)!\n      const wasDisabled = isTeleportDisabled(n1.props)\n      const currentContainer = wasDisabled ? container : target\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor\n      isSVG = isSVG || isTargetSVG(target)\n\n      if (dynamicChildren) {\n        // fast path when the teleport happens to be a block root\n        patchBlockChildren(\n          n1.dynamicChildren!,\n          dynamicChildren,\n          currentContainer,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds\n        )\n        // even in block tree mode we need to make sure all root-level nodes\n        // in the teleport inherit previous DOM references so that they can\n        // be moved in future patches.\n        traverseStaticChildren(n1, n2, true)\n      } else if (!optimized) {\n        patchChildren(\n          n1,\n          n2,\n          currentContainer,\n          currentAnchor,\n          parentComponent,\n          parentSuspense,\n          isSVG,\n          slotScopeIds,\n          false\n        )\n      }\n\n      if (disabled) {\n        if (!wasDisabled) {\n          // enabled -> disabled\n          // move into main container\n          moveTeleport(\n            n2,\n            container,\n            mainAnchor,\n            internals,\n            TeleportMoveTypes.TOGGLE\n          )\n        }\n      } else {\n        // target changed\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = (n2.target = resolveTarget(\n            n2.props,\n            querySelector\n          ))\n          if (nextTarget) {\n            moveTeleport(\n              n2,\n              nextTarget,\n              null,\n              internals,\n              TeleportMoveTypes.TARGET_CHANGE\n            )\n          } else if (__DEV__) {\n            warn(\n              'Invalid Teleport target on update:',\n              target,\n              `(${typeof target})`\n            )\n          }\n        } else if (wasDisabled) {\n          // disabled -> enabled\n          // move into teleport target\n          moveTeleport(\n            n2,\n            target,\n            targetAnchor,\n            internals,\n            TeleportMoveTypes.TOGGLE\n          )\n        }\n      }\n    }\n  },\n\n  remove(\n    vnode: VNode,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    optimized: boolean,\n    { um: unmount, o: { remove: hostRemove } }: RendererInternals,\n    doRemove: Boolean\n  ) {\n    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode\n\n    if (target) {\n      hostRemove(targetAnchor!)\n    }\n\n    // an unmounted teleport should always remove its children if not disabled\n    if (doRemove || !isTeleportDisabled(props)) {\n      hostRemove(anchor!)\n      if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n        for (let i = 0; i < (children as VNode[]).length; i++) {\n          const child = (children as VNode[])[i]\n          unmount(\n            child,\n            parentComponent,\n            parentSuspense,\n            true,\n            !!child.dynamicChildren\n          )\n        }\n      }\n    }\n  },\n\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n}\n\nexport const enum TeleportMoveTypes {\n  TARGET_CHANGE,\n  TOGGLE, // enable / disable\n  REORDER // moved in the main view\n}\n\nfunction moveTeleport(\n  vnode: VNode,\n  container: RendererElement,\n  parentAnchor: RendererNode | null,\n  { o: { insert }, m: move }: RendererInternals,\n  moveType: TeleportMoveTypes = TeleportMoveTypes.REORDER\n) {\n  // move target anchor if this is a target change.\n  if (moveType === TeleportMoveTypes.TARGET_CHANGE) {\n    insert(vnode.targetAnchor!, container, parentAnchor)\n  }\n  const { el, anchor, shapeFlag, children, props } = vnode\n  const isReorder = moveType === TeleportMoveTypes.REORDER\n  // move main view anchor if this is a re-order.\n  if (isReorder) {\n    insert(el!, container, parentAnchor)\n  }\n  // if this is a re-order and teleport is enabled (content is in target)\n  // do not move children. So the opposite is: only move children if this\n  // is not a reorder, or the teleport is disabled\n  if (!isReorder || isTeleportDisabled(props)) {\n    // Teleport has either Array children or no children.\n    if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n      for (let i = 0; i < (children as VNode[]).length; i++) {\n        move(\n          (children as VNode[])[i],\n          container,\n          parentAnchor,\n          MoveType.REORDER\n        )\n      }\n    }\n  }\n  // move main view anchor if this is a re-order.\n  if (isReorder) {\n    insert(anchor!, container, parentAnchor)\n  }\n}\n\ninterface TeleportTargetElement extends Element {\n  // last teleport target\n  _lpa?: Node | null\n}\n\nfunction hydrateTeleport(\n  node: Node,\n  vnode: TeleportVNode,\n  parentComponent: ComponentInternalInstance | null,\n  parentSuspense: SuspenseBoundary | null,\n  slotScopeIds: string[] | null,\n  optimized: boolean,\n  {\n    o: { nextSibling, parentNode, querySelector }\n  }: RendererInternals<Node, Element>,\n  hydrateChildren: (\n    node: Node | null,\n    vnode: VNode,\n    container: Element,\n    parentComponent: ComponentInternalInstance | null,\n    parentSuspense: SuspenseBoundary | null,\n    slotScopeIds: string[] | null,\n    optimized: boolean\n  ) => Node | null\n): Node | null {\n  const target = (vnode.target = resolveTarget<Element>(\n    vnode.props,\n    querySelector\n  ))\n  if (target) {\n    // if multiple teleports rendered to the same target element, we need to\n    // pick up from where the last teleport finished instead of the first node\n    const targetNode =\n      (target as TeleportTargetElement)._lpa || target.firstChild\n    if (vnode.shapeFlag & ShapeFlags.ARRAY_CHILDREN) {\n      if (isTeleportDisabled(vnode.props)) {\n        vnode.anchor = hydrateChildren(\n          nextSibling(node),\n          vnode,\n          parentNode(node)!,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        )\n        vnode.targetAnchor = targetNode\n      } else {\n        vnode.anchor = nextSibling(node)\n        vnode.targetAnchor = hydrateChildren(\n          targetNode,\n          vnode,\n          target,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        )\n      }\n      ;(target as TeleportTargetElement)._lpa =\n        vnode.targetAnchor && nextSibling(vnode.targetAnchor as Node)\n    }\n  }\n  return vnode.anchor && nextSibling(vnode.anchor as Node)\n}\n\n// Force-casted public typing for h and TSX props inference\nexport const Teleport = TeleportImpl as any as {\n  __isTeleport: true\n  new (): { $props: VNodeProps & TeleportProps }\n}\n", "import {\n  currentInstance,\n  ConcreteComponent,\n  ComponentOptions,\n  getComponentName\n} from '../component'\nimport { currentRenderingInstance } from '../componentRenderContext'\nimport { Directive } from '../directives'\nimport { camelize, capitalize, isString } from '@vue/shared'\nimport { warn } from '../warning'\nimport { VNodeTypes } from '../vnode'\n\nexport const COMPONENTS = 'components'\nexport const DIRECTIVES = 'directives'\nexport const FILTERS = 'filters'\n\nexport type AssetTypes = typeof COMPONENTS | typeof DIRECTIVES | typeof FILTERS\n\n/**\n * @private\n */\nexport function resolveComponent(\n  name: string,\n  maybeSelfReference?: boolean\n): ConcreteComponent | string {\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name\n}\n\nexport const NULL_DYNAMIC_COMPONENT = Symbol()\n\n/**\n * @private\n */\nexport function resolveDynamicComponent(component: unknown): VNodeTypes {\n  if (isString(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component\n  } else {\n    // invalid types will fallthrough to createVNode and raise warning\n    return (component || NULL_DYNAMIC_COMPONENT) as any\n  }\n}\n\n/**\n * @private\n */\nexport function resolveDirective(name: string): Directive | undefined {\n  return resolveAsset(DIRECTIVES, name)\n}\n\n/**\n * v2 compat only\n * @internal\n */\nexport function resolveFilter(name: string): Function | undefined {\n  return resolveAsset(FILTERS, name)\n}\n\n/**\n * @private\n * overload 1: components\n */\nfunction resolveAsset(\n  type: typeof COMPONENTS,\n  name: string,\n  warnMissing?: boolean,\n  maybeSelfReference?: boolean\n): ConcreteComponent | undefined\n// overload 2: directives\nfunction resolveAsset(\n  type: typeof DIRECTIVES,\n  name: string\n): Directive | undefined\n// implementation\n// overload 3: filters (compat only)\nfunction resolveAsset(type: typeof FILTERS, name: string): Function | undefined\n// implementation\nfunction resolveAsset(\n  type: AssetTypes,\n  name: string,\n  warnMissing = true,\n  maybeSelfReference = false\n) {\n  const instance = currentRenderingInstance || currentInstance\n  if (instance) {\n    const Component = instance.type\n\n    // explicit self name has highest priority\n    if (type === COMPONENTS) {\n      const selfName = getComponentName(Component)\n      if (\n        selfName &&\n        (selfName === name ||\n          selfName === camelize(name) ||\n          selfName === capitalize(camelize(name)))\n      ) {\n        return Component\n      }\n    }\n\n    const res =\n      // local registration\n      // check instance[type] first which is resolved for options API\n      resolve(instance[type] || (Component as ComponentOptions)[type], name) ||\n      // global registration\n      resolve(instance.appContext[type], name)\n\n    if (!res && maybeSelfReference) {\n      // fallback to implicit self-reference\n      return Component\n    }\n\n    if (__DEV__ && warnMissing && !res) {\n      const extra =\n        type === COMPONENTS\n          ? `\\nIf this is a native custom element, make sure to exclude it from ` +\n            `component resolution via compilerOptions.isCustomElement.`\n          : ``\n      warn(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`)\n    }\n\n    return res\n  } else if (__DEV__) {\n    warn(\n      `resolve${capitalize(type.slice(0, -1))} ` +\n        `can only be used in render() or setup().`\n    )\n  }\n}\n\nfunction resolve(registry: Record<string, any> | undefined, name: string) {\n  return (\n    registry &&\n    (registry[name] ||\n      registry[camelize(name)] ||\n      registry[capitalize(camelize(name))])\n  )\n}\n", "import {\n  isArray,\n  isFunction,\n  isString,\n  isObject,\n  EMPTY_ARR,\n  extend,\n  normalizeClass,\n  normalizeStyle,\n  PatchFlags,\n  ShapeFlags,\n  SlotFlags,\n  isOn\n} from '@vue/shared'\nimport {\n  ComponentInternalInstance,\n  Data,\n  ConcreteComponent,\n  ClassComponent,\n  Component,\n  isClassComponent\n} from './component'\nimport { RawSlots } from './componentSlots'\nimport { isProxy, Ref, toRaw, ReactiveFlags, isRef } from '@vue/reactivity'\nimport { AppContext } from './apiCreateApp'\nimport {\n  SuspenseImpl,\n  isSuspense,\n  SuspenseBoundary\n} from './components/Suspense'\nimport { DirectiveBinding } from './directives'\nimport { TransitionHooks } from './components/BaseTransition'\nimport { warn } from './warning'\nimport { TeleportImpl, isTeleport } from './components/Teleport'\nimport {\n  currentRenderingInstance,\n  currentScopeId\n} from './componentRenderContext'\nimport { RendererNode, RendererElement } from './renderer'\nimport { NULL_DYNAMIC_COMPONENT } from './helpers/resolveAssets'\nimport { hmrDirtyComponents } from './hmr'\nimport { convertLegacyComponent } from './compat/component'\nimport { convertLegacyVModelProps } from './compat/componentVModel'\nimport { defineLegacyVNodeProperties } from './compat/renderFn'\nimport { callWithAsyncErrorHandling, ErrorCodes } from './errorHandling'\n\nexport const Fragment = Symbol(__DEV__ ? 'Fragment' : undefined) as any as {\n  __isFragment: true\n  new (): {\n    $props: VNodeProps\n  }\n}\nexport const Text = Symbol(__DEV__ ? 'Text' : undefined)\nexport const Comment = Symbol(__DEV__ ? 'Comment' : undefined)\nexport const Static = Symbol(__DEV__ ? 'Static' : undefined)\n\nexport type VNodeTypes =\n  | string\n  | VNode\n  | Component\n  | typeof Text\n  | typeof Static\n  | typeof Comment\n  | typeof Fragment\n  | typeof TeleportImpl\n  | typeof SuspenseImpl\n\nexport type VNodeRef =\n  | string\n  | Ref\n  | ((ref: object | null, refs: Record<string, any>) => void)\n\nexport type VNodeNormalizedRefAtom = {\n  i: ComponentInternalInstance\n  r: VNodeRef\n  k?: string // setup ref key\n  f?: boolean // refInFor marker\n}\n\nexport type VNodeNormalizedRef =\n  | VNodeNormalizedRefAtom\n  | VNodeNormalizedRefAtom[]\n\ntype VNodeMountHook = (vnode: VNode) => void\ntype VNodeUpdateHook = (vnode: VNode, oldVNode: VNode) => void\nexport type VNodeHook =\n  | VNodeMountHook\n  | VNodeUpdateHook\n  | VNodeMountHook[]\n  | VNodeUpdateHook[]\n\n// https://github.com/microsoft/TypeScript/issues/33099\nexport type VNodeProps = {\n  key?: string | number | symbol\n  ref?: VNodeRef\n  ref_for?: boolean\n  ref_key?: string\n\n  // vnode hooks\n  onVnodeBeforeMount?: VNodeMountHook | VNodeMountHook[]\n  onVnodeMounted?: VNodeMountHook | VNodeMountHook[]\n  onVnodeBeforeUpdate?: VNodeUpdateHook | VNodeUpdateHook[]\n  onVnodeUpdated?: VNodeUpdateHook | VNodeUpdateHook[]\n  onVnodeBeforeUnmount?: VNodeMountHook | VNodeMountHook[]\n  onVnodeUnmounted?: VNodeMountHook | VNodeMountHook[]\n}\n\ntype VNodeChildAtom =\n  | VNode\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | void\n\nexport type VNodeArrayChildren = Array<VNodeArrayChildren | VNodeChildAtom>\n\nexport type VNodeChild = VNodeChildAtom | VNodeArrayChildren\n\nexport type VNodeNormalizedChildren =\n  | string\n  | VNodeArrayChildren\n  | RawSlots\n  | null\n\nexport interface VNode<\n  HostNode = RendererNode,\n  HostElement = RendererElement,\n  ExtraProps = { [key: string]: any }\n> {\n  /**\n   * @internal\n   */\n  __v_isVNode: true\n\n  /**\n   * @internal\n   */\n  [ReactiveFlags.SKIP]: true\n\n  type: VNodeTypes\n  props: (VNodeProps & ExtraProps) | null\n  key: string | number | symbol | null\n  ref: VNodeNormalizedRef | null\n  /**\n   * SFC only. This is assigned on vnode creation using currentScopeId\n   * which is set alongside currentRenderingInstance.\n   */\n  scopeId: string | null\n  /**\n   * SFC only. This is assigned to:\n   * - Slot fragment vnodes with :slotted SFC styles.\n   * - Component vnodes (during patch/hydration) so that its root node can\n   *   inherit the component's slotScopeIds\n   * @internal\n   */\n  slotScopeIds: string[] | null\n  children: VNodeNormalizedChildren\n  component: ComponentInternalInstance | null\n  dirs: DirectiveBinding[] | null\n  transition: TransitionHooks<HostElement> | null\n\n  // DOM\n  el: HostNode | null\n  anchor: HostNode | null // fragment anchor\n  target: HostElement | null // teleport target\n  targetAnchor: HostNode | null // teleport target anchor\n  /**\n   * number of elements contained in a static vnode\n   * @internal\n   */\n  staticCount: number\n\n  // suspense\n  suspense: SuspenseBoundary | null\n  /**\n   * @internal\n   */\n  ssContent: VNode | null\n  /**\n   * @internal\n   */\n  ssFallback: VNode | null\n\n  // optimization only\n  shapeFlag: number\n  patchFlag: number\n  /**\n   * @internal\n   */\n  dynamicProps: string[] | null\n  /**\n   * @internal\n   */\n  dynamicChildren: VNode[] | null\n\n  // application root node only\n  appContext: AppContext | null\n\n  /**\n   * @internal attached by v-memo\n   */\n  memo?: any[]\n  /**\n   * @internal __COMPAT__ only\n   */\n  isCompatRoot?: true\n  /**\n   * @internal custom element interception hook\n   */\n  ce?: (instance: ComponentInternalInstance) => void\n}\n\n// Since v-if and v-for are the two possible ways node structure can dynamically\n// change, once we consider v-if branches and each v-for fragment a block, we\n// can divide a template into nested blocks, and within each block the node\n// structure would be stable. This allows us to skip most children diffing\n// and only worry about the dynamic nodes (indicated by patch flags).\nexport const blockStack: (VNode[] | null)[] = []\nexport let currentBlock: VNode[] | null = null\n\n/**\n * Open a block.\n * This must be called before `createBlock`. It cannot be part of `createBlock`\n * because the children of the block are evaluated before `createBlock` itself\n * is called. The generated code typically looks like this:\n *\n * ```js\n * function render() {\n *   return (openBlock(),createBlock('div', null, [...]))\n * }\n * ```\n * disableTracking is true when creating a v-for fragment block, since a v-for\n * fragment always diffs its children.\n *\n * @private\n */\nexport function openBlock(disableTracking = false) {\n  blockStack.push((currentBlock = disableTracking ? null : []))\n}\n\nexport function closeBlock() {\n  blockStack.pop()\n  currentBlock = blockStack[blockStack.length - 1] || null\n}\n\n// Whether we should be tracking dynamic child nodes inside a block.\n// Only tracks when this value is > 0\n// We are not using a simple boolean because this value may need to be\n// incremented/decremented by nested usage of v-once (see below)\nexport let isBlockTreeEnabled = 1\n\n/**\n * Block tracking sometimes needs to be disabled, for example during the\n * creation of a tree that needs to be cached by v-once. The compiler generates\n * code like this:\n *\n * ``` js\n * _cache[1] || (\n *   setBlockTracking(-1),\n *   _cache[1] = createVNode(...),\n *   setBlockTracking(1),\n *   _cache[1]\n * )\n * ```\n *\n * @private\n */\nexport function setBlockTracking(value: number) {\n  isBlockTreeEnabled += value\n}\n\nfunction setupBlock(vnode: VNode) {\n  // save current block children on the block vnode\n  vnode.dynamicChildren =\n    isBlockTreeEnabled > 0 ? currentBlock || (EMPTY_ARR as any) : null\n  // close block\n  closeBlock()\n  // a block is always going to be patched, so track it as a child of its\n  // parent block\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode)\n  }\n  return vnode\n}\n\n/**\n * @private\n */\nexport function createElementBlock(\n  type: string | typeof Fragment,\n  props?: Record<string, any> | null,\n  children?: any,\n  patchFlag?: number,\n  dynamicProps?: string[],\n  shapeFlag?: number\n) {\n  return setupBlock(\n    createBaseVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      shapeFlag,\n      true /* isBlock */\n    )\n  )\n}\n\n/**\n * Create a block root vnode. Takes the same exact arguments as `createVNode`.\n * A block root keeps track of dynamic nodes within the block in the\n * `dynamicChildren` array.\n *\n * @private\n */\nexport function createBlock(\n  type: VNodeTypes | ClassComponent,\n  props?: Record<string, any> | null,\n  children?: any,\n  patchFlag?: number,\n  dynamicProps?: string[]\n): VNode {\n  return setupBlock(\n    createVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      true /* isBlock: prevent a block from tracking itself */\n    )\n  )\n}\n\nexport function isVNode(value: any): value is VNode {\n  return value ? value.__v_isVNode === true : false\n}\n\nexport function isSameVNodeType(n1: VNode, n2: VNode): boolean {\n  if (\n    __DEV__ &&\n    n2.shapeFlag & ShapeFlags.COMPONENT &&\n    hmrDirtyComponents.has(n2.type as ConcreteComponent)\n  ) {\n    // HMR only: if the component has been hot-updated, force a reload.\n    return false\n  }\n  return n1.type === n2.type && n1.key === n2.key\n}\n\nlet vnodeArgsTransformer:\n  | ((\n      args: Parameters<typeof _createVNode>,\n      instance: ComponentInternalInstance | null\n    ) => Parameters<typeof _createVNode>)\n  | undefined\n\n/**\n * Internal API for registering an arguments transform for createVNode\n * used for creating stubs in the test-utils\n * It is *internal* but needs to be exposed for test-utils to pick up proper\n * typings\n */\nexport function transformVNodeArgs(transformer?: typeof vnodeArgsTransformer) {\n  vnodeArgsTransformer = transformer\n}\n\nconst createVNodeWithArgsTransform = (\n  ...args: Parameters<typeof _createVNode>\n): VNode => {\n  return _createVNode(\n    ...(vnodeArgsTransformer\n      ? vnodeArgsTransformer(args, currentRenderingInstance)\n      : args)\n  )\n}\n\nexport const InternalObjectKey = `__vInternal`\n\nconst normalizeKey = ({ key }: VNodeProps): VNode['key'] =>\n  key != null ? key : null\n\nconst normalizeRef = ({\n  ref,\n  ref_key,\n  ref_for\n}: VNodeProps): VNodeNormalizedRefAtom | null => {\n  return (\n    ref != null\n      ? isString(ref) || isRef(ref) || isFunction(ref)\n        ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for }\n        : ref\n      : null\n  ) as any\n}\n\nfunction createBaseVNode(\n  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,\n  props: (Data & VNodeProps) | null = null,\n  children: unknown = null,\n  patchFlag = 0,\n  dynamicProps: string[] | null = null,\n  shapeFlag = type === Fragment ? 0 : ShapeFlags.ELEMENT,\n  isBlockNode = false,\n  needFullChildrenNormalization = false\n) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null\n  } as VNode\n\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children)\n    // normalize suspense children\n    if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {\n      ;(type as typeof SuspenseImpl).normalize(vnode)\n    }\n  } else if (children) {\n    // compiled element vnode - if children is passed, only possible types are\n    // string or Array.\n    vnode.shapeFlag |= isString(children)\n      ? ShapeFlags.TEXT_CHILDREN\n      : ShapeFlags.ARRAY_CHILDREN\n  }\n\n  // validate key\n  if (__DEV__ && vnode.key !== vnode.key) {\n    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type)\n  }\n\n  // track vnode for block tree\n  if (\n    isBlockTreeEnabled > 0 &&\n    // avoid a block node from tracking itself\n    !isBlockNode &&\n    // has current parent block\n    currentBlock &&\n    // presence of a patch flag indicates this node needs patching on updates.\n    // component nodes also should always be patched, because even if the\n    // component doesn't need to update, it needs to persist the instance on to\n    // the next vnode so that it can be properly unmounted later.\n    (vnode.patchFlag > 0 || shapeFlag & ShapeFlags.COMPONENT) &&\n    // the EVENTS flag is only for hydration and if it is the only flag, the\n    // vnode should not be considered dynamic due to handler caching.\n    vnode.patchFlag !== PatchFlags.HYDRATE_EVENTS\n  ) {\n    currentBlock.push(vnode)\n  }\n\n  if (__COMPAT__) {\n    convertLegacyVModelProps(vnode)\n    defineLegacyVNodeProperties(vnode)\n  }\n\n  return vnode\n}\n\nexport { createBaseVNode as createElementVNode }\n\nexport const createVNode = (\n  __DEV__ ? createVNodeWithArgsTransform : _createVNode\n) as typeof _createVNode\n\nfunction _createVNode(\n  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,\n  props: (Data & VNodeProps) | null = null,\n  children: unknown = null,\n  patchFlag: number = 0,\n  dynamicProps: string[] | null = null,\n  isBlockNode = false\n): VNode {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    if (__DEV__ && !type) {\n      warn(`Invalid vnode type when creating vnode: ${type}.`)\n    }\n    type = Comment\n  }\n\n  if (isVNode(type)) {\n    // createVNode receiving an existing vnode. This happens in cases like\n    // <component :is=\"vnode\"/>\n    // #2078 make sure to merge refs during the clone instead of overwriting it\n    const cloned = cloneVNode(type, props, true /* mergeRef: true */)\n    if (children) {\n      normalizeChildren(cloned, children)\n    }\n    return cloned\n  }\n\n  // class component normalization.\n  if (isClassComponent(type)) {\n    type = type.__vccOpts\n  }\n\n  // 2.x async/functional component compat\n  if (__COMPAT__) {\n    type = convertLegacyComponent(type, currentRenderingInstance)\n  }\n\n  // class & style normalization.\n  if (props) {\n    // for reactive or proxy objects, we need to clone it to enable mutation.\n    props = guardReactiveProps(props)!\n    let { class: klass, style } = props\n    if (klass && !isString(klass)) {\n      props.class = normalizeClass(klass)\n    }\n    if (isObject(style)) {\n      // reactive state objects need to be cloned since they are likely to be\n      // mutated\n      if (isProxy(style) && !isArray(style)) {\n        style = extend({}, style)\n      }\n      props.style = normalizeStyle(style)\n    }\n  }\n\n  // encode the vnode type information into a bitmap\n  const shapeFlag = isString(type)\n    ? ShapeFlags.ELEMENT\n    : __FEATURE_SUSPENSE__ && isSuspense(type)\n    ? ShapeFlags.SUSPENSE\n    : isTeleport(type)\n    ? ShapeFlags.TELEPORT\n    : isObject(type)\n    ? ShapeFlags.STATEFUL_COMPONENT\n    : isFunction(type)\n    ? ShapeFlags.FUNCTIONAL_COMPONENT\n    : 0\n\n  if (__DEV__ && shapeFlag & ShapeFlags.STATEFUL_COMPONENT && isProxy(type)) {\n    type = toRaw(type)\n    warn(\n      `Vue received a Component which was made a reactive object. This can ` +\n        `lead to unnecessary performance overhead, and should be avoided by ` +\n        `marking the component with \\`markRaw\\` or using \\`shallowRef\\` ` +\n        `instead of \\`ref\\`.`,\n      `\\nComponent that was made reactive: `,\n      type\n    )\n  }\n\n  return createBaseVNode(\n    type,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    shapeFlag,\n    isBlockNode,\n    true\n  )\n}\n\nexport function guardReactiveProps(props: (Data & VNodeProps) | null) {\n  if (!props) return null\n  return isProxy(props) || InternalObjectKey in props\n    ? extend({}, props)\n    : props\n}\n\nexport function cloneVNode<T, U>(\n  vnode: VNode<T, U>,\n  extraProps?: (Data & VNodeProps) | null,\n  mergeRef = false\n): VNode<T, U> {\n  // This is intentionally NOT using spread or extend to avoid the runtime\n  // key enumeration cost.\n  const { props, ref, patchFlag, children } = vnode\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props\n  const cloned: VNode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref:\n      extraProps && extraProps.ref\n        ? // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n          // if the vnode itself already has a ref, cloneVNode will need to merge\n          // the refs so the single vnode can be set on multiple refs\n          mergeRef && ref\n          ? isArray(ref)\n            ? ref.concat(normalizeRef(extraProps)!)\n            : [ref, normalizeRef(extraProps)!]\n          : normalizeRef(extraProps)\n        : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children:\n      __DEV__ && patchFlag === PatchFlags.HOISTED && isArray(children)\n        ? (children as VNode[]).map(deepCloneVNode)\n        : children,\n    target: vnode.target,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag:\n      extraProps && vnode.type !== Fragment\n        ? patchFlag === -1 // hoisted node\n          ? PatchFlags.FULL_PROPS\n          : patchFlag | PatchFlags.FULL_PROPS\n        : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition: vnode.transition,\n\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor\n  }\n  if (__COMPAT__) {\n    defineLegacyVNodeProperties(cloned)\n  }\n  return cloned as any\n}\n\n/**\n * Dev only, for HMR of hoisted vnodes reused in v-for\n * https://github.com/vitejs/vite/issues/2022\n */\nfunction deepCloneVNode(vnode: VNode): VNode {\n  const cloned = cloneVNode(vnode)\n  if (isArray(vnode.children)) {\n    cloned.children = (vnode.children as VNode[]).map(deepCloneVNode)\n  }\n  return cloned\n}\n\n/**\n * @private\n */\nexport function createTextVNode(text: string = ' ', flag: number = 0): VNode {\n  return createVNode(Text, null, text, flag)\n}\n\n/**\n * @private\n */\nexport function createStaticVNode(\n  content: string,\n  numberOfNodes: number\n): VNode {\n  // A static vnode can contain multiple stringified elements, and the number\n  // of elements is necessary for hydration.\n  const vnode = createVNode(Static, null, content)\n  vnode.staticCount = numberOfNodes\n  return vnode\n}\n\n/**\n * @private\n */\nexport function createCommentVNode(\n  text: string = '',\n  // when used as the v-else branch, the comment node must be created as a\n  // block to ensure correct updates.\n  asBlock: boolean = false\n): VNode {\n  return asBlock\n    ? (openBlock(), createBlock(Comment, null, text))\n    : createVNode(Comment, null, text)\n}\n\nexport function normalizeVNode(child: VNodeChild): VNode {\n  if (child == null || typeof child === 'boolean') {\n    // empty placeholder\n    return createVNode(Comment)\n  } else if (isArray(child)) {\n    // fragment\n    return createVNode(\n      Fragment,\n      null,\n      // #3666, avoid reference pollution when reusing vnode\n      child.slice()\n    )\n  } else if (typeof child === 'object') {\n    // already vnode, this should be the most common since compiled templates\n    // always produce all-vnode children arrays\n    return cloneIfMounted(child)\n  } else {\n    // strings and numbers\n    return createVNode(Text, null, String(child))\n  }\n}\n\n// optimized normalization for template-compiled render fns\nexport function cloneIfMounted(child: VNode): VNode {\n  return child.el === null || child.memo ? child : cloneVNode(child)\n}\n\nexport function normalizeChildren(vnode: VNode, children: unknown) {\n  let type = 0\n  const { shapeFlag } = vnode\n  if (children == null) {\n    children = null\n  } else if (isArray(children)) {\n    type = ShapeFlags.ARRAY_CHILDREN\n  } else if (typeof children === 'object') {\n    if (shapeFlag & (ShapeFlags.ELEMENT | ShapeFlags.TELEPORT)) {\n      // Normalize slot to plain children for plain element and Teleport\n      const slot = (children as any).default\n      if (slot) {\n        // _c marker is added by withCtx() indicating this is a compiled slot\n        slot._c && (slot._d = false)\n        normalizeChildren(vnode, slot())\n        slot._c && (slot._d = true)\n      }\n      return\n    } else {\n      type = ShapeFlags.SLOTS_CHILDREN\n      const slotFlag = (children as RawSlots)._\n      if (!slotFlag && !(InternalObjectKey in children!)) {\n        // if slots are not normalized, attach context instance\n        // (compiled / normalized slots already have context)\n        ;(children as RawSlots)._ctx = currentRenderingInstance\n      } else if (slotFlag === SlotFlags.FORWARDED && currentRenderingInstance) {\n        // a child component receives forwarded slots from the parent.\n        // its slot type is determined by its parent's slot type.\n        if (\n          (currentRenderingInstance.slots as RawSlots)._ === SlotFlags.STABLE\n        ) {\n          ;(children as RawSlots)._ = SlotFlags.STABLE\n        } else {\n          ;(children as RawSlots)._ = SlotFlags.DYNAMIC\n          vnode.patchFlag |= PatchFlags.DYNAMIC_SLOTS\n        }\n      }\n    }\n  } else if (isFunction(children)) {\n    children = { default: children, _ctx: currentRenderingInstance }\n    type = ShapeFlags.SLOTS_CHILDREN\n  } else {\n    children = String(children)\n    // force teleport children to array so it can be moved around\n    if (shapeFlag & ShapeFlags.TELEPORT) {\n      type = ShapeFlags.ARRAY_CHILDREN\n      children = [createTextVNode(children as string)]\n    } else {\n      type = ShapeFlags.TEXT_CHILDREN\n    }\n  }\n  vnode.children = children as VNodeNormalizedChildren\n  vnode.shapeFlag |= type\n}\n\nexport function mergeProps(...args: (Data & VNodeProps)[]) {\n  const ret: Data = {}\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i]\n    for (const key in toMerge) {\n      if (key === 'class') {\n        if (ret.class !== toMerge.class) {\n          ret.class = normalizeClass([ret.class, toMerge.class])\n        }\n      } else if (key === 'style') {\n        ret.style = normalizeStyle([ret.style, toMerge.style])\n      } else if (isOn(key)) {\n        const existing = ret[key]\n        const incoming = toMerge[key]\n        if (\n          incoming &&\n          existing !== incoming &&\n          !(isArray(existing) && existing.includes(incoming))\n        ) {\n          ret[key] = existing\n            ? [].concat(existing as any, incoming as any)\n            : incoming\n        }\n      } else if (key !== '') {\n        ret[key] = toMerge[key]\n      }\n    }\n  }\n  return ret\n}\n\nexport function invokeVNodeHook(\n  hook: VNodeHook,\n  instance: ComponentInternalInstance | null,\n  vnode: VNode,\n  prevVNode: VNode | null = null\n) {\n  callWithAsyncErrorHandling(hook, instance, ErrorCodes.VNODE_HOOK, [\n    vnode,\n    prevVNode\n  ])\n}\n", "import { VNode, VNodeChild } from '../vnode'\nimport { isArray, isString, isObject } from '@vue/shared'\nimport { warn } from '../warning'\n\n/**\n * v-for string\n * @private\n */\nexport function renderList(\n  source: string,\n  renderItem: (value: string, index: number) => VNodeChild\n): VNodeChild[]\n\n/**\n * v-for number\n */\nexport function renderList(\n  source: number,\n  renderItem: (value: number, index: number) => VNodeChild\n): VNodeChild[]\n\n/**\n * v-for array\n */\nexport function renderList<T>(\n  source: T[],\n  renderItem: (value: T, index: number) => VNodeChild\n): VNodeChild[]\n\n/**\n * v-for iterable\n */\nexport function renderList<T>(\n  source: Iterable<T>,\n  renderItem: (value: T, index: number) => VNodeChild\n): VNodeChild[]\n\n/**\n * v-for object\n */\nexport function renderList<T>(\n  source: T,\n  renderItem: <K extends keyof T>(\n    value: T[K],\n    key: K,\n    index: number\n  ) => VNodeChild\n): VNodeChild[]\n\n/**\n * Actual implementation\n */\nexport function renderList(\n  source: any,\n  renderItem: (...args: any[]) => VNodeChild,\n  cache?: any[],\n  index?: number\n): VNodeChild[] {\n  let ret: VNodeChild[]\n  const cached = (cache && cache[index!]) as VNode[] | undefined\n\n  if (isArray(source) || isString(source)) {\n    ret = new Array(source.length)\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(source[i], i, undefined, cached && cached[i])\n    }\n  } else if (typeof source === 'number') {\n    if (__DEV__ && !Number.isInteger(source)) {\n      warn(`The v-for range expect an integer value but got ${source}.`)\n      return []\n    }\n    ret = new Array(source)\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i, undefined, cached && cached[i])\n    }\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator as any]) {\n      ret = Array.from(source as Iterable<any>, (item, i) =>\n        renderItem(item, i, undefined, cached && cached[i])\n      )\n    } else {\n      const keys = Object.keys(source)\n      ret = new Array(keys.length)\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i]\n        ret[i] = renderItem(source[key], key, i, cached && cached[i])\n      }\n    }\n  } else {\n    ret = []\n  }\n\n  if (cache) {\n    cache[index!] = ret\n  }\n  return ret\n}\n", "import { Slot } from '../componentSlots'\nimport { isArray } from '@vue/shared'\n\ninterface CompiledSlotDescriptor {\n  name: string\n  fn: Slot\n}\n\n/**\n * Compiler runtime helper for creating dynamic slots object\n * @private\n */\nexport function createSlots(\n  slots: Record<string, Slot>,\n  dynamicSlots: (\n    | CompiledSlotDescriptor\n    | CompiledSlotDescriptor[]\n    | undefined\n  )[]\n): Record<string, Slot> {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i]\n    // array of dynamic slot generated by <template v-for=\"...\" #[...]>\n    if (isArray(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn\n      }\n    } else if (slot) {\n      // conditional single slot generated by <template v-if=\"...\" #foo>\n      slots[slot.name] = slot.fn\n    }\n  }\n  return slots\n}\n", "import { Data } from '../component'\nimport { Slots, RawSlots } from '../componentSlots'\nimport {\n  ContextualRenderFn,\n  currentRenderingInstance\n} from '../componentRenderContext'\nimport { Comment, isVNode } from '../vnode'\nimport {\n  VNodeArrayChildren,\n  openBlock,\n  createBlock,\n  Fragment,\n  VNode\n} from '../vnode'\nimport { PatchFlags, SlotFlags } from '@vue/shared'\nimport { warn } from '../warning'\nimport { createVNode } from '@vue/runtime-core'\n\n/**\n * Compiler runtime helper for rendering `<slot/>`\n * @private\n */\nexport function renderSlot(\n  slots: Slots,\n  name: string,\n  props: Data = {},\n  // this is not a user-facing function, so the fallback is always generated by\n  // the compiler and guaranteed to be a function returning an array\n  fallback?: () => VNodeArrayChildren,\n  noSlotted?: boolean\n): VNode {\n  if (currentRenderingInstance!.isCE) {\n    return createVNode(\n      'slot',\n      name === 'default' ? null : { name },\n      fallback && fallback()\n    )\n  }\n\n  let slot = slots[name]\n\n  if (__DEV__ && slot && slot.length > 1) {\n    warn(\n      `SSR-optimized slot function detected in a non-SSR-optimized render ` +\n        `function. You need to mark this component with $dynamic-slots in the ` +\n        `parent template.`\n    )\n    slot = () => []\n  }\n\n  // a compiled slot disables block tracking by default to avoid manual\n  // invocation interfering with template-based block tracking, but in\n  // `renderSlot` we can be sure that it's template-based so we can force\n  // enable it.\n  if (slot && (slot as ContextualRenderFn)._c) {\n    ;(slot as ContextualRenderFn)._d = false\n  }\n  openBlock()\n  const validSlotContent = slot && ensureValidVNode(slot(props))\n  const rendered = createBlock(\n    Fragment,\n    { key: props.key || `_${name}` },\n    validSlotContent || (fallback ? fallback() : []),\n    validSlotContent && (slots as RawSlots)._ === SlotFlags.STABLE\n      ? PatchFlags.STABLE_FRAGMENT\n      : PatchFlags.BAIL\n  )\n  if (!noSlotted && rendered.scopeId) {\n    rendered.slotScopeIds = [rendered.scopeId + '-s']\n  }\n  if (slot && (slot as ContextualRenderFn)._c) {\n    ;(slot as ContextualRenderFn)._d = true\n  }\n  return rendered\n}\n\nfunction ensureValidVNode(vnodes: VNodeArrayChildren) {\n  return vnodes.some(child => {\n    if (!isVNode(child)) return true\n    if (child.type === Comment) return false\n    if (\n      child.type === Fragment &&\n      !ensureValidVNode(child.children as VNodeArrayChildren)\n    )\n      return false\n    return true\n  })\n    ? vnodes\n    : null\n}\n", "import { toHandlerKey, isObject } from '@vue/shared'\nimport { warn } from '../warning'\n\n/**\n * For prefixing keys in v-on=\"obj\" with \"on\"\n * @private\n */\nexport function toHandlers(obj: Record<string, any>): Record<string, any> {\n  const ret: Record<string, any> = {}\n  if (__DEV__ && !isObject(obj)) {\n    warn(`v-on with no argument expects an object value.`)\n    return ret\n  }\n  for (const key in obj) {\n    ret[toHandlerKey(key)] = obj[key]\n  }\n  return ret\n}\n", "import {\n  ComponentInternalInstance,\n  Data,\n  getExposeProxy,\n  isStatefulComponent\n} from './component'\nimport { nextTick, queueJob } from './scheduler'\nimport { instanceWatch, WatchOptions, WatchStopHandle } from './apiWatch'\nimport {\n  EMPTY_OBJ,\n  hasOwn,\n  isGloballyWhitelisted,\n  NOOP,\n  extend,\n  isString,\n  isFunction,\n  UnionToIntersection\n} from '@vue/shared'\nimport {\n  toRaw,\n  shallowReadonly,\n  track,\n  TrackOpTypes,\n  ShallowUnwrapRef,\n  UnwrapNestedRefs\n} from '@vue/reactivity'\nimport {\n  ExtractComputedReturns,\n  ComponentOptionsBase,\n  ComputedOptions,\n  MethodOptions,\n  ComponentOptionsMixin,\n  OptionTypesType,\n  OptionTypesKeys,\n  resolveMergedOptions,\n  shouldCacheAccess,\n  MergedComponentOptionsOverride\n} from './componentOptions'\nimport { EmitsOptions, EmitFn } from './componentEmits'\nimport { Slots } from './componentSlots'\nimport { markAttrsAccessed } from './componentRenderUtils'\nimport { currentRenderingInstance } from './componentRenderContext'\nimport { warn } from './warning'\nimport { installCompatInstanceProperties } from './compat/instance'\n\n/**\n * Custom properties added to component instances in any way and can be accessed through `this`\n *\n * @example\n * Here is an example of adding a property `$router` to every component instance:\n * ```ts\n * import { createApp } from 'vue'\n * import { Router, createRouter } from 'vue-router'\n *\n * declare module '@vue/runtime-core' {\n *   interface ComponentCustomProperties {\n *     $router: Router\n *   }\n * }\n *\n * // effectively adding the router to every component instance\n * const app = createApp({})\n * const router = createRouter()\n * app.config.globalProperties.$router = router\n *\n * const vm = app.mount('#app')\n * // we can access the router from the instance\n * vm.$router.push('/')\n * ```\n */\nexport interface ComponentCustomProperties {}\n\ntype IsDefaultMixinComponent<T> = T extends ComponentOptionsMixin\n  ? ComponentOptionsMixin extends T\n    ? true\n    : false\n  : false\n\ntype MixinToOptionTypes<T> = T extends ComponentOptionsBase<\n  infer P,\n  infer B,\n  infer D,\n  infer C,\n  infer M,\n  infer Mixin,\n  infer Extends,\n  any,\n  any,\n  infer Defaults\n>\n  ? OptionTypesType<P & {}, B & {}, D & {}, C & {}, M & {}, Defaults & {}> &\n      IntersectionMixin<Mixin> &\n      IntersectionMixin<Extends>\n  : never\n\n// ExtractMixin(map type) is used to resolve circularly references\ntype ExtractMixin<T> = {\n  Mixin: MixinToOptionTypes<T>\n}[T extends ComponentOptionsMixin ? 'Mixin' : never]\n\ntype IntersectionMixin<T> = IsDefaultMixinComponent<T> extends true\n  ? OptionTypesType<{}, {}, {}, {}, {}>\n  : UnionToIntersection<ExtractMixin<T>>\n\ntype UnwrapMixinsType<\n  T,\n  Type extends OptionTypesKeys\n> = T extends OptionTypesType ? T[Type] : never\n\ntype EnsureNonVoid<T> = T extends void ? {} : T\n\nexport type ComponentPublicInstanceConstructor<\n  T extends ComponentPublicInstance<\n    Props,\n    RawBindings,\n    D,\n    C,\n    M\n  > = ComponentPublicInstance<any>,\n  Props = any,\n  RawBindings = any,\n  D = any,\n  C extends ComputedOptions = ComputedOptions,\n  M extends MethodOptions = MethodOptions\n> = {\n  __isFragment?: never\n  __isTeleport?: never\n  __isSuspense?: never\n  new (...args: any[]): T\n}\n\nexport type CreateComponentPublicInstance<\n  P = {},\n  B = {},\n  D = {},\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = {},\n  PublicProps = P,\n  Defaults = {},\n  MakeDefaultsOptional extends boolean = false,\n  PublicMixin = IntersectionMixin<Mixin> & IntersectionMixin<Extends>,\n  PublicP = UnwrapMixinsType<PublicMixin, 'P'> & EnsureNonVoid<P>,\n  PublicB = UnwrapMixinsType<PublicMixin, 'B'> & EnsureNonVoid<B>,\n  PublicD = UnwrapMixinsType<PublicMixin, 'D'> & EnsureNonVoid<D>,\n  PublicC extends ComputedOptions = UnwrapMixinsType<PublicMixin, 'C'> &\n    EnsureNonVoid<C>,\n  PublicM extends MethodOptions = UnwrapMixinsType<PublicMixin, 'M'> &\n    EnsureNonVoid<M>,\n  PublicDefaults = UnwrapMixinsType<PublicMixin, 'Defaults'> &\n    EnsureNonVoid<Defaults>\n> = ComponentPublicInstance<\n  PublicP,\n  PublicB,\n  PublicD,\n  PublicC,\n  PublicM,\n  E,\n  PublicProps,\n  PublicDefaults,\n  MakeDefaultsOptional,\n  ComponentOptionsBase<P, B, D, C, M, Mixin, Extends, E, string, Defaults>\n>\n\n// public properties exposed on the proxy, which is used as the render context\n// in templates (as `this` in the render option)\nexport type ComponentPublicInstance<\n  P = {}, // props type extracted from props option\n  B = {}, // raw bindings returned from setup()\n  D = {}, // return from data()\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  E extends EmitsOptions = {},\n  PublicProps = P,\n  Defaults = {},\n  MakeDefaultsOptional extends boolean = false,\n  Options = ComponentOptionsBase<any, any, any, any, any, any, any, any, any>\n> = {\n  $: ComponentInternalInstance\n  $data: D\n  $props: MakeDefaultsOptional extends true\n    ? Partial<Defaults> & Omit<P & PublicProps, keyof Defaults>\n    : P & PublicProps\n  $attrs: Data\n  $refs: Data\n  $slots: Slots\n  $root: ComponentPublicInstance | null\n  $parent: ComponentPublicInstance | null\n  $emit: EmitFn<E>\n  $el: any\n  $options: Options & MergedComponentOptionsOverride\n  $forceUpdate: () => void\n  $nextTick: typeof nextTick\n  $watch(\n    source: string | Function,\n    cb: Function,\n    options?: WatchOptions\n  ): WatchStopHandle\n} & P &\n  ShallowUnwrapRef<B> &\n  UnwrapNestedRefs<D> &\n  ExtractComputedReturns<C> &\n  M &\n  ComponentCustomProperties\n\nexport type PublicPropertiesMap = Record<\n  string,\n  (i: ComponentInternalInstance) => any\n>\n\n/**\n * #2437 In Vue 3, functional components do not have a public instance proxy but\n * they exist in the internal parent chain. For code that relies on traversing\n * public $parent chains, skip functional ones and go to the parent instead.\n */\nconst getPublicInstance = (\n  i: ComponentInternalInstance | null\n): ComponentPublicInstance | ComponentInternalInstance['exposed'] | null => {\n  if (!i) return null\n  if (isStatefulComponent(i)) return getExposeProxy(i) || i.proxy\n  return getPublicInstance(i.parent)\n}\n\nexport const publicPropertiesMap: PublicPropertiesMap = /*#__PURE__*/ extend(\n  Object.create(null),\n  {\n    $: i => i,\n    $el: i => i.vnode.el,\n    $data: i => i.data,\n    $props: i => (__DEV__ ? shallowReadonly(i.props) : i.props),\n    $attrs: i => (__DEV__ ? shallowReadonly(i.attrs) : i.attrs),\n    $slots: i => (__DEV__ ? shallowReadonly(i.slots) : i.slots),\n    $refs: i => (__DEV__ ? shallowReadonly(i.refs) : i.refs),\n    $parent: i => getPublicInstance(i.parent),\n    $root: i => getPublicInstance(i.root),\n    $emit: i => i.emit,\n    $options: i => (__FEATURE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type),\n    $forceUpdate: i => () => queueJob(i.update),\n    $nextTick: i => nextTick.bind(i.proxy!),\n    $watch: i => (__FEATURE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP)\n  } as PublicPropertiesMap\n)\n\nif (__COMPAT__) {\n  installCompatInstanceProperties(publicPropertiesMap)\n}\n\nconst enum AccessTypes {\n  OTHER,\n  SETUP,\n  DATA,\n  PROPS,\n  CONTEXT\n}\n\nexport interface ComponentRenderContext {\n  [key: string]: any\n  _: ComponentInternalInstance\n}\n\nexport const PublicInstanceProxyHandlers: ProxyHandler<any> = {\n  get({ _: instance }: ComponentRenderContext, key: string) {\n    const { ctx, setupState, data, props, accessCache, type, appContext } =\n      instance\n\n    // for internal formatters to know that this is a Vue instance\n    if (__DEV__ && key === '__isVue') {\n      return true\n    }\n\n    // prioritize <script setup> bindings during dev.\n    // this allows even properties that start with _ or $ to be used - so that\n    // it aligns with the production behavior where the render fn is inlined and\n    // indeed has access to all declared variables.\n    if (\n      __DEV__ &&\n      setupState !== EMPTY_OBJ &&\n      setupState.__isScriptSetup &&\n      hasOwn(setupState, key)\n    ) {\n      return setupState[key]\n    }\n\n    // data / props / ctx\n    // This getter gets called for every property access on the render context\n    // during render and is a major hotspot. The most expensive part of this\n    // is the multiple hasOwn() calls. It's much faster to do a simple property\n    // access on a plain object, so we use an accessCache object (with null\n    // prototype) to memoize what access type a key corresponds to.\n    let normalizedProps\n    if (key[0] !== '$') {\n      const n = accessCache![key]\n      if (n !== undefined) {\n        switch (n) {\n          case AccessTypes.SETUP:\n            return setupState[key]\n          case AccessTypes.DATA:\n            return data[key]\n          case AccessTypes.CONTEXT:\n            return ctx[key]\n          case AccessTypes.PROPS:\n            return props![key]\n          // default: just fallthrough\n        }\n      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n        accessCache![key] = AccessTypes.SETUP\n        return setupState[key]\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n        accessCache![key] = AccessTypes.DATA\n        return data[key]\n      } else if (\n        // only cache other properties when instance has declared (thus stable)\n        // props\n        (normalizedProps = instance.propsOptions[0]) &&\n        hasOwn(normalizedProps, key)\n      ) {\n        accessCache![key] = AccessTypes.PROPS\n        return props![key]\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        accessCache![key] = AccessTypes.CONTEXT\n        return ctx[key]\n      } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) {\n        accessCache![key] = AccessTypes.OTHER\n      }\n    }\n\n    const publicGetter = publicPropertiesMap[key]\n    let cssModule, globalProperties\n    // public $xxx properties\n    if (publicGetter) {\n      if (key === '$attrs') {\n        track(instance, TrackOpTypes.GET, key)\n        __DEV__ && markAttrsAccessed()\n      }\n      return publicGetter(instance)\n    } else if (\n      // css module (injected by vue-loader)\n      (cssModule = type.__cssModules) &&\n      (cssModule = cssModule[key])\n    ) {\n      return cssModule\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n      // user may set custom properties to `this` that start with `$`\n      accessCache![key] = AccessTypes.CONTEXT\n      return ctx[key]\n    } else if (\n      // global properties\n      ((globalProperties = appContext.config.globalProperties),\n      hasOwn(globalProperties, key))\n    ) {\n      if (__COMPAT__) {\n        const desc = Object.getOwnPropertyDescriptor(globalProperties, key)!\n        if (desc.get) {\n          return desc.get.call(instance.proxy)\n        } else {\n          const val = globalProperties[key]\n          return isFunction(val) ? val.bind(instance.proxy) : val\n        }\n      } else {\n        return globalProperties[key]\n      }\n    } else if (\n      __DEV__ &&\n      currentRenderingInstance &&\n      (!isString(key) ||\n        // #1091 avoid internal isRef/isVNode checks on component instance leading\n        // to infinite warning loop\n        key.indexOf('__v') !== 0)\n    ) {\n      if (\n        data !== EMPTY_OBJ &&\n        (key[0] === '$' || key[0] === '_') &&\n        hasOwn(data, key)\n      ) {\n        warn(\n          `Property ${JSON.stringify(\n            key\n          )} must be accessed via $data because it starts with a reserved ` +\n            `character (\"$\" or \"_\") and is not proxied on the render context.`\n        )\n      } else if (instance === currentRenderingInstance) {\n        warn(\n          `Property ${JSON.stringify(key)} was accessed during render ` +\n            `but is not defined on instance.`\n        )\n      }\n    }\n  },\n\n  set(\n    { _: instance }: ComponentRenderContext,\n    key: string,\n    value: any\n  ): boolean {\n    const { data, setupState, ctx } = instance\n    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n      setupState[key] = value\n      return true\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n      data[key] = value\n      return true\n    } else if (hasOwn(instance.props, key)) {\n      __DEV__ &&\n        warn(\n          `Attempting to mutate prop \"${key}\". Props are readonly.`,\n          instance\n        )\n      return false\n    }\n    if (key[0] === '$' && key.slice(1) in instance) {\n      __DEV__ &&\n        warn(\n          `Attempting to mutate public property \"${key}\". ` +\n            `Properties starting with $ are reserved and readonly.`,\n          instance\n        )\n      return false\n    } else {\n      if (__DEV__ && key in instance.appContext.config.globalProperties) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          value\n        })\n      } else {\n        ctx[key] = value\n      }\n    }\n    return true\n  },\n\n  has(\n    {\n      _: { data, setupState, accessCache, ctx, appContext, propsOptions }\n    }: ComponentRenderContext,\n    key: string\n  ) {\n    let normalizedProps\n    return (\n      !!accessCache![key] ||\n      (data !== EMPTY_OBJ && hasOwn(data, key)) ||\n      (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) ||\n      ((normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key)) ||\n      hasOwn(ctx, key) ||\n      hasOwn(publicPropertiesMap, key) ||\n      hasOwn(appContext.config.globalProperties, key)\n    )\n  },\n\n  defineProperty(\n    target: ComponentRenderContext,\n    key: string,\n    descriptor: PropertyDescriptor\n  ) {\n    if (descriptor.get != null) {\n      // invalidate key cache of a getter based property #5417\n      target.$.accessCache[key] = 0;\n    } else if (hasOwn(descriptor,'value')) {\n      this.set!(target, key, descriptor.value, null)\n    }\n    return Reflect.defineProperty(target, key, descriptor)\n  }\n}\n\nif (__DEV__ && !__TEST__) {\n  PublicInstanceProxyHandlers.ownKeys = (target: ComponentRenderContext) => {\n    warn(\n      `Avoid app logic that relies on enumerating keys on a component instance. ` +\n        `The keys will be empty in production mode to avoid performance overhead.`\n    )\n    return Reflect.ownKeys(target)\n  }\n}\n\nexport const RuntimeCompiledPublicInstanceProxyHandlers = /*#__PURE__*/ extend(\n  {},\n  PublicInstanceProxyHandlers,\n  {\n    get(target: ComponentRenderContext, key: string) {\n      // fast path for unscopables when using `with` block\n      if ((key as any) === Symbol.unscopables) {\n        return\n      }\n      return PublicInstanceProxyHandlers.get!(target, key, target)\n    },\n    has(_: ComponentRenderContext, key: string) {\n      const has = key[0] !== '_' && !isGloballyWhitelisted(key)\n      if (__DEV__ && !has && PublicInstanceProxyHandlers.has!(_, key)) {\n        warn(\n          `Property ${JSON.stringify(\n            key\n          )} should not start with _ which is a reserved prefix for Vue internals.`\n        )\n      }\n      return has\n    }\n  }\n)\n\n// dev only\n// In dev mode, the proxy target exposes the same properties as seen on `this`\n// for easier console inspection. In prod mode it will be an empty object so\n// these properties definitions can be skipped.\nexport function createDevRenderContext(instance: ComponentInternalInstance) {\n  const target: Record<string, any> = {}\n\n  // expose internal instance for proxy handlers\n  Object.defineProperty(target, `_`, {\n    configurable: true,\n    enumerable: false,\n    get: () => instance\n  })\n\n  // expose public properties\n  Object.keys(publicPropertiesMap).forEach(key => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => publicPropertiesMap[key](instance),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: NOOP\n    })\n  })\n\n  return target as ComponentRenderContext\n}\n\n// dev only\nexport function exposePropsOnRenderContext(\n  instance: ComponentInternalInstance\n) {\n  const {\n    ctx,\n    propsOptions: [propsOptions]\n  } = instance\n  if (propsOptions) {\n    Object.keys(propsOptions).forEach(key => {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => instance.props[key],\n        set: NOOP\n      })\n    })\n  }\n}\n\n// dev only\nexport function exposeSetupStateOnRenderContext(\n  instance: ComponentInternalInstance\n) {\n  const { ctx, setupState } = instance\n  Object.keys(toRaw(setupState)).forEach(key => {\n    if (!setupState.__isScriptSetup) {\n      if (key[0] === '$' || key[0] === '_') {\n        warn(\n          `setup() return property ${JSON.stringify(\n            key\n          )} should not start with \"$\" or \"_\" ` +\n            `which are reserved prefixes for Vue internals.`\n        )\n        return\n      }\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => setupState[key],\n        set: NOOP\n      })\n    }\n  })\n}\n", "import { VNode, VNodeChild, isVNode } from './vnode'\nimport {\n  pauseTracking,\n  resetTracking,\n  shallowReadonly,\n  proxyRefs,\n  EffectScope,\n  markRaw,\n  track,\n  TrackOpTypes,\n  ReactiveEffect\n} from '@vue/reactivity'\nimport {\n  ComponentPublicInstance,\n  PublicInstanceProxyHandlers,\n  createDevRenderContext,\n  exposePropsOnRenderContext,\n  exposeSetupStateOnRenderContext,\n  ComponentPublicInstanceConstructor,\n  publicPropertiesMap,\n  RuntimeCompiledPublicInstanceProxyHandlers\n} from './componentPublicInstance'\nimport {\n  ComponentPropsOptions,\n  NormalizedPropsOptions,\n  initProps,\n  normalizePropsOptions\n} from './componentProps'\nimport { Slots, initSlots, InternalSlots } from './componentSlots'\nimport { warn } from './warning'\nimport { ErrorCodes, callWithErrorHandling, handleError } from './errorHandling'\nimport { AppContext, createAppContext, AppConfig } from './apiCreateApp'\nimport { Directive, validateDirectiveName } from './directives'\nimport {\n  applyOptions,\n  ComponentOptions,\n  ComputedOptions,\n  MethodOptions\n} from './componentOptions'\nimport {\n  EmitsOptions,\n  ObjectEmitsOptions,\n  EmitFn,\n  emit,\n  normalizeEmitsOptions\n} from './componentEmits'\nimport {\n  EMPTY_OBJ,\n  isFunction,\n  NOOP,\n  isObject,\n  NO,\n  makeMap,\n  isPromise,\n  ShapeFlags,\n  extend\n} from '@vue/shared'\nimport { SuspenseBoundary } from './components/Suspense'\nimport { CompilerOptions } from '@vue/compiler-core'\nimport { markAttrsAccessed } from './componentRenderUtils'\nimport { currentRenderingInstance } from './componentRenderContext'\nimport { startMeasure, endMeasure } from './profiling'\nimport { convertLegacyRenderFn } from './compat/renderFn'\nimport {\n  CompatConfig,\n  globalCompatConfig,\n  validateCompatConfig\n} from './compat/compatConfig'\nimport { SchedulerJob } from './scheduler'\n\nexport type Data = Record<string, unknown>\n\n/**\n * For extending allowed non-declared props on components in TSX\n */\nexport interface ComponentCustomProps {}\n\n/**\n * Default allowed non-declared props on component in TSX\n */\nexport interface AllowedComponentProps {\n  class?: unknown\n  style?: unknown\n}\n\n// Note: can't mark this whole interface internal because some public interfaces\n// extend it.\nexport interface ComponentInternalOptions {\n  /**\n   * @internal\n   */\n  __scopeId?: string\n  /**\n   * @internal\n   */\n  __cssModules?: Data\n  /**\n   * @internal\n   */\n  __hmrId?: string\n  /**\n   * Compat build only, for bailing out of certain compatibility behavior\n   */\n  __isBuiltIn?: boolean\n  /**\n   * This one should be exposed so that devtools can make use of it\n   */\n  __file?: string\n}\n\nexport interface FunctionalComponent<P = {}, E extends EmitsOptions = {}>\n  extends ComponentInternalOptions {\n  // use of any here is intentional so it can be a valid JSX Element constructor\n  (props: P, ctx: Omit<SetupContext<E>, 'expose'>): any\n  props?: ComponentPropsOptions<P>\n  emits?: E | (keyof E)[]\n  inheritAttrs?: boolean\n  displayName?: string\n  compatConfig?: CompatConfig\n}\n\nexport interface ClassComponent {\n  new (...args: any[]): ComponentPublicInstance<any, any, any, any, any>\n  __vccOpts: ComponentOptions\n}\n\n/**\n * Concrete component type matches its actual value: it's either an options\n * object, or a function. Use this where the code expects to work with actual\n * values, e.g. checking if its a function or not. This is mostly for internal\n * implementation code.\n */\nexport type ConcreteComponent<\n  Props = {},\n  RawBindings = any,\n  D = any,\n  C extends ComputedOptions = ComputedOptions,\n  M extends MethodOptions = MethodOptions\n> =\n  | ComponentOptions<Props, RawBindings, D, C, M>\n  | FunctionalComponent<Props, any>\n\n/**\n * A type used in public APIs where a component type is expected.\n * The constructor type is an artificial type returned by defineComponent().\n */\nexport type Component<\n  Props = any,\n  RawBindings = any,\n  D = any,\n  C extends ComputedOptions = ComputedOptions,\n  M extends MethodOptions = MethodOptions\n> =\n  | ConcreteComponent<Props, RawBindings, D, C, M>\n  | ComponentPublicInstanceConstructor<Props>\n\nexport { ComponentOptions }\n\ntype LifecycleHook<TFn = Function> = TFn[] | null\n\nexport const enum LifecycleHooks {\n  BEFORE_CREATE = 'bc',\n  CREATED = 'c',\n  BEFORE_MOUNT = 'bm',\n  MOUNTED = 'm',\n  BEFORE_UPDATE = 'bu',\n  UPDATED = 'u',\n  BEFORE_UNMOUNT = 'bum',\n  UNMOUNTED = 'um',\n  DEACTIVATED = 'da',\n  ACTIVATED = 'a',\n  RENDER_TRIGGERED = 'rtg',\n  RENDER_TRACKED = 'rtc',\n  ERROR_CAPTURED = 'ec',\n  SERVER_PREFETCH = 'sp'\n}\n\nexport interface SetupContext<E = EmitsOptions> {\n  attrs: Data\n  slots: Slots\n  emit: EmitFn<E>\n  expose: (exposed?: Record<string, any>) => void\n}\n\n/**\n * @internal\n */\nexport type InternalRenderFunction = {\n  (\n    ctx: ComponentPublicInstance,\n    cache: ComponentInternalInstance['renderCache'],\n    // for compiler-optimized bindings\n    $props: ComponentInternalInstance['props'],\n    $setup: ComponentInternalInstance['setupState'],\n    $data: ComponentInternalInstance['data'],\n    $options: ComponentInternalInstance['ctx']\n  ): VNodeChild\n  _rc?: boolean // isRuntimeCompiled\n\n  // __COMPAT__ only\n  _compatChecked?: boolean // v3 and already checked for v2 compat\n  _compatWrapped?: boolean // is wrapped for v2 compat\n}\n\n/**\n * We expose a subset of properties on the internal instance as they are\n * useful for advanced external libraries and tools.\n */\nexport interface ComponentInternalInstance {\n  uid: number\n  type: ConcreteComponent\n  parent: ComponentInternalInstance | null\n  root: ComponentInternalInstance\n  appContext: AppContext\n  /**\n   * Vnode representing this component in its parent's vdom tree\n   */\n  vnode: VNode\n  /**\n   * The pending new vnode from parent updates\n   * @internal\n   */\n  next: VNode | null\n  /**\n   * Root vnode of this component's own vdom tree\n   */\n  subTree: VNode\n  /**\n   * Render effect instance\n   */\n  effect: ReactiveEffect\n  /**\n   * Bound effect runner to be passed to schedulers\n   */\n  update: SchedulerJob\n  /**\n   * The render function that returns vdom tree.\n   * @internal\n   */\n  render: InternalRenderFunction | null\n  /**\n   * SSR render function\n   * @internal\n   */\n  ssrRender?: Function | null\n  /**\n   * Object containing values this component provides for its descendents\n   * @internal\n   */\n  provides: Data\n  /**\n   * Tracking reactive effects (e.g. watchers) associated with this component\n   * so that they can be automatically stopped on component unmount\n   * @internal\n   */\n  scope: EffectScope\n  /**\n   * cache for proxy access type to avoid hasOwnProperty calls\n   * @internal\n   */\n  accessCache: Data | null\n  /**\n   * cache for render function values that rely on _ctx but won't need updates\n   * after initialized (e.g. inline handlers)\n   * @internal\n   */\n  renderCache: (Function | VNode)[]\n\n  /**\n   * Resolved component registry, only for components with mixins or extends\n   * @internal\n   */\n  components: Record<string, ConcreteComponent> | null\n  /**\n   * Resolved directive registry, only for components with mixins or extends\n   * @internal\n   */\n  directives: Record<string, Directive> | null\n  /**\n   * Resolved filters registry, v2 compat only\n   * @internal\n   */\n  filters?: Record<string, Function>\n  /**\n   * resolved props options\n   * @internal\n   */\n  propsOptions: NormalizedPropsOptions\n  /**\n   * resolved emits options\n   * @internal\n   */\n  emitsOptions: ObjectEmitsOptions | null\n  /**\n   * resolved inheritAttrs options\n   * @internal\n   */\n  inheritAttrs?: boolean\n  /**\n   * is custom element?\n   */\n  isCE?: boolean\n  /**\n   * custom element specific HMR method\n   */\n  ceReload?: (newStyles?: string[]) => void\n\n  // the rest are only for stateful components ---------------------------------\n\n  // main proxy that serves as the public instance (`this`)\n  proxy: ComponentPublicInstance | null\n\n  // exposed properties via expose()\n  exposed: Record<string, any> | null\n  exposeProxy: Record<string, any> | null\n\n  /**\n   * alternative proxy used only for runtime-compiled render functions using\n   * `with` block\n   * @internal\n   */\n  withProxy: ComponentPublicInstance | null\n  /**\n   * This is the target for the public instance proxy. It also holds properties\n   * injected by user options (computed, methods etc.) and user-attached\n   * custom properties (via `this.x = ...`)\n   * @internal\n   */\n  ctx: Data\n\n  // state\n  data: Data\n  props: Data\n  attrs: Data\n  slots: InternalSlots\n  refs: Data\n  emit: EmitFn\n  /**\n   * used for keeping track of .once event handlers on components\n   * @internal\n   */\n  emitted: Record<string, boolean> | null\n  /**\n   * used for caching the value returned from props default factory functions to\n   * avoid unnecessary watcher trigger\n   * @internal\n   */\n  propsDefaults: Data\n  /**\n   * setup related\n   * @internal\n   */\n  setupState: Data\n  /**\n   * devtools access to additional info\n   * @internal\n   */\n  devtoolsRawSetupState?: any\n  /**\n   * @internal\n   */\n  setupContext: SetupContext | null\n\n  /**\n   * suspense related\n   * @internal\n   */\n  suspense: SuspenseBoundary | null\n  /**\n   * suspense pending batch id\n   * @internal\n   */\n  suspenseId: number\n  /**\n   * @internal\n   */\n  asyncDep: Promise<any> | null\n  /**\n   * @internal\n   */\n  asyncResolved: boolean\n\n  // lifecycle\n  isMounted: boolean\n  isUnmounted: boolean\n  isDeactivated: boolean\n  /**\n   * @internal\n   */\n  [LifecycleHooks.BEFORE_CREATE]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.CREATED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.BEFORE_MOUNT]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.MOUNTED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.BEFORE_UPDATE]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.UPDATED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.BEFORE_UNMOUNT]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.UNMOUNTED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.RENDER_TRACKED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.RENDER_TRIGGERED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.ACTIVATED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.DEACTIVATED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.ERROR_CAPTURED]: LifecycleHook\n  /**\n   * @internal\n   */\n  [LifecycleHooks.SERVER_PREFETCH]: LifecycleHook<() => Promise<unknown>>\n}\n\nconst emptyAppContext = createAppContext()\n\nlet uid = 0\n\nexport function createComponentInstance(\n  vnode: VNode,\n  parent: ComponentInternalInstance | null,\n  suspense: SuspenseBoundary | null\n) {\n  const type = vnode.type as ConcreteComponent\n  // inherit parent app context - or - if root, adopt from root vnode\n  const appContext =\n    (parent ? parent.appContext : vnode.appContext) || emptyAppContext\n\n  const instance: ComponentInternalInstance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null!, // to be immediately set\n    next: null,\n    subTree: null!, // will be set synchronously right after creation\n    effect: null!,\n    update: null!, // will be set synchronously right after creation\n    scope: new EffectScope(true /* detached */),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    accessCache: null!,\n    renderCache: [],\n\n    // local resovled assets\n    components: null,\n    directives: null,\n\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n\n    // emit\n    emit: null!, // to be set immediately\n    emitted: null,\n\n    // props default value\n    propsDefaults: EMPTY_OBJ,\n\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n\n    // state\n    ctx: EMPTY_OBJ,\n    data: EMPTY_OBJ,\n    props: EMPTY_OBJ,\n    attrs: EMPTY_OBJ,\n    slots: EMPTY_OBJ,\n    refs: EMPTY_OBJ,\n    setupState: EMPTY_OBJ,\n    setupContext: null,\n\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  }\n  if (__DEV__) {\n    instance.ctx = createDevRenderContext(instance)\n  } else {\n    instance.ctx = { _: instance }\n  }\n  instance.root = parent ? parent.root : instance\n  instance.emit = emit.bind(null, instance)\n\n  // apply custom element special handling\n  if (vnode.ce) {\n    vnode.ce(instance)\n  }\n\n  return instance\n}\n\nexport let currentInstance: ComponentInternalInstance | null = null\n\nexport const getCurrentInstance: () => ComponentInternalInstance | null = () =>\n  currentInstance || currentRenderingInstance\n\nexport const setCurrentInstance = (instance: ComponentInternalInstance) => {\n  currentInstance = instance\n  instance.scope.on()\n}\n\nexport const unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off()\n  currentInstance = null\n}\n\nconst isBuiltInTag = /*#__PURE__*/ makeMap('slot,component')\n\nexport function validateComponentName(name: string, config: AppConfig) {\n  const appIsNativeTag = config.isNativeTag || NO\n  if (isBuiltInTag(name) || appIsNativeTag(name)) {\n    warn(\n      'Do not use built-in or reserved HTML elements as component id: ' + name\n    )\n  }\n}\n\nexport function isStatefulComponent(instance: ComponentInternalInstance) {\n  return instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT\n}\n\nexport let isInSSRComponentSetup = false\n\nexport function setupComponent(\n  instance: ComponentInternalInstance,\n  isSSR = false\n) {\n  isInSSRComponentSetup = isSSR\n\n  const { props, children } = instance.vnode\n  const isStateful = isStatefulComponent(instance)\n  initProps(instance, props, isStateful, isSSR)\n  initSlots(instance, children)\n\n  const setupResult = isStateful\n    ? setupStatefulComponent(instance, isSSR)\n    : undefined\n  isInSSRComponentSetup = false\n  return setupResult\n}\n\nfunction setupStatefulComponent(\n  instance: ComponentInternalInstance,\n  isSSR: boolean\n) {\n  const Component = instance.type as ComponentOptions\n\n  if (__DEV__) {\n    if (Component.name) {\n      validateComponentName(Component.name, instance.appContext.config)\n    }\n    if (Component.components) {\n      const names = Object.keys(Component.components)\n      for (let i = 0; i < names.length; i++) {\n        validateComponentName(names[i], instance.appContext.config)\n      }\n    }\n    if (Component.directives) {\n      const names = Object.keys(Component.directives)\n      for (let i = 0; i < names.length; i++) {\n        validateDirectiveName(names[i])\n      }\n    }\n    if (Component.compilerOptions && isRuntimeOnly()) {\n      warn(\n        `\"compilerOptions\" is only supported when using a build of Vue that ` +\n          `includes the runtime compiler. Since you are using a runtime-only ` +\n          `build, the options should be passed via your build tool config instead.`\n      )\n    }\n  }\n  // 0. create render proxy property access cache\n  instance.accessCache = Object.create(null)\n  // 1. create public instance / render proxy\n  // also mark it raw so it's never observed\n  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers))\n  if (__DEV__) {\n    exposePropsOnRenderContext(instance)\n  }\n  // 2. call setup()\n  const { setup } = Component\n  if (setup) {\n    const setupContext = (instance.setupContext =\n      setup.length > 1 ? createSetupContext(instance) : null)\n\n    setCurrentInstance(instance)\n    pauseTracking()\n    const setupResult = callWithErrorHandling(\n      setup,\n      instance,\n      ErrorCodes.SETUP_FUNCTION,\n      [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext]\n    )\n    resetTracking()\n    unsetCurrentInstance()\n\n    if (isPromise(setupResult)) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance)\n\n      if (isSSR) {\n        // return the promise so server-renderer can wait on it\n        return setupResult\n          .then((resolvedResult: unknown) => {\n            handleSetupResult(instance, resolvedResult, isSSR)\n          })\n          .catch(e => {\n            handleError(e, instance, ErrorCodes.SETUP_FUNCTION)\n          })\n      } else if (__FEATURE_SUSPENSE__) {\n        // async setup returned Promise.\n        // bail here and wait for re-entry.\n        instance.asyncDep = setupResult\n      } else if (__DEV__) {\n        warn(\n          `setup() returned a Promise, but the version of Vue you are using ` +\n            `does not support it yet.`\n        )\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR)\n    }\n  } else {\n    finishComponentSetup(instance, isSSR)\n  }\n}\n\nexport function handleSetupResult(\n  instance: ComponentInternalInstance,\n  setupResult: unknown,\n  isSSR: boolean\n) {\n  if (isFunction(setupResult)) {\n    // setup returned an inline render function\n    if (__SSR__ && (instance.type as ComponentOptions).__ssrInlineRender) {\n      // when the function's name is `ssrRender` (compiled by SFC inline mode),\n      // set it as ssrRender instead.\n      instance.ssrRender = setupResult\n    } else {\n      instance.render = setupResult as InternalRenderFunction\n    }\n  } else if (isObject(setupResult)) {\n    if (__DEV__ && isVNode(setupResult)) {\n      warn(\n        `setup() should not return VNodes directly - ` +\n          `return a render function instead.`\n      )\n    }\n    // setup returned bindings.\n    // assuming a render function compiled from template is present.\n    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {\n      instance.devtoolsRawSetupState = setupResult\n    }\n    instance.setupState = proxyRefs(setupResult)\n    if (__DEV__) {\n      exposeSetupStateOnRenderContext(instance)\n    }\n  } else if (__DEV__ && setupResult !== undefined) {\n    warn(\n      `setup() should return an object. Received: ${\n        setupResult === null ? 'null' : typeof setupResult\n      }`\n    )\n  }\n  finishComponentSetup(instance, isSSR)\n}\n\ntype CompileFunction = (\n  template: string | object,\n  options?: CompilerOptions\n) => InternalRenderFunction\n\nlet compile: CompileFunction | undefined\nlet installWithProxy: (i: ComponentInternalInstance) => void\n\n/**\n * For runtime-dom to register the compiler.\n * Note the exported method uses any to avoid d.ts relying on the compiler types.\n */\nexport function registerRuntimeCompiler(_compile: any) {\n  compile = _compile\n  installWithProxy = i => {\n    if (i.render!._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers)\n    }\n  }\n}\n\n// dev only\nexport const isRuntimeOnly = () => !compile\n\nexport function finishComponentSetup(\n  instance: ComponentInternalInstance,\n  isSSR: boolean,\n  skipOptions?: boolean\n) {\n  const Component = instance.type as ComponentOptions\n\n  if (__COMPAT__) {\n    convertLegacyRenderFn(instance)\n\n    if (__DEV__ && Component.compatConfig) {\n      validateCompatConfig(Component.compatConfig)\n    }\n  }\n\n  // template / render function normalization\n  // could be already set when returned from setup()\n  if (!instance.render) {\n    // only do on-the-fly compile if not in SSR - SSR on-the-fly compilation\n    // is done by server-renderer\n    if (!isSSR && compile && !Component.render) {\n      const template =\n        (__COMPAT__ &&\n          instance.vnode.props &&\n          instance.vnode.props['inline-template']) ||\n        Component.template\n      if (template) {\n        if (__DEV__) {\n          startMeasure(instance, `compile`)\n        }\n        const { isCustomElement, compilerOptions } = instance.appContext.config\n        const { delimiters, compilerOptions: componentCompilerOptions } =\n          Component\n        const finalCompilerOptions: CompilerOptions = extend(\n          extend(\n            {\n              isCustomElement,\n              delimiters\n            },\n            compilerOptions\n          ),\n          componentCompilerOptions\n        )\n        if (__COMPAT__) {\n          // pass runtime compat config into the compiler\n          finalCompilerOptions.compatConfig = Object.create(globalCompatConfig)\n          if (Component.compatConfig) {\n            extend(finalCompilerOptions.compatConfig, Component.compatConfig)\n          }\n        }\n        Component.render = compile(template, finalCompilerOptions)\n        if (__DEV__) {\n          endMeasure(instance, `compile`)\n        }\n      }\n    }\n\n    instance.render = (Component.render || NOOP) as InternalRenderFunction\n\n    // for runtime-compiled render functions using `with` blocks, the render\n    // proxy used needs a different `has` handler which is more performant and\n    // also only allows a whitelist of globals to fallthrough.\n    if (installWithProxy) {\n      installWithProxy(instance)\n    }\n  }\n\n  // support for 2.x options\n  if (__FEATURE_OPTIONS_API__ && !(__COMPAT__ && skipOptions)) {\n    setCurrentInstance(instance)\n    pauseTracking()\n    applyOptions(instance)\n    resetTracking()\n    unsetCurrentInstance()\n  }\n\n  // warn missing template/render\n  // the runtime compilation of template in SSR is done by server-render\n  if (__DEV__ && !Component.render && instance.render === NOOP && !isSSR) {\n    /* istanbul ignore if */\n    if (!compile && Component.template) {\n      warn(\n        `Component provided template option but ` +\n          `runtime compilation is not supported in this build of Vue.` +\n          (__ESM_BUNDLER__\n            ? ` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".`\n            : __ESM_BROWSER__\n            ? ` Use \"vue.esm-browser.js\" instead.`\n            : __GLOBAL__\n            ? ` Use \"vue.global.js\" instead.`\n            : ``) /* should not happen */\n      )\n    } else {\n      warn(`Component is missing template or render function.`)\n    }\n  }\n}\n\nfunction createAttrsProxy(instance: ComponentInternalInstance): Data {\n  return new Proxy(\n    instance.attrs,\n    __DEV__\n      ? {\n          get(target, key: string) {\n            markAttrsAccessed()\n            track(instance, TrackOpTypes.GET, '$attrs')\n            return target[key]\n          },\n          set() {\n            warn(`setupContext.attrs is readonly.`)\n            return false\n          },\n          deleteProperty() {\n            warn(`setupContext.attrs is readonly.`)\n            return false\n          }\n        }\n      : {\n          get(target, key: string) {\n            track(instance, TrackOpTypes.GET, '$attrs')\n            return target[key]\n          }\n        }\n  )\n}\n\nexport function createSetupContext(\n  instance: ComponentInternalInstance\n): SetupContext {\n  const expose: SetupContext['expose'] = exposed => {\n    if (__DEV__ && instance.exposed) {\n      warn(`expose() should be called only once per setup().`)\n    }\n    instance.exposed = exposed || {}\n  }\n\n  let attrs: Data\n  if (__DEV__) {\n    // We use getters in dev in case libs like test-utils overwrite instance\n    // properties (overwrites should not be done in prod)\n    return Object.freeze({\n      get attrs() {\n        return attrs || (attrs = createAttrsProxy(instance))\n      },\n      get slots() {\n        return shallowReadonly(instance.slots)\n      },\n      get emit() {\n        return (event: string, ...args: any[]) => instance.emit(event, ...args)\n      },\n      expose\n    })\n  } else {\n    return {\n      get attrs() {\n        return attrs || (attrs = createAttrsProxy(instance))\n      },\n      slots: instance.slots,\n      emit: instance.emit,\n      expose\n    }\n  }\n}\n\nexport function getExposeProxy(instance: ComponentInternalInstance) {\n  if (instance.exposed) {\n    return (\n      instance.exposeProxy ||\n      (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\n        get(target, key: string) {\n          if (key in target) {\n            return target[key]\n          } else if (key in publicPropertiesMap) {\n            return publicPropertiesMap[key](instance)\n          }\n        }\n      }))\n    )\n  }\n}\n\nconst classifyRE = /(?:^|[-_])(\\w)/g\nconst classify = (str: string): string =>\n  str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '')\n\nexport function getComponentName(\n  Component: ConcreteComponent\n): string | undefined {\n  return isFunction(Component)\n    ? Component.displayName || Component.name\n    : Component.name\n}\n\n/* istanbul ignore next */\nexport function formatComponentName(\n  instance: ComponentInternalInstance | null,\n  Component: ConcreteComponent,\n  isRoot = false\n): string {\n  let name = getComponentName(Component)\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/)\n    if (match) {\n      name = match[1]\n    }\n  }\n\n  if (!name && instance && instance.parent) {\n    // try to infer the name based on reverse resolution\n    const inferFromRegistry = (registry: Record<string, any> | undefined) => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key\n        }\n      }\n    }\n    name =\n      inferFromRegistry(\n        instance.components ||\n          (instance.parent.type as ComponentOptions).components\n      ) || inferFromRegistry(instance.appContext.components)\n  }\n\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`\n}\n\nexport function isClassComponent(value: unknown): value is ClassComponent {\n  return isFunction(value) && '__vccOpts' in value\n}\n", "import { computed as _computed } from '@vue/reactivity'\nimport { isInSSRComponentSetup } from './component'\n\nexport const computed = ((getterOrOptions: any, debugOptions?: any) => {\n  // @ts-ignore\n  return _computed(getterOrOptions, debugOptions, isInSSRComponentSetup)\n}) as typeof _computed\n", "import { ComponentPropsOptions } from '@vue/runtime-core'\nimport { isArray, isPromise, isFunction } from '@vue/shared'\nimport {\n  getCurrentInstance,\n  setCurrentInstance,\n  SetupContext,\n  createSetupContext,\n  unsetCurrentInstance\n} from './component'\nimport { EmitFn, EmitsOptions } from './componentEmits'\nimport { ComponentObjectPropsOptions, ExtractPropTypes } from './componentProps'\nimport { warn } from './warning'\n\n// dev only\nconst warnRuntimeUsage = (method: string) =>\n  warn(\n    `${method}() is a compiler-hint helper that is only usable inside ` +\n      `<script setup> of a single file component. Its arguments should be ` +\n      `compiled away and passing it at runtime has no effect.`\n  )\n\n/**\n * Vue `<script setup>` compiler macro for declaring component props. The\n * expected argument is the same as the component `props` option.\n *\n * Example runtime declaration:\n * ```js\n * // using Array syntax\n * const props = defineProps(['foo', 'bar'])\n * // using Object syntax\n * const props = defineProps({\n *   foo: String,\n *   bar: {\n *     type: Number,\n *     required: true\n *   }\n * })\n * ```\n *\n * Equivalent type-based declaration:\n * ```ts\n * // will be compiled into equivalent runtime declarations\n * const props = defineProps<{\n *   foo?: string\n *   bar: number\n * }>()\n * ```\n *\n * This is only usable inside `<script setup>`, is compiled away in the\n * output and should **not** be actually called at runtime.\n */\n// overload 1: runtime props w/ array\nexport function defineProps<PropNames extends string = string>(\n  props: PropNames[]\n): Readonly<{ [key in PropNames]?: any }>\n// overload 2: runtime props w/ object\nexport function defineProps<\n  PP extends ComponentObjectPropsOptions = ComponentObjectPropsOptions\n>(props: PP): Readonly<ExtractPropTypes<PP>>\n// overload 3: typed-based declaration\nexport function defineProps<TypeProps>(): Readonly<TypeProps>\n// implementation\nexport function defineProps() {\n  if (__DEV__) {\n    warnRuntimeUsage(`defineProps`)\n  }\n  return null as any\n}\n\n/**\n * Vue `<script setup>` compiler macro for declaring a component's emitted\n * events. The expected argument is the same as the component `emits` option.\n *\n * Example runtime declaration:\n * ```js\n * const emit = defineEmits(['change', 'update'])\n * ```\n *\n * Example type-based declaration:\n * ```ts\n * const emit = defineEmits<{\n *   (event: 'change'): void\n *   (event: 'update', id: number): void\n * }>()\n *\n * emit('change')\n * emit('update', 1)\n * ```\n *\n * This is only usable inside `<script setup>`, is compiled away in the\n * output and should **not** be actually called at runtime.\n */\n// overload 1: runtime emits w/ array\nexport function defineEmits<EE extends string = string>(\n  emitOptions: EE[]\n): EmitFn<EE[]>\nexport function defineEmits<E extends EmitsOptions = EmitsOptions>(\n  emitOptions: E\n): EmitFn<E>\nexport function defineEmits<TypeEmit>(): TypeEmit\n// implementation\nexport function defineEmits() {\n  if (__DEV__) {\n    warnRuntimeUsage(`defineEmits`)\n  }\n  return null as any\n}\n\n/**\n * Vue `<script setup>` compiler macro for declaring a component's exposed\n * instance properties when it is accessed by a parent component via template\n * refs.\n *\n * `<script setup>` components are closed by default - i.e. variables inside\n * the `<script setup>` scope is not exposed to parent unless explicitly exposed\n * via `defineExpose`.\n *\n * This is only usable inside `<script setup>`, is compiled away in the\n * output and should **not** be actually called at runtime.\n */\nexport function defineExpose<\n  Exposed extends Record<string, any> = Record<string, any>\n>(exposed?: Exposed) {\n  if (__DEV__) {\n    warnRuntimeUsage(`defineExpose`)\n  }\n}\n\ntype NotUndefined<T> = T extends undefined ? never : T\n\ntype InferDefaults<T> = {\n  [K in keyof T]?: InferDefault<T, NotUndefined<T[K]>>\n}\n\ntype InferDefault<P, T> = T extends\n  | null\n  | number\n  | string\n  | boolean\n  | symbol\n  | Function\n  ? T\n  : (props: P) => T\n\ntype PropsWithDefaults<Base, Defaults> = Base & {\n  [K in keyof Defaults]: K extends keyof Base ? NotUndefined<Base[K]> : never\n}\n\n/**\n * Vue `<script setup>` compiler macro for providing props default values when\n * using type-based `defineProps` declaration.\n *\n * Example usage:\n * ```ts\n * withDefaults(defineProps<{\n *   size?: number\n *   labels?: string[]\n * }>(), {\n *   size: 3,\n *   labels: () => ['default label']\n * })\n * ```\n *\n * This is only usable inside `<script setup>`, is compiled away in the output\n * and should **not** be actually called at runtime.\n */\nexport function withDefaults<Props, Defaults extends InferDefaults<Props>>(\n  props: Props,\n  defaults: Defaults\n): PropsWithDefaults<Props, Defaults> {\n  if (__DEV__) {\n    warnRuntimeUsage(`withDefaults`)\n  }\n  return null as any\n}\n\nexport function useSlots(): SetupContext['slots'] {\n  return getContext().slots\n}\n\nexport function useAttrs(): SetupContext['attrs'] {\n  return getContext().attrs\n}\n\nfunction getContext(): SetupContext {\n  const i = getCurrentInstance()!\n  if (__DEV__ && !i) {\n    warn(`useContext() called without active instance.`)\n  }\n  return i.setupContext || (i.setupContext = createSetupContext(i))\n}\n\n/**\n * Runtime helper for merging default declarations. Imported by compiled code\n * only.\n * @internal\n */\nexport function mergeDefaults(\n  raw: ComponentPropsOptions,\n  defaults: Record<string, any>\n): ComponentObjectPropsOptions {\n  const props = isArray(raw)\n    ? raw.reduce(\n        (normalized, p) => ((normalized[p] = {}), normalized),\n        {} as ComponentObjectPropsOptions\n      )\n    : raw\n  for (const key in defaults) {\n    const opt = props[key]\n    if (opt) {\n      if (isArray(opt) || isFunction(opt)) {\n        props[key] = { type: opt, default: defaults[key] }\n      } else {\n        opt.default = defaults[key]\n      }\n    } else if (opt === null) {\n      props[key] = { default: defaults[key] }\n    } else if (__DEV__) {\n      warn(`props default key \"${key}\" has no corresponding declaration.`)\n    }\n  }\n  return props\n}\n\n/**\n * Used to create a proxy for the rest element when destructuring props with\n * defineProps().\n * @internal\n */\nexport function createPropsRestProxy(\n  props: any,\n  excludedKeys: string[]\n): Record<string, any> {\n  const ret: Record<string, any> = {}\n  for (const key in props) {\n    if (!excludedKeys.includes(key)) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        get: () => props[key]\n      })\n    }\n  }\n  return ret\n}\n\n/**\n * `<script setup>` helper for persisting the current instance context over\n * async/await flows.\n *\n * `@vue/compiler-sfc` converts the following:\n *\n * ```ts\n * const x = await foo()\n * ```\n *\n * into:\n *\n * ```ts\n * let __temp, __restore\n * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)\n * ```\n * @internal\n */\nexport function withAsyncContext(getAwaitable: () => any) {\n  const ctx = getCurrentInstance()!\n  if (__DEV__ && !ctx) {\n    warn(\n      `withAsyncContext called without active current instance. ` +\n        `This is likely a bug.`\n    )\n  }\n  let awaitable = getAwaitable()\n  unsetCurrentInstance()\n  if (isPromise(awaitable)) {\n    awaitable = awaitable.catch(e => {\n      setCurrentInstance(ctx)\n      throw e\n    })\n  }\n  return [awaitable, () => setCurrentInstance(ctx)]\n}\n", "import {\n  VNode,\n  VNodeProps,\n  createVNode,\n  VNodeArrayChildren,\n  Fragment,\n  Text,\n  Comment,\n  isVNode\n} from './vnode'\nimport { Teleport, TeleportProps } from './components/Teleport'\nimport { Suspense, SuspenseProps } from './components/Suspense'\nimport { isObject, isArray } from '@vue/shared'\nimport { RawSlots } from './componentSlots'\nimport {\n  FunctionalComponent,\n  Component,\n  ComponentOptions,\n  ConcreteComponent\n} from './component'\nimport { EmitsOptions } from './componentEmits'\nimport { DefineComponent } from './apiDefineComponent'\n\n// `h` is a more user-friendly version of `createVNode` that allows omitting the\n// props when possible. It is intended for manually written render functions.\n// Compiler-generated code uses `createVNode` because\n// 1. it is monomorphic and avoids the extra call overhead\n// 2. it allows specifying patchFlags for optimization\n\n/*\n// type only\nh('div')\n\n// type + props\nh('div', {})\n\n// type + omit props + children\n// Omit props does NOT support named slots\nh('div', []) // array\nh('div', 'foo') // text\nh('div', h('br')) // vnode\nh(Component, () => {}) // default slot\n\n// type + props + children\nh('div', {}, []) // array\nh('div', {}, 'foo') // text\nh('div', {}, h('br')) // vnode\nh(Component, {}, () => {}) // default slot\nh(Component, {}, {}) // named slots\n\n// named slots without props requires explicit `null` to avoid ambiguity\nh(Component, null, {})\n**/\n\ntype RawProps = VNodeProps & {\n  // used to differ from a single VNode object as children\n  __v_isVNode?: never\n  // used to differ from Array children\n  [Symbol.iterator]?: never\n} & Record<string, any>\n\ntype RawChildren =\n  | string\n  | number\n  | boolean\n  | VNode\n  | VNodeArrayChildren\n  | (() => any)\n\n// fake constructor type returned from `defineComponent`\ninterface Constructor<P = any> {\n  __isFragment?: never\n  __isTeleport?: never\n  __isSuspense?: never\n  new (...args: any[]): { $props: P }\n}\n\n// The following is a series of overloads for providing props validation of\n// manually written render functions.\n\n// element\nexport function h(type: string, children?: RawChildren): VNode\nexport function h(\n  type: string,\n  props?: RawProps | null,\n  children?: RawChildren | RawSlots\n): VNode\n\n// text/comment\nexport function h(\n  type: typeof Text | typeof Comment,\n  children?: string | number | boolean\n): VNode\nexport function h(\n  type: typeof Text | typeof Comment,\n  props?: null,\n  children?: string | number | boolean\n): VNode\n// fragment\nexport function h(type: typeof Fragment, children?: VNodeArrayChildren): VNode\nexport function h(\n  type: typeof Fragment,\n  props?: RawProps | null,\n  children?: VNodeArrayChildren\n): VNode\n\n// teleport (target prop is required)\nexport function h(\n  type: typeof Teleport,\n  props: RawProps & TeleportProps,\n  children: RawChildren\n): VNode\n\n// suspense\nexport function h(type: typeof Suspense, children?: RawChildren): VNode\nexport function h(\n  type: typeof Suspense,\n  props?: (RawProps & SuspenseProps) | null,\n  children?: RawChildren | RawSlots\n): VNode\n\n// functional component\nexport function h<P, E extends EmitsOptions = {}>(\n  type: FunctionalComponent<P, E>,\n  props?: (RawProps & P) | ({} extends P ? null : never),\n  children?: RawChildren | RawSlots\n): VNode\n\n// catch-all for generic component types\nexport function h(type: Component, children?: RawChildren): VNode\n\n// concrete component\nexport function h<P>(\n  type: ConcreteComponent | string,\n  children?: RawChildren\n): VNode\nexport function h<P>(\n  type: ConcreteComponent<P> | string,\n  props?: (RawProps & P) | ({} extends P ? null : never),\n  children?: RawChildren\n): VNode\n\n// component without props\nexport function h(\n  type: Component,\n  props: null,\n  children?: RawChildren | RawSlots\n): VNode\n\n// exclude `defineComponent` constructors\nexport function h<P>(\n  type: ComponentOptions<P>,\n  props?: (RawProps & P) | ({} extends P ? null : never),\n  children?: RawChildren | RawSlots\n): VNode\n\n// fake constructor type returned by `defineComponent` or class component\nexport function h(type: Constructor, children?: RawChildren): VNode\nexport function h<P>(\n  type: Constructor<P>,\n  props?: (RawProps & P) | ({} extends P ? null : never),\n  children?: RawChildren | RawSlots\n): VNode\n\n// fake constructor type returned by `defineComponent`\nexport function h(type: DefineComponent, children?: RawChildren): VNode\nexport function h<P>(\n  type: DefineComponent<P>,\n  props?: (RawProps & P) | ({} extends P ? null : never),\n  children?: RawChildren | RawSlots\n): VNode\n\n// Actual implementation\nexport function h(type: any, propsOrChildren?: any, children?: any): VNode {\n  const l = arguments.length\n  if (l === 2) {\n    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\n      // single vnode without props\n      if (isVNode(propsOrChildren)) {\n        return createVNode(type, null, [propsOrChildren])\n      }\n      // props without children\n      return createVNode(type, propsOrChildren)\n    } else {\n      // omit props\n      return createVNode(type, null, propsOrChildren)\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2)\n    } else if (l === 3 && isVNode(children)) {\n      children = [children]\n    }\n    return createVNode(type, propsOrChildren, children)\n  }\n}\n", "import { inject } from '../apiInject'\nimport { warn } from '../warning'\n\nexport const ssrContextKey = Symbol(__DEV__ ? `ssrContext` : ``)\n\nexport const useSSRContext = <T = Record<string, any>>() => {\n  if (!__GLOBAL__) {\n    const ctx = inject<T>(ssrContextKey)\n    if (!ctx) {\n      warn(\n        `Server rendering context not provided. Make sure to only call ` +\n          `useSSRContext() conditionally in the server build.`\n      )\n    }\n    return ctx\n  } else if (__DEV__) {\n    warn(`useSSRContext() is not supported in the global build.`)\n  }\n}\n", "import { isReactive, isReadonly, isRef, Ref, toRaw } from '@vue/reactivity'\nimport { EMPTY_OBJ, extend, isArray, isFunction, isObject } from '@vue/shared'\nimport { isShallow } from '../../reactivity/src/reactive'\nimport { ComponentInternalInstance, ComponentOptions } from './component'\nimport { ComponentPublicInstance } from './componentPublicInstance'\n\nexport function initCustomFormatter() {\n  /* eslint-disable no-restricted-globals */\n  if (!__DEV__ || typeof window === 'undefined') {\n    return\n  }\n\n  const vueStyle = { style: 'color:#3ba776' }\n  const numberStyle = { style: 'color:#0b1bc9' }\n  const stringStyle = { style: 'color:#b62e24' }\n  const keywordStyle = { style: 'color:#9d288c' }\n\n  // custom formatter for Chrome\n  // https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html\n  const formatter = {\n    header(obj: unknown) {\n      // TODO also format ComponentPublicInstance & ctx.slots/attrs in setup\n      if (!isObject(obj)) {\n        return null\n      }\n\n      if (obj.__isVue) {\n        return ['div', vueStyle, `VueInstance`]\n      } else if (isRef(obj)) {\n        return [\n          'div',\n          {},\n          ['span', vueStyle, genRefFlag(obj)],\n          '<',\n          formatValue(obj.value),\n          `>`\n        ]\n      } else if (isReactive(obj)) {\n        return [\n          'div',\n          {},\n          ['span', vueStyle, isShallow(obj) ? 'ShallowReactive' : 'Reactive'],\n          '<',\n          formatValue(obj),\n          `>${isReadonly(obj) ? ` (readonly)` : ``}`\n        ]\n      } else if (isReadonly(obj)) {\n        return [\n          'div',\n          {},\n          ['span', vueStyle, isShallow(obj) ? 'ShallowReadonly' : 'Readonly'],\n          '<',\n          formatValue(obj),\n          '>'\n        ]\n      }\n      return null\n    },\n    hasBody(obj: unknown) {\n      return obj && (obj as any).__isVue\n    },\n    body(obj: unknown) {\n      if (obj && (obj as any).__isVue) {\n        return [\n          'div',\n          {},\n          ...formatInstance((obj as ComponentPublicInstance).$)\n        ]\n      }\n    }\n  }\n\n  function formatInstance(instance: ComponentInternalInstance) {\n    const blocks = []\n    if (instance.type.props && instance.props) {\n      blocks.push(createInstanceBlock('props', toRaw(instance.props)))\n    }\n    if (instance.setupState !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock('setup', instance.setupState))\n    }\n    if (instance.data !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock('data', toRaw(instance.data)))\n    }\n    const computed = extractKeys(instance, 'computed')\n    if (computed) {\n      blocks.push(createInstanceBlock('computed', computed))\n    }\n    const injected = extractKeys(instance, 'inject')\n    if (injected) {\n      blocks.push(createInstanceBlock('injected', injected))\n    }\n\n    blocks.push([\n      'div',\n      {},\n      [\n        'span',\n        {\n          style: keywordStyle.style + ';opacity:0.66'\n        },\n        '$ (internal): '\n      ],\n      ['object', { object: instance }]\n    ])\n    return blocks\n  }\n\n  function createInstanceBlock(type: string, target: any) {\n    target = extend({}, target)\n    if (!Object.keys(target).length) {\n      return ['span', {}]\n    }\n    return [\n      'div',\n      { style: 'line-height:1.25em;margin-bottom:0.6em' },\n      [\n        'div',\n        {\n          style: 'color:#476582'\n        },\n        type\n      ],\n      [\n        'div',\n        {\n          style: 'padding-left:1.25em'\n        },\n        ...Object.keys(target).map(key => {\n          return [\n            'div',\n            {},\n            ['span', keywordStyle, key + ': '],\n            formatValue(target[key], false)\n          ]\n        })\n      ]\n    ]\n  }\n\n  function formatValue(v: unknown, asRaw = true) {\n    if (typeof v === 'number') {\n      return ['span', numberStyle, v]\n    } else if (typeof v === 'string') {\n      return ['span', stringStyle, JSON.stringify(v)]\n    } else if (typeof v === 'boolean') {\n      return ['span', keywordStyle, v]\n    } else if (isObject(v)) {\n      return ['object', { object: asRaw ? toRaw(v) : v }]\n    } else {\n      return ['span', stringStyle, String(v)]\n    }\n  }\n\n  function extractKeys(instance: ComponentInternalInstance, type: string) {\n    const Comp = instance.type\n    if (isFunction(Comp)) {\n      return\n    }\n    const extracted: Record<string, any> = {}\n    for (const key in instance.ctx) {\n      if (isKeyOfType(Comp, key, type)) {\n        extracted[key] = instance.ctx[key]\n      }\n    }\n    return extracted\n  }\n\n  function isKeyOfType(Comp: ComponentOptions, key: string, type: string) {\n    const opts = Comp[type]\n    if (\n      (isArray(opts) && opts.includes(key)) ||\n      (isObject(opts) && key in opts)\n    ) {\n      return true\n    }\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n      return true\n    }\n    if (Comp.mixins && Comp.mixins.some(m => isKeyOfType(m, key, type))) {\n      return true\n    }\n  }\n\n  function genRefFlag(v: Ref) {\n    if (isShallow(v)) {\n      return `ShallowRef`\n    }\n    if ((v as any).effect) {\n      return `ComputedRef`\n    }\n    return `Ref`\n  }\n\n  if ((window as any).devtoolsFormatters) {\n    ;(window as any).devtoolsFormatters.push(formatter)\n  } else {\n    ;(window as any).devtoolsFormatters = [formatter]\n  }\n}\n", "import { currentBlock, isBlockTreeEnabled, VNode } from '../vnode'\n\nexport function withMemo(\n  memo: any[],\n  render: () => VNode<any, any>,\n  cache: any[],\n  index: number\n) {\n  const cached = cache[index] as VNode | undefined\n  if (cached && isMemoSame(cached, memo)) {\n    return cached\n  }\n  const ret = render()\n\n  // shallow clone\n  ret.memo = memo.slice()\n  return (cache[index] = ret)\n}\n\nexport function isMemoSame(cached: VNode, memo: any[]) {\n  const prev: any[] = cached.memo!\n  if (prev.length != memo.length) {\n    return false\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if (prev[i] !== memo[i]) {\n      return false\n    }\n  }\n\n  // make sure to let parent block track it when returning cached\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(cached)\n  }\n  return true\n}\n", "// Core API ------------------------------------------------------------------\n\nexport const version = __VERSION__\nexport {\n  // core\n  reactive,\n  ref,\n  readonly,\n  // utilities\n  unref,\n  proxyRefs,\n  isRef,\n  toRef,\n  toRefs,\n  isProxy,\n  isReactive,\n  isReadonly,\n  isShallow,\n  // advanced\n  customRef,\n  triggerRef,\n  shallowRef,\n  shallowReactive,\n  shallowReadonly,\n  markRaw,\n  toRaw,\n  // effect\n  effect,\n  stop,\n  ReactiveEffect,\n  // effect scope\n  effectScope,\n  EffectScope,\n  getCurrentScope,\n  onScopeDispose\n} from '@vue/reactivity'\nexport { computed } from './apiComputed'\nexport {\n  watch,\n  watchEffect,\n  watchPostEffect,\n  watchSyncEffect\n} from './apiWatch'\nexport {\n  onBeforeMount,\n  onMounted,\n  onBeforeUpdate,\n  onUpdated,\n  onBeforeUnmount,\n  onUnmounted,\n  onActivated,\n  onDeactivated,\n  onRenderTracked,\n  onRenderTriggered,\n  onErrorCaptured,\n  onServerPrefetch\n} from './apiLifecycle'\nexport { provide, inject } from './apiInject'\nexport { nextTick } from './scheduler'\nexport { defineComponent } from './apiDefineComponent'\nexport { defineAsyncComponent } from './apiAsyncComponent'\nexport { useAttrs, useSlots } from './apiSetupHelpers'\n\n// <script setup> API ----------------------------------------------------------\n\nexport {\n  // macros runtime, for typing and warnings only\n  defineProps,\n  defineEmits,\n  defineExpose,\n  withDefaults,\n  // internal\n  mergeDefaults,\n  createPropsRestProxy,\n  withAsyncContext\n} from './apiSetupHelpers'\n\n// Advanced API ----------------------------------------------------------------\n\n// For getting a hold of the internal instance in setup() - useful for advanced\n// plugins\nexport { getCurrentInstance } from './component'\n\n// For raw render function users\nexport { h } from './h'\n// Advanced render function utilities\nexport { createVNode, cloneVNode, mergeProps, isVNode } from './vnode'\n// VNode types\nexport { Fragment, Text, Comment, Static } from './vnode'\n// Built-in components\nexport { Teleport, TeleportProps } from './components/Teleport'\nexport { Suspense, SuspenseProps } from './components/Suspense'\nexport { KeepAlive, KeepAliveProps } from './components/KeepAlive'\nexport {\n  BaseTransition,\n  BaseTransitionProps\n} from './components/BaseTransition'\n// For using custom directives\nexport { withDirectives } from './directives'\n// SSR context\nexport { useSSRContext, ssrContextKey } from './helpers/useSsrContext'\n\n// Custom Renderer API ---------------------------------------------------------\n\nexport { createRenderer, createHydrationRenderer } from './renderer'\nexport { queuePostFlushCb } from './scheduler'\nexport { warn } from './warning'\nexport {\n  handleError,\n  callWithErrorHandling,\n  callWithAsyncErrorHandling,\n  ErrorCodes\n} from './errorHandling'\nexport {\n  resolveComponent,\n  resolveDirective,\n  resolveDynamicComponent\n} from './helpers/resolveAssets'\n// For integration with runtime compiler\nexport { registerRuntimeCompiler, isRuntimeOnly } from './component'\nexport {\n  useTransitionState,\n  resolveTransitionHooks,\n  setTransitionHooks,\n  getTransitionRawChildren\n} from './components/BaseTransition'\nexport { initCustomFormatter } from './customFormatter'\n\n// For devtools\nexport { devtools, setDevtoolsHook } from './devtools'\n\n// Types -------------------------------------------------------------------------\n\nimport { VNode } from './vnode'\nimport { ComponentInternalInstance } from './component'\n\n// Augment Ref unwrap bail types.\n// Note: if updating this, also update `types/refBail.d.ts`.\ndeclare module '@vue/reactivity' {\n  export interface RefUnwrapBailTypes {\n    runtimeCoreBailTypes:\n      | VNode\n      | {\n          // directly bailing on ComponentPublicInstance results in recursion\n          // so we use this as a bail hint\n          $: ComponentInternalInstance\n        }\n  }\n}\n\nexport {\n  Ref,\n  ToRef,\n  ToRefs,\n  UnwrapRef,\n  ShallowRef,\n  ShallowUnwrapRef,\n  CustomRefFactory,\n  ReactiveFlags,\n  DeepReadonly,\n  ShallowReactive,\n  UnwrapNestedRefs,\n  ComputedRef,\n  WritableComputedRef,\n  WritableComputedOptions,\n  ComputedGetter,\n  ComputedSetter,\n  ReactiveEffectRunner,\n  ReactiveEffectOptions,\n  EffectScheduler,\n  DebuggerOptions,\n  DebuggerEvent,\n  DebuggerEventExtraInfo,\n  TrackOpTypes,\n  TriggerOpTypes\n} from '@vue/reactivity'\nexport {\n  WatchEffect,\n  WatchOptions,\n  WatchOptionsBase,\n  WatchCallback,\n  WatchSource,\n  WatchStopHandle\n} from './apiWatch'\nexport { InjectionKey } from './apiInject'\nexport {\n  App,\n  AppConfig,\n  AppContext,\n  Plugin,\n  CreateAppFunction,\n  OptionMergeFunction\n} from './apiCreateApp'\nexport {\n  VNode,\n  VNodeChild,\n  VNodeTypes,\n  VNodeProps,\n  VNodeArrayChildren,\n  VNodeNormalizedChildren\n} from './vnode'\nexport {\n  Component,\n  ConcreteComponent,\n  FunctionalComponent,\n  ComponentInternalInstance,\n  SetupContext,\n  ComponentCustomProps,\n  AllowedComponentProps\n} from './component'\nexport { DefineComponent } from './apiDefineComponent'\nexport {\n  ComponentOptions,\n  ComponentOptionsMixin,\n  ComponentOptionsWithoutProps,\n  ComponentOptionsWithObjectProps,\n  ComponentOptionsWithArrayProps,\n  ComponentCustomOptions,\n  ComponentOptionsBase,\n  RenderFunction,\n  MethodOptions,\n  ComputedOptions,\n  RuntimeCompilerOptions\n} from './componentOptions'\nexport { EmitsOptions, ObjectEmitsOptions } from './componentEmits'\nexport {\n  ComponentPublicInstance,\n  ComponentCustomProperties,\n  CreateComponentPublicInstance\n} from './componentPublicInstance'\nexport {\n  Renderer,\n  RendererNode,\n  RendererElement,\n  HydrationRenderer,\n  RendererOptions,\n  RootRenderFunction\n} from './renderer'\nexport { RootHydrateFunction } from './hydration'\nexport { Slot, Slots } from './componentSlots'\nexport {\n  Prop,\n  PropType,\n  ComponentPropsOptions,\n  ComponentObjectPropsOptions,\n  ExtractPropTypes,\n  ExtractDefaultPropTypes\n} from './componentProps'\nexport {\n  Directive,\n  DirectiveBinding,\n  DirectiveHook,\n  ObjectDirective,\n  FunctionDirective,\n  DirectiveArguments\n} from './directives'\nexport { SuspenseBoundary } from './components/Suspense'\nexport { TransitionState, TransitionHooks } from './components/BaseTransition'\nexport {\n  AsyncComponentOptions,\n  AsyncComponentLoader\n} from './apiAsyncComponent'\nexport { HMRRuntime } from './hmr'\n\n// Internal API ----------------------------------------------------------------\n\n// **IMPORTANT** Internal APIs may change without notice between versions and\n// user code should avoid relying on them.\n\n// For compiler generated code\n// should sync with '@vue/compiler-core/src/runtimeHelpers.ts'\nexport {\n  withCtx,\n  pushScopeId,\n  popScopeId,\n  withScopeId\n} from './componentRenderContext'\nexport { renderList } from './helpers/renderList'\nexport { toHandlers } from './helpers/toHandlers'\nexport { renderSlot } from './helpers/renderSlot'\nexport { createSlots } from './helpers/createSlots'\nexport { withMemo, isMemoSame } from './helpers/withMemo'\nexport {\n  openBlock,\n  createBlock,\n  setBlockTracking,\n  createTextVNode,\n  createCommentVNode,\n  createStaticVNode,\n  createElementVNode,\n  createElementBlock,\n  guardReactiveProps\n} from './vnode'\nexport {\n  toDisplayString,\n  camelize,\n  capitalize,\n  toHandlerKey,\n  normalizeProps,\n  normalizeClass,\n  normalizeStyle\n} from '@vue/shared'\n\n// For test-utils\nexport { transformVNodeArgs } from './vnode'\n\n// SSR -------------------------------------------------------------------------\n\n// **IMPORTANT** These APIs are exposed solely for @vue/server-renderer and may\n// change without notice between versions. User code should never rely on them.\n\nimport { createComponentInstance, setupComponent } from './component'\nimport { renderComponentRoot } from './componentRenderUtils'\nimport { setCurrentRenderingInstance } from './componentRenderContext'\nimport { isVNode, normalizeVNode } from './vnode'\n\nconst _ssrUtils = {\n  createComponentInstance,\n  setupComponent,\n  renderComponentRoot,\n  setCurrentRenderingInstance,\n  isVNode,\n  normalizeVNode\n}\n\n/**\n * SSR utils for \\@vue/server-renderer. Only exposed in cjs builds.\n * @internal\n */\nexport const ssrUtils = (__SSR__ ? _ssrUtils : null) as typeof _ssrUtils\n\n// 2.x COMPAT ------------------------------------------------------------------\n\nexport { DeprecationTypes } from './compat/compatConfig'\nexport { CompatVue } from './compat/global'\nexport { LegacyConfig } from './compat/globalConfig'\n\nimport { warnDeprecation } from './compat/compatConfig'\nimport { createCompatVue } from './compat/global'\nimport {\n  isCompatEnabled,\n  checkCompatEnabled,\n  softAssertCompatEnabled\n} from './compat/compatConfig'\nimport { resolveFilter as _resolveFilter } from './helpers/resolveAssets'\n\n/**\n * @internal only exposed in compat builds\n */\nexport const resolveFilter = __COMPAT__ ? _resolveFilter : null\n\nconst _compatUtils = {\n  warnDeprecation,\n  createCompatVue,\n  isCompatEnabled,\n  checkCompatEnabled,\n  softAssertCompatEnabled\n}\n\n/**\n * @internal only exposed in compat builds.\n */\nexport const compatUtils = (\n  __COMPAT__ ? _compatUtils : null\n) as typeof _compatUtils\n", "import { RendererOptions } from '@vue/runtime-core'\n\nexport const svgNS = 'http://www.w3.org/2000/svg'\n\nconst doc = (typeof document !== 'undefined' ? document : null) as Document\n\nconst templateContainer = doc && doc.createElement('template')\n\nexport const nodeOps: Omit<RendererOptions<Node, Element>, 'patchProp'> = {\n  insert: (child, parent, anchor) => {\n    parent.insertBefore(child, anchor || null)\n  },\n\n  remove: child => {\n    const parent = child.parentNode\n    if (parent) {\n      parent.removeChild(child)\n    }\n  },\n\n  createElement: (tag, isSVG, is, props): Element => {\n    const el = isSVG\n      ? doc.createElementNS(svgNS, tag)\n      : doc.createElement(tag, is ? { is } : undefined)\n\n    if (tag === 'select' && props && props.multiple != null) {\n      ;(el as HTMLSelectElement).setAttribute('multiple', props.multiple)\n    }\n\n    return el\n  },\n\n  createText: text => doc.createTextNode(text),\n\n  createComment: text => doc.createComment(text),\n\n  setText: (node, text) => {\n    node.nodeValue = text\n  },\n\n  setElementText: (el, text) => {\n    el.textContent = text\n  },\n\n  parentNode: node => node.parentNode as Element | null,\n\n  nextSibling: node => node.nextSibling,\n\n  querySelector: selector => doc.querySelector(selector),\n\n  setScopeId(el, id) {\n    el.setAttribute(id, '')\n  },\n\n  cloneNode(el) {\n    const cloned = el.cloneNode(true)\n    // #3072\n    // - in `patchDOMProp`, we store the actual value in the `el._value` property.\n    // - normally, elements using `:value` bindings will not be hoisted, but if\n    //   the bound value is a constant, e.g. `:value=\"true\"` - they do get\n    //   hoisted.\n    // - in production, hoisted nodes are cloned when subsequent inserts, but\n    //   cloneNode() does not copy the custom property we attached.\n    // - This may need to account for other custom DOM properties we attach to\n    //   elements in addition to `_value` in the future.\n    if (`_value` in el) {\n      ;(cloned as any)._value = (el as any)._value\n    }\n    return cloned\n  },\n\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(content, parent, anchor, isSVG, start, end) {\n    // <parent> before | first ... last | anchor </parent>\n    const before = anchor ? anchor.previousSibling : parent.lastChild\n    // #5308 can only take cached path if:\n    // - has a single root node\n    // - nextSibling info is still available\n    if (start && (start === end || start.nextSibling)) {\n      // cached\n      while (true) {\n        parent.insertBefore(start!.cloneNode(true), anchor)\n        if (start === end || !(start = start!.nextSibling)) break\n      }\n    } else {\n      // fresh insert\n      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content\n      const template = templateContainer.content\n      if (isSVG) {\n        // remove outer svg wrapper\n        const wrapper = template.firstChild!\n        while (wrapper.firstChild) {\n          template.appendChild(wrapper.firstChild)\n        }\n        template.removeChild(wrapper)\n      }\n      parent.insertBefore(template, anchor)\n    }\n    return [\n      // first\n      before ? before.nextSibling! : parent.firstChild!,\n      // last\n      anchor ? anchor.previousSibling! : parent.lastChild!\n    ]\n  }\n}\n", "import { ElementWithTransition } from '../components/Transition'\n\n// compiler should normalize class + :class bindings on the same element\n// into a single binding ['staticClass', dynamic]\nexport function patchClass(el: Element, value: string | null, isSVG: boolean) {\n  // directly setting className should be faster than setAttribute in theory\n  // if this is an element during a transition, take the temporary transition\n  // classes into account.\n  const transitionClasses = (el as ElementWithTransition)._vtc\n  if (transitionClasses) {\n    value = (\n      value ? [value, ...transitionClasses] : [...transitionClasses]\n    ).join(' ')\n  }\n  if (value == null) {\n    el.removeAttribute('class')\n  } else if (isSVG) {\n    el.setAttribute('class', value)\n  } else {\n    el.className = value\n  }\n}\n", "import { isString, hyphenate, capitalize, isArray } from '@vue/shared'\nimport { camelize } from '@vue/runtime-core'\n\ntype Style = string | Record<string, string | string[]> | null\n\nexport function patchStyle(el: Element, prev: Style, next: Style) {\n  const style = (el as HTMLElement).style\n  const isCssString = isString(next)\n  if (next && !isCssString) {\n    for (const key in next) {\n      setStyle(style, key, next[key])\n    }\n    if (prev && !isString(prev)) {\n      for (const key in prev) {\n        if (next[key] == null) {\n          setStyle(style, key, '')\n        }\n      }\n    }\n  } else {\n    const currentDisplay = style.display\n    if (isCssString) {\n      if (prev !== next) {\n        style.cssText = next as string\n      }\n    } else if (prev) {\n      el.removeAttribute('style')\n    }\n    // indicates that the `display` of the element is controlled by `v-show`,\n    // so we always keep the current `display` value regardless of the `style`\n    // value, thus handing over control to `v-show`.\n    if ('_vod' in el) {\n      style.display = currentDisplay\n    }\n  }\n}\n\nconst importantRE = /\\s*!important$/\n\nfunction setStyle(\n  style: CSSStyleDeclaration,\n  name: string,\n  val: string | string[]\n) {\n  if (isArray(val)) {\n    val.forEach(v => setStyle(style, name, v))\n  } else {\n    if (name.startsWith('--')) {\n      // custom property definition\n      style.setProperty(name, val)\n    } else {\n      const prefixed = autoPrefix(style, name)\n      if (importantRE.test(val)) {\n        // !important\n        style.setProperty(\n          hyphenate(prefixed),\n          val.replace(importantRE, ''),\n          'important'\n        )\n      } else {\n        style[prefixed as any] = val\n      }\n    }\n  }\n}\n\nconst prefixes = ['Webkit', 'Moz', 'ms']\nconst prefixCache: Record<string, string> = {}\n\nfunction autoPrefix(style: CSSStyleDeclaration, rawName: string): string {\n  const cached = prefixCache[rawName]\n  if (cached) {\n    return cached\n  }\n  let name = camelize(rawName)\n  if (name !== 'filter' && name in style) {\n    return (prefixCache[rawName] = name)\n  }\n  name = capitalize(name)\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefixed = prefixes[i] + name\n    if (prefixed in style) {\n      return (prefixCache[rawName] = prefixed)\n    }\n  }\n  return rawName\n}\n", "import {\n  includeBooleanAttr,\n  isSpecialBooleanAttr,\n  makeMap,\n  NOOP\n} from '@vue/shared'\nimport {\n  compatUtils,\n  ComponentInternalInstance,\n  DeprecationTypes\n} from '@vue/runtime-core'\n\nexport const xlinkNS = 'http://www.w3.org/1999/xlink'\n\nexport function patchAttr(\n  el: Element,\n  key: string,\n  value: any,\n  isSVG: boolean,\n  instance?: ComponentInternalInstance | null\n) {\n  if (isSVG && key.startsWith('xlink:')) {\n    if (value == null) {\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length))\n    } else {\n      el.setAttributeNS(xlinkNS, key, value)\n    }\n  } else {\n    if (__COMPAT__ && compatCoerceAttr(el, key, value, instance)) {\n      return\n    }\n\n    // note we are only checking boolean attributes that don't have a\n    // corresponding dom prop of the same name here.\n    const isBoolean = isSpecialBooleanAttr(key)\n    if (value == null || (isBoolean && !includeBooleanAttr(value))) {\n      el.removeAttribute(key)\n    } else {\n      el.setAttribute(key, isBoolean ? '' : value)\n    }\n  }\n}\n\n// 2.x compat\nconst isEnumeratedAttr = __COMPAT__\n  ? /*#__PURE__*/ makeMap('contenteditable,draggable,spellcheck')\n  : NOOP\n\nexport function compatCoerceAttr(\n  el: Element,\n  key: string,\n  value: unknown,\n  instance: ComponentInternalInstance | null = null\n): boolean {\n  if (isEnumeratedAttr(key)) {\n    const v2CocercedValue =\n      value === null\n        ? 'false'\n        : typeof value !== 'boolean' && value !== undefined\n        ? 'true'\n        : null\n    if (\n      v2CocercedValue &&\n      compatUtils.softAssertCompatEnabled(\n        DeprecationTypes.ATTR_ENUMERATED_COERCION,\n        instance,\n        key,\n        value,\n        v2CocercedValue\n      )\n    ) {\n      el.setAttribute(key, v2CocercedValue)\n      return true\n    }\n  } else if (\n    value === false &&\n    !isSpecialBooleanAttr(key) &&\n    compatUtils.softAssertCompatEnabled(\n      DeprecationTypes.ATTR_FALSE_VALUE,\n      instance,\n      key\n    )\n  ) {\n    el.removeAttribute(key)\n    return true\n  }\n  return false\n}\n", "// __UNSAFE__\n// Reason: potentially setting innerHTML.\n// This can come from explicit usage of v-html or innerHTML as a prop in render\n\nimport { warn, DeprecationTypes, compatUtils } from '@vue/runtime-core'\nimport { includeBooleanAttr } from '@vue/shared'\n\n// functions. The user is responsible for using them with only trusted content.\nexport function patchDOMProp(\n  el: any,\n  key: string,\n  value: any,\n  // the following args are passed only due to potential innerHTML/textContent\n  // overriding existing VNodes, in which case the old tree must be properly\n  // unmounted.\n  prevChildren: any,\n  parentComponent: any,\n  parentSuspense: any,\n  unmountChildren: any\n) {\n  if (key === 'innerHTML' || key === 'textContent') {\n    if (prevChildren) {\n      unmountChildren(prevChildren, parentComponent, parentSuspense)\n    }\n    el[key] = value == null ? '' : value\n    return\n  }\n\n  if (\n    key === 'value' &&\n    el.tagName !== 'PROGRESS' &&\n    // custom elements may use _value internally\n    !el.tagName.includes('-')\n  ) {\n    // store value as _value as well since\n    // non-string values will be stringified.\n    el._value = value\n    const newValue = value == null ? '' : value\n    if (\n      el.value !== newValue ||\n      // #4956: always set for OPTION elements because its value falls back to\n      // textContent if no value attribute is present. And setting .value for\n      // OPTION has no side effect\n      el.tagName === 'OPTION'\n    ) {\n      el.value = newValue\n    }\n    if (value == null) {\n      el.removeAttribute(key)\n    }\n    return\n  }\n\n  if (value === '' || value == null) {\n    const type = typeof el[key]\n    if (type === 'boolean') {\n      // e.g. <select multiple> compiles to { multiple: '' }\n      el[key] = includeBooleanAttr(value)\n      return\n    } else if (value == null && type === 'string') {\n      // e.g. <div :id=\"null\">\n      el[key] = ''\n      el.removeAttribute(key)\n      return\n    } else if (type === 'number') {\n      // e.g. <img :width=\"null\">\n      // the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error\n      try {\n        el[key] = 0\n      } catch {}\n      el.removeAttribute(key)\n      return\n    }\n  }\n\n  if (\n    __COMPAT__ &&\n    value === false &&\n    compatUtils.isCompatEnabled(\n      DeprecationTypes.ATTR_FALSE_VALUE,\n      parentComponent\n    )\n  ) {\n    const type = typeof el[key]\n    if (type === 'string' || type === 'number') {\n      __DEV__ &&\n        compatUtils.warnDeprecation(\n          DeprecationTypes.ATTR_FALSE_VALUE,\n          parentComponent,\n          key\n        )\n      el[key] = type === 'number' ? 0 : ''\n      el.removeAttribute(key)\n      return\n    }\n  }\n\n  // some properties perform value validation and throw\n  try {\n    el[key] = value\n  } catch (e: any) {\n    if (__DEV__) {\n      warn(\n        `Failed setting prop \"${key}\" on <${el.tagName.toLowerCase()}>: ` +\n          `value ${value} is invalid.`,\n        e\n      )\n    }\n  }\n}\n", "import { hyphenate, isArray } from '@vue/shared'\nimport {\n  ComponentInternalInstance,\n  callWithAsyncErrorHandling\n} from '@vue/runtime-core'\nimport { ErrorCodes } from 'packages/runtime-core/src/errorHandling'\n\ninterface Invoker extends EventListener {\n  value: EventValue\n  attached: number\n}\n\ntype EventValue = Function | Function[]\n\n// Async edge case fix requires storing an event listener's attach timestamp.\nlet _getNow: () => number = Date.now\n\nlet skipTimestampCheck = false\n\nif (typeof window !== 'undefined') {\n  // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  if (_getNow() > document.createEvent('Event').timeStamp) {\n    // if the low-res timestamp which is bigger than the event timestamp\n    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listeners as well.\n    _getNow = () => performance.now()\n  }\n  // #3485: Firefox <= 53 has incorrect Event.timeStamp implementation\n  // and does not fire microtasks in between event propagation, so safe to exclude.\n  const ffMatch = navigator.userAgent.match(/firefox\\/(\\d+)/i)\n  skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53)\n}\n\n// To avoid the overhead of repeatedly calling performance.now(), we cache\n// and use the same timestamp for all event listeners attached in the same tick.\nlet cachedNow: number = 0\nconst p = Promise.resolve()\nconst reset = () => {\n  cachedNow = 0\n}\nconst getNow = () => cachedNow || (p.then(reset), (cachedNow = _getNow()))\n\nexport function addEventListener(\n  el: Element,\n  event: string,\n  handler: EventListener,\n  options?: EventListenerOptions\n) {\n  el.addEventListener(event, handler, options)\n}\n\nexport function removeEventListener(\n  el: Element,\n  event: string,\n  handler: EventListener,\n  options?: EventListenerOptions\n) {\n  el.removeEventListener(event, handler, options)\n}\n\nexport function patchEvent(\n  el: Element & { _vei?: Record<string, Invoker | undefined> },\n  rawName: string,\n  prevValue: EventValue | null,\n  nextValue: EventValue | null,\n  instance: ComponentInternalInstance | null = null\n) {\n  // vei = vue event invokers\n  const invokers = el._vei || (el._vei = {})\n  const existingInvoker = invokers[rawName]\n  if (nextValue && existingInvoker) {\n    // patch\n    existingInvoker.value = nextValue\n  } else {\n    const [name, options] = parseName(rawName)\n    if (nextValue) {\n      // add\n      const invoker = (invokers[rawName] = createInvoker(nextValue, instance))\n      addEventListener(el, name, invoker, options)\n    } else if (existingInvoker) {\n      // remove\n      removeEventListener(el, name, existingInvoker, options)\n      invokers[rawName] = undefined\n    }\n  }\n}\n\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/\n\nfunction parseName(name: string): [string, EventListenerOptions | undefined] {\n  let options: EventListenerOptions | undefined\n  if (optionsModifierRE.test(name)) {\n    options = {}\n    let m\n    while ((m = name.match(optionsModifierRE))) {\n      name = name.slice(0, name.length - m[0].length)\n      ;(options as any)[m[0].toLowerCase()] = true\n      options\n    }\n  }\n  return [hyphenate(name.slice(2)), options]\n}\n\nfunction createInvoker(\n  initialValue: EventValue,\n  instance: ComponentInternalInstance | null\n) {\n  const invoker: Invoker = (e: Event) => {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    const timeStamp = e.timeStamp || _getNow()\n\n    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {\n      callWithAsyncErrorHandling(\n        patchStopImmediatePropagation(e, invoker.value),\n        instance,\n        ErrorCodes.NATIVE_EVENT_HANDLER,\n        [e]\n      )\n    }\n  }\n  invoker.value = initialValue\n  invoker.attached = getNow()\n  return invoker\n}\n\nfunction patchStopImmediatePropagation(\n  e: Event,\n  value: EventValue\n): EventValue {\n  if (isArray(value)) {\n    const originalStop = e.stopImmediatePropagation\n    e.stopImmediatePropagation = () => {\n      originalStop.call(e)\n      ;(e as any)._stopped = true\n    }\n    return value.map(fn => (e: Event) => !(e as any)._stopped && fn && fn(e))\n  } else {\n    return value\n  }\n}\n", "import { patchClass } from './modules/class'\nimport { patchStyle } from './modules/style'\nimport { patchAttr } from './modules/attrs'\nimport { patchDOMProp } from './modules/props'\nimport { patchEvent } from './modules/events'\nimport { isOn, isString, isFunction, isModelListener } from '@vue/shared'\nimport { RendererOptions } from '@vue/runtime-core'\n\nconst nativeOnRE = /^on[a-z]/\n\ntype DOMRendererOptions = RendererOptions<Node, Element>\n\nexport const patchProp: DOMRendererOptions['patchProp'] = (\n  el,\n  key,\n  prevValue,\n  nextValue,\n  isSVG = false,\n  prevChildren,\n  parentComponent,\n  parentSuspense,\n  unmountChildren\n) => {\n  if (key === 'class') {\n    patchClass(el, nextValue, isSVG)\n  } else if (key === 'style') {\n    patchStyle(el, prevValue, nextValue)\n  } else if (isOn(key)) {\n    // ignore v-model listeners\n    if (!isModelListener(key)) {\n      patchEvent(el, key, prevValue, nextValue, parentComponent)\n    }\n  } else if (\n    key[0] === '.'\n      ? ((key = key.slice(1)), true)\n      : key[0] === '^'\n      ? ((key = key.slice(1)), false)\n      : shouldSetAsProp(el, key, nextValue, isSVG)\n  ) {\n    patchDOMProp(\n      el,\n      key,\n      nextValue,\n      prevChildren,\n      parentComponent,\n      parentSuspense,\n      unmountChildren\n    )\n  } else {\n    // special case for <input v-model type=\"checkbox\"> with\n    // :true-value & :false-value\n    // store value as dom properties since non-string values will be\n    // stringified.\n    if (key === 'true-value') {\n      ;(el as any)._trueValue = nextValue\n    } else if (key === 'false-value') {\n      ;(el as any)._falseValue = nextValue\n    }\n    patchAttr(el, key, nextValue, isSVG, parentComponent)\n  }\n}\n\nfunction shouldSetAsProp(\n  el: Element,\n  key: string,\n  value: unknown,\n  isSVG: boolean\n) {\n  if (isSVG) {\n    // most keys must be set as attribute on svg elements to work\n    // ...except innerHTML & textContent\n    if (key === 'innerHTML' || key === 'textContent') {\n      return true\n    }\n    // or native onclick with function values\n    if (key in el && nativeOnRE.test(key) && isFunction(value)) {\n      return true\n    }\n    return false\n  }\n\n  // spellcheck and draggable are numerated attrs, however their\n  // corresponding DOM properties are actually booleans - this leads to\n  // setting it with a string \"false\" value leading it to be coerced to\n  // `true`, so we need to always treat them as attributes.\n  // Note that `contentEditable` doesn't have this problem: its DOM\n  // property is also enumerated string values.\n  if (key === 'spellcheck' || key === 'draggable') {\n    return false\n  }\n\n  // #1787, #2840 form property on form elements is readonly and must be set as\n  // attribute.\n  if (key === 'form') {\n    return false\n  }\n\n  // #1526 <input list> must be set as attribute\n  if (key === 'list' && el.tagName === 'INPUT') {\n    return false\n  }\n\n  // #2766 <textarea type> must be set as attribute\n  if (key === 'type' && el.tagName === 'TEXTAREA') {\n    return false\n  }\n\n  // native onclick with string value, must be set as attribute\n  if (nativeOnRE.test(key) && isString(value)) {\n    return false\n  }\n\n  return key in el\n}\n", "import {\n  ComponentOptionsMixin,\n  ComponentOptionsWithArrayProps,\n  ComponentOptionsWithObjectProps,\n  ComponentOptionsWithoutProps,\n  ComponentPropsOptions,\n  ComponentPublicInstance,\n  ComputedOptions,\n  EmitsOptions,\n  MethodOptions,\n  RenderFunction,\n  SetupContext,\n  ComponentInternalInstance,\n  VNode,\n  RootHydrateFunction,\n  ExtractPropTypes,\n  createVNode,\n  defineComponent,\n  nextTick,\n  warn,\n  ConcreteComponent,\n  ComponentOptions\n} from '@vue/runtime-core'\nimport { camelize, extend, hyphenate, isArray, toNumber } from '@vue/shared'\nimport { hydrate, render } from '.'\n\nexport type VueElementConstructor<P = {}> = {\n  new (initialProps?: Record<string, any>): VueElement & P\n}\n\n// defineCustomElement provides the same type inference as defineComponent\n// so most of the following overloads should be kept in sync w/ defineComponent.\n\n// overload 1: direct setup function\nexport function defineCustomElement<Props, RawBindings = object>(\n  setup: (\n    props: Readonly<Props>,\n    ctx: SetupContext\n  ) => RawBindings | RenderFunction\n): VueElementConstructor<Props>\n\n// overload 2: object format with no props\nexport function defineCustomElement<\n  Props = {},\n  RawBindings = {},\n  D = {},\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = EmitsOptions,\n  EE extends string = string\n>(\n  options: ComponentOptionsWithoutProps<\n    Props,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    EE\n  > & { styles?: string[] }\n): VueElementConstructor<Props>\n\n// overload 3: object format with array props declaration\nexport function defineCustomElement<\n  PropNames extends string,\n  RawBindings,\n  D,\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = Record<string, any>,\n  EE extends string = string\n>(\n  options: ComponentOptionsWithArrayProps<\n    PropNames,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    EE\n  > & { styles?: string[] }\n): VueElementConstructor<{ [K in PropNames]: any }>\n\n// overload 4: object format with object props declaration\nexport function defineCustomElement<\n  PropsOptions extends Readonly<ComponentPropsOptions>,\n  RawBindings,\n  D,\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = Record<string, any>,\n  EE extends string = string\n>(\n  options: ComponentOptionsWithObjectProps<\n    PropsOptions,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    EE\n  > & { styles?: string[] }\n): VueElementConstructor<ExtractPropTypes<PropsOptions>>\n\n// overload 5: defining a custom element from the returned value of\n// `defineComponent`\nexport function defineCustomElement(options: {\n  new (...args: any[]): ComponentPublicInstance\n}): VueElementConstructor\n\nexport function defineCustomElement(\n  options: any,\n  hydate?: RootHydrateFunction\n): VueElementConstructor {\n  const Comp = defineComponent(options as any)\n  class VueCustomElement extends VueElement {\n    static def = Comp\n    constructor(initialProps?: Record<string, any>) {\n      super(Comp, initialProps, hydate)\n    }\n  }\n\n  return VueCustomElement\n}\n\nexport const defineSSRCustomElement = ((options: any) => {\n  // @ts-ignore\n  return defineCustomElement(options, hydrate)\n}) as typeof defineCustomElement\n\nconst BaseClass = (\n  typeof HTMLElement !== 'undefined' ? HTMLElement : class {}\n) as typeof HTMLElement\n\ntype InnerComponentDef = ConcreteComponent & { styles?: string[] }\n\nexport class VueElement extends BaseClass {\n  /**\n   * @internal\n   */\n  _instance: ComponentInternalInstance | null = null\n\n  private _connected = false\n  private _resolved = false\n  private _numberProps: Record<string, true> | null = null\n  private _styles?: HTMLStyleElement[]\n\n  constructor(\n    private _def: InnerComponentDef,\n    private _props: Record<string, any> = {},\n    hydrate?: RootHydrateFunction\n  ) {\n    super()\n    if (this.shadowRoot && hydrate) {\n      hydrate(this._createVNode(), this.shadowRoot)\n    } else {\n      if (__DEV__ && this.shadowRoot) {\n        warn(\n          `Custom element has pre-rendered declarative shadow root but is not ` +\n            `defined as hydratable. Use \\`defineSSRCustomElement\\`.`\n        )\n      }\n      this.attachShadow({ mode: 'open' })\n    }\n  }\n\n  connectedCallback() {\n    this._connected = true\n    if (!this._instance) {\n      this._resolveDef()\n    }\n  }\n\n  disconnectedCallback() {\n    this._connected = false\n    nextTick(() => {\n      if (!this._connected) {\n        render(null, this.shadowRoot!)\n        this._instance = null\n      }\n    })\n  }\n\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  private _resolveDef() {\n    if (this._resolved) {\n      return\n    }\n    this._resolved = true\n\n    // set initial attrs\n    for (let i = 0; i < this.attributes.length; i++) {\n      this._setAttr(this.attributes[i].name)\n    }\n\n    // watch future attr changes\n    new MutationObserver(mutations => {\n      for (const m of mutations) {\n        this._setAttr(m.attributeName!)\n      }\n    }).observe(this, { attributes: true })\n\n    const resolve = (def: InnerComponentDef) => {\n      const { props, styles } = def\n      const hasOptions = !isArray(props)\n      const rawKeys = props ? (hasOptions ? Object.keys(props) : props) : []\n\n      // cast Number-type props set before resolve\n      let numberProps\n      if (hasOptions) {\n        for (const key in this._props) {\n          const opt = props[key]\n          if (opt === Number || (opt && opt.type === Number)) {\n            this._props[key] = toNumber(this._props[key])\n            ;(numberProps || (numberProps = Object.create(null)))[key] = true\n          }\n        }\n      }\n      this._numberProps = numberProps\n\n      // check if there are props set pre-upgrade or connect\n      for (const key of Object.keys(this)) {\n        if (key[0] !== '_') {\n          this._setProp(key, this[key as keyof this], true, false)\n        }\n      }\n\n      // defining getter/setters on prototype\n      for (const key of rawKeys.map(camelize)) {\n        Object.defineProperty(this, key, {\n          get() {\n            return this._getProp(key)\n          },\n          set(val) {\n            this._setProp(key, val)\n          }\n        })\n      }\n\n      // apply CSS\n      this._applyStyles(styles)\n\n      // initial render\n      this._update()\n    }\n\n    const asyncDef = (this._def as ComponentOptions).__asyncLoader\n    if (asyncDef) {\n      asyncDef().then(resolve)\n    } else {\n      resolve(this._def)\n    }\n  }\n\n  protected _setAttr(key: string) {\n    let value = this.getAttribute(key)\n    if (this._numberProps && this._numberProps[key]) {\n      value = toNumber(value)\n    }\n    this._setProp(camelize(key), value, false)\n  }\n\n  /**\n   * @internal\n   */\n  protected _getProp(key: string) {\n    return this._props[key]\n  }\n\n  /**\n   * @internal\n   */\n  protected _setProp(\n    key: string,\n    val: any,\n    shouldReflect = true,\n    shouldUpdate = true\n  ) {\n    if (val !== this._props[key]) {\n      this._props[key] = val\n      if (shouldUpdate && this._instance) {\n        this._update()\n      }\n      // reflect\n      if (shouldReflect) {\n        if (val === true) {\n          this.setAttribute(hyphenate(key), '')\n        } else if (typeof val === 'string' || typeof val === 'number') {\n          this.setAttribute(hyphenate(key), val + '')\n        } else if (!val) {\n          this.removeAttribute(hyphenate(key))\n        }\n      }\n    }\n  }\n\n  private _update() {\n    render(this._createVNode(), this.shadowRoot!)\n  }\n\n  private _createVNode(): VNode<any, any> {\n    const vnode = createVNode(this._def, extend({}, this._props))\n    if (!this._instance) {\n      vnode.ce = instance => {\n        this._instance = instance\n        instance.isCE = true\n        // HMR\n        if (__DEV__) {\n          instance.ceReload = newStyles => {\n            // always reset styles\n            if (this._styles) {\n              this._styles.forEach(s => this.shadowRoot!.removeChild(s))\n              this._styles.length = 0\n            }\n            this._applyStyles(newStyles)\n            // if this is an async component, ceReload is called from the inner\n            // component so no need to reload the async wrapper\n            if (!(this._def as ComponentOptions).__asyncLoader) {\n              // reload\n              this._instance = null\n              this._update()\n            }\n          }\n        }\n\n        // intercept emit\n        instance.emit = (event: string, ...args: any[]) => {\n          this.dispatchEvent(\n            new CustomEvent(event, {\n              detail: args\n            })\n          )\n        }\n\n        // locate nearest Vue custom element parent for provide/inject\n        let parent: Node | null = this\n        while (\n          (parent =\n            parent && (parent.parentNode || (parent as ShadowRoot).host))\n        ) {\n          if (parent instanceof VueElement) {\n            instance.parent = parent._instance\n            break\n          }\n        }\n      }\n    }\n    return vnode\n  }\n\n  private _applyStyles(styles: string[] | undefined) {\n    if (styles) {\n      styles.forEach(css => {\n        const s = document.createElement('style')\n        s.textContent = css\n        this.shadowRoot!.appendChild(s)\n        // record for HMR\n        if (__DEV__) {\n          ;(this._styles || (this._styles = [])).push(s)\n        }\n      })\n    }\n  }\n}\n", "import { warn, getCurrentInstance } from '@vue/runtime-core'\nimport { EMPTY_OBJ } from '@vue/shared'\n\nexport function useCssModule(name = '$style'): Record<string, string> {\n  /* istanbul ignore else */\n  if (!__GLOBAL__) {\n    const instance = getCurrentInstance()!\n    if (!instance) {\n      __DEV__ && warn(`useCssModule must be called inside setup()`)\n      return EMPTY_OBJ\n    }\n    const modules = instance.type.__cssModules\n    if (!modules) {\n      __DEV__ && warn(`Current instance does not have CSS modules injected.`)\n      return EMPTY_OBJ\n    }\n    const mod = modules[name]\n    if (!mod) {\n      __DEV__ &&\n        warn(`Current instance does not have CSS module named \"${name}\".`)\n      return EMPTY_OBJ\n    }\n    return mod as Record<string, string>\n  } else {\n    if (__DEV__) {\n      warn(`useCssModule() is not supported in the global build.`)\n    }\n    return EMPTY_OBJ\n  }\n}\n", "import {\n  getCurrentInstance,\n  warn,\n  VNode,\n  Fragment,\n  Static,\n  watchPostEffect,\n  onMounted,\n  onUnmounted\n} from '@vue/runtime-core'\nimport { ShapeFlags } from '@vue/shared'\n\n/**\n * Runtime helper for SFC's CSS variable injection feature.\n * @private\n */\nexport function useCssVars(getter: (ctx: any) => Record<string, string>) {\n  if (!__BROWSER__ && !__TEST__) return\n\n  const instance = getCurrentInstance()\n  /* istanbul ignore next */\n  if (!instance) {\n    __DEV__ &&\n      warn(`useCssVars is called without current active component instance.`)\n    return\n  }\n\n  const setVars = () =>\n    setVarsOnVNode(instance.subTree, getter(instance.proxy!))\n  watchPostEffect(setVars)\n  onMounted(() => {\n    const ob = new MutationObserver(setVars)\n    ob.observe(instance.subTree.el!.parentNode, { childList: true })\n    onUnmounted(() => ob.disconnect())\n  })\n}\n\nfunction setVarsOnVNode(vnode: VNode, vars: Record<string, string>) {\n  if (__FEATURE_SUSPENSE__ && vnode.shapeFlag & ShapeFlags.SUSPENSE) {\n    const suspense = vnode.suspense!\n    vnode = suspense.activeBranch!\n    if (suspense.pendingBranch && !suspense.isHydrating) {\n      suspense.effects.push(() => {\n        setVarsOnVNode(suspense.activeBranch!, vars)\n      })\n    }\n  }\n\n  // drill down HOCs until it's a non-component vnode\n  while (vnode.component) {\n    vnode = vnode.component.subTree\n  }\n\n  if (vnode.shapeFlag & ShapeFlags.ELEMENT && vnode.el) {\n    setVarsOnNode(vnode.el as Node, vars)\n  } else if (vnode.type === Fragment) {\n    ;(vnode.children as VNode[]).forEach(c => setVarsOnVNode(c, vars))\n  } else if (vnode.type === Static) {\n    let { el, anchor } = vnode\n    while (el) {\n      setVarsOnNode(el as Node, vars)\n      if (el === anchor) break\n      el = el.nextSibling\n    }\n  }\n}\n\nfunction setVarsOnNode(el: Node, vars: Record<string, string>) {\n  if (el.nodeType === 1) {\n    const style = (el as HTMLElement).style\n    for (const key in vars) {\n      style.setProperty(`--${key}`, vars[key])\n    }\n  }\n}\n", "import {\n  BaseTransition,\n  BaseTransitionProps,\n  h,\n  warn,\n  FunctionalComponent,\n  compatUtils,\n  DeprecationTypes\n} from '@vue/runtime-core'\nimport { isObject, toNumber, extend, isArray } from '@vue/shared'\n\nconst TRANSITION = 'transition'\nconst ANIMATION = 'animation'\n\nexport interface TransitionProps extends BaseTransitionProps<Element> {\n  name?: string\n  type?: typeof TRANSITION | typeof ANIMATION\n  css?: boolean\n  duration?: number | { enter: number; leave: number }\n  // custom transition classes\n  enterFromClass?: string\n  enterActiveClass?: string\n  enterToClass?: string\n  appearFromClass?: string\n  appearActiveClass?: string\n  appearToClass?: string\n  leaveFromClass?: string\n  leaveActiveClass?: string\n  leaveToClass?: string\n}\n\nexport interface ElementWithTransition extends HTMLElement {\n  // _vtc = Vue Transition Classes.\n  // Store the temporarily-added transition classes on the element\n  // so that we can avoid overwriting them if the element's class is patched\n  // during the transition.\n  _vtc?: Set<string>\n}\n\n// DOM Transition is a higher-order-component based on the platform-agnostic\n// base Transition component, with DOM-specific logic.\nexport const Transition: FunctionalComponent<TransitionProps> = (\n  props,\n  { slots }\n) => h(BaseTransition, resolveTransitionProps(props), slots)\n\nTransition.displayName = 'Transition'\n\nif (__COMPAT__) {\n  Transition.__isBuiltIn = true\n}\n\nconst DOMTransitionPropsValidators = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: true\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n}\n\nexport const TransitionPropsValidators = (Transition.props =\n  /*#__PURE__*/ extend(\n    {},\n    (BaseTransition as any).props,\n    DOMTransitionPropsValidators\n  ))\n\n/**\n * #3227 Incoming hooks may be merged into arrays when wrapping Transition\n * with custom HOCs.\n */\nconst callHook = (\n  hook: Function | Function[] | undefined,\n  args: any[] = []\n) => {\n  if (isArray(hook)) {\n    hook.forEach(h => h(...args))\n  } else if (hook) {\n    hook(...args)\n  }\n}\n\n/**\n * Check if a hook expects a callback (2nd arg), which means the user\n * intends to explicitly control the end of the transition.\n */\nconst hasExplicitCallback = (\n  hook: Function | Function[] | undefined\n): boolean => {\n  return hook\n    ? isArray(hook)\n      ? hook.some(h => h.length > 1)\n      : hook.length > 1\n    : false\n}\n\nexport function resolveTransitionProps(\n  rawProps: TransitionProps\n): BaseTransitionProps<Element> {\n  const baseProps: BaseTransitionProps<Element> = {}\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      ;(baseProps as any)[key] = (rawProps as any)[key]\n    }\n  }\n\n  if (rawProps.css === false) {\n    return baseProps\n  }\n\n  const {\n    name = 'v',\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps\n\n  // legacy transition class compat\n  const legacyClassEnabled =\n    __COMPAT__ &&\n    compatUtils.isCompatEnabled(DeprecationTypes.TRANSITION_CLASSES, null)\n  let legacyEnterFromClass: string\n  let legacyAppearFromClass: string\n  let legacyLeaveFromClass: string\n  if (__COMPAT__ && legacyClassEnabled) {\n    const toLegacyClass = (cls: string) => cls.replace(/-from$/, '')\n    if (!rawProps.enterFromClass) {\n      legacyEnterFromClass = toLegacyClass(enterFromClass)\n    }\n    if (!rawProps.appearFromClass) {\n      legacyAppearFromClass = toLegacyClass(appearFromClass)\n    }\n    if (!rawProps.leaveFromClass) {\n      legacyLeaveFromClass = toLegacyClass(leaveFromClass)\n    }\n  }\n\n  const durations = normalizeDuration(duration)\n  const enterDuration = durations && durations[0]\n  const leaveDuration = durations && durations[1]\n  const {\n    onBeforeEnter,\n    onEnter,\n    onEnterCancelled,\n    onLeave,\n    onLeaveCancelled,\n    onBeforeAppear = onBeforeEnter,\n    onAppear = onEnter,\n    onAppearCancelled = onEnterCancelled\n  } = baseProps\n\n  const finishEnter = (el: Element, isAppear: boolean, done?: () => void) => {\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass)\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass)\n    done && done()\n  }\n\n  const finishLeave = (el: Element, done?: () => void) => {\n    removeTransitionClass(el, leaveToClass)\n    removeTransitionClass(el, leaveActiveClass)\n    done && done()\n  }\n\n  const makeEnterHook = (isAppear: boolean) => {\n    return (el: Element, done: () => void) => {\n      const hook = isAppear ? onAppear : onEnter\n      const resolve = () => finishEnter(el, isAppear, done)\n      callHook(hook, [el, resolve])\n      nextFrame(() => {\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass)\n        if (__COMPAT__ && legacyClassEnabled) {\n          removeTransitionClass(\n            el,\n            isAppear ? legacyAppearFromClass : legacyEnterFromClass\n          )\n        }\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass)\n        if (!hasExplicitCallback(hook)) {\n          whenTransitionEnds(el, type, enterDuration, resolve)\n        }\n      })\n    }\n  }\n\n  return extend(baseProps, {\n    onBeforeEnter(el) {\n      callHook(onBeforeEnter, [el])\n      addTransitionClass(el, enterFromClass)\n      if (__COMPAT__ && legacyClassEnabled) {\n        addTransitionClass(el, legacyEnterFromClass)\n      }\n      addTransitionClass(el, enterActiveClass)\n    },\n    onBeforeAppear(el) {\n      callHook(onBeforeAppear, [el])\n      addTransitionClass(el, appearFromClass)\n      if (__COMPAT__ && legacyClassEnabled) {\n        addTransitionClass(el, legacyAppearFromClass)\n      }\n      addTransitionClass(el, appearActiveClass)\n    },\n    onEnter: makeEnterHook(false),\n    onAppear: makeEnterHook(true),\n    onLeave(el, done) {\n      const resolve = () => finishLeave(el, done)\n      addTransitionClass(el, leaveFromClass)\n      if (__COMPAT__ && legacyClassEnabled) {\n        addTransitionClass(el, legacyLeaveFromClass)\n      }\n      // force reflow so *-leave-from classes immediately take effect (#2593)\n      forceReflow()\n      addTransitionClass(el, leaveActiveClass)\n      nextFrame(() => {\n        removeTransitionClass(el, leaveFromClass)\n        if (__COMPAT__ && legacyClassEnabled) {\n          removeTransitionClass(el, legacyLeaveFromClass)\n        }\n        addTransitionClass(el, leaveToClass)\n        if (!hasExplicitCallback(onLeave)) {\n          whenTransitionEnds(el, type, leaveDuration, resolve)\n        }\n      })\n      callHook(onLeave, [el, resolve])\n    },\n    onEnterCancelled(el) {\n      finishEnter(el, false)\n      callHook(onEnterCancelled, [el])\n    },\n    onAppearCancelled(el) {\n      finishEnter(el, true)\n      callHook(onAppearCancelled, [el])\n    },\n    onLeaveCancelled(el) {\n      finishLeave(el)\n      callHook(onLeaveCancelled, [el])\n    }\n  } as BaseTransitionProps<Element>)\n}\n\nfunction normalizeDuration(\n  duration: TransitionProps['duration']\n): [number, number] | null {\n  if (duration == null) {\n    return null\n  } else if (isObject(duration)) {\n    return [NumberOf(duration.enter), NumberOf(duration.leave)]\n  } else {\n    const n = NumberOf(duration)\n    return [n, n]\n  }\n}\n\nfunction NumberOf(val: unknown): number {\n  const res = toNumber(val)\n  if (__DEV__) validateDuration(res)\n  return res\n}\n\nfunction validateDuration(val: unknown) {\n  if (typeof val !== 'number') {\n    warn(\n      `<transition> explicit duration is not a valid number - ` +\n        `got ${JSON.stringify(val)}.`\n    )\n  } else if (isNaN(val)) {\n    warn(\n      `<transition> explicit duration is NaN - ` +\n        'the duration expression might be incorrect.'\n    )\n  }\n}\n\nexport function addTransitionClass(el: Element, cls: string) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.add(c))\n  ;(\n    (el as ElementWithTransition)._vtc ||\n    ((el as ElementWithTransition)._vtc = new Set())\n  ).add(cls)\n}\n\nexport function removeTransitionClass(el: Element, cls: string) {\n  cls.split(/\\s+/).forEach(c => c && el.classList.remove(c))\n  const { _vtc } = el as ElementWithTransition\n  if (_vtc) {\n    _vtc.delete(cls)\n    if (!_vtc!.size) {\n      ;(el as ElementWithTransition)._vtc = undefined\n    }\n  }\n}\n\nfunction nextFrame(cb: () => void) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb)\n  })\n}\n\nlet endId = 0\n\nfunction whenTransitionEnds(\n  el: Element & { _endId?: number },\n  expectedType: TransitionProps['type'] | undefined,\n  explicitTimeout: number | null,\n  resolve: () => void\n) {\n  const id = (el._endId = ++endId)\n  const resolveIfNotStale = () => {\n    if (id === el._endId) {\n      resolve()\n    }\n  }\n\n  if (explicitTimeout) {\n    return setTimeout(resolveIfNotStale, explicitTimeout)\n  }\n\n  const { type, timeout, propCount } = getTransitionInfo(el, expectedType)\n  if (!type) {\n    return resolve()\n  }\n\n  const endEvent = type + 'end'\n  let ended = 0\n  const end = () => {\n    el.removeEventListener(endEvent, onEnd)\n    resolveIfNotStale()\n  }\n  const onEnd = (e: Event) => {\n    if (e.target === el && ++ended >= propCount) {\n      end()\n    }\n  }\n  setTimeout(() => {\n    if (ended < propCount) {\n      end()\n    }\n  }, timeout + 1)\n  el.addEventListener(endEvent, onEnd)\n}\n\ninterface CSSTransitionInfo {\n  type: typeof TRANSITION | typeof ANIMATION | null\n  propCount: number\n  timeout: number\n  hasTransform: boolean\n}\n\nexport function getTransitionInfo(\n  el: Element,\n  expectedType?: TransitionProps['type']\n): CSSTransitionInfo {\n  const styles: any = window.getComputedStyle(el)\n  // JSDOM may return undefined for transition properties\n  const getStyleProperties = (key: string) => (styles[key] || '').split(', ')\n  const transitionDelays = getStyleProperties(TRANSITION + 'Delay')\n  const transitionDurations = getStyleProperties(TRANSITION + 'Duration')\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations)\n  const animationDelays = getStyleProperties(ANIMATION + 'Delay')\n  const animationDurations = getStyleProperties(ANIMATION + 'Duration')\n  const animationTimeout = getTimeout(animationDelays, animationDurations)\n\n  let type: CSSTransitionInfo['type'] = null\n  let timeout = 0\n  let propCount = 0\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION\n      timeout = transitionTimeout\n      propCount = transitionDurations.length\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION\n      timeout = animationTimeout\n      propCount = animationDurations.length\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout)\n    type =\n      timeout > 0\n        ? transitionTimeout > animationTimeout\n          ? TRANSITION\n          : ANIMATION\n        : null\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0\n  }\n  const hasTransform =\n    type === TRANSITION &&\n    /\\b(transform|all)(,|$)/.test(styles[TRANSITION + 'Property'])\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  }\n}\n\nfunction getTimeout(delays: string[], durations: string[]): number {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays)\n  }\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])))\n}\n\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\n// numbers in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down\n// (i.e. acting as a floor function) causing unexpected behaviors\nfunction toMs(s: string): number {\n  return Number(s.slice(0, -1).replace(',', '.')) * 1000\n}\n\n// synchronously force layout to put elements into a certain state\nexport function forceReflow() {\n  return document.body.offsetHeight\n}\n", "import {\n  TransitionProps,\n  addTransitionClass,\n  removeTransitionClass,\n  ElementWithTransition,\n  getTransitionInfo,\n  resolveTransitionProps,\n  TransitionPropsValidators,\n  forceReflow\n} from './Transition'\nimport {\n  Fragment,\n  VNode,\n  warn,\n  resolveTransitionHooks,\n  useTransitionState,\n  getTransitionRawChildren,\n  getCurrentInstance,\n  setTransitionHooks,\n  createVNode,\n  onUpdated,\n  SetupContext,\n  toRaw,\n  compatUtils,\n  DeprecationTypes,\n  ComponentOptions\n} from '@vue/runtime-core'\nimport { extend } from '@vue/shared'\n\nconst positionMap = new WeakMap<VNode, DOMRect>()\nconst newPositionMap = new WeakMap<VNode, DOMRect>()\n\nexport type TransitionGroupProps = Omit<TransitionProps, 'mode'> & {\n  tag?: string\n  moveClass?: string\n}\n\nconst TransitionGroupImpl: ComponentOptions = {\n  name: 'TransitionGroup',\n\n  props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {\n    tag: String,\n    moveClass: String\n  }),\n\n  setup(props: TransitionGroupProps, { slots }: SetupContext) {\n    const instance = getCurrentInstance()!\n    const state = useTransitionState()\n    let prevChildren: VNode[]\n    let children: VNode[]\n\n    onUpdated(() => {\n      // children is guaranteed to exist after initial render\n      if (!prevChildren.length) {\n        return\n      }\n      const moveClass = props.moveClass || `${props.name || 'v'}-move`\n\n      if (\n        !hasCSSTransform(\n          prevChildren[0].el as ElementWithTransition,\n          instance.vnode.el as Node,\n          moveClass\n        )\n      ) {\n        return\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      prevChildren.forEach(callPendingCbs)\n      prevChildren.forEach(recordPosition)\n      const movedChildren = prevChildren.filter(applyTranslation)\n\n      // force reflow to put everything in position\n      forceReflow()\n\n      movedChildren.forEach(c => {\n        const el = c.el as ElementWithTransition\n        const style = el.style\n        addTransitionClass(el, moveClass)\n        style.transform = style.webkitTransform = style.transitionDuration = ''\n        const cb = ((el as any)._moveCb = (e: TransitionEvent) => {\n          if (e && e.target !== el) {\n            return\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener('transitionend', cb)\n            ;(el as any)._moveCb = null\n            removeTransitionClass(el, moveClass)\n          }\n        })\n        el.addEventListener('transitionend', cb)\n      })\n    })\n\n    return () => {\n      const rawProps = toRaw(props)\n      const cssTransitionProps = resolveTransitionProps(rawProps)\n      let tag = rawProps.tag || Fragment\n\n      if (\n        __COMPAT__ &&\n        !rawProps.tag &&\n        compatUtils.checkCompatEnabled(\n          DeprecationTypes.TRANSITION_GROUP_ROOT,\n          instance.parent\n        )\n      ) {\n        tag = 'span'\n      }\n\n      prevChildren = children\n      children = slots.default ? getTransitionRawChildren(slots.default()) : []\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n        if (child.key != null) {\n          setTransitionHooks(\n            child,\n            resolveTransitionHooks(child, cssTransitionProps, state, instance)\n          )\n        } else if (__DEV__) {\n          warn(`<TransitionGroup> children must be keyed.`)\n        }\n      }\n\n      if (prevChildren) {\n        for (let i = 0; i < prevChildren.length; i++) {\n          const child = prevChildren[i]\n          setTransitionHooks(\n            child,\n            resolveTransitionHooks(child, cssTransitionProps, state, instance)\n          )\n          positionMap.set(child, (child.el as Element).getBoundingClientRect())\n        }\n      }\n\n      return createVNode(tag, null, children)\n    }\n  }\n}\n\nif (__COMPAT__) {\n  TransitionGroupImpl.__isBuiltIn = true\n}\n\n/**\n * TransitionGroup does not support \"mode\" so we need to remove it from the\n * props declarations, but direct delete operation is considered a side effect\n * and will make the entire transition feature non-tree-shakeable, so we do it\n * in a function and mark the function's invocation as pure.\n */\nconst removeMode = (props: any) => delete props.mode\n/*#__PURE__*/ removeMode(TransitionGroupImpl.props)\n\nexport const TransitionGroup = TransitionGroupImpl as unknown as {\n  new (): {\n    $props: TransitionGroupProps\n  }\n}\n\nfunction callPendingCbs(c: VNode) {\n  const el = c.el as any\n  if (el._moveCb) {\n    el._moveCb()\n  }\n  if (el._enterCb) {\n    el._enterCb()\n  }\n}\n\nfunction recordPosition(c: VNode) {\n  newPositionMap.set(c, (c.el as Element).getBoundingClientRect())\n}\n\nfunction applyTranslation(c: VNode): VNode | undefined {\n  const oldPos = positionMap.get(c)!\n  const newPos = newPositionMap.get(c)!\n  const dx = oldPos.left - newPos.left\n  const dy = oldPos.top - newPos.top\n  if (dx || dy) {\n    const s = (c.el as HTMLElement).style\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`\n    s.transitionDuration = '0s'\n    return c\n  }\n}\n\nfunction hasCSSTransform(\n  el: ElementWithTransition,\n  root: Node,\n  moveClass: string\n): boolean {\n  // Detect whether an element with the move class applied has\n  // CSS transitions. Since the element may be inside an entering\n  // transition at this very moment, we make a clone of it and remove\n  // all other transition classes applied to ensure only the move class\n  // is applied.\n  const clone = el.cloneNode() as HTMLElement\n  if (el._vtc) {\n    el._vtc.forEach(cls => {\n      cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c))\n    })\n  }\n  moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c))\n  clone.style.display = 'none'\n  const container = (\n    root.nodeType === 1 ? root : root.parentNode\n  ) as HTMLElement\n  container.appendChild(clone)\n  const { hasTransform } = getTransitionInfo(clone)\n  container.removeChild(clone)\n  return hasTransform\n}\n", "import {\n  ObjectDirective,\n  VNode,\n  DirectiveHook,\n  DirectiveBinding,\n  warn\n} from '@vue/runtime-core'\nimport { addEventListener } from '../modules/events'\nimport {\n  isArray,\n  looseEqual,\n  looseIndexOf,\n  invokeArrayFns,\n  toNumber,\n  isSet\n} from '@vue/shared'\n\ntype AssignerFn = (value: any) => void\n\nconst getModelAssigner = (vnode: VNode): AssignerFn => {\n  const fn = vnode.props!['onUpdate:modelValue']\n  return isArray(fn) ? value => invokeArrayFns(fn, value) : fn\n}\n\nfunction onCompositionStart(e: Event) {\n  ;(e.target as any).composing = true\n}\n\nfunction onCompositionEnd(e: Event) {\n  const target = e.target as any\n  if (target.composing) {\n    target.composing = false\n    trigger(target, 'input')\n  }\n}\n\nfunction trigger(el: HTMLElement, type: string) {\n  const e = document.createEvent('HTMLEvents')\n  e.initEvent(type, true, true)\n  el.dispatchEvent(e)\n}\n\ntype ModelDirective<T> = ObjectDirective<T & { _assign: AssignerFn }>\n\n// We are exporting the v-model runtime directly as vnode hooks so that it can\n// be tree-shaken in case v-model is never used.\nexport const vModelText: ModelDirective<\n  HTMLInputElement | HTMLTextAreaElement\n> = {\n  created(el, { modifiers: { lazy, trim, number } }, vnode) {\n    el._assign = getModelAssigner(vnode)\n    const castToNumber =\n      number || (vnode.props && vnode.props.type === 'number')\n    addEventListener(el, lazy ? 'change' : 'input', e => {\n      if ((e.target as any).composing) return\n      let domValue: string | number = el.value\n      if (trim) {\n        domValue = domValue.trim()\n      } else if (castToNumber) {\n        domValue = toNumber(domValue)\n      }\n      el._assign(domValue)\n    })\n    if (trim) {\n      addEventListener(el, 'change', () => {\n        el.value = el.value.trim()\n      })\n    }\n    if (!lazy) {\n      addEventListener(el, 'compositionstart', onCompositionStart)\n      addEventListener(el, 'compositionend', onCompositionEnd)\n      // Safari < 10.2 & UIWebView doesn't fire compositionend when\n      // switching focus before confirming composition choice\n      // this also fixes the issue where some browsers e.g. iOS Chrome\n      // fires \"change\" instead of \"input\" on autocomplete.\n      addEventListener(el, 'change', onCompositionEnd)\n    }\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(el, { value }) {\n    el.value = value == null ? '' : value\n  },\n  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\n    el._assign = getModelAssigner(vnode)\n    // avoid clearing unresolved text. #2302\n    if ((el as any).composing) return\n    if (document.activeElement === el) {\n      if (lazy) {\n        return\n      }\n      if (trim && el.value.trim() === value) {\n        return\n      }\n      if ((number || el.type === 'number') && toNumber(el.value) === value) {\n        return\n      }\n    }\n    const newValue = value == null ? '' : value\n    if (el.value !== newValue) {\n      el.value = newValue\n    }\n  }\n}\n\nexport const vModelCheckbox: ModelDirective<HTMLInputElement> = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el._assign = getModelAssigner(vnode)\n    addEventListener(el, 'change', () => {\n      const modelValue = (el as any)._modelValue\n      const elementValue = getValue(el)\n      const checked = el.checked\n      const assign = el._assign\n      if (isArray(modelValue)) {\n        const index = looseIndexOf(modelValue, elementValue)\n        const found = index !== -1\n        if (checked && !found) {\n          assign(modelValue.concat(elementValue))\n        } else if (!checked && found) {\n          const filtered = [...modelValue]\n          filtered.splice(index, 1)\n          assign(filtered)\n        }\n      } else if (isSet(modelValue)) {\n        const cloned = new Set(modelValue)\n        if (checked) {\n          cloned.add(elementValue)\n        } else {\n          cloned.delete(elementValue)\n        }\n        assign(cloned)\n      } else {\n        assign(getCheckboxValue(el, checked))\n      }\n    })\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el._assign = getModelAssigner(vnode)\n    setChecked(el, binding, vnode)\n  }\n}\n\nfunction setChecked(\n  el: HTMLInputElement,\n  { value, oldValue }: DirectiveBinding,\n  vnode: VNode\n) {\n  // store the v-model value on the element so it can be accessed by the\n  // change listener.\n  ;(el as any)._modelValue = value\n  if (isArray(value)) {\n    el.checked = looseIndexOf(value, vnode.props!.value) > -1\n  } else if (isSet(value)) {\n    el.checked = value.has(vnode.props!.value)\n  } else if (value !== oldValue) {\n    el.checked = looseEqual(value, getCheckboxValue(el, true))\n  }\n}\n\nexport const vModelRadio: ModelDirective<HTMLInputElement> = {\n  created(el, { value }, vnode) {\n    el.checked = looseEqual(value, vnode.props!.value)\n    el._assign = getModelAssigner(vnode)\n    addEventListener(el, 'change', () => {\n      el._assign(getValue(el))\n    })\n  },\n  beforeUpdate(el, { value, oldValue }, vnode) {\n    el._assign = getModelAssigner(vnode)\n    if (value !== oldValue) {\n      el.checked = looseEqual(value, vnode.props!.value)\n    }\n  }\n}\n\nexport const vModelSelect: ModelDirective<HTMLSelectElement> = {\n  // <select multiple> value need to be deep traversed\n  deep: true,\n  created(el, { value, modifiers: { number } }, vnode) {\n    const isSetModel = isSet(value)\n    addEventListener(el, 'change', () => {\n      const selectedVal = Array.prototype.filter\n        .call(el.options, (o: HTMLOptionElement) => o.selected)\n        .map((o: HTMLOptionElement) =>\n          number ? toNumber(getValue(o)) : getValue(o)\n        )\n      el._assign(\n        el.multiple\n          ? isSetModel\n            ? new Set(selectedVal)\n            : selectedVal\n          : selectedVal[0]\n      )\n    })\n    el._assign = getModelAssigner(vnode)\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(el, { value }) {\n    setSelected(el, value)\n  },\n  beforeUpdate(el, _binding, vnode) {\n    el._assign = getModelAssigner(vnode)\n  },\n  updated(el, { value }) {\n    setSelected(el, value)\n  }\n}\n\nfunction setSelected(el: HTMLSelectElement, value: any) {\n  const isMultiple = el.multiple\n  if (isMultiple && !isArray(value) && !isSet(value)) {\n    __DEV__ &&\n      warn(\n        `<select multiple v-model> expects an Array or Set value for its binding, ` +\n          `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`\n      )\n    return\n  }\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    const option = el.options[i]\n    const optionValue = getValue(option)\n    if (isMultiple) {\n      if (isArray(value)) {\n        option.selected = looseIndexOf(value, optionValue) > -1\n      } else {\n        option.selected = value.has(optionValue)\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) el.selectedIndex = i\n        return\n      }\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1\n  }\n}\n\n// retrieve raw value set via :value bindings\nfunction getValue(el: HTMLOptionElement | HTMLInputElement) {\n  return '_value' in el ? (el as any)._value : el.value\n}\n\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\nfunction getCheckboxValue(\n  el: HTMLInputElement & { _trueValue?: any; _falseValue?: any },\n  checked: boolean\n) {\n  const key = checked ? '_trueValue' : '_falseValue'\n  return key in el ? el[key] : checked\n}\n\nexport const vModelDynamic: ObjectDirective<\n  HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement\n> = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, 'created')\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, 'mounted')\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate')\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, 'updated')\n  }\n}\n\nfunction callModelHook(\n  el: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement,\n  binding: DirectiveBinding,\n  vnode: VNode,\n  prevVNode: VNode | null,\n  hook: keyof ObjectDirective\n) {\n  let modelToUse: ObjectDirective\n  switch (el.tagName) {\n    case 'SELECT':\n      modelToUse = vModelSelect\n      break\n    case 'TEXTAREA':\n      modelToUse = vModelText\n      break\n    default:\n      switch (vnode.props && vnode.props.type) {\n        case 'checkbox':\n          modelToUse = vModelCheckbox\n          break\n        case 'radio':\n          modelToUse = vModelRadio\n          break\n        default:\n          modelToUse = vModelText\n      }\n  }\n  const fn = modelToUse[hook] as DirectiveHook\n  fn && fn(el, binding, vnode, prevVNode)\n}\n\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nexport function initVModelForSSR() {\n  vModelText.getSSRProps = ({ value }) => ({ value })\n\n  vModelRadio.getSSRProps = ({ value }, vnode) => {\n    if (vnode.props && looseEqual(vnode.props.value, value)) {\n      return { checked: true }\n    }\n  }\n\n  vModelCheckbox.getSSRProps = ({ value }, vnode) => {\n    if (isArray(value)) {\n      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {\n        return { checked: true }\n      }\n    } else if (isSet(value)) {\n      if (vnode.props && value.has(vnode.props.value)) {\n        return { checked: true }\n      }\n    } else if (value) {\n      return { checked: true }\n    }\n  }\n}\n", "import {\n  getCurrentInstance,\n  DeprecationTypes,\n  LegacyConfig,\n  compatUtils,\n  ComponentInternalInstance\n} from '@vue/runtime-core'\nimport { hyphenate, isArray } from '@vue/shared'\n\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta']\n\ntype KeyedEvent = KeyboardEvent | MouseEvent | TouchEvent\n\nconst modifierGuards: Record<\n  string,\n  (e: Event, modifiers: string[]) => void | boolean\n> = {\n  stop: e => e.stopPropagation(),\n  prevent: e => e.preventDefault(),\n  self: e => e.target !== e.currentTarget,\n  ctrl: e => !(e as KeyedEvent).ctrlKey,\n  shift: e => !(e as KeyedEvent).shiftKey,\n  alt: e => !(e as KeyedEvent).altKey,\n  meta: e => !(e as KeyedEvent).metaKey,\n  left: e => 'button' in e && (e as MouseEvent).button !== 0,\n  middle: e => 'button' in e && (e as MouseEvent).button !== 1,\n  right: e => 'button' in e && (e as MouseEvent).button !== 2,\n  exact: (e, modifiers) =>\n    systemModifiers.some(m => (e as any)[`${m}Key`] && !modifiers.includes(m))\n}\n\n/**\n * @private\n */\nexport const withModifiers = (fn: Function, modifiers: string[]) => {\n  return (event: Event, ...args: unknown[]) => {\n    for (let i = 0; i < modifiers.length; i++) {\n      const guard = modifierGuards[modifiers[i]]\n      if (guard && guard(event, modifiers)) return\n    }\n    return fn(event, ...args)\n  }\n}\n\n// Kept for 2.x compat.\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\nconst keyNames: Record<string, string | string[]> = {\n  esc: 'escape',\n  space: ' ',\n  up: 'arrow-up',\n  left: 'arrow-left',\n  right: 'arrow-right',\n  down: 'arrow-down',\n  delete: 'backspace'\n}\n\n/**\n * @private\n */\nexport const withKeys = (fn: Function, modifiers: string[]) => {\n  let globalKeyCodes: LegacyConfig['keyCodes']\n  let instance: ComponentInternalInstance | null = null\n  if (__COMPAT__) {\n    instance = getCurrentInstance()\n    if (\n      compatUtils.isCompatEnabled(DeprecationTypes.CONFIG_KEY_CODES, instance)\n    ) {\n      if (instance) {\n        globalKeyCodes = (instance.appContext.config as LegacyConfig).keyCodes\n      }\n    }\n    if (__DEV__ && modifiers.some(m => /^\\d+$/.test(m))) {\n      compatUtils.warnDeprecation(\n        DeprecationTypes.V_ON_KEYCODE_MODIFIER,\n        instance\n      )\n    }\n  }\n\n  return (event: KeyboardEvent) => {\n    if (!('key' in event)) {\n      return\n    }\n\n    const eventKey = hyphenate(event.key)\n    if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\n      return fn(event)\n    }\n\n    if (__COMPAT__) {\n      const keyCode = String(event.keyCode)\n      if (\n        compatUtils.isCompatEnabled(\n          DeprecationTypes.V_ON_KEYCODE_MODIFIER,\n          instance\n        ) &&\n        modifiers.some(mod => mod == keyCode)\n      ) {\n        return fn(event)\n      }\n      if (globalKeyCodes) {\n        for (const mod of modifiers) {\n          const codes = globalKeyCodes[mod]\n          if (codes) {\n            const matches = isArray(codes)\n              ? codes.some(code => String(code) === keyCode)\n              : String(codes) === keyCode\n            if (matches) {\n              return fn(event)\n            }\n          }\n        }\n      }\n    }\n  }\n}\n", "import { ObjectDirective } from '@vue/runtime-core'\n\ninterface VShowElement extends HTMLElement {\n  // _vod = vue original display\n  _vod: string\n}\n\nexport const vShow: ObjectDirective<VShowElement> = {\n  beforeMount(el, { value }, { transition }) {\n    el._vod = el.style.display === 'none' ? '' : el.style.display\n    if (transition && value) {\n      transition.beforeEnter(el)\n    } else {\n      setDisplay(el, value)\n    }\n  },\n  mounted(el, { value }, { transition }) {\n    if (transition && value) {\n      transition.enter(el)\n    }\n  },\n  updated(el, { value, oldValue }, { transition }) {\n    if (!value === !oldValue) return\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el)\n        setDisplay(el, true)\n        transition.enter(el)\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false)\n        })\n      }\n    } else {\n      setDisplay(el, value)\n    }\n  },\n  beforeUnmount(el, { value }) {\n    setDisplay(el, value)\n  }\n}\n\nfunction setDisplay(el: VShowElement, value: unknown): void {\n  el.style.display = value ? el._vod : 'none'\n}\n\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nexport function initVShowForSSR() {\n  vShow.getSSRProps = ({ value }) => {\n    if (!value) {\n      return { style: { display: 'none' } }\n    }\n  }\n}\n", "import {\n  createRenderer,\n  createHydrationRenderer,\n  warn,\n  RootRenderFunction,\n  CreateAppFunction,\n  Renderer,\n  HydrationRenderer,\n  App,\n  RootHydrateFunction,\n  isRuntimeOnly,\n  DeprecationTypes,\n  compatUtils\n} from '@vue/runtime-core'\nimport { nodeOps } from './nodeOps'\nimport { patchProp } from './patchProp'\n// Importing from the compiler, will be tree-shaken in prod\nimport {\n  isFunction,\n  isString,\n  isHTMLTag,\n  isSVGTag,\n  extend,\n  NOOP\n} from '@vue/shared'\n\ndeclare module '@vue/reactivity' {\n  export interface RefUnwrapBailTypes {\n    // Note: if updating this, also update `types/refBail.d.ts`.\n    runtimeDOMBailTypes: Node | Window\n  }\n}\n\nconst rendererOptions = extend({ patchProp }, nodeOps)\n\n// lazy create the renderer - this makes core renderer logic tree-shakable\n// in case the user only imports reactivity utilities from Vue.\nlet renderer: Renderer<Element | ShadowRoot> | HydrationRenderer\n\nlet enabledHydration = false\n\nfunction ensureRenderer() {\n  return (\n    renderer ||\n    (renderer = createRenderer<Node, Element | ShadowRoot>(rendererOptions))\n  )\n}\n\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration\n    ? renderer\n    : createHydrationRenderer(rendererOptions)\n  enabledHydration = true\n  return renderer as HydrationRenderer\n}\n\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\nexport const render = ((...args) => {\n  ensureRenderer().render(...args)\n}) as RootRenderFunction<Element | ShadowRoot>\n\nexport const hydrate = ((...args) => {\n  ensureHydrationRenderer().hydrate(...args)\n}) as RootHydrateFunction\n\nexport const createApp = ((...args) => {\n  const app = ensureRenderer().createApp(...args)\n\n  if (__DEV__) {\n    injectNativeTagCheck(app)\n    injectCompilerOptionsCheck(app)\n  }\n\n  const { mount } = app\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\n    const container = normalizeContainer(containerOrSelector)\n    if (!container) return\n\n    const component = app._component\n    if (!isFunction(component) && !component.render && !component.template) {\n      // __UNSAFE__\n      // Reason: potential execution of JS expressions in in-DOM template.\n      // The user must make sure the in-DOM template is trusted. If it's\n      // rendered by the server, the template should not contain any user data.\n      component.template = container.innerHTML\n      // 2.x compat check\n      if (__COMPAT__ && __DEV__) {\n        for (let i = 0; i < container.attributes.length; i++) {\n          const attr = container.attributes[i]\n          if (attr.name !== 'v-cloak' && /^(v-|:|@)/.test(attr.name)) {\n            compatUtils.warnDeprecation(\n              DeprecationTypes.GLOBAL_MOUNT_CONTAINER,\n              null\n            )\n            break\n          }\n        }\n      }\n    }\n\n    // clear content before mounting\n    container.innerHTML = ''\n    const proxy = mount(container, false, container instanceof SVGElement)\n    if (container instanceof Element) {\n      container.removeAttribute('v-cloak')\n      container.setAttribute('data-v-app', '')\n    }\n    return proxy\n  }\n\n  return app\n}) as CreateAppFunction<Element>\n\nexport const createSSRApp = ((...args) => {\n  const app = ensureHydrationRenderer().createApp(...args)\n\n  if (__DEV__) {\n    injectNativeTagCheck(app)\n    injectCompilerOptionsCheck(app)\n  }\n\n  const { mount } = app\n  app.mount = (containerOrSelector: Element | ShadowRoot | string): any => {\n    const container = normalizeContainer(containerOrSelector)\n    if (container) {\n      return mount(container, true, container instanceof SVGElement)\n    }\n  }\n\n  return app\n}) as CreateAppFunction<Element>\n\nfunction injectNativeTagCheck(app: App) {\n  // Inject `isNativeTag`\n  // this is used for component name validation (dev only)\n  Object.defineProperty(app.config, 'isNativeTag', {\n    value: (tag: string) => isHTMLTag(tag) || isSVGTag(tag),\n    writable: false\n  })\n}\n\n// dev only\nfunction injectCompilerOptionsCheck(app: App) {\n  if (isRuntimeOnly()) {\n    const isCustomElement = app.config.isCustomElement\n    Object.defineProperty(app.config, 'isCustomElement', {\n      get() {\n        return isCustomElement\n      },\n      set() {\n        warn(\n          `The \\`isCustomElement\\` config option is deprecated. Use ` +\n            `\\`compilerOptions.isCustomElement\\` instead.`\n        )\n      }\n    })\n\n    const compilerOptions = app.config.compilerOptions\n    const msg =\n      `The \\`compilerOptions\\` config option is only respected when using ` +\n      `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` +\n      `Since you are using the runtime-only build, \\`compilerOptions\\` ` +\n      `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` +\n      `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` +\n      `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` +\n      `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`\n\n    Object.defineProperty(app.config, 'compilerOptions', {\n      get() {\n        warn(msg)\n        return compilerOptions\n      },\n      set() {\n        warn(msg)\n      }\n    })\n  }\n}\n\nfunction normalizeContainer(\n  container: Element | ShadowRoot | string\n): Element | null {\n  if (isString(container)) {\n    const res = document.querySelector(container)\n    if (__DEV__ && !res) {\n      warn(\n        `Failed to mount app: mount target selector \"${container}\" returned null.`\n      )\n    }\n    return res\n  }\n  if (\n    __DEV__ &&\n    window.ShadowRoot &&\n    container instanceof window.ShadowRoot &&\n    container.mode === 'closed'\n  ) {\n    warn(\n      `mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`\n    )\n  }\n  return container as any\n}\n\n// Custom element support\nexport {\n  defineCustomElement,\n  defineSSRCustomElement,\n  VueElement,\n  VueElementConstructor\n} from './apiCustomElement'\n\n// SFC CSS utilities\nexport { useCssModule } from './helpers/useCssModule'\nexport { useCssVars } from './helpers/useCssVars'\n\n// DOM-only components\nexport { Transition, TransitionProps } from './components/Transition'\nexport {\n  TransitionGroup,\n  TransitionGroupProps\n} from './components/TransitionGroup'\n\n// **Internal** DOM-only runtime directive helpers\nexport {\n  vModelText,\n  vModelCheckbox,\n  vModelRadio,\n  vModelSelect,\n  vModelDynamic\n} from './directives/vModel'\nexport { withModifiers, withKeys } from './directives/vOn'\nexport { vShow } from './directives/vShow'\n\nimport { initVModelForSSR } from './directives/vModel'\nimport { initVShowForSSR } from './directives/vShow'\n\nlet ssrDirectiveInitialized = false\n\n/**\n * @internal\n */\nexport const initDirectivesForSSR = __SSR__\n  ? () => {\n      if (!ssrDirectiveInitialized) {\n        ssrDirectiveInitialized = true\n        initVModelForSSR()\n        initVShowForSSR()\n      }\n    }\n  : NOOP\n\n// re-export everything from core\n// h, Component, reactivity API, nextTick, flags & types\nexport * from '@vue/runtime-core'\n", "import { initCustomFormatter } from '@vue/runtime-dom'\n\nexport function initDev() {\n  if (__BROWSER__) {\n    if (!__ESM_BUNDLER__) {\n      console.info(\n        `You are running a development build of Vue.\\n` +\n          `Make sure to use the production build (*.prod.js) when deploying for production.`\n      )\n    }\n\n    initCustomFormatter()\n  }\n}\n", "import { SourceLocation } from './ast'\n\nexport interface CompilerError extends SyntaxError {\n  code: number | string\n  loc?: SourceLocation\n}\n\nexport interface CoreCompilerError extends CompilerError {\n  code: ErrorCodes\n}\n\nexport function defaultOnError(error: CompilerError) {\n  throw error\n}\n\nexport function defaultOnWarn(msg: CompilerError) {\n  __DEV__ && console.warn(`[Vue warn] ${msg.message}`)\n}\n\ntype InferCompilerError<T> = T extends ErrorCodes\n  ? CoreCompilerError\n  : CompilerError\n\nexport function createCompilerError<T extends number>(\n  code: T,\n  loc?: SourceLocation,\n  messages?: { [code: number]: string },\n  additionalMessage?: string\n): InferCompilerError<T> {\n  const msg =\n    __DEV__ || !__BROWSER__\n      ? (messages || errorMessages)[code] + (additionalMessage || ``)\n      : code\n  const error = new SyntaxError(String(msg)) as InferCompilerError<T>\n  error.code = code\n  error.loc = loc\n  return error\n}\n\nexport const enum ErrorCodes {\n  // parse errors\n  ABRUPT_CLOSING_OF_EMPTY_COMMENT,\n  CDATA_IN_HTML_CONTENT,\n  DUPLICATE_ATTRIBUTE,\n  END_TAG_WITH_ATTRIBUTES,\n  END_TAG_WITH_TRAILING_SOLIDUS,\n  EOF_BEFORE_TAG_NAME,\n  EOF_IN_CDATA,\n  EOF_IN_COMMENT,\n  EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT,\n  EOF_IN_TAG,\n  INCORRECTLY_CLOSED_COMMENT,\n  INCORRECTLY_OPENED_COMMENT,\n  INVALID_FIRST_CHARACTER_OF_TAG_NAME,\n  MISSING_ATTRIBUTE_VALUE,\n  MISSING_END_TAG_NAME,\n  MISSING_WHITESPACE_BETWEEN_ATTRIBUTES,\n  NESTED_COMMENT,\n  UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n  UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n  UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME,\n  UNEXPECTED_NULL_CHARACTER,\n  UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n  UNEXPECTED_SOLIDUS_IN_TAG,\n\n  // Vue-specific parse errors\n  X_INVALID_END_TAG,\n  X_MISSING_END_TAG,\n  X_MISSING_INTERPOLATION_END,\n  X_MISSING_DIRECTIVE_NAME,\n  X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END,\n\n  // transform errors\n  X_V_IF_NO_EXPRESSION,\n  X_V_IF_SAME_KEY,\n  X_V_ELSE_NO_ADJACENT_IF,\n  X_V_FOR_NO_EXPRESSION,\n  X_V_FOR_MALFORMED_EXPRESSION,\n  X_V_FOR_TEMPLATE_KEY_PLACEMENT,\n  X_V_BIND_NO_EXPRESSION,\n  X_V_ON_NO_EXPRESSION,\n  X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n  X_V_SLOT_MIXED_SLOT_USAGE,\n  X_V_SLOT_DUPLICATE_SLOT_NAMES,\n  X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\n  X_V_SLOT_MISPLACED,\n  X_V_MODEL_NO_EXPRESSION,\n  X_V_MODEL_MALFORMED_EXPRESSION,\n  X_V_MODEL_ON_SCOPE_VARIABLE,\n  X_INVALID_EXPRESSION,\n  X_KEEP_ALIVE_INVALID_CHILDREN,\n\n  // generic errors\n  X_PREFIX_ID_NOT_SUPPORTED,\n  X_MODULE_MODE_NOT_SUPPORTED,\n  X_CACHE_HANDLER_NOT_SUPPORTED,\n  X_SCOPE_ID_NOT_SUPPORTED,\n\n  // Special value for higher-order compilers to pick up the last code\n  // to avoid collision of error codes. This should always be kept as the last\n  // item.\n  __EXTEND_POINT__\n}\n\nexport const errorMessages: Record<ErrorCodes, string> = {\n  // parse errors\n  [ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT]: 'Illegal comment.',\n  [ErrorCodes.CDATA_IN_HTML_CONTENT]:\n    'CDATA section is allowed only in XML context.',\n  [ErrorCodes.DUPLICATE_ATTRIBUTE]: 'Duplicate attribute.',\n  [ErrorCodes.END_TAG_WITH_ATTRIBUTES]: 'End tag cannot have attributes.',\n  [ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS]: \"Illegal '/' in tags.\",\n  [ErrorCodes.EOF_BEFORE_TAG_NAME]: 'Unexpected EOF in tag.',\n  [ErrorCodes.EOF_IN_CDATA]: 'Unexpected EOF in CDATA section.',\n  [ErrorCodes.EOF_IN_COMMENT]: 'Unexpected EOF in comment.',\n  [ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT]:\n    'Unexpected EOF in script.',\n  [ErrorCodes.EOF_IN_TAG]: 'Unexpected EOF in tag.',\n  [ErrorCodes.INCORRECTLY_CLOSED_COMMENT]: 'Incorrectly closed comment.',\n  [ErrorCodes.INCORRECTLY_OPENED_COMMENT]: 'Incorrectly opened comment.',\n  [ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME]:\n    \"Illegal tag name. Use '&lt;' to print '<'.\",\n  [ErrorCodes.MISSING_ATTRIBUTE_VALUE]: 'Attribute value was expected.',\n  [ErrorCodes.MISSING_END_TAG_NAME]: 'End tag name was expected.',\n  [ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES]:\n    'Whitespace was expected.',\n  [ErrorCodes.NESTED_COMMENT]: \"Unexpected '<!--' in comment.\",\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME]:\n    'Attribute name cannot contain U+0022 (\"), U+0027 (\\'), and U+003C (<).',\n  [ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE]:\n    'Unquoted attribute value cannot contain U+0022 (\"), U+0027 (\\'), U+003C (<), U+003D (=), and U+0060 (`).',\n  [ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME]:\n    \"Attribute name cannot start with '='.\",\n  [ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME]:\n    \"'<?' is allowed only in XML context.\",\n  [ErrorCodes.UNEXPECTED_NULL_CHARACTER]: `Unexpected null character.`,\n  [ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG]: \"Illegal '/' in tags.\",\n\n  // Vue-specific parse errors\n  [ErrorCodes.X_INVALID_END_TAG]: 'Invalid end tag.',\n  [ErrorCodes.X_MISSING_END_TAG]: 'Element is missing end tag.',\n  [ErrorCodes.X_MISSING_INTERPOLATION_END]:\n    'Interpolation end sign was not found.',\n  [ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END]:\n    'End bracket for dynamic directive argument was not found. ' +\n    'Note that dynamic directive argument cannot contain spaces.',\n  [ErrorCodes.X_MISSING_DIRECTIVE_NAME]: 'Legal directive name was expected.',\n\n  // transform errors\n  [ErrorCodes.X_V_IF_NO_EXPRESSION]: `v-if/v-else-if is missing expression.`,\n  [ErrorCodes.X_V_IF_SAME_KEY]: `v-if/else branches must use unique keys.`,\n  [ErrorCodes.X_V_ELSE_NO_ADJACENT_IF]: `v-else/v-else-if has no adjacent v-if or v-else-if.`,\n  [ErrorCodes.X_V_FOR_NO_EXPRESSION]: `v-for is missing expression.`,\n  [ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION]: `v-for has invalid expression.`,\n  [ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT]: `<template v-for> key should be placed on the <template> tag.`,\n  [ErrorCodes.X_V_BIND_NO_EXPRESSION]: `v-bind is missing expression.`,\n  [ErrorCodes.X_V_ON_NO_EXPRESSION]: `v-on is missing expression.`,\n  [ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET]: `Unexpected custom directive on <slot> outlet.`,\n  [ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE]:\n    `Mixed v-slot usage on both the component and nested <template>.` +\n    `When there are multiple named slots, all slots should use <template> ` +\n    `syntax to avoid scope ambiguity.`,\n  [ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES]: `Duplicate slot names found. `,\n  [ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN]:\n    `Extraneous children found when component already has explicitly named ` +\n    `default slot. These children will be ignored.`,\n  [ErrorCodes.X_V_SLOT_MISPLACED]: `v-slot can only be used on components or <template> tags.`,\n  [ErrorCodes.X_V_MODEL_NO_EXPRESSION]: `v-model is missing expression.`,\n  [ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION]: `v-model value must be a valid JavaScript member expression.`,\n  [ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,\n  [ErrorCodes.X_INVALID_EXPRESSION]: `Error parsing JavaScript expression: `,\n  [ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN]: `<KeepAlive> expects exactly one child component.`,\n\n  // generic errors\n  [ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED]: `\"prefixIdentifiers\" option is not supported in this build of compiler.`,\n  [ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED]: `ES module mode is not supported in this build of compiler.`,\n  [ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED]: `\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.`,\n  [ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED]: `\"scopeId\" option is only supported in module mode.`,\n\n  // just to fulfill types\n  [ErrorCodes.__EXTEND_POINT__]: ``\n}\n", "export const FRAGMENT = Symbol(__DEV__ ? `Fragment` : ``)\nexport const TELEPORT = Symbol(__DEV__ ? `Teleport` : ``)\nexport const SUSPENSE = Symbol(__DEV__ ? `Suspense` : ``)\nexport const KEEP_ALIVE = Symbol(__DEV__ ? `KeepAlive` : ``)\nexport const BASE_TRANSITION = Symbol(__DEV__ ? `BaseTransition` : ``)\nexport const OPEN_BLOCK = Symbol(__DEV__ ? `openBlock` : ``)\nexport const CREATE_BLOCK = Symbol(__DEV__ ? `createBlock` : ``)\nexport const CREATE_ELEMENT_BLOCK = Symbol(__DEV__ ? `createElementBlock` : ``)\nexport const CREATE_VNODE = Symbol(__DEV__ ? `createVNode` : ``)\nexport const CREATE_ELEMENT_VNODE = Symbol(__DEV__ ? `createElementVNode` : ``)\nexport const CREATE_COMMENT = Symbol(__DEV__ ? `createCommentVNode` : ``)\nexport const CREATE_TEXT = Symbol(__DEV__ ? `createTextVNode` : ``)\nexport const CREATE_STATIC = Symbol(__DEV__ ? `createStaticVNode` : ``)\nexport const RESOLVE_COMPONENT = Symbol(__DEV__ ? `resolveComponent` : ``)\nexport const RESOLVE_DYNAMIC_COMPONENT = Symbol(\n  __DEV__ ? `resolveDynamicComponent` : ``\n)\nexport const RESOLVE_DIRECTIVE = Symbol(__DEV__ ? `resolveDirective` : ``)\nexport const RESOLVE_FILTER = Symbol(__DEV__ ? `resolveFilter` : ``)\nexport const WITH_DIRECTIVES = Symbol(__DEV__ ? `withDirectives` : ``)\nexport const RENDER_LIST = Symbol(__DEV__ ? `renderList` : ``)\nexport const RENDER_SLOT = Symbol(__DEV__ ? `renderSlot` : ``)\nexport const CREATE_SLOTS = Symbol(__DEV__ ? `createSlots` : ``)\nexport const TO_DISPLAY_STRING = Symbol(__DEV__ ? `toDisplayString` : ``)\nexport const MERGE_PROPS = Symbol(__DEV__ ? `mergeProps` : ``)\nexport const NORMALIZE_CLASS = Symbol(__DEV__ ? `normalizeClass` : ``)\nexport const NORMALIZE_STYLE = Symbol(__DEV__ ? `normalizeStyle` : ``)\nexport const NORMALIZE_PROPS = Symbol(__DEV__ ? `normalizeProps` : ``)\nexport const GUARD_REACTIVE_PROPS = Symbol(__DEV__ ? `guardReactiveProps` : ``)\nexport const TO_HANDLERS = Symbol(__DEV__ ? `toHandlers` : ``)\nexport const CAMELIZE = Symbol(__DEV__ ? `camelize` : ``)\nexport const CAPITALIZE = Symbol(__DEV__ ? `capitalize` : ``)\nexport const TO_HANDLER_KEY = Symbol(__DEV__ ? `toHandlerKey` : ``)\nexport const SET_BLOCK_TRACKING = Symbol(__DEV__ ? `setBlockTracking` : ``)\nexport const PUSH_SCOPE_ID = Symbol(__DEV__ ? `pushScopeId` : ``)\nexport const POP_SCOPE_ID = Symbol(__DEV__ ? `popScopeId` : ``)\nexport const WITH_CTX = Symbol(__DEV__ ? `withCtx` : ``)\nexport const UNREF = Symbol(__DEV__ ? `unref` : ``)\nexport const IS_REF = Symbol(__DEV__ ? `isRef` : ``)\nexport const WITH_MEMO = Symbol(__DEV__ ? `withMemo` : ``)\nexport const IS_MEMO_SAME = Symbol(__DEV__ ? `isMemoSame` : ``)\n\n// Name mapping for runtime helpers that need to be imported from 'vue' in\n// generated code. Make sure these are correctly exported in the runtime!\n// Using `any` here because TS doesn't allow symbols as index type.\nexport const helperNameMap: any = {\n  [FRAGMENT]: `Fragment`,\n  [TELEPORT]: `Teleport`,\n  [SUSPENSE]: `Suspense`,\n  [KEEP_ALIVE]: `KeepAlive`,\n  [BASE_TRANSITION]: `BaseTransition`,\n  [OPEN_BLOCK]: `openBlock`,\n  [CREATE_BLOCK]: `createBlock`,\n  [CREATE_ELEMENT_BLOCK]: `createElementBlock`,\n  [CREATE_VNODE]: `createVNode`,\n  [CREATE_ELEMENT_VNODE]: `createElementVNode`,\n  [CREATE_COMMENT]: `createCommentVNode`,\n  [CREATE_TEXT]: `createTextVNode`,\n  [CREATE_STATIC]: `createStaticVNode`,\n  [RESOLVE_COMPONENT]: `resolveComponent`,\n  [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,\n  [RESOLVE_DIRECTIVE]: `resolveDirective`,\n  [RESOLVE_FILTER]: `resolveFilter`,\n  [WITH_DIRECTIVES]: `withDirectives`,\n  [RENDER_LIST]: `renderList`,\n  [RENDER_SLOT]: `renderSlot`,\n  [CREATE_SLOTS]: `createSlots`,\n  [TO_DISPLAY_STRING]: `toDisplayString`,\n  [MERGE_PROPS]: `mergeProps`,\n  [NORMALIZE_CLASS]: `normalizeClass`,\n  [NORMALIZE_STYLE]: `normalizeStyle`,\n  [NORMALIZE_PROPS]: `normalizeProps`,\n  [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,\n  [TO_HANDLERS]: `toHandlers`,\n  [CAMELIZE]: `camelize`,\n  [CAPITALIZE]: `capitalize`,\n  [TO_HANDLER_KEY]: `toHandlerKey`,\n  [SET_BLOCK_TRACKING]: `setBlockTracking`,\n  [PUSH_SCOPE_ID]: `pushScopeId`,\n  [POP_SCOPE_ID]: `popScopeId`,\n  [WITH_CTX]: `withCtx`,\n  [UNREF]: `unref`,\n  [IS_REF]: `isRef`,\n  [WITH_MEMO]: `withMemo`,\n  [IS_MEMO_SAME]: `isMemoSame`\n}\n\nexport function registerRuntimeHelpers(helpers: any) {\n  Object.getOwnPropertySymbols(helpers).forEach(s => {\n    helperNameMap[s] = helpers[s]\n  })\n}\n", "import { isString } from '@vue/shared'\nimport { ForParseResult } from './transforms/vFor'\nimport {\n  RENDER_SLOT,\n  CREATE_SLOTS,\n  RENDER_LIST,\n  OPEN_BLOCK,\n  FRAGMENT,\n  WITH_DIRECTIVES,\n  WITH_MEMO\n} from './runtimeHelpers'\nimport { PropsExpression } from './transforms/transformElement'\nimport { ImportItem, TransformContext } from './transform'\nimport { getVNodeBlockHelper, getVNodeHelper } from './utils'\n\n// Vue template is a platform-agnostic superset of HTML (syntax only).\n// More namespaces like SVG and MathML are declared by platform specific\n// compilers.\nexport type Namespace = number\n\nexport const enum Namespaces {\n  HTML\n}\n\nexport const enum NodeTypes {\n  ROOT,\n  ELEMENT,\n  TEXT,\n  COMMENT,\n  SIMPLE_EXPRESSION,\n  INTERPOLATION,\n  ATTRIBUTE,\n  DIRECTIVE,\n  // containers\n  COMPOUND_EXPRESSION,\n  IF,\n  IF_BRANCH,\n  FOR,\n  TEXT_CALL,\n  // codegen\n  VNODE_CALL,\n  JS_CALL_EXPRESSION,\n  JS_OBJECT_EXPRESSION,\n  JS_PROPERTY,\n  JS_ARRAY_EXPRESSION,\n  JS_FUNCTION_EXPRESSION,\n  JS_CONDITIONAL_EXPRESSION,\n  JS_CACHE_EXPRESSION,\n\n  // ssr codegen\n  JS_BLOCK_STATEMENT,\n  JS_TEMPLATE_LITERAL,\n  JS_IF_STATEMENT,\n  JS_ASSIGNMENT_EXPRESSION,\n  JS_SEQUENCE_EXPRESSION,\n  JS_RETURN_STATEMENT\n}\n\nexport const enum ElementTypes {\n  ELEMENT,\n  COMPONENT,\n  SLOT,\n  TEMPLATE\n}\n\nexport interface Node {\n  type: NodeTypes\n  loc: SourceLocation\n}\n\n// The node's range. The `start` is inclusive and `end` is exclusive.\n// [start, end)\nexport interface SourceLocation {\n  start: Position\n  end: Position\n  source: string\n}\n\nexport interface Position {\n  offset: number // from start of file\n  line: number\n  column: number\n}\n\nexport type ParentNode = RootNode | ElementNode | IfBranchNode | ForNode\n\nexport type ExpressionNode = SimpleExpressionNode | CompoundExpressionNode\n\nexport type TemplateChildNode =\n  | ElementNode\n  | InterpolationNode\n  | CompoundExpressionNode\n  | TextNode\n  | CommentNode\n  | IfNode\n  | IfBranchNode\n  | ForNode\n  | TextCallNode\n\nexport interface RootNode extends Node {\n  type: NodeTypes.ROOT\n  children: TemplateChildNode[]\n  helpers: symbol[]\n  components: string[]\n  directives: string[]\n  hoists: (JSChildNode | null)[]\n  imports: ImportItem[]\n  cached: number\n  temps: number\n  ssrHelpers?: symbol[]\n  codegenNode?: TemplateChildNode | JSChildNode | BlockStatement\n\n  // v2 compat only\n  filters?: string[]\n}\n\nexport type ElementNode =\n  | PlainElementNode\n  | ComponentNode\n  | SlotOutletNode\n  | TemplateNode\n\nexport interface BaseElementNode extends Node {\n  type: NodeTypes.ELEMENT\n  ns: Namespace\n  tag: string\n  tagType: ElementTypes\n  isSelfClosing: boolean\n  props: Array<AttributeNode | DirectiveNode>\n  children: TemplateChildNode[]\n}\n\nexport interface PlainElementNode extends BaseElementNode {\n  tagType: ElementTypes.ELEMENT\n  codegenNode:\n    | VNodeCall\n    | SimpleExpressionNode // when hoisted\n    | CacheExpression // when cached by v-once\n    | MemoExpression // when cached by v-memo\n    | undefined\n  ssrCodegenNode?: TemplateLiteral\n}\n\nexport interface ComponentNode extends BaseElementNode {\n  tagType: ElementTypes.COMPONENT\n  codegenNode:\n    | VNodeCall\n    | CacheExpression // when cached by v-once\n    | MemoExpression // when cached by v-memo\n    | undefined\n  ssrCodegenNode?: CallExpression\n}\n\nexport interface SlotOutletNode extends BaseElementNode {\n  tagType: ElementTypes.SLOT\n  codegenNode:\n    | RenderSlotCall\n    | CacheExpression // when cached by v-once\n    | undefined\n  ssrCodegenNode?: CallExpression\n}\n\nexport interface TemplateNode extends BaseElementNode {\n  tagType: ElementTypes.TEMPLATE\n  // TemplateNode is a container type that always gets compiled away\n  codegenNode: undefined\n}\n\nexport interface TextNode extends Node {\n  type: NodeTypes.TEXT\n  content: string\n}\n\nexport interface CommentNode extends Node {\n  type: NodeTypes.COMMENT\n  content: string\n}\n\nexport interface AttributeNode extends Node {\n  type: NodeTypes.ATTRIBUTE\n  name: string\n  value: TextNode | undefined\n}\n\nexport interface DirectiveNode extends Node {\n  type: NodeTypes.DIRECTIVE\n  name: string\n  exp: ExpressionNode | undefined\n  arg: ExpressionNode | undefined\n  modifiers: string[]\n  /**\n   * optional property to cache the expression parse result for v-for\n   */\n  parseResult?: ForParseResult\n}\n\n/**\n * Static types have several levels.\n * Higher levels implies lower levels. e.g. a node that can be stringified\n * can always be hoisted and skipped for patch.\n */\nexport const enum ConstantTypes {\n  NOT_CONSTANT = 0,\n  CAN_SKIP_PATCH,\n  CAN_HOIST,\n  CAN_STRINGIFY\n}\n\nexport interface SimpleExpressionNode extends Node {\n  type: NodeTypes.SIMPLE_EXPRESSION\n  content: string\n  isStatic: boolean\n  constType: ConstantTypes\n  /**\n   * Indicates this is an identifier for a hoist vnode call and points to the\n   * hoisted node.\n   */\n  hoisted?: JSChildNode\n  /**\n   * an expression parsed as the params of a function will track\n   * the identifiers declared inside the function body.\n   */\n  identifiers?: string[]\n  isHandlerKey?: boolean\n}\n\nexport interface InterpolationNode extends Node {\n  type: NodeTypes.INTERPOLATION\n  content: ExpressionNode\n}\n\nexport interface CompoundExpressionNode extends Node {\n  type: NodeTypes.COMPOUND_EXPRESSION\n  children: (\n    | SimpleExpressionNode\n    | CompoundExpressionNode\n    | InterpolationNode\n    | TextNode\n    | string\n    | symbol\n  )[]\n\n  /**\n   * an expression parsed as the params of a function will track\n   * the identifiers declared inside the function body.\n   */\n  identifiers?: string[]\n  isHandlerKey?: boolean\n}\n\nexport interface IfNode extends Node {\n  type: NodeTypes.IF\n  branches: IfBranchNode[]\n  codegenNode?: IfConditionalExpression | CacheExpression // <div v-if v-once>\n}\n\nexport interface IfBranchNode extends Node {\n  type: NodeTypes.IF_BRANCH\n  condition: ExpressionNode | undefined // else\n  children: TemplateChildNode[]\n  userKey?: AttributeNode | DirectiveNode\n}\n\nexport interface ForNode extends Node {\n  type: NodeTypes.FOR\n  source: ExpressionNode\n  valueAlias: ExpressionNode | undefined\n  keyAlias: ExpressionNode | undefined\n  objectIndexAlias: ExpressionNode | undefined\n  parseResult: ForParseResult\n  children: TemplateChildNode[]\n  codegenNode?: ForCodegenNode\n}\n\nexport interface TextCallNode extends Node {\n  type: NodeTypes.TEXT_CALL\n  content: TextNode | InterpolationNode | CompoundExpressionNode\n  codegenNode: CallExpression | SimpleExpressionNode // when hoisted\n}\n\nexport type TemplateTextChildNode =\n  | TextNode\n  | InterpolationNode\n  | CompoundExpressionNode\n\nexport interface VNodeCall extends Node {\n  type: NodeTypes.VNODE_CALL\n  tag: string | symbol | CallExpression\n  props: PropsExpression | undefined\n  children:\n    | TemplateChildNode[] // multiple children\n    | TemplateTextChildNode // single text child\n    | SlotsExpression // component slots\n    | ForRenderListExpression // v-for fragment call\n    | SimpleExpressionNode // hoisted\n    | undefined\n  patchFlag: string | undefined\n  dynamicProps: string | SimpleExpressionNode | undefined\n  directives: DirectiveArguments | undefined\n  isBlock: boolean\n  disableTracking: boolean\n  isComponent: boolean\n}\n\n// JS Node Types ---------------------------------------------------------------\n\n// We also include a number of JavaScript AST nodes for code generation.\n// The AST is an intentionally minimal subset just to meet the exact needs of\n// Vue render function generation.\n\nexport type JSChildNode =\n  | VNodeCall\n  | CallExpression\n  | ObjectExpression\n  | ArrayExpression\n  | ExpressionNode\n  | FunctionExpression\n  | ConditionalExpression\n  | CacheExpression\n  | AssignmentExpression\n  | SequenceExpression\n\nexport interface CallExpression extends Node {\n  type: NodeTypes.JS_CALL_EXPRESSION\n  callee: string | symbol\n  arguments: (\n    | string\n    | symbol\n    | JSChildNode\n    | SSRCodegenNode\n    | TemplateChildNode\n    | TemplateChildNode[]\n  )[]\n}\n\nexport interface ObjectExpression extends Node {\n  type: NodeTypes.JS_OBJECT_EXPRESSION\n  properties: Array<Property>\n}\n\nexport interface Property extends Node {\n  type: NodeTypes.JS_PROPERTY\n  key: ExpressionNode\n  value: JSChildNode\n}\n\nexport interface ArrayExpression extends Node {\n  type: NodeTypes.JS_ARRAY_EXPRESSION\n  elements: Array<string | Node>\n}\n\nexport interface FunctionExpression extends Node {\n  type: NodeTypes.JS_FUNCTION_EXPRESSION\n  params: ExpressionNode | string | (ExpressionNode | string)[] | undefined\n  returns?: TemplateChildNode | TemplateChildNode[] | JSChildNode\n  body?: BlockStatement | IfStatement\n  newline: boolean\n  /**\n   * This flag is for codegen to determine whether it needs to generate the\n   * withScopeId() wrapper\n   */\n  isSlot: boolean\n  /**\n   * __COMPAT__ only, indicates a slot function that should be excluded from\n   * the legacy $scopedSlots instance property.\n   */\n  isNonScopedSlot?: boolean\n}\n\nexport interface ConditionalExpression extends Node {\n  type: NodeTypes.JS_CONDITIONAL_EXPRESSION\n  test: JSChildNode\n  consequent: JSChildNode\n  alternate: JSChildNode\n  newline: boolean\n}\n\nexport interface CacheExpression extends Node {\n  type: NodeTypes.JS_CACHE_EXPRESSION\n  index: number\n  value: JSChildNode\n  isVNode: boolean\n}\n\nexport interface MemoExpression extends CallExpression {\n  callee: typeof WITH_MEMO\n  arguments: [ExpressionNode, MemoFactory, string, string]\n}\n\ninterface MemoFactory extends FunctionExpression {\n  returns: BlockCodegenNode\n}\n\n// SSR-specific Node Types -----------------------------------------------------\n\nexport type SSRCodegenNode =\n  | BlockStatement\n  | TemplateLiteral\n  | IfStatement\n  | AssignmentExpression\n  | ReturnStatement\n  | SequenceExpression\n\nexport interface BlockStatement extends Node {\n  type: NodeTypes.JS_BLOCK_STATEMENT\n  body: (JSChildNode | IfStatement)[]\n}\n\nexport interface TemplateLiteral extends Node {\n  type: NodeTypes.JS_TEMPLATE_LITERAL\n  elements: (string | JSChildNode)[]\n}\n\nexport interface IfStatement extends Node {\n  type: NodeTypes.JS_IF_STATEMENT\n  test: ExpressionNode\n  consequent: BlockStatement\n  alternate: IfStatement | BlockStatement | ReturnStatement | undefined\n}\n\nexport interface AssignmentExpression extends Node {\n  type: NodeTypes.JS_ASSIGNMENT_EXPRESSION\n  left: SimpleExpressionNode\n  right: JSChildNode\n}\n\nexport interface SequenceExpression extends Node {\n  type: NodeTypes.JS_SEQUENCE_EXPRESSION\n  expressions: JSChildNode[]\n}\n\nexport interface ReturnStatement extends Node {\n  type: NodeTypes.JS_RETURN_STATEMENT\n  returns: TemplateChildNode | TemplateChildNode[] | JSChildNode\n}\n\n// Codegen Node Types ----------------------------------------------------------\n\nexport interface DirectiveArguments extends ArrayExpression {\n  elements: DirectiveArgumentNode[]\n}\n\nexport interface DirectiveArgumentNode extends ArrayExpression {\n  elements: // dir, exp, arg, modifiers\n  | [string]\n    | [string, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode]\n    | [string, ExpressionNode, ExpressionNode, ObjectExpression]\n}\n\n// renderSlot(...)\nexport interface RenderSlotCall extends CallExpression {\n  callee: typeof RENDER_SLOT\n  arguments: // $slots, name, props, fallback\n  | [string, string | ExpressionNode]\n    | [string, string | ExpressionNode, PropsExpression]\n    | [\n        string,\n        string | ExpressionNode,\n        PropsExpression | '{}',\n        TemplateChildNode[]\n      ]\n}\n\nexport type SlotsExpression = SlotsObjectExpression | DynamicSlotsExpression\n\n// { foo: () => [...] }\nexport interface SlotsObjectExpression extends ObjectExpression {\n  properties: SlotsObjectProperty[]\n}\n\nexport interface SlotsObjectProperty extends Property {\n  value: SlotFunctionExpression\n}\n\nexport interface SlotFunctionExpression extends FunctionExpression {\n  returns: TemplateChildNode[]\n}\n\n// createSlots({ ... }, [\n//    foo ? () => [] : undefined,\n//    renderList(list, i => () => [i])\n// ])\nexport interface DynamicSlotsExpression extends CallExpression {\n  callee: typeof CREATE_SLOTS\n  arguments: [SlotsObjectExpression, DynamicSlotEntries]\n}\n\nexport interface DynamicSlotEntries extends ArrayExpression {\n  elements: (ConditionalDynamicSlotNode | ListDynamicSlotNode)[]\n}\n\nexport interface ConditionalDynamicSlotNode extends ConditionalExpression {\n  consequent: DynamicSlotNode\n  alternate: DynamicSlotNode | SimpleExpressionNode\n}\n\nexport interface ListDynamicSlotNode extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ListDynamicSlotIterator]\n}\n\nexport interface ListDynamicSlotIterator extends FunctionExpression {\n  returns: DynamicSlotNode\n}\n\nexport interface DynamicSlotNode extends ObjectExpression {\n  properties: [Property, DynamicSlotFnProperty]\n}\n\nexport interface DynamicSlotFnProperty extends Property {\n  value: SlotFunctionExpression\n}\n\nexport type BlockCodegenNode = VNodeCall | RenderSlotCall\n\nexport interface IfConditionalExpression extends ConditionalExpression {\n  consequent: BlockCodegenNode | MemoExpression\n  alternate: BlockCodegenNode | IfConditionalExpression | MemoExpression\n}\n\nexport interface ForCodegenNode extends VNodeCall {\n  isBlock: true\n  tag: typeof FRAGMENT\n  props: undefined\n  children: ForRenderListExpression\n  patchFlag: string\n  disableTracking: boolean\n}\n\nexport interface ForRenderListExpression extends CallExpression {\n  callee: typeof RENDER_LIST\n  arguments: [ExpressionNode, ForIteratorExpression]\n}\n\nexport interface ForIteratorExpression extends FunctionExpression {\n  returns: BlockCodegenNode\n}\n\n// AST Utilities ---------------------------------------------------------------\n\n// Some expressions, e.g. sequence and conditional expressions, are never\n// associated with template nodes, so their source locations are just a stub.\n// Container types like CompoundExpression also don't need a real location.\nexport const locStub: SourceLocation = {\n  source: '',\n  start: { line: 1, column: 1, offset: 0 },\n  end: { line: 1, column: 1, offset: 0 }\n}\n\nexport function createRoot(\n  children: TemplateChildNode[],\n  loc = locStub\n): RootNode {\n  return {\n    type: NodeTypes.ROOT,\n    children,\n    helpers: [],\n    components: [],\n    directives: [],\n    hoists: [],\n    imports: [],\n    cached: 0,\n    temps: 0,\n    codegenNode: undefined,\n    loc\n  }\n}\n\nexport function createVNodeCall(\n  context: TransformContext | null,\n  tag: VNodeCall['tag'],\n  props?: VNodeCall['props'],\n  children?: VNodeCall['children'],\n  patchFlag?: VNodeCall['patchFlag'],\n  dynamicProps?: VNodeCall['dynamicProps'],\n  directives?: VNodeCall['directives'],\n  isBlock: VNodeCall['isBlock'] = false,\n  disableTracking: VNodeCall['disableTracking'] = false,\n  isComponent: VNodeCall['isComponent'] = false,\n  loc = locStub\n): VNodeCall {\n  if (context) {\n    if (isBlock) {\n      context.helper(OPEN_BLOCK)\n      context.helper(getVNodeBlockHelper(context.inSSR, isComponent))\n    } else {\n      context.helper(getVNodeHelper(context.inSSR, isComponent))\n    }\n    if (directives) {\n      context.helper(WITH_DIRECTIVES)\n    }\n  }\n\n  return {\n    type: NodeTypes.VNODE_CALL,\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent,\n    loc\n  }\n}\n\nexport function createArrayExpression(\n  elements: ArrayExpression['elements'],\n  loc: SourceLocation = locStub\n): ArrayExpression {\n  return {\n    type: NodeTypes.JS_ARRAY_EXPRESSION,\n    loc,\n    elements\n  }\n}\n\nexport function createObjectExpression(\n  properties: ObjectExpression['properties'],\n  loc: SourceLocation = locStub\n): ObjectExpression {\n  return {\n    type: NodeTypes.JS_OBJECT_EXPRESSION,\n    loc,\n    properties\n  }\n}\n\nexport function createObjectProperty(\n  key: Property['key'] | string,\n  value: Property['value']\n): Property {\n  return {\n    type: NodeTypes.JS_PROPERTY,\n    loc: locStub,\n    key: isString(key) ? createSimpleExpression(key, true) : key,\n    value\n  }\n}\n\nexport function createSimpleExpression(\n  content: SimpleExpressionNode['content'],\n  isStatic: SimpleExpressionNode['isStatic'] = false,\n  loc: SourceLocation = locStub,\n  constType: ConstantTypes = ConstantTypes.NOT_CONSTANT\n): SimpleExpressionNode {\n  return {\n    type: NodeTypes.SIMPLE_EXPRESSION,\n    loc,\n    content,\n    isStatic,\n    constType: isStatic ? ConstantTypes.CAN_STRINGIFY : constType\n  }\n}\n\nexport function createInterpolation(\n  content: InterpolationNode['content'] | string,\n  loc: SourceLocation\n): InterpolationNode {\n  return {\n    type: NodeTypes.INTERPOLATION,\n    loc,\n    content: isString(content)\n      ? createSimpleExpression(content, false, loc)\n      : content\n  }\n}\n\nexport function createCompoundExpression(\n  children: CompoundExpressionNode['children'],\n  loc: SourceLocation = locStub\n): CompoundExpressionNode {\n  return {\n    type: NodeTypes.COMPOUND_EXPRESSION,\n    loc,\n    children\n  }\n}\n\ntype InferCodegenNodeType<T> = T extends typeof RENDER_SLOT\n  ? RenderSlotCall\n  : CallExpression\n\nexport function createCallExpression<T extends CallExpression['callee']>(\n  callee: T,\n  args: CallExpression['arguments'] = [],\n  loc: SourceLocation = locStub\n): InferCodegenNodeType<T> {\n  return {\n    type: NodeTypes.JS_CALL_EXPRESSION,\n    loc,\n    callee,\n    arguments: args\n  } as InferCodegenNodeType<T>\n}\n\nexport function createFunctionExpression(\n  params: FunctionExpression['params'],\n  returns: FunctionExpression['returns'] = undefined,\n  newline: boolean = false,\n  isSlot: boolean = false,\n  loc: SourceLocation = locStub\n): FunctionExpression {\n  return {\n    type: NodeTypes.JS_FUNCTION_EXPRESSION,\n    params,\n    returns,\n    newline,\n    isSlot,\n    loc\n  }\n}\n\nexport function createConditionalExpression(\n  test: ConditionalExpression['test'],\n  consequent: ConditionalExpression['consequent'],\n  alternate: ConditionalExpression['alternate'],\n  newline = true\n): ConditionalExpression {\n  return {\n    type: NodeTypes.JS_CONDITIONAL_EXPRESSION,\n    test,\n    consequent,\n    alternate,\n    newline,\n    loc: locStub\n  }\n}\n\nexport function createCacheExpression(\n  index: number,\n  value: JSChildNode,\n  isVNode: boolean = false\n): CacheExpression {\n  return {\n    type: NodeTypes.JS_CACHE_EXPRESSION,\n    index,\n    value,\n    isVNode,\n    loc: locStub\n  }\n}\n\nexport function createBlockStatement(\n  body: BlockStatement['body']\n): BlockStatement {\n  return {\n    type: NodeTypes.JS_BLOCK_STATEMENT,\n    body,\n    loc: locStub\n  }\n}\n\nexport function createTemplateLiteral(\n  elements: TemplateLiteral['elements']\n): TemplateLiteral {\n  return {\n    type: NodeTypes.JS_TEMPLATE_LITERAL,\n    elements,\n    loc: locStub\n  }\n}\n\nexport function createIfStatement(\n  test: IfStatement['test'],\n  consequent: IfStatement['consequent'],\n  alternate?: IfStatement['alternate']\n): IfStatement {\n  return {\n    type: NodeTypes.JS_IF_STATEMENT,\n    test,\n    consequent,\n    alternate,\n    loc: locStub\n  }\n}\n\nexport function createAssignmentExpression(\n  left: AssignmentExpression['left'],\n  right: AssignmentExpression['right']\n): AssignmentExpression {\n  return {\n    type: NodeTypes.JS_ASSIGNMENT_EXPRESSION,\n    left,\n    right,\n    loc: locStub\n  }\n}\n\nexport function createSequenceExpression(\n  expressions: SequenceExpression['expressions']\n): SequenceExpression {\n  return {\n    type: NodeTypes.JS_SEQUENCE_EXPRESSION,\n    expressions,\n    loc: locStub\n  }\n}\n\nexport function createReturnStatement(\n  returns: ReturnStatement['returns']\n): ReturnStatement {\n  return {\n    type: NodeTypes.JS_RETURN_STATEMENT,\n    returns,\n    loc: locStub\n  }\n}\n", "import {\n  SourceLocation,\n  Position,\n  ElementNode,\n  NodeTypes,\n  CallExpression,\n  createCallExpression,\n  DirectiveNode,\n  ElementTypes,\n  TemplateChildNode,\n  RootNode,\n  ObjectExpression,\n  Property,\n  JSChildNode,\n  createObjectExpression,\n  SlotOutletNode,\n  TemplateNode,\n  RenderSlotCall,\n  ExpressionNode,\n  IfBranchNode,\n  TextNode,\n  InterpolationNode,\n  VNodeCall,\n  SimpleExpressionNode,\n  BlockCodegenNode,\n  MemoExpression\n} from './ast'\nimport { TransformContext } from './transform'\nimport {\n  MERGE_PROPS,\n  TELEPORT,\n  SUSPENSE,\n  KEEP_ALIVE,\n  BASE_TRANSITION,\n  TO_HANDLERS,\n  NORMALIZE_PROPS,\n  GUARD_REACTIVE_PROPS,\n  CREATE_BLOCK,\n  CREATE_ELEMENT_BLOCK,\n  CREATE_VNODE,\n  CREATE_ELEMENT_VNODE,\n  WITH_MEMO,\n  OPEN_BLOCK\n} from './runtimeHelpers'\nimport { isString, isObject, hyphenate, extend, NOOP } from '@vue/shared'\nimport { PropsExpression } from './transforms/transformElement'\nimport { parseExpression } from '@babel/parser'\nimport { Expression } from '@babel/types'\n\nexport const isStaticExp = (p: JSChildNode): p is SimpleExpressionNode =>\n  p.type === NodeTypes.SIMPLE_EXPRESSION && p.isStatic\n\nexport const isBuiltInType = (tag: string, expected: string): boolean =>\n  tag === expected || tag === hyphenate(expected)\n\nexport function isCoreComponent(tag: string): symbol | void {\n  if (isBuiltInType(tag, 'Teleport')) {\n    return TELEPORT\n  } else if (isBuiltInType(tag, 'Suspense')) {\n    return SUSPENSE\n  } else if (isBuiltInType(tag, 'KeepAlive')) {\n    return KEEP_ALIVE\n  } else if (isBuiltInType(tag, 'BaseTransition')) {\n    return BASE_TRANSITION\n  }\n}\n\nconst nonIdentifierRE = /^\\d|[^\\$\\w]/\nexport const isSimpleIdentifier = (name: string): boolean =>\n  !nonIdentifierRE.test(name)\n\nconst enum MemberExpLexState {\n  inMemberExp,\n  inBrackets,\n  inParens,\n  inString\n}\n\nconst validFirstIdentCharRE = /[A-Za-z_$\\xA0-\\uFFFF]/\nconst validIdentCharRE = /[\\.\\?\\w$\\xA0-\\uFFFF]/\nconst whitespaceRE = /\\s+[.[]\\s*|\\s*[.[]\\s+/g\n\n/**\n * Simple lexer to check if an expression is a member expression. This is\n * lax and only checks validity at the root level (i.e. does not validate exps\n * inside square brackets), but it's ok since these are only used on template\n * expressions and false positives are invalid expressions in the first place.\n */\nexport const isMemberExpressionBrowser = (path: string): boolean => {\n  // remove whitespaces around . or [ first\n  path = path.trim().replace(whitespaceRE, s => s.trim())\n\n  let state = MemberExpLexState.inMemberExp\n  let stateStack: MemberExpLexState[] = []\n  let currentOpenBracketCount = 0\n  let currentOpenParensCount = 0\n  let currentStringType: \"'\" | '\"' | '`' | null = null\n\n  for (let i = 0; i < path.length; i++) {\n    const char = path.charAt(i)\n    switch (state) {\n      case MemberExpLexState.inMemberExp:\n        if (char === '[') {\n          stateStack.push(state)\n          state = MemberExpLexState.inBrackets\n          currentOpenBracketCount++\n        } else if (char === '(') {\n          stateStack.push(state)\n          state = MemberExpLexState.inParens\n          currentOpenParensCount++\n        } else if (\n          !(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)\n        ) {\n          return false\n        }\n        break\n      case MemberExpLexState.inBrackets:\n        if (char === `'` || char === `\"` || char === '`') {\n          stateStack.push(state)\n          state = MemberExpLexState.inString\n          currentStringType = char\n        } else if (char === `[`) {\n          currentOpenBracketCount++\n        } else if (char === `]`) {\n          if (!--currentOpenBracketCount) {\n            state = stateStack.pop()!\n          }\n        }\n        break\n      case MemberExpLexState.inParens:\n        if (char === `'` || char === `\"` || char === '`') {\n          stateStack.push(state)\n          state = MemberExpLexState.inString\n          currentStringType = char\n        } else if (char === `(`) {\n          currentOpenParensCount++\n        } else if (char === `)`) {\n          // if the exp ends as a call then it should not be considered valid\n          if (i === path.length - 1) {\n            return false\n          }\n          if (!--currentOpenParensCount) {\n            state = stateStack.pop()!\n          }\n        }\n        break\n      case MemberExpLexState.inString:\n        if (char === currentStringType) {\n          state = stateStack.pop()!\n          currentStringType = null\n        }\n        break\n    }\n  }\n  return !currentOpenBracketCount && !currentOpenParensCount\n}\n\nexport const isMemberExpressionNode = __BROWSER__\n  ? (NOOP as any as (path: string, context: TransformContext) => boolean)\n  : (path: string, context: TransformContext): boolean => {\n      try {\n        let ret: Expression = parseExpression(path, {\n          plugins: context.expressionPlugins\n        })\n        if (ret.type === 'TSAsExpression' || ret.type === 'TSTypeAssertion') {\n          ret = ret.expression\n        }\n        return (\n          ret.type === 'MemberExpression' ||\n          ret.type === 'OptionalMemberExpression' ||\n          ret.type === 'Identifier'\n        )\n      } catch (e) {\n        return false\n      }\n    }\n\nexport const isMemberExpression = __BROWSER__\n  ? isMemberExpressionBrowser\n  : isMemberExpressionNode\n\nexport function getInnerRange(\n  loc: SourceLocation,\n  offset: number,\n  length: number\n): SourceLocation {\n  __TEST__ && assert(offset <= loc.source.length)\n  const source = loc.source.slice(offset, offset + length)\n  const newLoc: SourceLocation = {\n    source,\n    start: advancePositionWithClone(loc.start, loc.source, offset),\n    end: loc.end\n  }\n\n  if (length != null) {\n    __TEST__ && assert(offset + length <= loc.source.length)\n    newLoc.end = advancePositionWithClone(\n      loc.start,\n      loc.source,\n      offset + length\n    )\n  }\n\n  return newLoc\n}\n\nexport function advancePositionWithClone(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  return advancePositionWithMutation(\n    extend({}, pos),\n    source,\n    numberOfCharacters\n  )\n}\n\n// advance by mutation without cloning (for performance reasons), since this\n// gets called a lot in the parser\nexport function advancePositionWithMutation(\n  pos: Position,\n  source: string,\n  numberOfCharacters: number = source.length\n): Position {\n  let linesCount = 0\n  let lastNewLinePos = -1\n  for (let i = 0; i < numberOfCharacters; i++) {\n    if (source.charCodeAt(i) === 10 /* newline char code */) {\n      linesCount++\n      lastNewLinePos = i\n    }\n  }\n\n  pos.offset += numberOfCharacters\n  pos.line += linesCount\n  pos.column =\n    lastNewLinePos === -1\n      ? pos.column + numberOfCharacters\n      : numberOfCharacters - lastNewLinePos\n\n  return pos\n}\n\nexport function assert(condition: boolean, msg?: string) {\n  /* istanbul ignore if */\n  if (!condition) {\n    throw new Error(msg || `unexpected compiler condition`)\n  }\n}\n\nexport function findDir(\n  node: ElementNode,\n  name: string | RegExp,\n  allowEmpty: boolean = false\n): DirectiveNode | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (\n      p.type === NodeTypes.DIRECTIVE &&\n      (allowEmpty || p.exp) &&\n      (isString(name) ? p.name === name : name.test(p.name))\n    ) {\n      return p\n    }\n  }\n}\n\nexport function findProp(\n  node: ElementNode,\n  name: string,\n  dynamicOnly: boolean = false,\n  allowEmpty: boolean = false\n): ElementNode['props'][0] | undefined {\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (p.type === NodeTypes.ATTRIBUTE) {\n      if (dynamicOnly) continue\n      if (p.name === name && (p.value || allowEmpty)) {\n        return p\n      }\n    } else if (\n      p.name === 'bind' &&\n      (p.exp || allowEmpty) &&\n      isStaticArgOf(p.arg, name)\n    ) {\n      return p\n    }\n  }\n}\n\nexport function isStaticArgOf(\n  arg: DirectiveNode['arg'],\n  name: string\n): boolean {\n  return !!(arg && isStaticExp(arg) && arg.content === name)\n}\n\nexport function hasDynamicKeyVBind(node: ElementNode): boolean {\n  return node.props.some(\n    p =>\n      p.type === NodeTypes.DIRECTIVE &&\n      p.name === 'bind' &&\n      (!p.arg || // v-bind=\"obj\"\n        p.arg.type !== NodeTypes.SIMPLE_EXPRESSION || // v-bind:[_ctx.foo]\n        !p.arg.isStatic) // v-bind:[foo]\n  )\n}\n\nexport function isText(\n  node: TemplateChildNode\n): node is TextNode | InterpolationNode {\n  return node.type === NodeTypes.INTERPOLATION || node.type === NodeTypes.TEXT\n}\n\nexport function isVSlot(p: ElementNode['props'][0]): p is DirectiveNode {\n  return p.type === NodeTypes.DIRECTIVE && p.name === 'slot'\n}\n\nexport function isTemplateNode(\n  node: RootNode | TemplateChildNode\n): node is TemplateNode {\n  return (\n    node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.TEMPLATE\n  )\n}\n\nexport function isSlotOutlet(\n  node: RootNode | TemplateChildNode\n): node is SlotOutletNode {\n  return node.type === NodeTypes.ELEMENT && node.tagType === ElementTypes.SLOT\n}\n\nexport function getVNodeHelper(ssr: boolean, isComponent: boolean) {\n  return ssr || isComponent ? CREATE_VNODE : CREATE_ELEMENT_VNODE\n}\n\nexport function getVNodeBlockHelper(ssr: boolean, isComponent: boolean) {\n  return ssr || isComponent ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK\n}\n\nconst propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS])\n\nfunction getUnnormalizedProps(\n  props: PropsExpression | '{}',\n  callPath: CallExpression[] = []\n): [PropsExpression | '{}', CallExpression[]] {\n  if (\n    props &&\n    !isString(props) &&\n    props.type === NodeTypes.JS_CALL_EXPRESSION\n  ) {\n    const callee = props.callee\n    if (!isString(callee) && propsHelperSet.has(callee)) {\n      return getUnnormalizedProps(\n        props.arguments[0] as PropsExpression,\n        callPath.concat(props)\n      )\n    }\n  }\n  return [props, callPath]\n}\nexport function injectProp(\n  node: VNodeCall | RenderSlotCall,\n  prop: Property,\n  context: TransformContext\n) {\n  let propsWithInjection: ObjectExpression | CallExpression | undefined\n  /**\n   * 1. mergeProps(...)\n   * 2. toHandlers(...)\n   * 3. normalizeProps(...)\n   * 4. normalizeProps(guardReactiveProps(...))\n   *\n   * we need to get the real props before normalization\n   */\n  let props =\n    node.type === NodeTypes.VNODE_CALL ? node.props : node.arguments[2]\n  let callPath: CallExpression[] = []\n  let parentCall: CallExpression | undefined\n  if (\n    props &&\n    !isString(props) &&\n    props.type === NodeTypes.JS_CALL_EXPRESSION\n  ) {\n    const ret = getUnnormalizedProps(props)\n    props = ret[0]\n    callPath = ret[1]\n    parentCall = callPath[callPath.length - 1]\n  }\n\n  if (props == null || isString(props)) {\n    propsWithInjection = createObjectExpression([prop])\n  } else if (props.type === NodeTypes.JS_CALL_EXPRESSION) {\n    // merged props... add ours\n    // only inject key to object literal if it's the first argument so that\n    // if doesn't override user provided keys\n    const first = props.arguments[0] as string | JSChildNode\n    if (!isString(first) && first.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n      first.properties.unshift(prop)\n    } else {\n      if (props.callee === TO_HANDLERS) {\n        // #2366\n        propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n          createObjectExpression([prop]),\n          props\n        ])\n      } else {\n        props.arguments.unshift(createObjectExpression([prop]))\n      }\n    }\n    !propsWithInjection && (propsWithInjection = props)\n  } else if (props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n    let alreadyExists = false\n    // check existing key to avoid overriding user provided keys\n    if (prop.key.type === NodeTypes.SIMPLE_EXPRESSION) {\n      const propKeyName = prop.key.content\n      alreadyExists = props.properties.some(\n        p =>\n          p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\n          p.key.content === propKeyName\n      )\n    }\n    if (!alreadyExists) {\n      props.properties.unshift(prop)\n    }\n    propsWithInjection = props\n  } else {\n    // single v-bind with expression, return a merged replacement\n    propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [\n      createObjectExpression([prop]),\n      props\n    ])\n    // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,\n    // it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,\n    // the `guardReactiveProps` will no longer be needed\n    if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {\n      parentCall = callPath[callPath.length - 2]\n    }\n  }\n  if (node.type === NodeTypes.VNODE_CALL) {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection\n    } else {\n      node.props = propsWithInjection\n    }\n  } else {\n    if (parentCall) {\n      parentCall.arguments[0] = propsWithInjection\n    } else {\n      node.arguments[2] = propsWithInjection\n    }\n  }\n}\n\nexport function toValidAssetId(\n  name: string,\n  type: 'component' | 'directive' | 'filter'\n): string {\n  // see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character\n  return `_${type}_${name.replace(/[^\\w]/g, (searchValue, replaceValue) => {\n    return searchValue === '-' ? '_' : name.charCodeAt(replaceValue).toString()\n  })}`\n}\n\n// Check if a node contains expressions that reference current context scope ids\nexport function hasScopeRef(\n  node: TemplateChildNode | IfBranchNode | ExpressionNode | undefined,\n  ids: TransformContext['identifiers']\n): boolean {\n  if (!node || Object.keys(ids).length === 0) {\n    return false\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      for (let i = 0; i < node.props.length; i++) {\n        const p = node.props[i]\n        if (\n          p.type === NodeTypes.DIRECTIVE &&\n          (hasScopeRef(p.arg, ids) || hasScopeRef(p.exp, ids))\n        ) {\n          return true\n        }\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.FOR:\n      if (hasScopeRef(node.source, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.IF:\n      return node.branches.some(b => hasScopeRef(b, ids))\n    case NodeTypes.IF_BRANCH:\n      if (hasScopeRef(node.condition, ids)) {\n        return true\n      }\n      return node.children.some(c => hasScopeRef(c, ids))\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return (\n        !node.isStatic &&\n        isSimpleIdentifier(node.content) &&\n        !!ids[node.content]\n      )\n    case NodeTypes.COMPOUND_EXPRESSION:\n      return node.children.some(c => isObject(c) && hasScopeRef(c, ids))\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return hasScopeRef(node.content, ids)\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return false\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return false\n  }\n}\n\nexport function getMemoedVNodeCall(node: BlockCodegenNode | MemoExpression) {\n  if (node.type === NodeTypes.JS_CALL_EXPRESSION && node.callee === WITH_MEMO) {\n    return node.arguments[1].returns as VNodeCall\n  } else {\n    return node\n  }\n}\n\nexport function makeBlock(\n  node: VNodeCall,\n  { helper, removeHelper, inSSR }: TransformContext\n) {\n  if (!node.isBlock) {\n    node.isBlock = true\n    removeHelper(getVNodeHelper(inSSR, node.isComponent))\n    helper(OPEN_BLOCK)\n    helper(getVNodeBlockHelper(inSSR, node.isComponent))\n  }\n}\n", "import { SourceLocation } from '../ast'\nimport { CompilerError } from '../errors'\nimport { ParserContext } from '../parse'\nimport { TransformContext } from '../transform'\n\nexport type CompilerCompatConfig = Partial<\n  Record<CompilerDeprecationTypes, boolean | 'suppress-warning'>\n> & {\n  MODE?: 2 | 3\n}\n\nexport interface CompilerCompatOptions {\n  compatConfig?: CompilerCompatConfig\n}\n\nexport const enum CompilerDeprecationTypes {\n  COMPILER_IS_ON_ELEMENT = 'COMPILER_IS_ON_ELEMENT',\n  COMPILER_V_BIND_SYNC = 'COMPILER_V_BIND_SYNC',\n  COMPILER_V_BIND_PROP = 'COMPILER_V_BIND_PROP',\n  COMPILER_V_BIND_OBJECT_ORDER = 'COMPILER_V_BIND_OBJECT_ORDER',\n  COMPILER_V_ON_NATIVE = 'COMPILER_V_ON_NATIVE',\n  COMPILER_V_IF_V_FOR_PRECEDENCE = 'COMPILER_V_IF_V_FOR_PRECEDENCE',\n  COMPILER_NATIVE_TEMPLATE = 'COMPILER_NATIVE_TEMPLATE',\n  COMPILER_INLINE_TEMPLATE = 'COMPILER_INLINE_TEMPLATE',\n  COMPILER_FILTERS = 'COMPILER_FILTER'\n}\n\ntype DeprecationData = {\n  message: string | ((...args: any[]) => string)\n  link?: string\n}\n\nconst deprecationData: Record<CompilerDeprecationTypes, DeprecationData> = {\n  [CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT]: {\n    message:\n      `Platform-native elements with \"is\" prop will no longer be ` +\n      `treated as components in Vue 3 unless the \"is\" value is explicitly ` +\n      `prefixed with \"vue:\".`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_BIND_SYNC]: {\n    message: key =>\n      `.sync modifier for v-bind has been removed. Use v-model with ` +\n      `argument instead. \\`v-bind:${key}.sync\\` should be changed to ` +\n      `\\`v-model:${key}\\`.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-model.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_BIND_PROP]: {\n    message:\n      `.prop modifier for v-bind has been removed and no longer necessary. ` +\n      `Vue 3 will automatically set a binding as DOM property when appropriate.`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER]: {\n    message:\n      `v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript ` +\n      `object spread: it will now overwrite an existing non-mergeable attribute ` +\n      `that appears before v-bind in the case of conflict. ` +\n      `To retain 2.x behavior, move v-bind to make it the first attribute. ` +\n      `You can also suppress this warning if the usage is intended.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-bind.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_ON_NATIVE]: {\n    message: `.native modifier for v-on has been removed as is no longer necessary.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE]: {\n    message:\n      `v-if / v-for precedence when used on the same element has changed ` +\n      `in Vue 3: v-if now takes higher precedence and will no longer have ` +\n      `access to v-for scope variables. It is best to avoid the ambiguity ` +\n      `with <template> tags or use a computed property that filters v-for ` +\n      `data source.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE]: {\n    message:\n      `<template> with no special directives will render as a native template ` +\n      `element instead of its inner content in Vue 3.`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE]: {\n    message: `\"inline-template\" has been removed in Vue 3.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html`\n  },\n\n  [CompilerDeprecationTypes.COMPILER_FILTERS]: {\n    message:\n      `filters have been removed in Vue 3. ` +\n      `The \"|\" symbol will be treated as native JavaScript bitwise OR operator. ` +\n      `Use method calls or computed properties instead.`,\n    link: `https://v3-migration.vuejs.org/breaking-changes/filters.html`\n  }\n}\n\nfunction getCompatValue(\n  key: CompilerDeprecationTypes | 'MODE',\n  context: ParserContext | TransformContext\n) {\n  const config = (context as ParserContext).options\n    ? (context as ParserContext).options.compatConfig\n    : (context as TransformContext).compatConfig\n  const value = config && config[key]\n  if (key === 'MODE') {\n    return value || 3 // compiler defaults to v3 behavior\n  } else {\n    return value\n  }\n}\n\nexport function isCompatEnabled(\n  key: CompilerDeprecationTypes,\n  context: ParserContext | TransformContext\n) {\n  const mode = getCompatValue('MODE', context)\n  const value = getCompatValue(key, context)\n  // in v3 mode, only enable if explicitly set to true\n  // otherwise enable for any non-false value\n  return mode === 3 ? value === true : value !== false\n}\n\nexport function checkCompatEnabled(\n  key: CompilerDeprecationTypes,\n  context: ParserContext | TransformContext,\n  loc: SourceLocation | null,\n  ...args: any[]\n): boolean {\n  const enabled = isCompatEnabled(key, context)\n  if (__DEV__ && enabled) {\n    warnDeprecation(key, context, loc, ...args)\n  }\n  return enabled\n}\n\nexport function warnDeprecation(\n  key: CompilerDeprecationTypes,\n  context: ParserContext | TransformContext,\n  loc: SourceLocation | null,\n  ...args: any[]\n) {\n  const val = getCompatValue(key, context)\n  if (val === 'suppress-warning') {\n    return\n  }\n  const { message, link } = deprecationData[key]\n  const msg = `(deprecation ${key}) ${\n    typeof message === 'function' ? message(...args) : message\n  }${link ? `\\n  Details: ${link}` : ``}`\n\n  const err = new SyntaxError(msg) as CompilerError\n  err.code = key\n  if (loc) err.loc = loc\n  context.onWarn(err)\n}\n", "import { ErrorHandlingOptions, ParserOptions } from './options'\nimport { NO, isArray, makeMap, extend } from '@vue/shared'\nimport {\n  ErrorCodes,\n  createCompilerError,\n  defaultOnError,\n  defaultOnWarn\n} from './errors'\nimport {\n  assert,\n  advancePositionWithMutation,\n  advancePositionWithClone,\n  isCoreComponent,\n  isStaticArgOf\n} from './utils'\nimport {\n  Namespaces,\n  AttributeNode,\n  CommentNode,\n  DirectiveNode,\n  ElementNode,\n  ElementTypes,\n  ExpressionNode,\n  NodeTypes,\n  Position,\n  RootNode,\n  SourceLocation,\n  TextNode,\n  TemplateChildNode,\n  InterpolationNode,\n  createRoot,\n  ConstantTypes\n} from './ast'\nimport {\n  checkCompatEnabled,\n  CompilerCompatOptions,\n  CompilerDeprecationTypes,\n  isCompatEnabled,\n  warnDeprecation\n} from './compat/compatConfig'\n\ntype OptionalOptions =\n  | 'whitespace'\n  | 'isNativeTag'\n  | 'isBuiltInComponent'\n  | keyof CompilerCompatOptions\ntype MergedParserOptions = Omit<Required<ParserOptions>, OptionalOptions> &\n  Pick<ParserOptions, OptionalOptions>\ntype AttributeValue =\n  | {\n      content: string\n      isQuoted: boolean\n      loc: SourceLocation\n    }\n  | undefined\n\n// The default decoder only provides escapes for characters reserved as part of\n// the template syntax, and is only used if the custom renderer did not provide\n// a platform-specific decoder.\nconst decodeRE = /&(gt|lt|amp|apos|quot);/g\nconst decodeMap: Record<string, string> = {\n  gt: '>',\n  lt: '<',\n  amp: '&',\n  apos: \"'\",\n  quot: '\"'\n}\n\nexport const defaultParserOptions: MergedParserOptions = {\n  delimiters: [`{{`, `}}`],\n  getNamespace: () => Namespaces.HTML,\n  getTextMode: () => TextModes.DATA,\n  isVoidTag: NO,\n  isPreTag: NO,\n  isCustomElement: NO,\n  decodeEntities: (rawText: string): string =>\n    rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),\n  onError: defaultOnError,\n  onWarn: defaultOnWarn,\n  comments: __DEV__\n}\n\nexport const enum TextModes {\n  //          | Elements | Entities | End sign              | Inside of\n  DATA, //    | \u2714        | \u2714        | End tags of ancestors |\n  RCDATA, //  | \u2718        | \u2714        | End tag of the parent | <textarea>\n  RAWTEXT, // | \u2718        | \u2718        | End tag of the parent | <style>,<script>\n  CDATA,\n  ATTRIBUTE_VALUE\n}\n\nexport interface ParserContext {\n  options: MergedParserOptions\n  readonly originalSource: string\n  source: string\n  offset: number\n  line: number\n  column: number\n  inPre: boolean // HTML <pre> tag, preserve whitespaces\n  inVPre: boolean // v-pre, do not process directives and interpolations\n  onWarn: NonNullable<ErrorHandlingOptions['onWarn']>\n}\n\nexport function baseParse(\n  content: string,\n  options: ParserOptions = {}\n): RootNode {\n  const context = createParserContext(content, options)\n  const start = getCursor(context)\n  return createRoot(\n    parseChildren(context, TextModes.DATA, []),\n    getSelection(context, start)\n  )\n}\n\nfunction createParserContext(\n  content: string,\n  rawOptions: ParserOptions\n): ParserContext {\n  const options = extend({}, defaultParserOptions)\n\n  let key: keyof ParserOptions\n  for (key in rawOptions) {\n    // @ts-ignore\n    options[key] =\n      rawOptions[key] === undefined\n        ? defaultParserOptions[key]\n        : rawOptions[key]\n  }\n  return {\n    options,\n    column: 1,\n    line: 1,\n    offset: 0,\n    originalSource: content,\n    source: content,\n    inPre: false,\n    inVPre: false,\n    onWarn: options.onWarn\n  }\n}\n\nfunction parseChildren(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  const parent = last(ancestors)\n  const ns = parent ? parent.ns : Namespaces.HTML\n  const nodes: TemplateChildNode[] = []\n\n  while (!isEnd(context, mode, ancestors)) {\n    __TEST__ && assert(context.source.length > 0)\n    const s = context.source\n    let node: TemplateChildNode | TemplateChildNode[] | undefined = undefined\n\n    if (mode === TextModes.DATA || mode === TextModes.RCDATA) {\n      if (!context.inVPre && startsWith(s, context.options.delimiters[0])) {\n        // '{{'\n        node = parseInterpolation(context, mode)\n      } else if (mode === TextModes.DATA && s[0] === '<') {\n        // https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state\n        if (s.length === 1) {\n          emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 1)\n        } else if (s[1] === '!') {\n          // https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state\n          if (startsWith(s, '<!--')) {\n            node = parseComment(context)\n          } else if (startsWith(s, '<!DOCTYPE')) {\n            // Ignore DOCTYPE by a limitation.\n            node = parseBogusComment(context)\n          } else if (startsWith(s, '<![CDATA[')) {\n            if (ns !== Namespaces.HTML) {\n              node = parseCDATA(context, ancestors)\n            } else {\n              emitError(context, ErrorCodes.CDATA_IN_HTML_CONTENT)\n              node = parseBogusComment(context)\n            }\n          } else {\n            emitError(context, ErrorCodes.INCORRECTLY_OPENED_COMMENT)\n            node = parseBogusComment(context)\n          }\n        } else if (s[1] === '/') {\n          // https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state\n          if (s.length === 2) {\n            emitError(context, ErrorCodes.EOF_BEFORE_TAG_NAME, 2)\n          } else if (s[2] === '>') {\n            emitError(context, ErrorCodes.MISSING_END_TAG_NAME, 2)\n            advanceBy(context, 3)\n            continue\n          } else if (/[a-z]/i.test(s[2])) {\n            emitError(context, ErrorCodes.X_INVALID_END_TAG)\n            parseTag(context, TagType.End, parent)\n            continue\n          } else {\n            emitError(\n              context,\n              ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME,\n              2\n            )\n            node = parseBogusComment(context)\n          }\n        } else if (/[a-z]/i.test(s[1])) {\n          node = parseElement(context, ancestors)\n\n          // 2.x <template> with no directive compat\n          if (\n            __COMPAT__ &&\n            isCompatEnabled(\n              CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\n              context\n            ) &&\n            node &&\n            node.tag === 'template' &&\n            !node.props.some(\n              p =>\n                p.type === NodeTypes.DIRECTIVE &&\n                isSpecialTemplateDirective(p.name)\n            )\n          ) {\n            __DEV__ &&\n              warnDeprecation(\n                CompilerDeprecationTypes.COMPILER_NATIVE_TEMPLATE,\n                context,\n                node.loc\n              )\n            node = node.children\n          }\n        } else if (s[1] === '?') {\n          emitError(\n            context,\n            ErrorCodes.UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME,\n            1\n          )\n          node = parseBogusComment(context)\n        } else {\n          emitError(context, ErrorCodes.INVALID_FIRST_CHARACTER_OF_TAG_NAME, 1)\n        }\n      }\n    }\n    if (!node) {\n      node = parseText(context, mode)\n    }\n\n    if (isArray(node)) {\n      for (let i = 0; i < node.length; i++) {\n        pushNode(nodes, node[i])\n      }\n    } else {\n      pushNode(nodes, node)\n    }\n  }\n\n  // Whitespace handling strategy like v2\n  let removedWhitespace = false\n  if (mode !== TextModes.RAWTEXT && mode !== TextModes.RCDATA) {\n    const shouldCondense = context.options.whitespace !== 'preserve'\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i]\n      if (!context.inPre && node.type === NodeTypes.TEXT) {\n        if (!/[^\\t\\r\\n\\f ]/.test(node.content)) {\n          const prev = nodes[i - 1]\n          const next = nodes[i + 1]\n          // Remove if:\n          // - the whitespace is the first or last node, or:\n          // - (condense mode) the whitespace is adjacent to a comment, or:\n          // - (condense mode) the whitespace is between two elements AND contains newline\n          if (\n            !prev ||\n            !next ||\n            (shouldCondense &&\n              (prev.type === NodeTypes.COMMENT ||\n                next.type === NodeTypes.COMMENT ||\n                (prev.type === NodeTypes.ELEMENT &&\n                  next.type === NodeTypes.ELEMENT &&\n                  /[\\r\\n]/.test(node.content))))\n          ) {\n            removedWhitespace = true\n            nodes[i] = null as any\n          } else {\n            // Otherwise, the whitespace is condensed into a single space\n            node.content = ' '\n          }\n        } else if (shouldCondense) {\n          // in condense mode, consecutive whitespaces in text are condensed\n          // down to a single space.\n          node.content = node.content.replace(/[\\t\\r\\n\\f ]+/g, ' ')\n        }\n      }\n      // Remove comment nodes if desired by configuration.\n      else if (node.type === NodeTypes.COMMENT && !context.options.comments) {\n        removedWhitespace = true\n        nodes[i] = null as any\n      }\n    }\n    if (context.inPre && parent && context.options.isPreTag(parent.tag)) {\n      // remove leading newline per html spec\n      // https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element\n      const first = nodes[0]\n      if (first && first.type === NodeTypes.TEXT) {\n        first.content = first.content.replace(/^\\r?\\n/, '')\n      }\n    }\n  }\n\n  return removedWhitespace ? nodes.filter(Boolean) : nodes\n}\n\nfunction pushNode(nodes: TemplateChildNode[], node: TemplateChildNode): void {\n  if (node.type === NodeTypes.TEXT) {\n    const prev = last(nodes)\n    // Merge if both this and the previous node are text and those are\n    // consecutive. This happens for cases like \"a < b\".\n    if (\n      prev &&\n      prev.type === NodeTypes.TEXT &&\n      prev.loc.end.offset === node.loc.start.offset\n    ) {\n      prev.content += node.content\n      prev.loc.end = node.loc.end\n      prev.loc.source += node.loc.source\n      return\n    }\n  }\n\n  nodes.push(node)\n}\n\nfunction parseCDATA(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): TemplateChildNode[] {\n  __TEST__ &&\n    assert(last(ancestors) == null || last(ancestors)!.ns !== Namespaces.HTML)\n  __TEST__ && assert(startsWith(context.source, '<![CDATA['))\n\n  advanceBy(context, 9)\n  const nodes = parseChildren(context, TextModes.CDATA, ancestors)\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_CDATA)\n  } else {\n    __TEST__ && assert(startsWith(context.source, ']]>'))\n    advanceBy(context, 3)\n  }\n\n  return nodes\n}\n\nfunction parseComment(context: ParserContext): CommentNode {\n  __TEST__ && assert(startsWith(context.source, '<!--'))\n\n  const start = getCursor(context)\n  let content: string\n\n  // Regular comment.\n  const match = /--(\\!)?>/.exec(context.source)\n  if (!match) {\n    content = context.source.slice(4)\n    advanceBy(context, context.source.length)\n    emitError(context, ErrorCodes.EOF_IN_COMMENT)\n  } else {\n    if (match.index <= 3) {\n      emitError(context, ErrorCodes.ABRUPT_CLOSING_OF_EMPTY_COMMENT)\n    }\n    if (match[1]) {\n      emitError(context, ErrorCodes.INCORRECTLY_CLOSED_COMMENT)\n    }\n    content = context.source.slice(4, match.index)\n\n    // Advancing with reporting nested comments.\n    const s = context.source.slice(0, match.index)\n    let prevIndex = 1,\n      nestedIndex = 0\n    while ((nestedIndex = s.indexOf('<!--', prevIndex)) !== -1) {\n      advanceBy(context, nestedIndex - prevIndex + 1)\n      if (nestedIndex + 4 < s.length) {\n        emitError(context, ErrorCodes.NESTED_COMMENT)\n      }\n      prevIndex = nestedIndex + 1\n    }\n    advanceBy(context, match.index + match[0].length - prevIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseBogusComment(context: ParserContext): CommentNode | undefined {\n  __TEST__ && assert(/^<(?:[\\!\\?]|\\/[^a-z>])/i.test(context.source))\n\n  const start = getCursor(context)\n  const contentStart = context.source[1] === '?' ? 1 : 2\n  let content: string\n\n  const closeIndex = context.source.indexOf('>')\n  if (closeIndex === -1) {\n    content = context.source.slice(contentStart)\n    advanceBy(context, context.source.length)\n  } else {\n    content = context.source.slice(contentStart, closeIndex)\n    advanceBy(context, closeIndex + 1)\n  }\n\n  return {\n    type: NodeTypes.COMMENT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseElement(\n  context: ParserContext,\n  ancestors: ElementNode[]\n): ElementNode | undefined {\n  __TEST__ && assert(/^<[a-z]/i.test(context.source))\n\n  // Start tag.\n  const wasInPre = context.inPre\n  const wasInVPre = context.inVPre\n  const parent = last(ancestors)\n  const element = parseTag(context, TagType.Start, parent)\n  const isPreBoundary = context.inPre && !wasInPre\n  const isVPreBoundary = context.inVPre && !wasInVPre\n\n  if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {\n    // #4030 self-closing <pre> tag\n    if (isPreBoundary) {\n      context.inPre = false\n    }\n    if (isVPreBoundary) {\n      context.inVPre = false\n    }\n    return element\n  }\n\n  // Children.\n  ancestors.push(element)\n  const mode = context.options.getTextMode(element, parent)\n  const children = parseChildren(context, mode, ancestors)\n  ancestors.pop()\n\n  // 2.x inline-template compat\n  if (__COMPAT__) {\n    const inlineTemplateProp = element.props.find(\n      p => p.type === NodeTypes.ATTRIBUTE && p.name === 'inline-template'\n    ) as AttributeNode\n    if (\n      inlineTemplateProp &&\n      checkCompatEnabled(\n        CompilerDeprecationTypes.COMPILER_INLINE_TEMPLATE,\n        context,\n        inlineTemplateProp.loc\n      )\n    ) {\n      const loc = getSelection(context, element.loc.end)\n      inlineTemplateProp.value = {\n        type: NodeTypes.TEXT,\n        content: loc.source,\n        loc\n      }\n    }\n  }\n\n  element.children = children\n\n  // End tag.\n  if (startsWithEndTagOpen(context.source, element.tag)) {\n    parseTag(context, TagType.End, parent)\n  } else {\n    emitError(context, ErrorCodes.X_MISSING_END_TAG, 0, element.loc.start)\n    if (context.source.length === 0 && element.tag.toLowerCase() === 'script') {\n      const first = children[0]\n      if (first && startsWith(first.loc.source, '<!--')) {\n        emitError(context, ErrorCodes.EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT)\n      }\n    }\n  }\n\n  element.loc = getSelection(context, element.loc.start)\n\n  if (isPreBoundary) {\n    context.inPre = false\n  }\n  if (isVPreBoundary) {\n    context.inVPre = false\n  }\n  return element\n}\n\nconst enum TagType {\n  Start,\n  End\n}\n\nconst isSpecialTemplateDirective = /*#__PURE__*/ makeMap(\n  `if,else,else-if,for,slot`\n)\n\n/**\n * Parse a tag (E.g. `<div id=a>`) with that type (start tag or end tag).\n */\nfunction parseTag(\n  context: ParserContext,\n  type: TagType.Start,\n  parent: ElementNode | undefined\n): ElementNode\nfunction parseTag(\n  context: ParserContext,\n  type: TagType.End,\n  parent: ElementNode | undefined\n): void\nfunction parseTag(\n  context: ParserContext,\n  type: TagType,\n  parent: ElementNode | undefined\n): ElementNode | undefined {\n  __TEST__ && assert(/^<\\/?[a-z]/i.test(context.source))\n  __TEST__ &&\n    assert(\n      type === (startsWith(context.source, '</') ? TagType.End : TagType.Start)\n    )\n\n  // Tag open.\n  const start = getCursor(context)\n  const match = /^<\\/?([a-z][^\\t\\r\\n\\f />]*)/i.exec(context.source)!\n  const tag = match[1]\n  const ns = context.options.getNamespace(tag, parent)\n\n  advanceBy(context, match[0].length)\n  advanceSpaces(context)\n\n  // save current state in case we need to re-parse attributes with v-pre\n  const cursor = getCursor(context)\n  const currentSource = context.source\n\n  // check <pre> tag\n  if (context.options.isPreTag(tag)) {\n    context.inPre = true\n  }\n\n  // Attributes.\n  let props = parseAttributes(context, type)\n\n  // check v-pre\n  if (\n    type === TagType.Start &&\n    !context.inVPre &&\n    props.some(p => p.type === NodeTypes.DIRECTIVE && p.name === 'pre')\n  ) {\n    context.inVPre = true\n    // reset context\n    extend(context, cursor)\n    context.source = currentSource\n    // re-parse attrs and filter out v-pre itself\n    props = parseAttributes(context, type).filter(p => p.name !== 'v-pre')\n  }\n\n  // Tag close.\n  let isSelfClosing = false\n  if (context.source.length === 0) {\n    emitError(context, ErrorCodes.EOF_IN_TAG)\n  } else {\n    isSelfClosing = startsWith(context.source, '/>')\n    if (type === TagType.End && isSelfClosing) {\n      emitError(context, ErrorCodes.END_TAG_WITH_TRAILING_SOLIDUS)\n    }\n    advanceBy(context, isSelfClosing ? 2 : 1)\n  }\n\n  if (type === TagType.End) {\n    return\n  }\n\n  // 2.x deprecation checks\n  if (\n    __COMPAT__ &&\n    __DEV__ &&\n    isCompatEnabled(\n      CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\n      context\n    )\n  ) {\n    let hasIf = false\n    let hasFor = false\n    for (let i = 0; i < props.length; i++) {\n      const p = props[i]\n      if (p.type === NodeTypes.DIRECTIVE) {\n        if (p.name === 'if') {\n          hasIf = true\n        } else if (p.name === 'for') {\n          hasFor = true\n        }\n      }\n      if (hasIf && hasFor) {\n        warnDeprecation(\n          CompilerDeprecationTypes.COMPILER_V_IF_V_FOR_PRECEDENCE,\n          context,\n          getSelection(context, start)\n        )\n        break\n      }\n    }\n  }\n\n  let tagType = ElementTypes.ELEMENT\n  if (!context.inVPre) {\n    if (tag === 'slot') {\n      tagType = ElementTypes.SLOT\n    } else if (tag === 'template') {\n      if (\n        props.some(\n          p =>\n            p.type === NodeTypes.DIRECTIVE && isSpecialTemplateDirective(p.name)\n        )\n      ) {\n        tagType = ElementTypes.TEMPLATE\n      }\n    } else if (isComponent(tag, props, context)) {\n      tagType = ElementTypes.COMPONENT\n    }\n  }\n\n  return {\n    type: NodeTypes.ELEMENT,\n    ns,\n    tag,\n    tagType,\n    props,\n    isSelfClosing,\n    children: [],\n    loc: getSelection(context, start),\n    codegenNode: undefined // to be created during transform phase\n  }\n}\n\nfunction isComponent(\n  tag: string,\n  props: (AttributeNode | DirectiveNode)[],\n  context: ParserContext\n) {\n  const options = context.options\n  if (options.isCustomElement(tag)) {\n    return false\n  }\n  if (\n    tag === 'component' ||\n    /^[A-Z]/.test(tag) ||\n    isCoreComponent(tag) ||\n    (options.isBuiltInComponent && options.isBuiltInComponent(tag)) ||\n    (options.isNativeTag && !options.isNativeTag(tag))\n  ) {\n    return true\n  }\n  // at this point the tag should be a native tag, but check for potential \"is\"\n  // casting\n  for (let i = 0; i < props.length; i++) {\n    const p = props[i]\n    if (p.type === NodeTypes.ATTRIBUTE) {\n      if (p.name === 'is' && p.value) {\n        if (p.value.content.startsWith('vue:')) {\n          return true\n        } else if (\n          __COMPAT__ &&\n          checkCompatEnabled(\n            CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n            context,\n            p.loc\n          )\n        ) {\n          return true\n        }\n      }\n    } else {\n      // directive\n      // v-is (TODO Deprecate)\n      if (p.name === 'is') {\n        return true\n      } else if (\n        // :is on plain element - only treat as component in compat mode\n        p.name === 'bind' &&\n        isStaticArgOf(p.arg, 'is') &&\n        __COMPAT__ &&\n        checkCompatEnabled(\n          CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n          context,\n          p.loc\n        )\n      ) {\n        return true\n      }\n    }\n  }\n}\n\nfunction parseAttributes(\n  context: ParserContext,\n  type: TagType\n): (AttributeNode | DirectiveNode)[] {\n  const props = []\n  const attributeNames = new Set<string>()\n  while (\n    context.source.length > 0 &&\n    !startsWith(context.source, '>') &&\n    !startsWith(context.source, '/>')\n  ) {\n    if (startsWith(context.source, '/')) {\n      emitError(context, ErrorCodes.UNEXPECTED_SOLIDUS_IN_TAG)\n      advanceBy(context, 1)\n      advanceSpaces(context)\n      continue\n    }\n    if (type === TagType.End) {\n      emitError(context, ErrorCodes.END_TAG_WITH_ATTRIBUTES)\n    }\n\n    const attr = parseAttribute(context, attributeNames)\n\n    // Trim whitespace between class\n    // https://github.com/vuejs/core/issues/4251\n    if (\n      attr.type === NodeTypes.ATTRIBUTE &&\n      attr.value &&\n      attr.name === 'class'\n    ) {\n      attr.value.content = attr.value.content.replace(/\\s+/g, ' ').trim()\n    }\n\n    if (type === TagType.Start) {\n      props.push(attr)\n    }\n\n    if (/^[^\\t\\r\\n\\f />]/.test(context.source)) {\n      emitError(context, ErrorCodes.MISSING_WHITESPACE_BETWEEN_ATTRIBUTES)\n    }\n    advanceSpaces(context)\n  }\n  return props\n}\n\nfunction parseAttribute(\n  context: ParserContext,\n  nameSet: Set<string>\n): AttributeNode | DirectiveNode {\n  __TEST__ && assert(/^[^\\t\\r\\n\\f />]/.test(context.source))\n\n  // Name.\n  const start = getCursor(context)\n  const match = /^[^\\t\\r\\n\\f />][^\\t\\r\\n\\f />=]*/.exec(context.source)!\n  const name = match[0]\n\n  if (nameSet.has(name)) {\n    emitError(context, ErrorCodes.DUPLICATE_ATTRIBUTE)\n  }\n  nameSet.add(name)\n\n  if (name[0] === '=') {\n    emitError(context, ErrorCodes.UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME)\n  }\n  {\n    const pattern = /[\"'<]/g\n    let m: RegExpExecArray | null\n    while ((m = pattern.exec(name))) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME,\n        m.index\n      )\n    }\n  }\n\n  advanceBy(context, name.length)\n\n  // Value\n  let value: AttributeValue = undefined\n\n  if (/^[\\t\\r\\n\\f ]*=/.test(context.source)) {\n    advanceSpaces(context)\n    advanceBy(context, 1)\n    advanceSpaces(context)\n    value = parseAttributeValue(context)\n    if (!value) {\n      emitError(context, ErrorCodes.MISSING_ATTRIBUTE_VALUE)\n    }\n  }\n  const loc = getSelection(context, start)\n\n  if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\\.|@|#)/.test(name)) {\n    const match =\n      /(?:^v-([a-z0-9-]+))?(?:(?::|^\\.|^@|^#)(\\[[^\\]]+\\]|[^\\.]+))?(.+)?$/i.exec(\n        name\n      )!\n\n    let isPropShorthand = startsWith(name, '.')\n    let dirName =\n      match[1] ||\n      (isPropShorthand || startsWith(name, ':')\n        ? 'bind'\n        : startsWith(name, '@')\n        ? 'on'\n        : 'slot')\n    let arg: ExpressionNode | undefined\n\n    if (match[2]) {\n      const isSlot = dirName === 'slot'\n      const startOffset = name.lastIndexOf(match[2])\n      const loc = getSelection(\n        context,\n        getNewPosition(context, start, startOffset),\n        getNewPosition(\n          context,\n          start,\n          startOffset + match[2].length + ((isSlot && match[3]) || '').length\n        )\n      )\n      let content = match[2]\n      let isStatic = true\n\n      if (content.startsWith('[')) {\n        isStatic = false\n\n        if (!content.endsWith(']')) {\n          emitError(\n            context,\n            ErrorCodes.X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END\n          )\n          content = content.slice(1)\n        } else {\n          content = content.slice(1, content.length - 1)\n        }\n      } else if (isSlot) {\n        // #1241 special case for v-slot: vuetify relies extensively on slot\n        // names containing dots. v-slot doesn't have any modifiers and Vue 2.x\n        // supports such usage so we are keeping it consistent with 2.x.\n        content += match[3] || ''\n      }\n\n      arg = {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content,\n        isStatic,\n        constType: isStatic\n          ? ConstantTypes.CAN_STRINGIFY\n          : ConstantTypes.NOT_CONSTANT,\n        loc\n      }\n    }\n\n    if (value && value.isQuoted) {\n      const valueLoc = value.loc\n      valueLoc.start.offset++\n      valueLoc.start.column++\n      valueLoc.end = advancePositionWithClone(valueLoc.start, value.content)\n      valueLoc.source = valueLoc.source.slice(1, -1)\n    }\n\n    const modifiers = match[3] ? match[3].slice(1).split('.') : []\n    if (isPropShorthand) modifiers.push('prop')\n\n    // 2.x compat v-bind:foo.sync -> v-model:foo\n    if (__COMPAT__ && dirName === 'bind' && arg) {\n      if (\n        modifiers.includes('sync') &&\n        checkCompatEnabled(\n          CompilerDeprecationTypes.COMPILER_V_BIND_SYNC,\n          context,\n          loc,\n          arg.loc.source\n        )\n      ) {\n        dirName = 'model'\n        modifiers.splice(modifiers.indexOf('sync'), 1)\n      }\n\n      if (__DEV__ && modifiers.includes('prop')) {\n        checkCompatEnabled(\n          CompilerDeprecationTypes.COMPILER_V_BIND_PROP,\n          context,\n          loc\n        )\n      }\n    }\n\n    return {\n      type: NodeTypes.DIRECTIVE,\n      name: dirName,\n      exp: value && {\n        type: NodeTypes.SIMPLE_EXPRESSION,\n        content: value.content,\n        isStatic: false,\n        // Treat as non-constant by default. This can be potentially set to\n        // other values by `transformExpression` to make it eligible for hoisting.\n        constType: ConstantTypes.NOT_CONSTANT,\n        loc: value.loc\n      },\n      arg,\n      modifiers,\n      loc\n    }\n  }\n\n  // missing directive name or illegal directive name\n  if (!context.inVPre && startsWith(name, 'v-')) {\n    emitError(context, ErrorCodes.X_MISSING_DIRECTIVE_NAME)\n  }\n\n  return {\n    type: NodeTypes.ATTRIBUTE,\n    name,\n    value: value && {\n      type: NodeTypes.TEXT,\n      content: value.content,\n      loc: value.loc\n    },\n    loc\n  }\n}\n\nfunction parseAttributeValue(context: ParserContext): AttributeValue {\n  const start = getCursor(context)\n  let content: string\n\n  const quote = context.source[0]\n  const isQuoted = quote === `\"` || quote === `'`\n  if (isQuoted) {\n    // Quoted value.\n    advanceBy(context, 1)\n\n    const endIndex = context.source.indexOf(quote)\n    if (endIndex === -1) {\n      content = parseTextData(\n        context,\n        context.source.length,\n        TextModes.ATTRIBUTE_VALUE\n      )\n    } else {\n      content = parseTextData(context, endIndex, TextModes.ATTRIBUTE_VALUE)\n      advanceBy(context, 1)\n    }\n  } else {\n    // Unquoted\n    const match = /^[^\\t\\r\\n\\f >]+/.exec(context.source)\n    if (!match) {\n      return undefined\n    }\n    const unexpectedChars = /[\"'<=`]/g\n    let m: RegExpExecArray | null\n    while ((m = unexpectedChars.exec(match[0]))) {\n      emitError(\n        context,\n        ErrorCodes.UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE,\n        m.index\n      )\n    }\n    content = parseTextData(context, match[0].length, TextModes.ATTRIBUTE_VALUE)\n  }\n\n  return { content, isQuoted, loc: getSelection(context, start) }\n}\n\nfunction parseInterpolation(\n  context: ParserContext,\n  mode: TextModes\n): InterpolationNode | undefined {\n  const [open, close] = context.options.delimiters\n  __TEST__ && assert(startsWith(context.source, open))\n\n  const closeIndex = context.source.indexOf(close, open.length)\n  if (closeIndex === -1) {\n    emitError(context, ErrorCodes.X_MISSING_INTERPOLATION_END)\n    return undefined\n  }\n\n  const start = getCursor(context)\n  advanceBy(context, open.length)\n  const innerStart = getCursor(context)\n  const innerEnd = getCursor(context)\n  const rawContentLength = closeIndex - open.length\n  const rawContent = context.source.slice(0, rawContentLength)\n  const preTrimContent = parseTextData(context, rawContentLength, mode)\n  const content = preTrimContent.trim()\n  const startOffset = preTrimContent.indexOf(content)\n  if (startOffset > 0) {\n    advancePositionWithMutation(innerStart, rawContent, startOffset)\n  }\n  const endOffset =\n    rawContentLength - (preTrimContent.length - content.length - startOffset)\n  advancePositionWithMutation(innerEnd, rawContent, endOffset)\n  advanceBy(context, close.length)\n\n  return {\n    type: NodeTypes.INTERPOLATION,\n    content: {\n      type: NodeTypes.SIMPLE_EXPRESSION,\n      isStatic: false,\n      // Set `isConstant` to false by default and will decide in transformExpression\n      constType: ConstantTypes.NOT_CONSTANT,\n      content,\n      loc: getSelection(context, innerStart, innerEnd)\n    },\n    loc: getSelection(context, start)\n  }\n}\n\nfunction parseText(context: ParserContext, mode: TextModes): TextNode {\n  __TEST__ && assert(context.source.length > 0)\n\n  const endTokens =\n    mode === TextModes.CDATA ? [']]>'] : ['<', context.options.delimiters[0]]\n\n  let endIndex = context.source.length\n  for (let i = 0; i < endTokens.length; i++) {\n    const index = context.source.indexOf(endTokens[i], 1)\n    if (index !== -1 && endIndex > index) {\n      endIndex = index\n    }\n  }\n\n  __TEST__ && assert(endIndex > 0)\n\n  const start = getCursor(context)\n  const content = parseTextData(context, endIndex, mode)\n\n  return {\n    type: NodeTypes.TEXT,\n    content,\n    loc: getSelection(context, start)\n  }\n}\n\n/**\n * Get text data with a given length from the current location.\n * This translates HTML entities in the text data.\n */\nfunction parseTextData(\n  context: ParserContext,\n  length: number,\n  mode: TextModes\n): string {\n  const rawText = context.source.slice(0, length)\n  advanceBy(context, length)\n  if (\n    mode === TextModes.RAWTEXT ||\n    mode === TextModes.CDATA ||\n    !rawText.includes('&')\n  ) {\n    return rawText\n  } else {\n    // DATA or RCDATA containing \"&\"\". Entity decoding required.\n    return context.options.decodeEntities(\n      rawText,\n      mode === TextModes.ATTRIBUTE_VALUE\n    )\n  }\n}\n\nfunction getCursor(context: ParserContext): Position {\n  const { column, line, offset } = context\n  return { column, line, offset }\n}\n\nfunction getSelection(\n  context: ParserContext,\n  start: Position,\n  end?: Position\n): SourceLocation {\n  end = end || getCursor(context)\n  return {\n    start,\n    end,\n    source: context.originalSource.slice(start.offset, end.offset)\n  }\n}\n\nfunction last<T>(xs: T[]): T | undefined {\n  return xs[xs.length - 1]\n}\n\nfunction startsWith(source: string, searchString: string): boolean {\n  return source.startsWith(searchString)\n}\n\nfunction advanceBy(context: ParserContext, numberOfCharacters: number): void {\n  const { source } = context\n  __TEST__ && assert(numberOfCharacters <= source.length)\n  advancePositionWithMutation(context, source, numberOfCharacters)\n  context.source = source.slice(numberOfCharacters)\n}\n\nfunction advanceSpaces(context: ParserContext): void {\n  const match = /^[\\t\\r\\n\\f ]+/.exec(context.source)\n  if (match) {\n    advanceBy(context, match[0].length)\n  }\n}\n\nfunction getNewPosition(\n  context: ParserContext,\n  start: Position,\n  numberOfCharacters: number\n): Position {\n  return advancePositionWithClone(\n    start,\n    context.originalSource.slice(start.offset, numberOfCharacters),\n    numberOfCharacters\n  )\n}\n\nfunction emitError(\n  context: ParserContext,\n  code: ErrorCodes,\n  offset?: number,\n  loc: Position = getCursor(context)\n): void {\n  if (offset) {\n    loc.offset += offset\n    loc.column += offset\n  }\n  context.options.onError(\n    createCompilerError(code, {\n      start: loc,\n      end: loc,\n      source: ''\n    })\n  )\n}\n\nfunction isEnd(\n  context: ParserContext,\n  mode: TextModes,\n  ancestors: ElementNode[]\n): boolean {\n  const s = context.source\n\n  switch (mode) {\n    case TextModes.DATA:\n      if (startsWith(s, '</')) {\n        // TODO: probably bad performance\n        for (let i = ancestors.length - 1; i >= 0; --i) {\n          if (startsWithEndTagOpen(s, ancestors[i].tag)) {\n            return true\n          }\n        }\n      }\n      break\n\n    case TextModes.RCDATA:\n    case TextModes.RAWTEXT: {\n      const parent = last(ancestors)\n      if (parent && startsWithEndTagOpen(s, parent.tag)) {\n        return true\n      }\n      break\n    }\n\n    case TextModes.CDATA:\n      if (startsWith(s, ']]>')) {\n        return true\n      }\n      break\n  }\n\n  return !s\n}\n\nfunction startsWithEndTagOpen(source: string, tag: string): boolean {\n  return (\n    startsWith(source, '</') &&\n    source.slice(2, 2 + tag.length).toLowerCase() === tag.toLowerCase() &&\n    /[\\t\\r\\n\\f />]/.test(source[2 + tag.length] || '>')\n  )\n}\n", "import {\n  ConstantTypes,\n  RootNode,\n  NodeTypes,\n  TemplateChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  PlainElementNode,\n  ComponentNode,\n  TemplateNode,\n  VNodeCall,\n  ParentNode,\n  JSChildNode,\n  CallExpression,\n  createArrayExpression\n} from '../ast'\nimport { TransformContext } from '../transform'\nimport { PatchFlags, isString, isSymbol, isArray } from '@vue/shared'\nimport { getVNodeBlockHelper, getVNodeHelper, isSlotOutlet } from '../utils'\nimport {\n  OPEN_BLOCK,\n  GUARD_REACTIVE_PROPS,\n  NORMALIZE_CLASS,\n  NORMALIZE_PROPS,\n  NORMALIZE_STYLE\n} from '../runtimeHelpers'\n\nexport function hoistStatic(root: RootNode, context: TransformContext) {\n  walk(\n    root,\n    context,\n    // Root node is unfortunately non-hoistable due to potential parent\n    // fallthrough attributes.\n    isSingleElementRoot(root, root.children[0])\n  )\n}\n\nexport function isSingleElementRoot(\n  root: RootNode,\n  child: TemplateChildNode\n): child is PlainElementNode | ComponentNode | TemplateNode {\n  const { children } = root\n  return (\n    children.length === 1 &&\n    child.type === NodeTypes.ELEMENT &&\n    !isSlotOutlet(child)\n  )\n}\n\nfunction walk(\n  node: ParentNode,\n  context: TransformContext,\n  doNotHoistNode: boolean = false\n) {\n  const { children } = node\n  const originalCount = children.length\n  let hoistedCount = 0\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    // only plain elements & text calls are eligible for hoisting.\n    if (\n      child.type === NodeTypes.ELEMENT &&\n      child.tagType === ElementTypes.ELEMENT\n    ) {\n      const constantType = doNotHoistNode\n        ? ConstantTypes.NOT_CONSTANT\n        : getConstantType(child, context)\n      if (constantType > ConstantTypes.NOT_CONSTANT) {\n        if (constantType >= ConstantTypes.CAN_HOIST) {\n          ;(child.codegenNode as VNodeCall).patchFlag =\n            PatchFlags.HOISTED + (__DEV__ ? ` /* HOISTED */` : ``)\n          child.codegenNode = context.hoist(child.codegenNode!)\n          hoistedCount++\n          continue\n        }\n      } else {\n        // node may contain dynamic children, but its props may be eligible for\n        // hoisting.\n        const codegenNode = child.codegenNode!\n        if (codegenNode.type === NodeTypes.VNODE_CALL) {\n          const flag = getPatchFlag(codegenNode)\n          if (\n            (!flag ||\n              flag === PatchFlags.NEED_PATCH ||\n              flag === PatchFlags.TEXT) &&\n            getGeneratedPropsConstantType(child, context) >=\n              ConstantTypes.CAN_HOIST\n          ) {\n            const props = getNodeProps(child)\n            if (props) {\n              codegenNode.props = context.hoist(props)\n            }\n          }\n          if (codegenNode.dynamicProps) {\n            codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps)\n          }\n        }\n      }\n    } else if (\n      child.type === NodeTypes.TEXT_CALL &&\n      getConstantType(child.content, context) >= ConstantTypes.CAN_HOIST\n    ) {\n      child.codegenNode = context.hoist(child.codegenNode)\n      hoistedCount++\n    }\n\n    // walk further\n    if (child.type === NodeTypes.ELEMENT) {\n      const isComponent = child.tagType === ElementTypes.COMPONENT\n      if (isComponent) {\n        context.scopes.vSlot++\n      }\n      walk(child, context)\n      if (isComponent) {\n        context.scopes.vSlot--\n      }\n    } else if (child.type === NodeTypes.FOR) {\n      // Do not hoist v-for single child because it has to be a block\n      walk(child, context, child.children.length === 1)\n    } else if (child.type === NodeTypes.IF) {\n      for (let i = 0; i < child.branches.length; i++) {\n        // Do not hoist v-if single child because it has to be a block\n        walk(\n          child.branches[i],\n          context,\n          child.branches[i].children.length === 1\n        )\n      }\n    }\n  }\n\n  if (hoistedCount && context.transformHoist) {\n    context.transformHoist(children, context, node)\n  }\n\n  // all children were hoisted - the entire children array is hoistable.\n  if (\n    hoistedCount &&\n    hoistedCount === originalCount &&\n    node.type === NodeTypes.ELEMENT &&\n    node.tagType === ElementTypes.ELEMENT &&\n    node.codegenNode &&\n    node.codegenNode.type === NodeTypes.VNODE_CALL &&\n    isArray(node.codegenNode.children)\n  ) {\n    node.codegenNode.children = context.hoist(\n      createArrayExpression(node.codegenNode.children)\n    )\n  }\n}\n\nexport function getConstantType(\n  node: TemplateChildNode | SimpleExpressionNode,\n  context: TransformContext\n): ConstantTypes {\n  const { constantCache } = context\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n      if (node.tagType !== ElementTypes.ELEMENT) {\n        return ConstantTypes.NOT_CONSTANT\n      }\n      const cached = constantCache.get(node)\n      if (cached !== undefined) {\n        return cached\n      }\n      const codegenNode = node.codegenNode!\n      if (codegenNode.type !== NodeTypes.VNODE_CALL) {\n        return ConstantTypes.NOT_CONSTANT\n      }\n      if (\n        codegenNode.isBlock &&\n        node.tag !== 'svg' &&\n        node.tag !== 'foreignObject'\n      ) {\n        return ConstantTypes.NOT_CONSTANT\n      }\n      const flag = getPatchFlag(codegenNode)\n      if (!flag) {\n        let returnType = ConstantTypes.CAN_STRINGIFY\n\n        // Element itself has no patch flag. However we still need to check:\n\n        // 1. Even for a node with no patch flag, it is possible for it to contain\n        // non-hoistable expressions that refers to scope variables, e.g. compiler\n        // injected keys or cached event handlers. Therefore we need to always\n        // check the codegenNode's props to be sure.\n        const generatedPropsType = getGeneratedPropsConstantType(node, context)\n        if (generatedPropsType === ConstantTypes.NOT_CONSTANT) {\n          constantCache.set(node, ConstantTypes.NOT_CONSTANT)\n          return ConstantTypes.NOT_CONSTANT\n        }\n        if (generatedPropsType < returnType) {\n          returnType = generatedPropsType\n        }\n\n        // 2. its children.\n        for (let i = 0; i < node.children.length; i++) {\n          const childType = getConstantType(node.children[i], context)\n          if (childType === ConstantTypes.NOT_CONSTANT) {\n            constantCache.set(node, ConstantTypes.NOT_CONSTANT)\n            return ConstantTypes.NOT_CONSTANT\n          }\n          if (childType < returnType) {\n            returnType = childType\n          }\n        }\n\n        // 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0\n        // type, check if any of the props can cause the type to be lowered\n        // we can skip can_patch because it's guaranteed by the absence of a\n        // patchFlag.\n        if (returnType > ConstantTypes.CAN_SKIP_PATCH) {\n          for (let i = 0; i < node.props.length; i++) {\n            const p = node.props[i]\n            if (p.type === NodeTypes.DIRECTIVE && p.name === 'bind' && p.exp) {\n              const expType = getConstantType(p.exp, context)\n              if (expType === ConstantTypes.NOT_CONSTANT) {\n                constantCache.set(node, ConstantTypes.NOT_CONSTANT)\n                return ConstantTypes.NOT_CONSTANT\n              }\n              if (expType < returnType) {\n                returnType = expType\n              }\n            }\n          }\n        }\n\n        // only svg/foreignObject could be block here, however if they are\n        // static then they don't need to be blocks since there will be no\n        // nested updates.\n        if (codegenNode.isBlock) {\n          context.removeHelper(OPEN_BLOCK)\n          context.removeHelper(\n            getVNodeBlockHelper(context.inSSR, codegenNode.isComponent)\n          )\n          codegenNode.isBlock = false\n          context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent))\n        }\n\n        constantCache.set(node, returnType)\n        return returnType\n      } else {\n        constantCache.set(node, ConstantTypes.NOT_CONSTANT)\n        return ConstantTypes.NOT_CONSTANT\n      }\n    case NodeTypes.TEXT:\n    case NodeTypes.COMMENT:\n      return ConstantTypes.CAN_STRINGIFY\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n    case NodeTypes.IF_BRANCH:\n      return ConstantTypes.NOT_CONSTANT\n    case NodeTypes.INTERPOLATION:\n    case NodeTypes.TEXT_CALL:\n      return getConstantType(node.content, context)\n    case NodeTypes.SIMPLE_EXPRESSION:\n      return node.constType\n    case NodeTypes.COMPOUND_EXPRESSION:\n      let returnType = ConstantTypes.CAN_STRINGIFY\n      for (let i = 0; i < node.children.length; i++) {\n        const child = node.children[i]\n        if (isString(child) || isSymbol(child)) {\n          continue\n        }\n        const childType = getConstantType(child, context)\n        if (childType === ConstantTypes.NOT_CONSTANT) {\n          return ConstantTypes.NOT_CONSTANT\n        } else if (childType < returnType) {\n          returnType = childType\n        }\n      }\n      return returnType\n    default:\n      if (__DEV__) {\n        const exhaustiveCheck: never = node\n        exhaustiveCheck\n      }\n      return ConstantTypes.NOT_CONSTANT\n  }\n}\n\nconst allowHoistedHelperSet = new Set([\n  NORMALIZE_CLASS,\n  NORMALIZE_STYLE,\n  NORMALIZE_PROPS,\n  GUARD_REACTIVE_PROPS\n])\n\nfunction getConstantTypeOfHelperCall(\n  value: CallExpression,\n  context: TransformContext\n): ConstantTypes {\n  if (\n    value.type === NodeTypes.JS_CALL_EXPRESSION &&\n    !isString(value.callee) &&\n    allowHoistedHelperSet.has(value.callee)\n  ) {\n    const arg = value.arguments[0] as JSChildNode\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n      return getConstantType(arg, context)\n    } else if (arg.type === NodeTypes.JS_CALL_EXPRESSION) {\n      // in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`\n      return getConstantTypeOfHelperCall(arg, context)\n    }\n  }\n  return ConstantTypes.NOT_CONSTANT\n}\n\nfunction getGeneratedPropsConstantType(\n  node: PlainElementNode,\n  context: TransformContext\n): ConstantTypes {\n  let returnType = ConstantTypes.CAN_STRINGIFY\n  const props = getNodeProps(node)\n  if (props && props.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n    const { properties } = props\n    for (let i = 0; i < properties.length; i++) {\n      const { key, value } = properties[i]\n      const keyType = getConstantType(key, context)\n      if (keyType === ConstantTypes.NOT_CONSTANT) {\n        return keyType\n      }\n      if (keyType < returnType) {\n        returnType = keyType\n      }\n      let valueType: ConstantTypes\n      if (value.type === NodeTypes.SIMPLE_EXPRESSION) {\n        valueType = getConstantType(value, context)\n      } else if (value.type === NodeTypes.JS_CALL_EXPRESSION) {\n        // some helper calls can be hoisted,\n        // such as the `normalizeProps` generated by the compiler for pre-normalize class,\n        // in this case we need to respect the ConstantType of the helper's arguments\n        valueType = getConstantTypeOfHelperCall(value, context)\n      } else {\n        valueType = ConstantTypes.NOT_CONSTANT\n      }\n      if (valueType === ConstantTypes.NOT_CONSTANT) {\n        return valueType\n      }\n      if (valueType < returnType) {\n        returnType = valueType\n      }\n    }\n  }\n  return returnType\n}\n\nfunction getNodeProps(node: PlainElementNode) {\n  const codegenNode = node.codegenNode!\n  if (codegenNode.type === NodeTypes.VNODE_CALL) {\n    return codegenNode.props\n  }\n}\n\nfunction getPatchFlag(node: VNodeCall): number | undefined {\n  const flag = node.patchFlag\n  return flag ? parseInt(flag, 10) : undefined\n}\n", "import { TransformOptions } from './options'\nimport {\n  RootNode,\n  NodeTypes,\n  ParentNode,\n  TemplateChildNode,\n  ElementNode,\n  DirectiveNode,\n  Property,\n  ExpressionNode,\n  createSimpleExpression,\n  JSChildNode,\n  SimpleExpressionNode,\n  ElementTypes,\n  CacheExpression,\n  createCacheExpression,\n  TemplateLiteral,\n  createVNodeCall,\n  ConstantTypes,\n  ArrayExpression\n} from './ast'\nimport {\n  isString,\n  isArray,\n  NOOP,\n  PatchFlags,\n  PatchFlagNames,\n  EMPTY_OBJ,\n  capitalize,\n  camelize\n} from '@vue/shared'\nimport { defaultOnError, defaultOnWarn } from './errors'\nimport {\n  TO_DISPLAY_STRING,\n  FRAGMENT,\n  helperNameMap,\n  CREATE_COMMENT\n} from './runtimeHelpers'\nimport { isVSlot, makeBlock } from './utils'\nimport { hoistStatic, isSingleElementRoot } from './transforms/hoistStatic'\nimport { CompilerCompatOptions } from './compat/compatConfig'\n\n// There are two types of transforms:\n//\n// - NodeTransform:\n//   Transforms that operate directly on a ChildNode. NodeTransforms may mutate,\n//   replace or remove the node being processed.\nexport type NodeTransform = (\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) => void | (() => void) | (() => void)[]\n\n// - DirectiveTransform:\n//   Transforms that handles a single directive attribute on an element.\n//   It translates the raw directive into actual props for the VNode.\nexport type DirectiveTransform = (\n  dir: DirectiveNode,\n  node: ElementNode,\n  context: TransformContext,\n  // a platform specific compiler can import the base transform and augment\n  // it by passing in this optional argument.\n  augmentor?: (ret: DirectiveTransformResult) => DirectiveTransformResult\n) => DirectiveTransformResult\n\nexport interface DirectiveTransformResult {\n  props: Property[]\n  needRuntime?: boolean | symbol\n  ssrTagParts?: TemplateLiteral['elements']\n}\n\n// A structural directive transform is a technically a NodeTransform;\n// Only v-if and v-for fall into this category.\nexport type StructuralDirectiveTransform = (\n  node: ElementNode,\n  dir: DirectiveNode,\n  context: TransformContext\n) => void | (() => void)\n\nexport interface ImportItem {\n  exp: string | ExpressionNode\n  path: string\n}\n\nexport interface TransformContext\n  extends Required<\n      Omit<TransformOptions, 'filename' | keyof CompilerCompatOptions>\n    >,\n    CompilerCompatOptions {\n  selfName: string | null\n  root: RootNode\n  helpers: Map<symbol, number>\n  components: Set<string>\n  directives: Set<string>\n  hoists: (JSChildNode | null)[]\n  imports: ImportItem[]\n  temps: number\n  cached: number\n  identifiers: { [name: string]: number | undefined }\n  scopes: {\n    vFor: number\n    vSlot: number\n    vPre: number\n    vOnce: number\n  }\n  parent: ParentNode | null\n  childIndex: number\n  currentNode: RootNode | TemplateChildNode | null\n  inVOnce: boolean\n  helper<T extends symbol>(name: T): T\n  removeHelper<T extends symbol>(name: T): void\n  helperString(name: symbol): string\n  replaceNode(node: TemplateChildNode): void\n  removeNode(node?: TemplateChildNode): void\n  onNodeRemoved(): void\n  addIdentifiers(exp: ExpressionNode | string): void\n  removeIdentifiers(exp: ExpressionNode | string): void\n  hoist(exp: string | JSChildNode | ArrayExpression): SimpleExpressionNode\n  cache<T extends JSChildNode>(exp: T, isVNode?: boolean): CacheExpression | T\n  constantCache: Map<TemplateChildNode, ConstantTypes>\n\n  // 2.x Compat only\n  filters?: Set<string>\n}\n\nexport function createTransformContext(\n  root: RootNode,\n  {\n    filename = '',\n    prefixIdentifiers = false,\n    hoistStatic = false,\n    cacheHandlers = false,\n    nodeTransforms = [],\n    directiveTransforms = {},\n    transformHoist = null,\n    isBuiltInComponent = NOOP,\n    isCustomElement = NOOP,\n    expressionPlugins = [],\n    scopeId = null,\n    slotted = true,\n    ssr = false,\n    inSSR = false,\n    ssrCssVars = ``,\n    bindingMetadata = EMPTY_OBJ,\n    inline = false,\n    isTS = false,\n    onError = defaultOnError,\n    onWarn = defaultOnWarn,\n    compatConfig\n  }: TransformOptions\n): TransformContext {\n  const nameMatch = filename.replace(/\\?.*$/, '').match(/([^/\\\\]+)\\.\\w+$/)\n  const context: TransformContext = {\n    // options\n    selfName: nameMatch && capitalize(camelize(nameMatch[1])),\n    prefixIdentifiers,\n    hoistStatic,\n    cacheHandlers,\n    nodeTransforms,\n    directiveTransforms,\n    transformHoist,\n    isBuiltInComponent,\n    isCustomElement,\n    expressionPlugins,\n    scopeId,\n    slotted,\n    ssr,\n    inSSR,\n    ssrCssVars,\n    bindingMetadata,\n    inline,\n    isTS,\n    onError,\n    onWarn,\n    compatConfig,\n\n    // state\n    root,\n    helpers: new Map(),\n    components: new Set(),\n    directives: new Set(),\n    hoists: [],\n    imports: [],\n    constantCache: new Map(),\n    temps: 0,\n    cached: 0,\n    identifiers: Object.create(null),\n    scopes: {\n      vFor: 0,\n      vSlot: 0,\n      vPre: 0,\n      vOnce: 0\n    },\n    parent: null,\n    currentNode: root,\n    childIndex: 0,\n    inVOnce: false,\n\n    // methods\n    helper(name) {\n      const count = context.helpers.get(name) || 0\n      context.helpers.set(name, count + 1)\n      return name\n    },\n    removeHelper(name) {\n      const count = context.helpers.get(name)\n      if (count) {\n        const currentCount = count - 1\n        if (!currentCount) {\n          context.helpers.delete(name)\n        } else {\n          context.helpers.set(name, currentCount)\n        }\n      }\n    },\n    helperString(name) {\n      return `_${helperNameMap[context.helper(name)]}`\n    },\n    replaceNode(node) {\n      /* istanbul ignore if */\n      if (__DEV__) {\n        if (!context.currentNode) {\n          throw new Error(`Node being replaced is already removed.`)\n        }\n        if (!context.parent) {\n          throw new Error(`Cannot replace root node.`)\n        }\n      }\n      context.parent!.children[context.childIndex] = context.currentNode = node\n    },\n    removeNode(node) {\n      if (__DEV__ && !context.parent) {\n        throw new Error(`Cannot remove root node.`)\n      }\n      const list = context.parent!.children\n      const removalIndex = node\n        ? list.indexOf(node)\n        : context.currentNode\n        ? context.childIndex\n        : -1\n      /* istanbul ignore if */\n      if (__DEV__ && removalIndex < 0) {\n        throw new Error(`node being removed is not a child of current parent`)\n      }\n      if (!node || node === context.currentNode) {\n        // current node removed\n        context.currentNode = null\n        context.onNodeRemoved()\n      } else {\n        // sibling node removed\n        if (context.childIndex > removalIndex) {\n          context.childIndex--\n          context.onNodeRemoved()\n        }\n      }\n      context.parent!.children.splice(removalIndex, 1)\n    },\n    onNodeRemoved: () => {},\n    addIdentifiers(exp) {\n      // identifier tracking only happens in non-browser builds.\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          addId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(addId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          addId(exp.content)\n        }\n      }\n    },\n    removeIdentifiers(exp) {\n      if (!__BROWSER__) {\n        if (isString(exp)) {\n          removeId(exp)\n        } else if (exp.identifiers) {\n          exp.identifiers.forEach(removeId)\n        } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          removeId(exp.content)\n        }\n      }\n    },\n    hoist(exp) {\n      if (isString(exp)) exp = createSimpleExpression(exp)\n      context.hoists.push(exp)\n      const identifier = createSimpleExpression(\n        `_hoisted_${context.hoists.length}`,\n        false,\n        exp.loc,\n        ConstantTypes.CAN_HOIST\n      )\n      identifier.hoisted = exp\n      return identifier\n    },\n    cache(exp, isVNode = false) {\n      return createCacheExpression(context.cached++, exp, isVNode)\n    }\n  }\n\n  if (__COMPAT__) {\n    context.filters = new Set()\n  }\n\n  function addId(id: string) {\n    const { identifiers } = context\n    if (identifiers[id] === undefined) {\n      identifiers[id] = 0\n    }\n    identifiers[id]!++\n  }\n\n  function removeId(id: string) {\n    context.identifiers[id]!--\n  }\n\n  return context\n}\n\nexport function transform(root: RootNode, options: TransformOptions) {\n  const context = createTransformContext(root, options)\n  traverseNode(root, context)\n  if (options.hoistStatic) {\n    hoistStatic(root, context)\n  }\n  if (!options.ssr) {\n    createRootCodegen(root, context)\n  }\n  // finalize meta information\n  root.helpers = [...context.helpers.keys()]\n  root.components = [...context.components]\n  root.directives = [...context.directives]\n  root.imports = context.imports\n  root.hoists = context.hoists\n  root.temps = context.temps\n  root.cached = context.cached\n\n  if (__COMPAT__) {\n    root.filters = [...context.filters!]\n  }\n}\n\nfunction createRootCodegen(root: RootNode, context: TransformContext) {\n  const { helper } = context\n  const { children } = root\n  if (children.length === 1) {\n    const child = children[0]\n    // if the single child is an element, turn it into a block.\n    if (isSingleElementRoot(root, child) && child.codegenNode) {\n      // single element root is never hoisted so codegenNode will never be\n      // SimpleExpressionNode\n      const codegenNode = child.codegenNode\n      if (codegenNode.type === NodeTypes.VNODE_CALL) {\n        makeBlock(codegenNode, context)\n      }\n      root.codegenNode = codegenNode\n    } else {\n      // - single <slot/>, IfNode, ForNode: already blocks.\n      // - single text node: always patched.\n      // root codegen falls through via genNode()\n      root.codegenNode = child\n    }\n  } else if (children.length > 1) {\n    // root has multiple nodes - return a fragment block.\n    let patchFlag = PatchFlags.STABLE_FRAGMENT\n    let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\n    // check if the fragment actually contains a single valid child with\n    // the rest being comments\n    if (\n      __DEV__ &&\n      children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\n    ) {\n      patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\n      patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\n    }\n    root.codegenNode = createVNodeCall(\n      context,\n      helper(FRAGMENT),\n      undefined,\n      root.children,\n      patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\n      undefined,\n      undefined,\n      true,\n      undefined,\n      false /* isComponent */\n    )\n  } else {\n    // no children = noop. codegen will return null.\n  }\n}\n\nexport function traverseChildren(\n  parent: ParentNode,\n  context: TransformContext\n) {\n  let i = 0\n  const nodeRemoved = () => {\n    i--\n  }\n  for (; i < parent.children.length; i++) {\n    const child = parent.children[i]\n    if (isString(child)) continue\n    context.parent = parent\n    context.childIndex = i\n    context.onNodeRemoved = nodeRemoved\n    traverseNode(child, context)\n  }\n}\n\nexport function traverseNode(\n  node: RootNode | TemplateChildNode,\n  context: TransformContext\n) {\n  context.currentNode = node\n  // apply transform plugins\n  const { nodeTransforms } = context\n  const exitFns = []\n  for (let i = 0; i < nodeTransforms.length; i++) {\n    const onExit = nodeTransforms[i](node, context)\n    if (onExit) {\n      if (isArray(onExit)) {\n        exitFns.push(...onExit)\n      } else {\n        exitFns.push(onExit)\n      }\n    }\n    if (!context.currentNode) {\n      // node was removed\n      return\n    } else {\n      // node may have been replaced\n      node = context.currentNode\n    }\n  }\n\n  switch (node.type) {\n    case NodeTypes.COMMENT:\n      if (!context.ssr) {\n        // inject import for the Comment symbol, which is needed for creating\n        // comment nodes with `createVNode`\n        context.helper(CREATE_COMMENT)\n      }\n      break\n    case NodeTypes.INTERPOLATION:\n      // no need to traverse, but we need to inject toString helper\n      if (!context.ssr) {\n        context.helper(TO_DISPLAY_STRING)\n      }\n      break\n\n    // for container types, further traverse downwards\n    case NodeTypes.IF:\n      for (let i = 0; i < node.branches.length; i++) {\n        traverseNode(node.branches[i], context)\n      }\n      break\n    case NodeTypes.IF_BRANCH:\n    case NodeTypes.FOR:\n    case NodeTypes.ELEMENT:\n    case NodeTypes.ROOT:\n      traverseChildren(node, context)\n      break\n  }\n\n  // exit transforms\n  context.currentNode = node\n  let i = exitFns.length\n  while (i--) {\n    exitFns[i]()\n  }\n}\n\nexport function createStructuralDirectiveTransform(\n  name: string | RegExp,\n  fn: StructuralDirectiveTransform\n): NodeTransform {\n  const matches = isString(name)\n    ? (n: string) => n === name\n    : (n: string) => name.test(n)\n\n  return (node, context) => {\n    if (node.type === NodeTypes.ELEMENT) {\n      const { props } = node\n      // structural directive transforms are not concerned with slots\n      // as they are handled separately in vSlot.ts\n      if (node.tagType === ElementTypes.TEMPLATE && props.some(isVSlot)) {\n        return\n      }\n      const exitFns = []\n      for (let i = 0; i < props.length; i++) {\n        const prop = props[i]\n        if (prop.type === NodeTypes.DIRECTIVE && matches(prop.name)) {\n          // structural directives are removed to avoid infinite recursion\n          // also we remove them *before* applying so that it can further\n          // traverse itself in case it moves the node around\n          props.splice(i, 1)\n          i--\n          const onExit = fn(node, prop, context)\n          if (onExit) exitFns.push(onExit)\n        }\n      }\n      return exitFns\n    }\n  }\n}\n", "import { CodegenOptions } from './options'\nimport {\n  RootNode,\n  TemplateChildNode,\n  TextNode,\n  CommentNode,\n  ExpressionNode,\n  NodeTypes,\n  JSChildNode,\n  CallExpression,\n  ArrayExpression,\n  ObjectExpression,\n  Position,\n  InterpolationNode,\n  CompoundExpressionNode,\n  SimpleExpressionNode,\n  FunctionExpression,\n  ConditionalExpression,\n  CacheExpression,\n  locStub,\n  SSRCodegenNode,\n  TemplateLiteral,\n  IfStatement,\n  AssignmentExpression,\n  ReturnStatement,\n  VNodeCall,\n  SequenceExpression\n} from './ast'\nimport { SourceMapGenerator, RawSourceMap } from 'source-map'\nimport {\n  advancePositionWithMutation,\n  assert,\n  getVNodeBlockHelper,\n  getVNodeHelper,\n  isSimpleIdentifier,\n  toValidAssetId\n} from './utils'\nimport { isString, isArray, isSymbol } from '@vue/shared'\nimport {\n  helperNameMap,\n  TO_DISPLAY_STRING,\n  CREATE_VNODE,\n  RESOLVE_COMPONENT,\n  RESOLVE_DIRECTIVE,\n  SET_BLOCK_TRACKING,\n  CREATE_COMMENT,\n  CREATE_TEXT,\n  PUSH_SCOPE_ID,\n  POP_SCOPE_ID,\n  WITH_DIRECTIVES,\n  CREATE_ELEMENT_VNODE,\n  OPEN_BLOCK,\n  CREATE_STATIC,\n  WITH_CTX,\n  RESOLVE_FILTER\n} from './runtimeHelpers'\nimport { ImportItem } from './transform'\n\nconst PURE_ANNOTATION = `/*#__PURE__*/`\n\ntype CodegenNode = TemplateChildNode | JSChildNode | SSRCodegenNode\n\nexport interface CodegenResult {\n  code: string\n  preamble: string\n  ast: RootNode\n  map?: RawSourceMap\n}\n\nexport interface CodegenContext\n  extends Omit<Required<CodegenOptions>, 'bindingMetadata' | 'inline'> {\n  source: string\n  code: string\n  line: number\n  column: number\n  offset: number\n  indentLevel: number\n  pure: boolean\n  map?: SourceMapGenerator\n  helper(key: symbol): string\n  push(code: string, node?: CodegenNode): void\n  indent(): void\n  deindent(withoutNewLine?: boolean): void\n  newline(): void\n}\n\nfunction createCodegenContext(\n  ast: RootNode,\n  {\n    mode = 'function',\n    prefixIdentifiers = mode === 'module',\n    sourceMap = false,\n    filename = `template.vue.html`,\n    scopeId = null,\n    optimizeImports = false,\n    runtimeGlobalName = `Vue`,\n    runtimeModuleName = `vue`,\n    ssrRuntimeModuleName = 'vue/server-renderer',\n    ssr = false,\n    isTS = false,\n    inSSR = false\n  }: CodegenOptions\n): CodegenContext {\n  const context: CodegenContext = {\n    mode,\n    prefixIdentifiers,\n    sourceMap,\n    filename,\n    scopeId,\n    optimizeImports,\n    runtimeGlobalName,\n    runtimeModuleName,\n    ssrRuntimeModuleName,\n    ssr,\n    isTS,\n    inSSR,\n    source: ast.loc.source,\n    code: ``,\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n    pure: false,\n    map: undefined,\n    helper(key) {\n      return `_${helperNameMap[key]}`\n    },\n    push(code, node) {\n      context.code += code\n      if (!__BROWSER__ && context.map) {\n        if (node) {\n          let name\n          if (node.type === NodeTypes.SIMPLE_EXPRESSION && !node.isStatic) {\n            const content = node.content.replace(/^_ctx\\./, '')\n            if (content !== node.content && isSimpleIdentifier(content)) {\n              name = content\n            }\n          }\n          addMapping(node.loc.start, name)\n        }\n        advancePositionWithMutation(context, code)\n        if (node && node.loc !== locStub) {\n          addMapping(node.loc.end)\n        }\n      }\n    },\n    indent() {\n      newline(++context.indentLevel)\n    },\n    deindent(withoutNewLine = false) {\n      if (withoutNewLine) {\n        --context.indentLevel\n      } else {\n        newline(--context.indentLevel)\n      }\n    },\n    newline() {\n      newline(context.indentLevel)\n    }\n  }\n\n  function newline(n: number) {\n    context.push('\\n' + `  `.repeat(n))\n  }\n\n  function addMapping(loc: Position, name?: string) {\n    context.map!.addMapping({\n      name,\n      source: context.filename,\n      original: {\n        line: loc.line,\n        column: loc.column - 1 // source-map column is 0 based\n      },\n      generated: {\n        line: context.line,\n        column: context.column - 1\n      }\n    })\n  }\n\n  if (!__BROWSER__ && sourceMap) {\n    // lazy require source-map implementation, only in non-browser builds\n    context.map = new SourceMapGenerator()\n    context.map!.setSourceContent(filename, context.source)\n  }\n\n  return context\n}\n\nexport function generate(\n  ast: RootNode,\n  options: CodegenOptions & {\n    onContextCreated?: (context: CodegenContext) => void\n  } = {}\n): CodegenResult {\n  const context = createCodegenContext(ast, options)\n  if (options.onContextCreated) options.onContextCreated(context)\n  const {\n    mode,\n    push,\n    prefixIdentifiers,\n    indent,\n    deindent,\n    newline,\n    scopeId,\n    ssr\n  } = context\n\n  const hasHelpers = ast.helpers.length > 0\n  const useWithBlock = !prefixIdentifiers && mode !== 'module'\n  const genScopeId = !__BROWSER__ && scopeId != null && mode === 'module'\n  const isSetupInlined = !__BROWSER__ && !!options.inline\n\n  // preambles\n  // in setup() inline mode, the preamble is generated in a sub context\n  // and returned separately.\n  const preambleContext = isSetupInlined\n    ? createCodegenContext(ast, options)\n    : context\n  if (!__BROWSER__ && mode === 'module') {\n    genModulePreamble(ast, preambleContext, genScopeId, isSetupInlined)\n  } else {\n    genFunctionPreamble(ast, preambleContext)\n  }\n  // enter render function\n  const functionName = ssr ? `ssrRender` : `render`\n  const args = ssr ? ['_ctx', '_push', '_parent', '_attrs'] : ['_ctx', '_cache']\n  if (!__BROWSER__ && options.bindingMetadata && !options.inline) {\n    // binding optimization args\n    args.push('$props', '$setup', '$data', '$options')\n  }\n  const signature =\n    !__BROWSER__ && options.isTS\n      ? args.map(arg => `${arg}: any`).join(',')\n      : args.join(', ')\n\n  if (isSetupInlined) {\n    push(`(${signature}) => {`)\n  } else {\n    push(`function ${functionName}(${signature}) {`)\n  }\n  indent()\n\n  if (useWithBlock) {\n    push(`with (_ctx) {`)\n    indent()\n    // function mode const declarations should be inside with block\n    // also they should be renamed to avoid collision with user properties\n    if (hasHelpers) {\n      push(\n        `const { ${ast.helpers\n          .map(s => `${helperNameMap[s]}: _${helperNameMap[s]}`)\n          .join(', ')} } = _Vue`\n      )\n      push(`\\n`)\n      newline()\n    }\n  }\n\n  // generate asset resolution statements\n  if (ast.components.length) {\n    genAssets(ast.components, 'component', context)\n    if (ast.directives.length || ast.temps > 0) {\n      newline()\n    }\n  }\n  if (ast.directives.length) {\n    genAssets(ast.directives, 'directive', context)\n    if (ast.temps > 0) {\n      newline()\n    }\n  }\n  if (__COMPAT__ && ast.filters && ast.filters.length) {\n    newline()\n    genAssets(ast.filters, 'filter', context)\n    newline()\n  }\n\n  if (ast.temps > 0) {\n    push(`let `)\n    for (let i = 0; i < ast.temps; i++) {\n      push(`${i > 0 ? `, ` : ``}_temp${i}`)\n    }\n  }\n  if (ast.components.length || ast.directives.length || ast.temps) {\n    push(`\\n`)\n    newline()\n  }\n\n  // generate the VNode tree expression\n  if (!ssr) {\n    push(`return `)\n  }\n  if (ast.codegenNode) {\n    genNode(ast.codegenNode, context)\n  } else {\n    push(`null`)\n  }\n\n  if (useWithBlock) {\n    deindent()\n    push(`}`)\n  }\n\n  deindent()\n  push(`}`)\n\n  return {\n    ast,\n    code: context.code,\n    preamble: isSetupInlined ? preambleContext.code : ``,\n    // SourceMapGenerator does have toJSON() method but it's not in the types\n    map: context.map ? (context.map as any).toJSON() : undefined\n  }\n}\n\nfunction genFunctionPreamble(ast: RootNode, context: CodegenContext) {\n  const {\n    ssr,\n    prefixIdentifiers,\n    push,\n    newline,\n    runtimeModuleName,\n    runtimeGlobalName,\n    ssrRuntimeModuleName\n  } = context\n  const VueBinding =\n    !__BROWSER__ && ssr\n      ? `require(${JSON.stringify(runtimeModuleName)})`\n      : runtimeGlobalName\n  const aliasHelper = (s: symbol) => `${helperNameMap[s]}: _${helperNameMap[s]}`\n  // Generate const declaration for helpers\n  // In prefix mode, we place the const declaration at top so it's done\n  // only once; But if we not prefixing, we place the declaration inside the\n  // with block so it doesn't incur the `in` check cost for every helper access.\n  if (ast.helpers.length > 0) {\n    if (!__BROWSER__ && prefixIdentifiers) {\n      push(\n        `const { ${ast.helpers.map(aliasHelper).join(', ')} } = ${VueBinding}\\n`\n      )\n    } else {\n      // \"with\" mode.\n      // save Vue in a separate variable to avoid collision\n      push(`const _Vue = ${VueBinding}\\n`)\n      // in \"with\" mode, helpers are declared inside the with block to avoid\n      // has check cost, but hoists are lifted out of the function - we need\n      // to provide the helper here.\n      if (ast.hoists.length) {\n        const staticHelpers = [\n          CREATE_VNODE,\n          CREATE_ELEMENT_VNODE,\n          CREATE_COMMENT,\n          CREATE_TEXT,\n          CREATE_STATIC\n        ]\n          .filter(helper => ast.helpers.includes(helper))\n          .map(aliasHelper)\n          .join(', ')\n        push(`const { ${staticHelpers} } = _Vue\\n`)\n      }\n    }\n  }\n  // generate variables for ssr helpers\n  if (!__BROWSER__ && ast.ssrHelpers && ast.ssrHelpers.length) {\n    // ssr guarantees prefixIdentifier: true\n    push(\n      `const { ${ast.ssrHelpers\n        .map(aliasHelper)\n        .join(', ')} } = require(\"${ssrRuntimeModuleName}\")\\n`\n    )\n  }\n  genHoists(ast.hoists, context)\n  newline()\n  push(`return `)\n}\n\nfunction genModulePreamble(\n  ast: RootNode,\n  context: CodegenContext,\n  genScopeId: boolean,\n  inline?: boolean\n) {\n  const {\n    push,\n    newline,\n    optimizeImports,\n    runtimeModuleName,\n    ssrRuntimeModuleName\n  } = context\n\n  if (genScopeId && ast.hoists.length) {\n    ast.helpers.push(PUSH_SCOPE_ID, POP_SCOPE_ID)\n  }\n\n  // generate import statements for helpers\n  if (ast.helpers.length) {\n    if (optimizeImports) {\n      // when bundled with webpack with code-split, calling an import binding\n      // as a function leads to it being wrapped with `Object(a.b)` or `(0,a.b)`,\n      // incurring both payload size increase and potential perf overhead.\n      // therefore we assign the imports to variables (which is a constant ~50b\n      // cost per-component instead of scaling with template size)\n      push(\n        `import { ${ast.helpers\n          .map(s => helperNameMap[s])\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\n      )\n      push(\n        `\\n// Binding optimization for webpack code-split\\nconst ${ast.helpers\n          .map(s => `_${helperNameMap[s]} = ${helperNameMap[s]}`)\n          .join(', ')}\\n`\n      )\n    } else {\n      push(\n        `import { ${ast.helpers\n          .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\n          .join(', ')} } from ${JSON.stringify(runtimeModuleName)}\\n`\n      )\n    }\n  }\n\n  if (ast.ssrHelpers && ast.ssrHelpers.length) {\n    push(\n      `import { ${ast.ssrHelpers\n        .map(s => `${helperNameMap[s]} as _${helperNameMap[s]}`)\n        .join(', ')} } from \"${ssrRuntimeModuleName}\"\\n`\n    )\n  }\n\n  if (ast.imports.length) {\n    genImports(ast.imports, context)\n    newline()\n  }\n\n  genHoists(ast.hoists, context)\n  newline()\n\n  if (!inline) {\n    push(`export `)\n  }\n}\n\nfunction genAssets(\n  assets: string[],\n  type: 'component' | 'directive' | 'filter',\n  { helper, push, newline, isTS }: CodegenContext\n) {\n  const resolver = helper(\n    __COMPAT__ && type === 'filter'\n      ? RESOLVE_FILTER\n      : type === 'component'\n      ? RESOLVE_COMPONENT\n      : RESOLVE_DIRECTIVE\n  )\n  for (let i = 0; i < assets.length; i++) {\n    let id = assets[i]\n    // potential component implicit self-reference inferred from SFC filename\n    const maybeSelfReference = id.endsWith('__self')\n    if (maybeSelfReference) {\n      id = id.slice(0, -6)\n    }\n    push(\n      `const ${toValidAssetId(id, type)} = ${resolver}(${JSON.stringify(id)}${\n        maybeSelfReference ? `, true` : ``\n      })${isTS ? `!` : ``}`\n    )\n    if (i < assets.length - 1) {\n      newline()\n    }\n  }\n}\n\nfunction genHoists(hoists: (JSChildNode | null)[], context: CodegenContext) {\n  if (!hoists.length) {\n    return\n  }\n  context.pure = true\n  const { push, newline, helper, scopeId, mode } = context\n  const genScopeId = !__BROWSER__ && scopeId != null && mode !== 'function'\n  newline()\n\n  // generate inlined withScopeId helper\n  if (genScopeId) {\n    push(\n      `const _withScopeId = n => (${helper(\n        PUSH_SCOPE_ID\n      )}(\"${scopeId}\"),n=n(),${helper(POP_SCOPE_ID)}(),n)`\n    )\n    newline()\n  }\n\n  for (let i = 0; i < hoists.length; i++) {\n    const exp = hoists[i]\n    if (exp) {\n      const needScopeIdWrapper = genScopeId && exp.type === NodeTypes.VNODE_CALL\n      push(\n        `const _hoisted_${i + 1} = ${\n          needScopeIdWrapper ? `${PURE_ANNOTATION} _withScopeId(() => ` : ``\n        }`\n      )\n      genNode(exp, context)\n      if (needScopeIdWrapper) {\n        push(`)`)\n      }\n      newline()\n    }\n  }\n\n  context.pure = false\n}\n\nfunction genImports(importsOptions: ImportItem[], context: CodegenContext) {\n  if (!importsOptions.length) {\n    return\n  }\n  importsOptions.forEach(imports => {\n    context.push(`import `)\n    genNode(imports.exp, context)\n    context.push(` from '${imports.path}'`)\n    context.newline()\n  })\n}\n\nfunction isText(n: string | CodegenNode) {\n  return (\n    isString(n) ||\n    n.type === NodeTypes.SIMPLE_EXPRESSION ||\n    n.type === NodeTypes.TEXT ||\n    n.type === NodeTypes.INTERPOLATION ||\n    n.type === NodeTypes.COMPOUND_EXPRESSION\n  )\n}\n\nfunction genNodeListAsArray(\n  nodes: (string | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext\n) {\n  const multilines =\n    nodes.length > 3 ||\n    ((!__BROWSER__ || __DEV__) && nodes.some(n => isArray(n) || !isText(n)))\n  context.push(`[`)\n  multilines && context.indent()\n  genNodeList(nodes, context, multilines)\n  multilines && context.deindent()\n  context.push(`]`)\n}\n\nfunction genNodeList(\n  nodes: (string | symbol | CodegenNode | TemplateChildNode[])[],\n  context: CodegenContext,\n  multilines: boolean = false,\n  comma: boolean = true\n) {\n  const { push, newline } = context\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]\n    if (isString(node)) {\n      push(node)\n    } else if (isArray(node)) {\n      genNodeListAsArray(node, context)\n    } else {\n      genNode(node, context)\n    }\n    if (i < nodes.length - 1) {\n      if (multilines) {\n        comma && push(',')\n        newline()\n      } else {\n        comma && push(', ')\n      }\n    }\n  }\n}\n\nfunction genNode(node: CodegenNode | symbol | string, context: CodegenContext) {\n  if (isString(node)) {\n    context.push(node)\n    return\n  }\n  if (isSymbol(node)) {\n    context.push(context.helper(node))\n    return\n  }\n  switch (node.type) {\n    case NodeTypes.ELEMENT:\n    case NodeTypes.IF:\n    case NodeTypes.FOR:\n      __DEV__ &&\n        assert(\n          node.codegenNode != null,\n          `Codegen node is missing for element/if/for node. ` +\n            `Apply appropriate transforms first.`\n        )\n      genNode(node.codegenNode!, context)\n      break\n    case NodeTypes.TEXT:\n      genText(node, context)\n      break\n    case NodeTypes.SIMPLE_EXPRESSION:\n      genExpression(node, context)\n      break\n    case NodeTypes.INTERPOLATION:\n      genInterpolation(node, context)\n      break\n    case NodeTypes.TEXT_CALL:\n      genNode(node.codegenNode, context)\n      break\n    case NodeTypes.COMPOUND_EXPRESSION:\n      genCompoundExpression(node, context)\n      break\n    case NodeTypes.COMMENT:\n      genComment(node, context)\n      break\n    case NodeTypes.VNODE_CALL:\n      genVNodeCall(node, context)\n      break\n\n    case NodeTypes.JS_CALL_EXPRESSION:\n      genCallExpression(node, context)\n      break\n    case NodeTypes.JS_OBJECT_EXPRESSION:\n      genObjectExpression(node, context)\n      break\n    case NodeTypes.JS_ARRAY_EXPRESSION:\n      genArrayExpression(node, context)\n      break\n    case NodeTypes.JS_FUNCTION_EXPRESSION:\n      genFunctionExpression(node, context)\n      break\n    case NodeTypes.JS_CONDITIONAL_EXPRESSION:\n      genConditionalExpression(node, context)\n      break\n    case NodeTypes.JS_CACHE_EXPRESSION:\n      genCacheExpression(node, context)\n      break\n    case NodeTypes.JS_BLOCK_STATEMENT:\n      genNodeList(node.body, context, true, false)\n      break\n\n    // SSR only types\n    case NodeTypes.JS_TEMPLATE_LITERAL:\n      !__BROWSER__ && genTemplateLiteral(node, context)\n      break\n    case NodeTypes.JS_IF_STATEMENT:\n      !__BROWSER__ && genIfStatement(node, context)\n      break\n    case NodeTypes.JS_ASSIGNMENT_EXPRESSION:\n      !__BROWSER__ && genAssignmentExpression(node, context)\n      break\n    case NodeTypes.JS_SEQUENCE_EXPRESSION:\n      !__BROWSER__ && genSequenceExpression(node, context)\n      break\n    case NodeTypes.JS_RETURN_STATEMENT:\n      !__BROWSER__ && genReturnStatement(node, context)\n      break\n\n    /* istanbul ignore next */\n    case NodeTypes.IF_BRANCH:\n      // noop\n      break\n    default:\n      if (__DEV__) {\n        assert(false, `unhandled codegen node type: ${(node as any).type}`)\n        // make sure we exhaust all possible types\n        const exhaustiveCheck: never = node\n        return exhaustiveCheck\n      }\n  }\n}\n\nfunction genText(\n  node: TextNode | SimpleExpressionNode,\n  context: CodegenContext\n) {\n  context.push(JSON.stringify(node.content), node)\n}\n\nfunction genExpression(node: SimpleExpressionNode, context: CodegenContext) {\n  const { content, isStatic } = node\n  context.push(isStatic ? JSON.stringify(content) : content, node)\n}\n\nfunction genInterpolation(node: InterpolationNode, context: CodegenContext) {\n  const { push, helper, pure } = context\n  if (pure) push(PURE_ANNOTATION)\n  push(`${helper(TO_DISPLAY_STRING)}(`)\n  genNode(node.content, context)\n  push(`)`)\n}\n\nfunction genCompoundExpression(\n  node: CompoundExpressionNode,\n  context: CodegenContext\n) {\n  for (let i = 0; i < node.children!.length; i++) {\n    const child = node.children![i]\n    if (isString(child)) {\n      context.push(child)\n    } else {\n      genNode(child, context)\n    }\n  }\n}\n\nfunction genExpressionAsPropertyKey(\n  node: ExpressionNode,\n  context: CodegenContext\n) {\n  const { push } = context\n  if (node.type === NodeTypes.COMPOUND_EXPRESSION) {\n    push(`[`)\n    genCompoundExpression(node, context)\n    push(`]`)\n  } else if (node.isStatic) {\n    // only quote keys if necessary\n    const text = isSimpleIdentifier(node.content)\n      ? node.content\n      : JSON.stringify(node.content)\n    push(text, node)\n  } else {\n    push(`[${node.content}]`, node)\n  }\n}\n\nfunction genComment(node: CommentNode, context: CodegenContext) {\n  const { push, helper, pure } = context\n  if (pure) {\n    push(PURE_ANNOTATION)\n  }\n  push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node)\n}\n\nfunction genVNodeCall(node: VNodeCall, context: CodegenContext) {\n  const { push, helper, pure } = context\n  const {\n    tag,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    directives,\n    isBlock,\n    disableTracking,\n    isComponent\n  } = node\n  if (directives) {\n    push(helper(WITH_DIRECTIVES) + `(`)\n  }\n  if (isBlock) {\n    push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `)\n  }\n  if (pure) {\n    push(PURE_ANNOTATION)\n  }\n  const callHelper: symbol = isBlock\n    ? getVNodeBlockHelper(context.inSSR, isComponent)\n    : getVNodeHelper(context.inSSR, isComponent)\n  push(helper(callHelper) + `(`, node)\n  genNodeList(\n    genNullableArgs([tag, props, children, patchFlag, dynamicProps]),\n    context\n  )\n  push(`)`)\n  if (isBlock) {\n    push(`)`)\n  }\n  if (directives) {\n    push(`, `)\n    genNode(directives, context)\n    push(`)`)\n  }\n}\n\nfunction genNullableArgs(args: any[]): CallExpression['arguments'] {\n  let i = args.length\n  while (i--) {\n    if (args[i] != null) break\n  }\n  return args.slice(0, i + 1).map(arg => arg || `null`)\n}\n\n// JavaScript\nfunction genCallExpression(node: CallExpression, context: CodegenContext) {\n  const { push, helper, pure } = context\n  const callee = isString(node.callee) ? node.callee : helper(node.callee)\n  if (pure) {\n    push(PURE_ANNOTATION)\n  }\n  push(callee + `(`, node)\n  genNodeList(node.arguments, context)\n  push(`)`)\n}\n\nfunction genObjectExpression(node: ObjectExpression, context: CodegenContext) {\n  const { push, indent, deindent, newline } = context\n  const { properties } = node\n  if (!properties.length) {\n    push(`{}`, node)\n    return\n  }\n  const multilines =\n    properties.length > 1 ||\n    ((!__BROWSER__ || __DEV__) &&\n      properties.some(p => p.value.type !== NodeTypes.SIMPLE_EXPRESSION))\n  push(multilines ? `{` : `{ `)\n  multilines && indent()\n  for (let i = 0; i < properties.length; i++) {\n    const { key, value } = properties[i]\n    // key\n    genExpressionAsPropertyKey(key, context)\n    push(`: `)\n    // value\n    genNode(value, context)\n    if (i < properties.length - 1) {\n      // will only reach this if it's multilines\n      push(`,`)\n      newline()\n    }\n  }\n  multilines && deindent()\n  push(multilines ? `}` : ` }`)\n}\n\nfunction genArrayExpression(node: ArrayExpression, context: CodegenContext) {\n  genNodeListAsArray(node.elements as CodegenNode[], context)\n}\n\nfunction genFunctionExpression(\n  node: FunctionExpression,\n  context: CodegenContext\n) {\n  const { push, indent, deindent } = context\n  const { params, returns, body, newline, isSlot } = node\n  if (isSlot) {\n    // wrap slot functions with owner context\n    push(`_${helperNameMap[WITH_CTX]}(`)\n  }\n  push(`(`, node)\n  if (isArray(params)) {\n    genNodeList(params, context)\n  } else if (params) {\n    genNode(params, context)\n  }\n  push(`) => `)\n  if (newline || body) {\n    push(`{`)\n    indent()\n  }\n  if (returns) {\n    if (newline) {\n      push(`return `)\n    }\n    if (isArray(returns)) {\n      genNodeListAsArray(returns, context)\n    } else {\n      genNode(returns, context)\n    }\n  } else if (body) {\n    genNode(body, context)\n  }\n  if (newline || body) {\n    deindent()\n    push(`}`)\n  }\n  if (isSlot) {\n    if (__COMPAT__ && node.isNonScopedSlot) {\n      push(`, undefined, true`)\n    }\n    push(`)`)\n  }\n}\n\nfunction genConditionalExpression(\n  node: ConditionalExpression,\n  context: CodegenContext\n) {\n  const { test, consequent, alternate, newline: needNewline } = node\n  const { push, indent, deindent, newline } = context\n  if (test.type === NodeTypes.SIMPLE_EXPRESSION) {\n    const needsParens = !isSimpleIdentifier(test.content)\n    needsParens && push(`(`)\n    genExpression(test, context)\n    needsParens && push(`)`)\n  } else {\n    push(`(`)\n    genNode(test, context)\n    push(`)`)\n  }\n  needNewline && indent()\n  context.indentLevel++\n  needNewline || push(` `)\n  push(`? `)\n  genNode(consequent, context)\n  context.indentLevel--\n  needNewline && newline()\n  needNewline || push(` `)\n  push(`: `)\n  const isNested = alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n  if (!isNested) {\n    context.indentLevel++\n  }\n  genNode(alternate, context)\n  if (!isNested) {\n    context.indentLevel--\n  }\n  needNewline && deindent(true /* without newline */)\n}\n\nfunction genCacheExpression(node: CacheExpression, context: CodegenContext) {\n  const { push, helper, indent, deindent, newline } = context\n  push(`_cache[${node.index}] || (`)\n  if (node.isVNode) {\n    indent()\n    push(`${helper(SET_BLOCK_TRACKING)}(-1),`)\n    newline()\n  }\n  push(`_cache[${node.index}] = `)\n  genNode(node.value, context)\n  if (node.isVNode) {\n    push(`,`)\n    newline()\n    push(`${helper(SET_BLOCK_TRACKING)}(1),`)\n    newline()\n    push(`_cache[${node.index}]`)\n    deindent()\n  }\n  push(`)`)\n}\n\nfunction genTemplateLiteral(node: TemplateLiteral, context: CodegenContext) {\n  const { push, indent, deindent } = context\n  push('`')\n  const l = node.elements.length\n  const multilines = l > 3\n  for (let i = 0; i < l; i++) {\n    const e = node.elements[i]\n    if (isString(e)) {\n      push(e.replace(/(`|\\$|\\\\)/g, '\\\\$1'))\n    } else {\n      push('${')\n      if (multilines) indent()\n      genNode(e, context)\n      if (multilines) deindent()\n      push('}')\n    }\n  }\n  push('`')\n}\n\nfunction genIfStatement(node: IfStatement, context: CodegenContext) {\n  const { push, indent, deindent } = context\n  const { test, consequent, alternate } = node\n  push(`if (`)\n  genNode(test, context)\n  push(`) {`)\n  indent()\n  genNode(consequent, context)\n  deindent()\n  push(`}`)\n  if (alternate) {\n    push(` else `)\n    if (alternate.type === NodeTypes.JS_IF_STATEMENT) {\n      genIfStatement(alternate, context)\n    } else {\n      push(`{`)\n      indent()\n      genNode(alternate, context)\n      deindent()\n      push(`}`)\n    }\n  }\n}\n\nfunction genAssignmentExpression(\n  node: AssignmentExpression,\n  context: CodegenContext\n) {\n  genNode(node.left, context)\n  context.push(` = `)\n  genNode(node.right, context)\n}\n\nfunction genSequenceExpression(\n  node: SequenceExpression,\n  context: CodegenContext\n) {\n  context.push(`(`)\n  genNodeList(node.expressions, context)\n  context.push(`)`)\n}\n\nfunction genReturnStatement(\n  { returns }: ReturnStatement,\n  context: CodegenContext\n) {\n  context.push(`return `)\n  if (isArray(returns)) {\n    genNodeListAsArray(returns, context)\n  } else {\n    genNode(returns, context)\n  }\n}\n", "// @ts-check\n/** @typedef { import('estree').BaseNode} BaseNode */\n\n/** @typedef {{\n\tskip: () => void;\n\tremove: () => void;\n\treplace: (node: BaseNode) => void;\n}} WalkerContext */\n\nclass WalkerBase {\n\tconstructor() {\n\t\t/** @type {boolean} */\n\t\tthis.should_skip = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.should_remove = false;\n\n\t\t/** @type {BaseNode | null} */\n\t\tthis.replacement = null;\n\n\t\t/** @type {WalkerContext} */\n\t\tthis.context = {\n\t\t\tskip: () => (this.should_skip = true),\n\t\t\tremove: () => (this.should_remove = true),\n\t\t\treplace: (node) => (this.replacement = node)\n\t\t};\n\t}\n\n\t/**\n\t *\n\t * @param {any} parent\n\t * @param {string} prop\n\t * @param {number} index\n\t * @param {BaseNode} node\n\t */\n\treplace(parent, prop, index, node) {\n\t\tif (parent) {\n\t\t\tif (index !== null) {\n\t\t\t\tparent[prop][index] = node;\n\t\t\t} else {\n\t\t\t\tparent[prop] = node;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {any} parent\n\t * @param {string} prop\n\t * @param {number} index\n\t */\n\tremove(parent, prop, index) {\n\t\tif (parent) {\n\t\t\tif (index !== null) {\n\t\t\t\tparent[prop].splice(index, 1);\n\t\t\t} else {\n\t\t\t\tdelete parent[prop];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// @ts-check\n\n/** @typedef { import('estree').BaseNode} BaseNode */\n/** @typedef { import('./walker.js').WalkerContext} WalkerContext */\n\n/** @typedef {(\n *    this: WalkerContext,\n *    node: BaseNode,\n *    parent: BaseNode,\n *    key: string,\n *    index: number\n * ) => void} SyncHandler */\n\nclass SyncWalker extends WalkerBase {\n\t/**\n\t *\n\t * @param {SyncHandler} enter\n\t * @param {SyncHandler} leave\n\t */\n\tconstructor(enter, leave) {\n\t\tsuper();\n\n\t\t/** @type {SyncHandler} */\n\t\tthis.enter = enter;\n\n\t\t/** @type {SyncHandler} */\n\t\tthis.leave = leave;\n\t}\n\n\t/**\n\t *\n\t * @param {BaseNode} node\n\t * @param {BaseNode} parent\n\t * @param {string} [prop]\n\t * @param {number} [index]\n\t * @returns {BaseNode}\n\t */\n\tvisit(node, parent, prop, index) {\n\t\tif (node) {\n\t\t\tif (this.enter) {\n\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tthis.should_skip = false;\n\t\t\t\tthis.should_remove = false;\n\t\t\t\tthis.replacement = null;\n\n\t\t\t\tthis.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\tif (skipped) return node;\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\n\t\t\tfor (const key in node) {\n\t\t\t\tconst value = node[key];\n\n\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\tif (!this.visit(value[i], node, key, i)) {\n\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\tthis.visit(value, node, key, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.leave) {\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tthis.replacement = null;\n\t\t\t\tthis.should_remove = false;\n\n\t\t\t\tthis.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.replacement = _replacement;\n\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n}\n\n// @ts-check\n\n/** @typedef { import('estree').BaseNode} BaseNode */\n/** @typedef { import('./walker').WalkerContext} WalkerContext */\n\n/** @typedef {(\n *    this: WalkerContext,\n *    node: BaseNode,\n *    parent: BaseNode,\n *    key: string,\n *    index: number\n * ) => Promise<void>} AsyncHandler */\n\nclass AsyncWalker extends WalkerBase {\n\t/**\n\t *\n\t * @param {AsyncHandler} enter\n\t * @param {AsyncHandler} leave\n\t */\n\tconstructor(enter, leave) {\n\t\tsuper();\n\n\t\t/** @type {AsyncHandler} */\n\t\tthis.enter = enter;\n\n\t\t/** @type {AsyncHandler} */\n\t\tthis.leave = leave;\n\t}\n\n\t/**\n\t *\n\t * @param {BaseNode} node\n\t * @param {BaseNode} parent\n\t * @param {string} [prop]\n\t * @param {number} [index]\n\t * @returns {Promise<BaseNode>}\n\t */\n\tasync visit(node, parent, prop, index) {\n\t\tif (node) {\n\t\t\tif (this.enter) {\n\t\t\t\tconst _should_skip = this.should_skip;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tthis.should_skip = false;\n\t\t\t\tthis.should_remove = false;\n\t\t\t\tthis.replacement = null;\n\n\t\t\t\tawait this.enter.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst skipped = this.should_skip;\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.should_skip = _should_skip;\n\t\t\t\tthis.should_remove = _should_remove;\n\t\t\t\tthis.replacement = _replacement;\n\n\t\t\t\tif (skipped) return node;\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\n\t\t\tfor (const key in node) {\n\t\t\t\tconst value = node[key];\n\n\t\t\t\tif (typeof value !== \"object\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (Array.isArray(value)) {\n\t\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t\tif (value[i] !== null && typeof value[i].type === 'string') {\n\t\t\t\t\t\t\tif (!(await this.visit(value[i], node, key, i))) {\n\t\t\t\t\t\t\t\t// removed\n\t\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (value !== null && typeof value.type === \"string\") {\n\t\t\t\t\tawait this.visit(value, node, key, null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.leave) {\n\t\t\t\tconst _replacement = this.replacement;\n\t\t\t\tconst _should_remove = this.should_remove;\n\t\t\t\tthis.replacement = null;\n\t\t\t\tthis.should_remove = false;\n\n\t\t\t\tawait this.leave.call(this.context, node, parent, prop, index);\n\n\t\t\t\tif (this.replacement) {\n\t\t\t\t\tnode = this.replacement;\n\t\t\t\t\tthis.replace(parent, prop, index, node);\n\t\t\t\t}\n\n\t\t\t\tif (this.should_remove) {\n\t\t\t\t\tthis.remove(parent, prop, index);\n\t\t\t\t}\n\n\t\t\t\tconst removed = this.should_remove;\n\n\t\t\t\tthis.replacement = _replacement;\n\t\t\t\tthis.should_remove = _should_remove;\n\n\t\t\t\tif (removed) return null;\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n}\n\n// @ts-check\n\n/** @typedef { import('estree').BaseNode} BaseNode */\n/** @typedef { import('./sync.js').SyncHandler} SyncHandler */\n/** @typedef { import('./async.js').AsyncHandler} AsyncHandler */\n\n/**\n *\n * @param {BaseNode} ast\n * @param {{\n *   enter?: SyncHandler\n *   leave?: SyncHandler\n * }} walker\n * @returns {BaseNode}\n */\nfunction walk(ast, { enter, leave }) {\n\tconst instance = new SyncWalker(enter, leave);\n\treturn instance.visit(ast, null);\n}\n\n/**\n *\n * @param {BaseNode} ast\n * @param {{\n *   enter?: AsyncHandler\n *   leave?: AsyncHandler\n * }} walker\n * @returns {Promise<BaseNode>}\n */\nasync function asyncWalk(ast, { enter, leave }) {\n\tconst instance = new AsyncWalker(enter, leave);\n\treturn await instance.visit(ast, null);\n}\n\nexport { asyncWalk, walk };\n", "// should only use types from @babel/types\n// do not import runtime methods\nimport type {\n  Identifier,\n  Node,\n  Function,\n  ObjectProperty,\n  BlockStatement,\n  Program\n} from '@babel/types'\nimport { walk } from 'estree-walker'\n\nexport function walkIdentifiers(\n  root: Node,\n  onIdentifier: (\n    node: Identifier,\n    parent: Node,\n    parentStack: Node[],\n    isReference: boolean,\n    isLocal: boolean\n  ) => void,\n  includeAll = false,\n  parentStack: Node[] = [],\n  knownIds: Record<string, number> = Object.create(null)\n) {\n  if (__BROWSER__) {\n    return\n  }\n\n  const rootExp =\n    root.type === 'Program' &&\n    root.body[0].type === 'ExpressionStatement' &&\n    root.body[0].expression\n\n  ;(walk as any)(root, {\n    enter(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\n      parent && parentStack.push(parent)\n      if (\n        parent &&\n        parent.type.startsWith('TS') &&\n        parent.type !== 'TSAsExpression' &&\n        parent.type !== 'TSNonNullExpression' &&\n        parent.type !== 'TSTypeAssertion'\n      ) {\n        return this.skip()\n      }\n      if (node.type === 'Identifier') {\n        const isLocal = !!knownIds[node.name]\n        const isRefed = isReferencedIdentifier(node, parent!, parentStack)\n        if (includeAll || (isRefed && !isLocal)) {\n          onIdentifier(node, parent!, parentStack, isRefed, isLocal)\n        }\n      } else if (\n        node.type === 'ObjectProperty' &&\n        parent!.type === 'ObjectPattern'\n      ) {\n        // mark property in destructure pattern\n        ;(node as any).inPattern = true\n      } else if (isFunctionType(node)) {\n        // walk function expressions and add its arguments to known identifiers\n        // so that we don't prefix them\n        walkFunctionParams(node, id => markScopeIdentifier(node, id, knownIds))\n      } else if (node.type === 'BlockStatement') {\n        // #3445 record block-level local variables\n        walkBlockDeclarations(node, id =>\n          markScopeIdentifier(node, id, knownIds)\n        )\n      }\n    },\n    leave(node: Node & { scopeIds?: Set<string> }, parent: Node | undefined) {\n      parent && parentStack.pop()\n      if (node !== rootExp && node.scopeIds) {\n        for (const id of node.scopeIds) {\n          knownIds[id]--\n          if (knownIds[id] === 0) {\n            delete knownIds[id]\n          }\n        }\n      }\n    }\n  })\n}\n\nexport function isReferencedIdentifier(\n  id: Identifier,\n  parent: Node | null,\n  parentStack: Node[]\n) {\n  if (__BROWSER__) {\n    return false\n  }\n\n  if (!parent) {\n    return true\n  }\n\n  // is a special keyword but parsed as identifier\n  if (id.name === 'arguments') {\n    return false\n  }\n\n  if (isReferenced(id, parent)) {\n    return true\n  }\n\n  // babel's isReferenced check returns false for ids being assigned to, so we\n  // need to cover those cases here\n  switch (parent.type) {\n    case 'AssignmentExpression':\n    case 'AssignmentPattern':\n      return true\n    case 'ObjectPattern':\n    case 'ArrayPattern':\n      return isInDestructureAssignment(parent, parentStack)\n  }\n\n  return false\n}\n\nexport function isInDestructureAssignment(\n  parent: Node,\n  parentStack: Node[]\n): boolean {\n  if (\n    parent &&\n    (parent.type === 'ObjectProperty' || parent.type === 'ArrayPattern')\n  ) {\n    let i = parentStack.length\n    while (i--) {\n      const p = parentStack[i]\n      if (p.type === 'AssignmentExpression') {\n        return true\n      } else if (p.type !== 'ObjectProperty' && !p.type.endsWith('Pattern')) {\n        break\n      }\n    }\n  }\n  return false\n}\n\nexport function walkFunctionParams(\n  node: Function,\n  onIdent: (id: Identifier) => void\n) {\n  for (const p of node.params) {\n    for (const id of extractIdentifiers(p)) {\n      onIdent(id)\n    }\n  }\n}\n\nexport function walkBlockDeclarations(\n  block: BlockStatement | Program,\n  onIdent: (node: Identifier) => void\n) {\n  for (const stmt of block.body) {\n    if (stmt.type === 'VariableDeclaration') {\n      if (stmt.declare) continue\n      for (const decl of stmt.declarations) {\n        for (const id of extractIdentifiers(decl.id)) {\n          onIdent(id)\n        }\n      }\n    } else if (\n      stmt.type === 'FunctionDeclaration' ||\n      stmt.type === 'ClassDeclaration'\n    ) {\n      if (stmt.declare || !stmt.id) continue\n      onIdent(stmt.id)\n    }\n  }\n}\n\nexport function extractIdentifiers(\n  param: Node,\n  nodes: Identifier[] = []\n): Identifier[] {\n  switch (param.type) {\n    case 'Identifier':\n      nodes.push(param)\n      break\n\n    case 'MemberExpression':\n      let object: any = param\n      while (object.type === 'MemberExpression') {\n        object = object.object\n      }\n      nodes.push(object)\n      break\n\n    case 'ObjectPattern':\n      for (const prop of param.properties) {\n        if (prop.type === 'RestElement') {\n          extractIdentifiers(prop.argument, nodes)\n        } else {\n          extractIdentifiers(prop.value, nodes)\n        }\n      }\n      break\n\n    case 'ArrayPattern':\n      param.elements.forEach(element => {\n        if (element) extractIdentifiers(element, nodes)\n      })\n      break\n\n    case 'RestElement':\n      extractIdentifiers(param.argument, nodes)\n      break\n\n    case 'AssignmentPattern':\n      extractIdentifiers(param.left, nodes)\n      break\n  }\n\n  return nodes\n}\n\nfunction markScopeIdentifier(\n  node: Node & { scopeIds?: Set<string> },\n  child: Identifier,\n  knownIds: Record<string, number>\n) {\n  const { name } = child\n  if (node.scopeIds && node.scopeIds.has(name)) {\n    return\n  }\n  if (name in knownIds) {\n    knownIds[name]++\n  } else {\n    knownIds[name] = 1\n  }\n  ;(node.scopeIds || (node.scopeIds = new Set())).add(name)\n}\n\nexport const isFunctionType = (node: Node): node is Function => {\n  return /Function(?:Expression|Declaration)$|Method$/.test(node.type)\n}\n\nexport const isStaticProperty = (node: Node): node is ObjectProperty =>\n  node &&\n  (node.type === 'ObjectProperty' || node.type === 'ObjectMethod') &&\n  !node.computed\n\nexport const isStaticPropertyKey = (node: Node, parent: Node) =>\n  isStaticProperty(parent) && parent.key === node\n\n/**\n * Copied from https://github.com/babel/babel/blob/main/packages/babel-types/src/validators/isReferenced.ts\n * To avoid runtime dependency on @babel/types (which includes process references)\n * This file should not change very often in babel but we may need to keep it\n * up-to-date from time to time.\n *\n * https://github.com/babel/babel/blob/main/LICENSE\n *\n */\nfunction isReferenced(node: Node, parent: Node, grandparent?: Node): boolean {\n  switch (parent.type) {\n    // yes: PARENT[NODE]\n    // yes: NODE.child\n    // no: parent.NODE\n    case 'MemberExpression':\n    case 'OptionalMemberExpression':\n      if (parent.property === node) {\n        return !!parent.computed\n      }\n      return parent.object === node\n\n    case 'JSXMemberExpression':\n      return parent.object === node\n    // no: let NODE = init;\n    // yes: let id = NODE;\n    case 'VariableDeclarator':\n      return parent.init === node\n\n    // yes: () => NODE\n    // no: (NODE) => {}\n    case 'ArrowFunctionExpression':\n      return parent.body === node\n\n    // no: class { #NODE; }\n    // no: class { get #NODE() {} }\n    // no: class { #NODE() {} }\n    // no: class { fn() { return this.#NODE; } }\n    case 'PrivateName':\n      return false\n\n    // no: class { NODE() {} }\n    // yes: class { [NODE]() {} }\n    // no: class { foo(NODE) {} }\n    case 'ClassMethod':\n    case 'ClassPrivateMethod':\n    case 'ObjectMethod':\n      if (parent.key === node) {\n        return !!parent.computed\n      }\n      return false\n\n    // yes: { [NODE]: \"\" }\n    // no: { NODE: \"\" }\n    // depends: { NODE }\n    // depends: { key: NODE }\n    case 'ObjectProperty':\n      if (parent.key === node) {\n        return !!parent.computed\n      }\n      // parent.value === node\n      return !grandparent || grandparent.type !== 'ObjectPattern'\n    // no: class { NODE = value; }\n    // yes: class { [NODE] = value; }\n    // yes: class { key = NODE; }\n    case 'ClassProperty':\n      if (parent.key === node) {\n        return !!parent.computed\n      }\n      return true\n    case 'ClassPrivateProperty':\n      return parent.key !== node\n\n    // no: class NODE {}\n    // yes: class Foo extends NODE {}\n    case 'ClassDeclaration':\n    case 'ClassExpression':\n      return parent.superClass === node\n\n    // yes: left = NODE;\n    // no: NODE = right;\n    case 'AssignmentExpression':\n      return parent.right === node\n\n    // no: [NODE = foo] = [];\n    // yes: [foo = NODE] = [];\n    case 'AssignmentPattern':\n      return parent.right === node\n\n    // no: NODE: for (;;) {}\n    case 'LabeledStatement':\n      return false\n\n    // no: try {} catch (NODE) {}\n    case 'CatchClause':\n      return false\n\n    // no: function foo(...NODE) {}\n    case 'RestElement':\n      return false\n\n    case 'BreakStatement':\n    case 'ContinueStatement':\n      return false\n\n    // no: function NODE() {}\n    // no: function foo(NODE) {}\n    case 'FunctionDeclaration':\n    case 'FunctionExpression':\n      return false\n\n    // no: export NODE from \"foo\";\n    // no: export * as NODE from \"foo\";\n    case 'ExportNamespaceSpecifier':\n    case 'ExportDefaultSpecifier':\n      return false\n\n    // no: export { foo as NODE };\n    // yes: export { NODE as foo };\n    // no: export { NODE as foo } from \"foo\";\n    case 'ExportSpecifier':\n      // @ts-expect-error\n      if (grandparent?.source) {\n        return false\n      }\n      return parent.local === node\n\n    // no: import NODE from \"foo\";\n    // no: import * as NODE from \"foo\";\n    // no: import { NODE as foo } from \"foo\";\n    // no: import { foo as NODE } from \"foo\";\n    // no: import NODE from \"bar\";\n    case 'ImportDefaultSpecifier':\n    case 'ImportNamespaceSpecifier':\n    case 'ImportSpecifier':\n      return false\n\n    // no: import \"foo\" assert { NODE: \"json\" }\n    case 'ImportAttribute':\n      return false\n\n    // no: <div NODE=\"foo\" />\n    case 'JSXAttribute':\n      return false\n\n    // no: [NODE] = [];\n    // no: ({ NODE }) = [];\n    case 'ObjectPattern':\n    case 'ArrayPattern':\n      return false\n\n    // no: new.NODE\n    // no: NODE.target\n    case 'MetaProperty':\n      return false\n\n    // yes: type X = { someProperty: NODE }\n    // no: type X = { NODE: OtherType }\n    case 'ObjectTypeProperty':\n      return parent.key !== node\n\n    // yes: enum X { Foo = NODE }\n    // no: enum X { NODE }\n    case 'TSEnumMember':\n      return parent.id !== node\n\n    // yes: { [NODE]: value }\n    // no: { NODE: value }\n    case 'TSPropertySignature':\n      if (parent.key === node) {\n        return !!parent.computed\n      }\n\n      return true\n  }\n\n  return true\n}\n", "// these keywords should not appear inside expressions, but operators like\n\nimport { SimpleExpressionNode } from './ast'\nimport { TransformContext } from './transform'\nimport { createCompilerError, ErrorCodes } from './errors'\n\n// typeof, instanceof and in are allowed\nconst prohibitedKeywordRE = new RegExp(\n  '\\\\b' +\n    (\n      'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n      'super,throw,while,yield,delete,export,import,return,switch,default,' +\n      'extends,finally,continue,debugger,function,arguments,typeof,void'\n    )\n      .split(',')\n      .join('\\\\b|\\\\b') +\n    '\\\\b'\n)\n\n// strip strings in expressions\nconst stripStringRE =\n  /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g\n\n/**\n * Validate a non-prefixed expression.\n * This is only called when using the in-browser runtime compiler since it\n * doesn't prefix expressions.\n */\nexport function validateBrowserExpression(\n  node: SimpleExpressionNode,\n  context: TransformContext,\n  asParams = false,\n  asRawStatements = false\n) {\n  const exp = node.content\n\n  // empty expressions are validated per-directive since some directives\n  // do allow empty expressions.\n  if (!exp.trim()) {\n    return\n  }\n\n  try {\n    new Function(\n      asRawStatements\n        ? ` ${exp} `\n        : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`\n    )\n  } catch (e: any) {\n    let message = e.message\n    const keywordMatch = exp\n      .replace(stripStringRE, '')\n      .match(prohibitedKeywordRE)\n    if (keywordMatch) {\n      message = `avoid using JavaScript keyword as property name: \"${keywordMatch[0]}\"`\n    }\n    context.onError(\n      createCompilerError(\n        ErrorCodes.X_INVALID_EXPRESSION,\n        node.loc,\n        undefined,\n        message\n      )\n    )\n  }\n}\n", "// - Parse expressions in templates into compound expressions so that each\n//   identifier gets more accurate source-map locations.\n//\n// - Prefix identifiers with `_ctx.` or `$xxx` (for known binding types) so that\n//   they are accessed from the right source\n//\n// - This transform is only applied in non-browser builds because it relies on\n//   an additional JavaScript parser. In the browser, there is no source-map\n//   support and the code is wrapped in `with (this) { ... }`.\nimport { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  createSimpleExpression,\n  ExpressionNode,\n  SimpleExpressionNode,\n  CompoundExpressionNode,\n  createCompoundExpression,\n  ConstantTypes\n} from '../ast'\nimport {\n  isInDestructureAssignment,\n  isStaticProperty,\n  isStaticPropertyKey,\n  walkIdentifiers\n} from '../babelUtils'\nimport { advancePositionWithClone, isSimpleIdentifier } from '../utils'\nimport { isGloballyWhitelisted, makeMap, hasOwn, isString } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  Node,\n  Identifier,\n  AssignmentExpression,\n  UpdateExpression\n} from '@babel/types'\nimport { validateBrowserExpression } from '../validateExpression'\nimport { parse } from '@babel/parser'\nimport { IS_REF, UNREF } from '../runtimeHelpers'\nimport { BindingTypes } from '../options'\n\nconst isLiteralWhitelisted = /*#__PURE__*/ makeMap('true,false,null,this')\n\nexport const transformExpression: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.INTERPOLATION) {\n    node.content = processExpression(\n      node.content as SimpleExpressionNode,\n      context\n    )\n  } else if (node.type === NodeTypes.ELEMENT) {\n    // handle directives on element\n    for (let i = 0; i < node.props.length; i++) {\n      const dir = node.props[i]\n      // do not process for v-on & v-for since they are special handled\n      if (dir.type === NodeTypes.DIRECTIVE && dir.name !== 'for') {\n        const exp = dir.exp\n        const arg = dir.arg\n        // do not process exp if this is v-on:arg - we need special handling\n        // for wrapping inline statements.\n        if (\n          exp &&\n          exp.type === NodeTypes.SIMPLE_EXPRESSION &&\n          !(dir.name === 'on' && arg)\n        ) {\n          dir.exp = processExpression(\n            exp,\n            context,\n            // slot args must be processed as function params\n            dir.name === 'slot'\n          )\n        }\n        if (arg && arg.type === NodeTypes.SIMPLE_EXPRESSION && !arg.isStatic) {\n          dir.arg = processExpression(arg, context)\n        }\n      }\n    }\n  }\n}\n\ninterface PrefixMeta {\n  prefix?: string\n  isConstant: boolean\n  start: number\n  end: number\n  scopeIds?: Set<string>\n}\n\n// Important: since this function uses Node.js only dependencies, it should\n// always be used with a leading !__BROWSER__ check so that it can be\n// tree-shaken from the browser build.\nexport function processExpression(\n  node: SimpleExpressionNode,\n  context: TransformContext,\n  // some expressions like v-slot props & v-for aliases should be parsed as\n  // function params\n  asParams = false,\n  // v-on handler values may contain multiple statements\n  asRawStatements = false,\n  localVars: Record<string, number> = Object.create(context.identifiers)\n): ExpressionNode {\n  if (__BROWSER__) {\n    if (__DEV__) {\n      // simple in-browser validation (same logic in 2.x)\n      validateBrowserExpression(node, context, asParams, asRawStatements)\n    }\n    return node\n  }\n\n  if (!context.prefixIdentifiers || !node.content.trim()) {\n    return node\n  }\n\n  const { inline, bindingMetadata } = context\n  const rewriteIdentifier = (raw: string, parent?: Node, id?: Identifier) => {\n    const type = hasOwn(bindingMetadata, raw) && bindingMetadata[raw]\n    if (inline) {\n      // x = y\n      const isAssignmentLVal =\n        parent && parent.type === 'AssignmentExpression' && parent.left === id\n      // x++\n      const isUpdateArg =\n        parent && parent.type === 'UpdateExpression' && parent.argument === id\n      // ({ x } = y)\n      const isDestructureAssignment =\n        parent && isInDestructureAssignment(parent, parentStack)\n\n      if (type === BindingTypes.SETUP_CONST || localVars[raw]) {\n        return raw\n      } else if (type === BindingTypes.SETUP_REF) {\n        return `${raw}.value`\n      } else if (type === BindingTypes.SETUP_MAYBE_REF) {\n        // const binding that may or may not be ref\n        // if it's not a ref, then assignments don't make sense -\n        // so we ignore the non-ref assignment case and generate code\n        // that assumes the value to be a ref for more efficiency\n        return isAssignmentLVal || isUpdateArg || isDestructureAssignment\n          ? `${raw}.value`\n          : `${context.helperString(UNREF)}(${raw})`\n      } else if (type === BindingTypes.SETUP_LET) {\n        if (isAssignmentLVal) {\n          // let binding.\n          // this is a bit more tricky as we need to cover the case where\n          // let is a local non-ref value, and we need to replicate the\n          // right hand side value.\n          // x = y --> isRef(x) ? x.value = y : x = y\n          const { right: rVal, operator } = parent as AssignmentExpression\n          const rExp = rawExp.slice(rVal.start! - 1, rVal.end! - 1)\n          const rExpString = stringifyExpression(\n            processExpression(\n              createSimpleExpression(rExp, false),\n              context,\n              false,\n              false,\n              knownIds\n            )\n          )\n          return `${context.helperString(IS_REF)}(${raw})${\n            context.isTS ? ` //@ts-ignore\\n` : ``\n          } ? ${raw}.value ${operator} ${rExpString} : ${raw}`\n        } else if (isUpdateArg) {\n          // make id replace parent in the code range so the raw update operator\n          // is removed\n          id!.start = parent!.start\n          id!.end = parent!.end\n          const { prefix: isPrefix, operator } = parent as UpdateExpression\n          const prefix = isPrefix ? operator : ``\n          const postfix = isPrefix ? `` : operator\n          // let binding.\n          // x++ --> isRef(a) ? a.value++ : a++\n          return `${context.helperString(IS_REF)}(${raw})${\n            context.isTS ? ` //@ts-ignore\\n` : ``\n          } ? ${prefix}${raw}.value${postfix} : ${prefix}${raw}${postfix}`\n        } else if (isDestructureAssignment) {\n          // TODO\n          // let binding in a destructure assignment - it's very tricky to\n          // handle both possible cases here without altering the original\n          // structure of the code, so we just assume it's not a ref here\n          // for now\n          return raw\n        } else {\n          return `${context.helperString(UNREF)}(${raw})`\n        }\n      } else if (type === BindingTypes.PROPS) {\n        // use __props which is generated by compileScript so in ts mode\n        // it gets correct type\n        return `__props.${raw}`\n      } else if (type === BindingTypes.PROPS_ALIASED) {\n        // prop with a different local alias (from defineProps() destructure)\n        return `__props.${bindingMetadata.__propsAliases![raw]}`\n      }\n    } else {\n      if (type && type.startsWith('setup')) {\n        // setup bindings in non-inline mode\n        return `$setup.${raw}`\n      } else if (type === BindingTypes.PROPS_ALIASED) {\n        return `$props.${bindingMetadata.__propsAliases![raw]}`\n      } else if (type) {\n        return `$${type}.${raw}`\n      }\n    }\n\n    // fallback to ctx\n    return `_ctx.${raw}`\n  }\n\n  // fast path if expression is a simple identifier.\n  const rawExp = node.content\n  // bail constant on parens (function invocation) and dot (member access)\n  const bailConstant = rawExp.indexOf(`(`) > -1 || rawExp.indexOf('.') > 0\n\n  if (isSimpleIdentifier(rawExp)) {\n    const isScopeVarReference = context.identifiers[rawExp]\n    const isAllowedGlobal = isGloballyWhitelisted(rawExp)\n    const isLiteral = isLiteralWhitelisted(rawExp)\n    if (!asParams && !isScopeVarReference && !isAllowedGlobal && !isLiteral) {\n      // const bindings exposed from setup can be skipped for patching but\n      // cannot be hoisted to module scope\n      if (bindingMetadata[node.content] === BindingTypes.SETUP_CONST) {\n        node.constType = ConstantTypes.CAN_SKIP_PATCH\n      }\n      node.content = rewriteIdentifier(rawExp)\n    } else if (!isScopeVarReference) {\n      if (isLiteral) {\n        node.constType = ConstantTypes.CAN_STRINGIFY\n      } else {\n        node.constType = ConstantTypes.CAN_HOIST\n      }\n    }\n    return node\n  }\n\n  let ast: any\n  // exp needs to be parsed differently:\n  // 1. Multiple inline statements (v-on, with presence of `;`): parse as raw\n  //    exp, but make sure to pad with spaces for consistent ranges\n  // 2. Expressions: wrap with parens (for e.g. object expressions)\n  // 3. Function arguments (v-for, v-slot): place in a function argument position\n  const source = asRawStatements\n    ? ` ${rawExp} `\n    : `(${rawExp})${asParams ? `=>{}` : ``}`\n  try {\n    ast = parse(source, {\n      plugins: context.expressionPlugins\n    }).program\n  } catch (e: any) {\n    context.onError(\n      createCompilerError(\n        ErrorCodes.X_INVALID_EXPRESSION,\n        node.loc,\n        undefined,\n        e.message\n      )\n    )\n    return node\n  }\n\n  type QualifiedId = Identifier & PrefixMeta\n  const ids: QualifiedId[] = []\n  const parentStack: Node[] = []\n  const knownIds: Record<string, number> = Object.create(context.identifiers)\n\n  walkIdentifiers(\n    ast,\n    (node, parent, _, isReferenced, isLocal) => {\n      if (isStaticPropertyKey(node, parent!)) {\n        return\n      }\n      // v2 wrapped filter call\n      if (__COMPAT__ && node.name.startsWith('_filter_')) {\n        return\n      }\n\n      const needPrefix = isReferenced && canPrefix(node)\n      if (needPrefix && !isLocal) {\n        if (isStaticProperty(parent!) && parent.shorthand) {\n          // property shorthand like { foo }, we need to add the key since\n          // we rewrite the value\n          ;(node as QualifiedId).prefix = `${node.name}: `\n        }\n        node.name = rewriteIdentifier(node.name, parent, node)\n        ids.push(node as QualifiedId)\n      } else {\n        // The identifier is considered constant unless it's pointing to a\n        // local scope variable (a v-for alias, or a v-slot prop)\n        if (!(needPrefix && isLocal) && !bailConstant) {\n          ;(node as QualifiedId).isConstant = true\n        }\n        // also generate sub-expressions for other identifiers for better\n        // source map support. (except for property keys which are static)\n        ids.push(node as QualifiedId)\n      }\n    },\n    true, // invoke on ALL identifiers\n    parentStack,\n    knownIds\n  )\n\n  // We break up the compound expression into an array of strings and sub\n  // expressions (for identifiers that have been prefixed). In codegen, if\n  // an ExpressionNode has the `.children` property, it will be used instead of\n  // `.content`.\n  const children: CompoundExpressionNode['children'] = []\n  ids.sort((a, b) => a.start - b.start)\n  ids.forEach((id, i) => {\n    // range is offset by -1 due to the wrapping parens when parsed\n    const start = id.start - 1\n    const end = id.end - 1\n    const last = ids[i - 1]\n    const leadingText = rawExp.slice(last ? last.end - 1 : 0, start)\n    if (leadingText.length || id.prefix) {\n      children.push(leadingText + (id.prefix || ``))\n    }\n    const source = rawExp.slice(start, end)\n    children.push(\n      createSimpleExpression(\n        id.name,\n        false,\n        {\n          source,\n          start: advancePositionWithClone(node.loc.start, source, start),\n          end: advancePositionWithClone(node.loc.start, source, end)\n        },\n        id.isConstant ? ConstantTypes.CAN_STRINGIFY : ConstantTypes.NOT_CONSTANT\n      )\n    )\n    if (i === ids.length - 1 && end < rawExp.length) {\n      children.push(rawExp.slice(end))\n    }\n  })\n\n  let ret\n  if (children.length) {\n    ret = createCompoundExpression(children, node.loc)\n  } else {\n    ret = node\n    ret.constType = bailConstant\n      ? ConstantTypes.NOT_CONSTANT\n      : ConstantTypes.CAN_STRINGIFY\n  }\n  ret.identifiers = Object.keys(knownIds)\n  return ret\n}\n\nfunction canPrefix(id: Identifier) {\n  // skip whitelisted globals\n  if (isGloballyWhitelisted(id.name)) {\n    return false\n  }\n  // special case for webpack compilation\n  if (id.name === 'require') {\n    return false\n  }\n  return true\n}\n\nfunction stringifyExpression(exp: ExpressionNode | string): string {\n  if (isString(exp)) {\n    return exp\n  } else if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n    return exp.content\n  } else {\n    return (exp.children as (ExpressionNode | string)[])\n      .map(stringifyExpression)\n      .join('')\n  }\n}\n", "import {\n  createStructuralDirectiveTransform,\n  TransformContext,\n  traverseNode\n} from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  ElementNode,\n  DirectiveNode,\n  IfBranchNode,\n  SimpleExpressionNode,\n  createCallExpression,\n  createConditionalExpression,\n  createSimpleExpression,\n  createObjectProperty,\n  createObjectExpression,\n  IfConditionalExpression,\n  BlockCodegenNode,\n  IfNode,\n  createVNodeCall,\n  AttributeNode,\n  locStub,\n  CacheExpression,\n  ConstantTypes,\n  MemoExpression\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport { validateBrowserExpression } from '../validateExpression'\nimport { FRAGMENT, CREATE_COMMENT } from '../runtimeHelpers'\nimport {\n  injectProp,\n  findDir,\n  findProp,\n  isBuiltInType,\n  makeBlock\n} from '../utils'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\nimport { getMemoedVNodeCall } from '..'\n\nexport const transformIf = createStructuralDirectiveTransform(\n  /^(if|else|else-if)$/,\n  (node, dir, context) => {\n    return processIf(node, dir, context, (ifNode, branch, isRoot) => {\n      // #1587: We need to dynamically increment the key based on the current\n      // node's sibling nodes, since chained v-if/else branches are\n      // rendered at the same depth\n      const siblings = context.parent!.children\n      let i = siblings.indexOf(ifNode)\n      let key = 0\n      while (i-- >= 0) {\n        const sibling = siblings[i]\n        if (sibling && sibling.type === NodeTypes.IF) {\n          key += sibling.branches.length\n        }\n      }\n\n      // Exit callback. Complete the codegenNode when all children have been\n      // transformed.\n      return () => {\n        if (isRoot) {\n          ifNode.codegenNode = createCodegenNodeForBranch(\n            branch,\n            key,\n            context\n          ) as IfConditionalExpression\n        } else {\n          // attach this branch's codegen node to the v-if root.\n          const parentCondition = getParentCondition(ifNode.codegenNode!)\n          parentCondition.alternate = createCodegenNodeForBranch(\n            branch,\n            key + ifNode.branches.length - 1,\n            context\n          )\n        }\n      }\n    })\n  }\n)\n\n// target-agnostic transform used for both Client and SSR\nexport function processIf(\n  node: ElementNode,\n  dir: DirectiveNode,\n  context: TransformContext,\n  processCodegen?: (\n    node: IfNode,\n    branch: IfBranchNode,\n    isRoot: boolean\n  ) => (() => void) | undefined\n) {\n  if (\n    dir.name !== 'else' &&\n    (!dir.exp || !(dir.exp as SimpleExpressionNode).content.trim())\n  ) {\n    const loc = dir.exp ? dir.exp.loc : node.loc\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_IF_NO_EXPRESSION, dir.loc)\n    )\n    dir.exp = createSimpleExpression(`true`, false, loc)\n  }\n\n  if (!__BROWSER__ && context.prefixIdentifiers && dir.exp) {\n    // dir.exp can only be simple expression because vIf transform is applied\n    // before expression transform.\n    dir.exp = processExpression(dir.exp as SimpleExpressionNode, context)\n  }\n\n  if (__DEV__ && __BROWSER__ && dir.exp) {\n    validateBrowserExpression(dir.exp as SimpleExpressionNode, context)\n  }\n\n  if (dir.name === 'if') {\n    const branch = createIfBranch(node, dir)\n    const ifNode: IfNode = {\n      type: NodeTypes.IF,\n      loc: node.loc,\n      branches: [branch]\n    }\n    context.replaceNode(ifNode)\n    if (processCodegen) {\n      return processCodegen(ifNode, branch, true)\n    }\n  } else {\n    // locate the adjacent v-if\n    const siblings = context.parent!.children\n    const comments = []\n    let i = siblings.indexOf(node)\n    while (i-- >= -1) {\n      const sibling = siblings[i]\n      if (__DEV__ && sibling && sibling.type === NodeTypes.COMMENT) {\n        context.removeNode(sibling)\n        comments.unshift(sibling)\n        continue\n      }\n\n      if (\n        sibling &&\n        sibling.type === NodeTypes.TEXT &&\n        !sibling.content.trim().length\n      ) {\n        context.removeNode(sibling)\n        continue\n      }\n\n      if (sibling && sibling.type === NodeTypes.IF) {\n        // Check if v-else was followed by v-else-if\n        if (\n          dir.name === 'else-if' &&\n          sibling.branches[sibling.branches.length - 1].condition === undefined\n        ) {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\n          )\n        }\n\n        // move the node to the if node's branches\n        context.removeNode()\n        const branch = createIfBranch(node, dir)\n        if (\n          __DEV__ &&\n          comments.length &&\n          // #3619 ignore comments if the v-if is direct child of <transition>\n          !(\n            context.parent &&\n            context.parent.type === NodeTypes.ELEMENT &&\n            isBuiltInType(context.parent.tag, 'transition')\n          )\n        ) {\n          branch.children = [...comments, ...branch.children]\n        }\n\n        // check if user is forcing same key on different branches\n        if (__DEV__ || !__BROWSER__) {\n          const key = branch.userKey\n          if (key) {\n            sibling.branches.forEach(({ userKey }) => {\n              if (isSameKey(userKey, key)) {\n                context.onError(\n                  createCompilerError(\n                    ErrorCodes.X_V_IF_SAME_KEY,\n                    branch.userKey!.loc\n                  )\n                )\n              }\n            })\n          }\n        }\n\n        sibling.branches.push(branch)\n        const onExit = processCodegen && processCodegen(sibling, branch, false)\n        // since the branch was removed, it will not be traversed.\n        // make sure to traverse here.\n        traverseNode(branch, context)\n        // call on exit\n        if (onExit) onExit()\n        // make sure to reset currentNode after traversal to indicate this\n        // node has been removed.\n        context.currentNode = null\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, node.loc)\n        )\n      }\n      break\n    }\n  }\n}\n\nfunction createIfBranch(node: ElementNode, dir: DirectiveNode): IfBranchNode {\n  return {\n    type: NodeTypes.IF_BRANCH,\n    loc: node.loc,\n    condition: dir.name === 'else' ? undefined : dir.exp,\n    children:\n      node.tagType === ElementTypes.TEMPLATE && !findDir(node, 'for')\n        ? node.children\n        : [node],\n    userKey: findProp(node, `key`)\n  }\n}\n\nfunction createCodegenNodeForBranch(\n  branch: IfBranchNode,\n  keyIndex: number,\n  context: TransformContext\n): IfConditionalExpression | BlockCodegenNode | MemoExpression {\n  if (branch.condition) {\n    return createConditionalExpression(\n      branch.condition,\n      createChildrenCodegenNode(branch, keyIndex, context),\n      // make sure to pass in asBlock: true so that the comment node call\n      // closes the current block.\n      createCallExpression(context.helper(CREATE_COMMENT), [\n        __DEV__ ? '\"v-if\"' : '\"\"',\n        'true'\n      ])\n    ) as IfConditionalExpression\n  } else {\n    return createChildrenCodegenNode(branch, keyIndex, context)\n  }\n}\n\nfunction createChildrenCodegenNode(\n  branch: IfBranchNode,\n  keyIndex: number,\n  context: TransformContext\n): BlockCodegenNode | MemoExpression {\n  const { helper } = context\n  const keyProperty = createObjectProperty(\n    `key`,\n    createSimpleExpression(\n      `${keyIndex}`,\n      false,\n      locStub,\n      ConstantTypes.CAN_HOIST\n    )\n  )\n  const { children } = branch\n  const firstChild = children[0]\n  const needFragmentWrapper =\n    children.length !== 1 || firstChild.type !== NodeTypes.ELEMENT\n  if (needFragmentWrapper) {\n    if (children.length === 1 && firstChild.type === NodeTypes.FOR) {\n      // optimize away nested fragments when child is a ForNode\n      const vnodeCall = firstChild.codegenNode!\n      injectProp(vnodeCall, keyProperty, context)\n      return vnodeCall\n    } else {\n      let patchFlag = PatchFlags.STABLE_FRAGMENT\n      let patchFlagText = PatchFlagNames[PatchFlags.STABLE_FRAGMENT]\n      // check if the fragment actually contains a single valid child with\n      // the rest being comments\n      if (\n        __DEV__ &&\n        children.filter(c => c.type !== NodeTypes.COMMENT).length === 1\n      ) {\n        patchFlag |= PatchFlags.DEV_ROOT_FRAGMENT\n        patchFlagText += `, ${PatchFlagNames[PatchFlags.DEV_ROOT_FRAGMENT]}`\n      }\n\n      return createVNodeCall(\n        context,\n        helper(FRAGMENT),\n        createObjectExpression([keyProperty]),\n        children,\n        patchFlag + (__DEV__ ? ` /* ${patchFlagText} */` : ``),\n        undefined,\n        undefined,\n        true,\n        false,\n        false /* isComponent */,\n        branch.loc\n      )\n    }\n  } else {\n    const ret = (firstChild as ElementNode).codegenNode as\n      | BlockCodegenNode\n      | MemoExpression\n    const vnodeCall = getMemoedVNodeCall(ret)\n    // Change createVNode to createBlock.\n    if (vnodeCall.type === NodeTypes.VNODE_CALL) {\n      makeBlock(vnodeCall, context)\n    }\n    // inject branch key\n    injectProp(vnodeCall, keyProperty, context)\n    return ret\n  }\n}\n\nfunction isSameKey(\n  a: AttributeNode | DirectiveNode | undefined,\n  b: AttributeNode | DirectiveNode\n): boolean {\n  if (!a || a.type !== b.type) {\n    return false\n  }\n  if (a.type === NodeTypes.ATTRIBUTE) {\n    if (a.value!.content !== (b as AttributeNode).value!.content) {\n      return false\n    }\n  } else {\n    // directive\n    const exp = a.exp!\n    const branchExp = (b as DirectiveNode).exp!\n    if (exp.type !== branchExp.type) {\n      return false\n    }\n    if (\n      exp.type !== NodeTypes.SIMPLE_EXPRESSION ||\n      exp.isStatic !== (branchExp as SimpleExpressionNode).isStatic ||\n      exp.content !== (branchExp as SimpleExpressionNode).content\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getParentCondition(\n  node: IfConditionalExpression | CacheExpression\n): IfConditionalExpression {\n  while (true) {\n    if (node.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\n      if (node.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION) {\n        node = node.alternate\n      } else {\n        return node\n      }\n    } else if (node.type === NodeTypes.JS_CACHE_EXPRESSION) {\n      node = node.value as IfConditionalExpression\n    }\n  }\n}\n", "import {\n  createStructuralDirectiveTransform,\n  TransformContext\n} from '../transform'\nimport {\n  NodeTypes,\n  ExpressionNode,\n  createSimpleExpression,\n  SourceLocation,\n  SimpleExpressionNode,\n  createCallExpression,\n  createFunctionExpression,\n  createObjectExpression,\n  createObjectProperty,\n  ForCodegenNode,\n  RenderSlotCall,\n  SlotOutletNode,\n  ElementNode,\n  DirectiveNode,\n  ForNode,\n  PlainElementNode,\n  createVNodeCall,\n  VNodeCall,\n  ForRenderListExpression,\n  BlockCodegenNode,\n  ForIteratorExpression,\n  ConstantTypes,\n  createBlockStatement,\n  createCompoundExpression\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  getInnerRange,\n  findProp,\n  isTemplateNode,\n  isSlotOutlet,\n  injectProp,\n  getVNodeBlockHelper,\n  getVNodeHelper,\n  findDir\n} from '../utils'\nimport {\n  RENDER_LIST,\n  OPEN_BLOCK,\n  FRAGMENT,\n  IS_MEMO_SAME\n} from '../runtimeHelpers'\nimport { processExpression } from './transformExpression'\nimport { validateBrowserExpression } from '../validateExpression'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\n\nexport const transformFor = createStructuralDirectiveTransform(\n  'for',\n  (node, dir, context) => {\n    const { helper, removeHelper } = context\n    return processFor(node, dir, context, forNode => {\n      // create the loop render function expression now, and add the\n      // iterator on exit after all children have been traversed\n      const renderExp = createCallExpression(helper(RENDER_LIST), [\n        forNode.source\n      ]) as ForRenderListExpression\n      const isTemplate = isTemplateNode(node)\n      const memo = findDir(node, 'memo')\n      const keyProp = findProp(node, `key`)\n      const keyExp =\n        keyProp &&\n        (keyProp.type === NodeTypes.ATTRIBUTE\n          ? createSimpleExpression(keyProp.value!.content, true)\n          : keyProp.exp!)\n      const keyProperty = keyProp ? createObjectProperty(`key`, keyExp!) : null\n\n      if (!__BROWSER__ && isTemplate) {\n        // #2085 / #5288 process :key and v-memo expressions need to be\n        // processed on `<template v-for>`. In this case the node is discarded\n        // and never traversed so its binding expressions won't be processed\n        // by the normal transforms.\n        if (memo) {\n          memo.exp = processExpression(\n            memo.exp! as SimpleExpressionNode,\n            context\n          )\n        }\n        if (keyProperty && keyProp!.type !== NodeTypes.ATTRIBUTE) {\n          keyProperty.value = processExpression(\n            keyProperty.value as SimpleExpressionNode,\n            context\n          )\n        }\n      }\n\n      const isStableFragment =\n        forNode.source.type === NodeTypes.SIMPLE_EXPRESSION &&\n        forNode.source.constType > ConstantTypes.NOT_CONSTANT\n      const fragmentFlag = isStableFragment\n        ? PatchFlags.STABLE_FRAGMENT\n        : keyProp\n        ? PatchFlags.KEYED_FRAGMENT\n        : PatchFlags.UNKEYED_FRAGMENT\n\n      forNode.codegenNode = createVNodeCall(\n        context,\n        helper(FRAGMENT),\n        undefined,\n        renderExp,\n        fragmentFlag +\n          (__DEV__ ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``),\n        undefined,\n        undefined,\n        true /* isBlock */,\n        !isStableFragment /* disableTracking */,\n        false /* isComponent */,\n        node.loc\n      ) as ForCodegenNode\n\n      return () => {\n        // finish the codegen now that all children have been traversed\n        let childBlock: BlockCodegenNode\n        const { children } = forNode\n\n        // check <template v-for> key placement\n        if ((__DEV__ || !__BROWSER__) && isTemplate) {\n          node.children.some(c => {\n            if (c.type === NodeTypes.ELEMENT) {\n              const key = findProp(c, 'key')\n              if (key) {\n                context.onError(\n                  createCompilerError(\n                    ErrorCodes.X_V_FOR_TEMPLATE_KEY_PLACEMENT,\n                    key.loc\n                  )\n                )\n                return true\n              }\n            }\n          })\n        }\n\n        const needFragmentWrapper =\n          children.length !== 1 || children[0].type !== NodeTypes.ELEMENT\n        const slotOutlet = isSlotOutlet(node)\n          ? node\n          : isTemplate &&\n            node.children.length === 1 &&\n            isSlotOutlet(node.children[0])\n          ? (node.children[0] as SlotOutletNode) // api-extractor somehow fails to infer this\n          : null\n\n        if (slotOutlet) {\n          // <slot v-for=\"...\"> or <template v-for=\"...\"><slot/></template>\n          childBlock = slotOutlet.codegenNode as RenderSlotCall\n          if (isTemplate && keyProperty) {\n            // <template v-for=\"...\" :key=\"...\"><slot/></template>\n            // we need to inject the key to the renderSlot() call.\n            // the props for renderSlot is passed as the 3rd argument.\n            injectProp(childBlock, keyProperty, context)\n          }\n        } else if (needFragmentWrapper) {\n          // <template v-for=\"...\"> with text or multi-elements\n          // should generate a fragment block for each loop\n          childBlock = createVNodeCall(\n            context,\n            helper(FRAGMENT),\n            keyProperty ? createObjectExpression([keyProperty]) : undefined,\n            node.children,\n            PatchFlags.STABLE_FRAGMENT +\n              (__DEV__\n                ? ` /* ${PatchFlagNames[PatchFlags.STABLE_FRAGMENT]} */`\n                : ``),\n            undefined,\n            undefined,\n            true,\n            undefined,\n            false /* isComponent */\n          )\n        } else {\n          // Normal element v-for. Directly use the child's codegenNode\n          // but mark it as a block.\n          childBlock = (children[0] as PlainElementNode)\n            .codegenNode as VNodeCall\n          if (isTemplate && keyProperty) {\n            injectProp(childBlock, keyProperty, context)\n          }\n          if (childBlock.isBlock !== !isStableFragment) {\n            if (childBlock.isBlock) {\n              // switch from block to vnode\n              removeHelper(OPEN_BLOCK)\n              removeHelper(\n                getVNodeBlockHelper(context.inSSR, childBlock.isComponent)\n              )\n            } else {\n              // switch from vnode to block\n              removeHelper(\n                getVNodeHelper(context.inSSR, childBlock.isComponent)\n              )\n            }\n          }\n          childBlock.isBlock = !isStableFragment\n          if (childBlock.isBlock) {\n            helper(OPEN_BLOCK)\n            helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent))\n          } else {\n            helper(getVNodeHelper(context.inSSR, childBlock.isComponent))\n          }\n        }\n\n        if (memo) {\n          const loop = createFunctionExpression(\n            createForLoopParams(forNode.parseResult, [\n              createSimpleExpression(`_cached`)\n            ])\n          )\n          loop.body = createBlockStatement([\n            createCompoundExpression([`const _memo = (`, memo.exp!, `)`]),\n            createCompoundExpression([\n              `if (_cached`,\n              ...(keyExp ? [` && _cached.key === `, keyExp] : []),\n              ` && ${context.helperString(\n                IS_MEMO_SAME\n              )}(_cached, _memo)) return _cached`\n            ]),\n            createCompoundExpression([`const _item = `, childBlock as any]),\n            createSimpleExpression(`_item.memo = _memo`),\n            createSimpleExpression(`return _item`)\n          ])\n          renderExp.arguments.push(\n            loop as ForIteratorExpression,\n            createSimpleExpression(`_cache`),\n            createSimpleExpression(String(context.cached++))\n          )\n        } else {\n          renderExp.arguments.push(\n            createFunctionExpression(\n              createForLoopParams(forNode.parseResult),\n              childBlock,\n              true /* force newline */\n            ) as ForIteratorExpression\n          )\n        }\n      }\n    })\n  }\n)\n\n// target-agnostic transform used for both Client and SSR\nexport function processFor(\n  node: ElementNode,\n  dir: DirectiveNode,\n  context: TransformContext,\n  processCodegen?: (forNode: ForNode) => (() => void) | undefined\n) {\n  if (!dir.exp) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_FOR_NO_EXPRESSION, dir.loc)\n    )\n    return\n  }\n\n  const parseResult = parseForExpression(\n    // can only be simple expression because vFor transform is applied\n    // before expression transform.\n    dir.exp as SimpleExpressionNode,\n    context\n  )\n\n  if (!parseResult) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, dir.loc)\n    )\n    return\n  }\n\n  const { addIdentifiers, removeIdentifiers, scopes } = context\n  const { source, value, key, index } = parseResult\n\n  const forNode: ForNode = {\n    type: NodeTypes.FOR,\n    loc: dir.loc,\n    source,\n    valueAlias: value,\n    keyAlias: key,\n    objectIndexAlias: index,\n    parseResult,\n    children: isTemplateNode(node) ? node.children : [node]\n  }\n\n  context.replaceNode(forNode)\n\n  // bookkeeping\n  scopes.vFor++\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    // scope management\n    // inject identifiers to context\n    value && addIdentifiers(value)\n    key && addIdentifiers(key)\n    index && addIdentifiers(index)\n  }\n\n  const onExit = processCodegen && processCodegen(forNode)\n\n  return () => {\n    scopes.vFor--\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      value && removeIdentifiers(value)\n      key && removeIdentifiers(key)\n      index && removeIdentifiers(index)\n    }\n    if (onExit) onExit()\n  }\n}\n\nconst forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/\n// This regex doesn't cover the case if key or index aliases have destructuring,\n// but those do not make sense in the first place, so this works in practice.\nconst forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/\nconst stripParensRE = /^\\(|\\)$/g\n\nexport interface ForParseResult {\n  source: ExpressionNode\n  value: ExpressionNode | undefined\n  key: ExpressionNode | undefined\n  index: ExpressionNode | undefined\n}\n\nexport function parseForExpression(\n  input: SimpleExpressionNode,\n  context: TransformContext\n): ForParseResult | undefined {\n  const loc = input.loc\n  const exp = input.content\n  const inMatch = exp.match(forAliasRE)\n  if (!inMatch) return\n\n  const [, LHS, RHS] = inMatch\n\n  const result: ForParseResult = {\n    source: createAliasExpression(\n      loc,\n      RHS.trim(),\n      exp.indexOf(RHS, LHS.length)\n    ),\n    value: undefined,\n    key: undefined,\n    index: undefined\n  }\n  if (!__BROWSER__ && context.prefixIdentifiers) {\n    result.source = processExpression(\n      result.source as SimpleExpressionNode,\n      context\n    )\n  }\n  if (__DEV__ && __BROWSER__) {\n    validateBrowserExpression(result.source as SimpleExpressionNode, context)\n  }\n\n  let valueContent = LHS.trim().replace(stripParensRE, '').trim()\n  const trimmedOffset = LHS.indexOf(valueContent)\n\n  const iteratorMatch = valueContent.match(forIteratorRE)\n  if (iteratorMatch) {\n    valueContent = valueContent.replace(forIteratorRE, '').trim()\n\n    const keyContent = iteratorMatch[1].trim()\n    let keyOffset: number | undefined\n    if (keyContent) {\n      keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length)\n      result.key = createAliasExpression(loc, keyContent, keyOffset)\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        result.key = processExpression(result.key, context, true)\n      }\n      if (__DEV__ && __BROWSER__) {\n        validateBrowserExpression(\n          result.key as SimpleExpressionNode,\n          context,\n          true\n        )\n      }\n    }\n\n    if (iteratorMatch[2]) {\n      const indexContent = iteratorMatch[2].trim()\n\n      if (indexContent) {\n        result.index = createAliasExpression(\n          loc,\n          indexContent,\n          exp.indexOf(\n            indexContent,\n            result.key\n              ? keyOffset! + keyContent.length\n              : trimmedOffset + valueContent.length\n          )\n        )\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          result.index = processExpression(result.index, context, true)\n        }\n        if (__DEV__ && __BROWSER__) {\n          validateBrowserExpression(\n            result.index as SimpleExpressionNode,\n            context,\n            true\n          )\n        }\n      }\n    }\n  }\n\n  if (valueContent) {\n    result.value = createAliasExpression(loc, valueContent, trimmedOffset)\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      result.value = processExpression(result.value, context, true)\n    }\n    if (__DEV__ && __BROWSER__) {\n      validateBrowserExpression(\n        result.value as SimpleExpressionNode,\n        context,\n        true\n      )\n    }\n  }\n\n  return result\n}\n\nfunction createAliasExpression(\n  range: SourceLocation,\n  content: string,\n  offset: number\n): SimpleExpressionNode {\n  return createSimpleExpression(\n    content,\n    false,\n    getInnerRange(range, offset, content.length)\n  )\n}\n\nexport function createForLoopParams(\n  { value, key, index }: ForParseResult,\n  memoArgs: ExpressionNode[] = []\n): ExpressionNode[] {\n  return createParamsList([value, key, index, ...memoArgs])\n}\n\nfunction createParamsList(\n  args: (ExpressionNode | undefined)[]\n): ExpressionNode[] {\n  let i = args.length\n  while (i--) {\n    if (args[i]) break\n  }\n  return args\n    .slice(0, i + 1)\n    .map((arg, i) => arg || createSimpleExpression(`_`.repeat(i + 1), false))\n}\n", "import {\n  ElementNode,\n  ObjectExpression,\n  createObjectExpression,\n  NodeTypes,\n  createObjectProperty,\n  createSimpleExpression,\n  createFunctionExpression,\n  DirectiveNode,\n  ElementTypes,\n  ExpressionNode,\n  Property,\n  TemplateChildNode,\n  SourceLocation,\n  createConditionalExpression,\n  ConditionalExpression,\n  SimpleExpressionNode,\n  FunctionExpression,\n  CallExpression,\n  createCallExpression,\n  createArrayExpression,\n  SlotsExpression\n} from '../ast'\nimport { TransformContext, NodeTransform } from '../transform'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  findDir,\n  isTemplateNode,\n  assert,\n  isVSlot,\n  hasScopeRef,\n  isStaticExp\n} from '../utils'\nimport { CREATE_SLOTS, RENDER_LIST, WITH_CTX } from '../runtimeHelpers'\nimport { parseForExpression, createForLoopParams } from './vFor'\nimport { SlotFlags, slotFlagsText } from '@vue/shared'\n\nconst defaultFallback = createSimpleExpression(`undefined`, false)\n\n// A NodeTransform that:\n// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed\n//    by transformExpression. This is only applied in non-browser builds with\n//    { prefixIdentifiers: true }.\n// 2. Track v-slot depths so that we know a slot is inside another slot.\n//    Note the exit callback is executed before buildSlots() on the same node,\n//    so only nested slots see positive numbers.\nexport const trackSlotScopes: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    (node.tagType === ElementTypes.COMPONENT ||\n      node.tagType === ElementTypes.TEMPLATE)\n  ) {\n    // We are only checking non-empty v-slot here\n    // since we only care about slots that introduce scope variables.\n    const vSlot = findDir(node, 'slot')\n    if (vSlot) {\n      const slotProps = vSlot.exp\n      if (!__BROWSER__ && context.prefixIdentifiers) {\n        slotProps && context.addIdentifiers(slotProps)\n      }\n      context.scopes.vSlot++\n      return () => {\n        if (!__BROWSER__ && context.prefixIdentifiers) {\n          slotProps && context.removeIdentifiers(slotProps)\n        }\n        context.scopes.vSlot--\n      }\n    }\n  }\n}\n\n// A NodeTransform that tracks scope identifiers for scoped slots with v-for.\n// This transform is only applied in non-browser builds with { prefixIdentifiers: true }\nexport const trackVForSlotScopes: NodeTransform = (node, context) => {\n  let vFor\n  if (\n    isTemplateNode(node) &&\n    node.props.some(isVSlot) &&\n    (vFor = findDir(node, 'for'))\n  ) {\n    const result = (vFor.parseResult = parseForExpression(\n      vFor.exp as SimpleExpressionNode,\n      context\n    ))\n    if (result) {\n      const { value, key, index } = result\n      const { addIdentifiers, removeIdentifiers } = context\n      value && addIdentifiers(value)\n      key && addIdentifiers(key)\n      index && addIdentifiers(index)\n\n      return () => {\n        value && removeIdentifiers(value)\n        key && removeIdentifiers(key)\n        index && removeIdentifiers(index)\n      }\n    }\n  }\n}\n\nexport type SlotFnBuilder = (\n  slotProps: ExpressionNode | undefined,\n  slotChildren: TemplateChildNode[],\n  loc: SourceLocation\n) => FunctionExpression\n\nconst buildClientSlotFn: SlotFnBuilder = (props, children, loc) =>\n  createFunctionExpression(\n    props,\n    children,\n    false /* newline */,\n    true /* isSlot */,\n    children.length ? children[0].loc : loc\n  )\n\n// Instead of being a DirectiveTransform, v-slot processing is called during\n// transformElement to build the slots object for a component.\nexport function buildSlots(\n  node: ElementNode,\n  context: TransformContext,\n  buildSlotFn: SlotFnBuilder = buildClientSlotFn\n): {\n  slots: SlotsExpression\n  hasDynamicSlots: boolean\n} {\n  context.helper(WITH_CTX)\n\n  const { children, loc } = node\n  const slotsProperties: Property[] = []\n  const dynamicSlots: (ConditionalExpression | CallExpression)[] = []\n\n  // If the slot is inside a v-for or another v-slot, force it to be dynamic\n  // since it likely uses a scope variable.\n  let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0\n  // with `prefixIdentifiers: true`, this can be further optimized to make\n  // it dynamic only when the slot actually uses the scope variables.\n  if (!__BROWSER__ && !context.ssr && context.prefixIdentifiers) {\n    hasDynamicSlots = hasScopeRef(node, context.identifiers)\n  }\n\n  // 1. Check for slot with slotProps on component itself.\n  //    <Comp v-slot=\"{ prop }\"/>\n  const onComponentSlot = findDir(node, 'slot', true)\n  if (onComponentSlot) {\n    const { arg, exp } = onComponentSlot\n    if (arg && !isStaticExp(arg)) {\n      hasDynamicSlots = true\n    }\n    slotsProperties.push(\n      createObjectProperty(\n        arg || createSimpleExpression('default', true),\n        buildSlotFn(exp, children, loc)\n      )\n    )\n  }\n\n  // 2. Iterate through children and check for template slots\n  //    <template v-slot:foo=\"{ prop }\">\n  let hasTemplateSlots = false\n  let hasNamedDefaultSlot = false\n  const implicitDefaultChildren: TemplateChildNode[] = []\n  const seenSlotNames = new Set<string>()\n\n  for (let i = 0; i < children.length; i++) {\n    const slotElement = children[i]\n    let slotDir\n\n    if (\n      !isTemplateNode(slotElement) ||\n      !(slotDir = findDir(slotElement, 'slot', true))\n    ) {\n      // not a <template v-slot>, skip.\n      if (slotElement.type !== NodeTypes.COMMENT) {\n        implicitDefaultChildren.push(slotElement)\n      }\n      continue\n    }\n\n    if (onComponentSlot) {\n      // already has on-component slot - this is incorrect usage.\n      context.onError(\n        createCompilerError(ErrorCodes.X_V_SLOT_MIXED_SLOT_USAGE, slotDir.loc)\n      )\n      break\n    }\n\n    hasTemplateSlots = true\n    const { children: slotChildren, loc: slotLoc } = slotElement\n    const {\n      arg: slotName = createSimpleExpression(`default`, true),\n      exp: slotProps,\n      loc: dirLoc\n    } = slotDir\n\n    // check if name is dynamic.\n    let staticSlotName: string | undefined\n    if (isStaticExp(slotName)) {\n      staticSlotName = slotName ? slotName.content : `default`\n    } else {\n      hasDynamicSlots = true\n    }\n\n    const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc)\n    // check if this slot is conditional (v-if/v-for)\n    let vIf: DirectiveNode | undefined\n    let vElse: DirectiveNode | undefined\n    let vFor: DirectiveNode | undefined\n    if ((vIf = findDir(slotElement, 'if'))) {\n      hasDynamicSlots = true\n      dynamicSlots.push(\n        createConditionalExpression(\n          vIf.exp!,\n          buildDynamicSlot(slotName, slotFunction),\n          defaultFallback\n        )\n      )\n    } else if (\n      (vElse = findDir(slotElement, /^else(-if)?$/, true /* allowEmpty */))\n    ) {\n      // find adjacent v-if\n      let j = i\n      let prev\n      while (j--) {\n        prev = children[j]\n        if (prev.type !== NodeTypes.COMMENT) {\n          break\n        }\n      }\n      if (prev && isTemplateNode(prev) && findDir(prev, 'if')) {\n        // remove node\n        children.splice(i, 1)\n        i--\n        __TEST__ && assert(dynamicSlots.length > 0)\n        // attach this slot to previous conditional\n        let conditional = dynamicSlots[\n          dynamicSlots.length - 1\n        ] as ConditionalExpression\n        while (\n          conditional.alternate.type === NodeTypes.JS_CONDITIONAL_EXPRESSION\n        ) {\n          conditional = conditional.alternate\n        }\n        conditional.alternate = vElse.exp\n          ? createConditionalExpression(\n              vElse.exp,\n              buildDynamicSlot(slotName, slotFunction),\n              defaultFallback\n            )\n          : buildDynamicSlot(slotName, slotFunction)\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_ELSE_NO_ADJACENT_IF, vElse.loc)\n        )\n      }\n    } else if ((vFor = findDir(slotElement, 'for'))) {\n      hasDynamicSlots = true\n      const parseResult =\n        vFor.parseResult ||\n        parseForExpression(vFor.exp as SimpleExpressionNode, context)\n      if (parseResult) {\n        // Render the dynamic slots as an array and add it to the createSlot()\n        // args. The runtime knows how to handle it appropriately.\n        dynamicSlots.push(\n          createCallExpression(context.helper(RENDER_LIST), [\n            parseResult.source,\n            createFunctionExpression(\n              createForLoopParams(parseResult),\n              buildDynamicSlot(slotName, slotFunction),\n              true /* force newline */\n            )\n          ])\n        )\n      } else {\n        context.onError(\n          createCompilerError(ErrorCodes.X_V_FOR_MALFORMED_EXPRESSION, vFor.loc)\n        )\n      }\n    } else {\n      // check duplicate static names\n      if (staticSlotName) {\n        if (seenSlotNames.has(staticSlotName)) {\n          context.onError(\n            createCompilerError(\n              ErrorCodes.X_V_SLOT_DUPLICATE_SLOT_NAMES,\n              dirLoc\n            )\n          )\n          continue\n        }\n        seenSlotNames.add(staticSlotName)\n        if (staticSlotName === 'default') {\n          hasNamedDefaultSlot = true\n        }\n      }\n      slotsProperties.push(createObjectProperty(slotName, slotFunction))\n    }\n  }\n\n  if (!onComponentSlot) {\n    const buildDefaultSlotProperty = (\n      props: ExpressionNode | undefined,\n      children: TemplateChildNode[]\n    ) => {\n      const fn = buildSlotFn(props, children, loc)\n      if (__COMPAT__ && context.compatConfig) {\n        fn.isNonScopedSlot = true\n      }\n      return createObjectProperty(`default`, fn)\n    }\n\n    if (!hasTemplateSlots) {\n      // implicit default slot (on component)\n      slotsProperties.push(buildDefaultSlotProperty(undefined, children))\n    } else if (\n      implicitDefaultChildren.length &&\n      // #3766\n      // with whitespace: 'preserve', whitespaces between slots will end up in\n      // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\n      implicitDefaultChildren.some(node => isNonWhitespaceContent(node))\n    ) {\n      // implicit default slot (mixed with named slots)\n      if (hasNamedDefaultSlot) {\n        context.onError(\n          createCompilerError(\n            ErrorCodes.X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN,\n            implicitDefaultChildren[0].loc\n          )\n        )\n      } else {\n        slotsProperties.push(\n          buildDefaultSlotProperty(undefined, implicitDefaultChildren)\n        )\n      }\n    }\n  }\n\n  const slotFlag = hasDynamicSlots\n    ? SlotFlags.DYNAMIC\n    : hasForwardedSlots(node.children)\n    ? SlotFlags.FORWARDED\n    : SlotFlags.STABLE\n\n  let slots = createObjectExpression(\n    slotsProperties.concat(\n      createObjectProperty(\n        `_`,\n        // 2 = compiled but dynamic = can skip normalization, but must run diff\n        // 1 = compiled and static = can skip normalization AND diff as optimized\n        createSimpleExpression(\n          slotFlag + (__DEV__ ? ` /* ${slotFlagsText[slotFlag]} */` : ``),\n          false\n        )\n      )\n    ),\n    loc\n  ) as SlotsExpression\n  if (dynamicSlots.length) {\n    slots = createCallExpression(context.helper(CREATE_SLOTS), [\n      slots,\n      createArrayExpression(dynamicSlots)\n    ]) as SlotsExpression\n  }\n\n  return {\n    slots,\n    hasDynamicSlots\n  }\n}\n\nfunction buildDynamicSlot(\n  name: ExpressionNode,\n  fn: FunctionExpression\n): ObjectExpression {\n  return createObjectExpression([\n    createObjectProperty(`name`, name),\n    createObjectProperty(`fn`, fn)\n  ])\n}\n\nfunction hasForwardedSlots(children: TemplateChildNode[]): boolean {\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i]\n    switch (child.type) {\n      case NodeTypes.ELEMENT:\n        if (\n          child.tagType === ElementTypes.SLOT ||\n          hasForwardedSlots(child.children)\n        ) {\n          return true\n        }\n        break\n      case NodeTypes.IF:\n        if (hasForwardedSlots(child.branches)) return true\n        break\n      case NodeTypes.IF_BRANCH:\n      case NodeTypes.FOR:\n        if (hasForwardedSlots(child.children)) return true\n        break\n      default:\n        break\n    }\n  }\n  return false\n}\n\nfunction isNonWhitespaceContent(node: TemplateChildNode): boolean {\n  if (node.type !== NodeTypes.TEXT && node.type !== NodeTypes.TEXT_CALL)\n    return true\n  return node.type === NodeTypes.TEXT\n    ? !!node.content.trim()\n    : isNonWhitespaceContent(node.content)\n}\n", "import { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  ElementTypes,\n  CallExpression,\n  ObjectExpression,\n  ElementNode,\n  DirectiveNode,\n  ExpressionNode,\n  ArrayExpression,\n  createCallExpression,\n  createArrayExpression,\n  createObjectProperty,\n  createSimpleExpression,\n  createObjectExpression,\n  Property,\n  ComponentNode,\n  VNodeCall,\n  TemplateTextChildNode,\n  DirectiveArguments,\n  createVNodeCall,\n  ConstantTypes\n} from '../ast'\nimport {\n  PatchFlags,\n  PatchFlagNames,\n  isSymbol,\n  isOn,\n  isObject,\n  isReservedProp,\n  capitalize,\n  camelize,\n  isBuiltInDirective\n} from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  RESOLVE_DIRECTIVE,\n  RESOLVE_COMPONENT,\n  RESOLVE_DYNAMIC_COMPONENT,\n  MERGE_PROPS,\n  NORMALIZE_CLASS,\n  NORMALIZE_STYLE,\n  NORMALIZE_PROPS,\n  TO_HANDLERS,\n  TELEPORT,\n  KEEP_ALIVE,\n  SUSPENSE,\n  UNREF,\n  GUARD_REACTIVE_PROPS\n} from '../runtimeHelpers'\nimport {\n  getInnerRange,\n  toValidAssetId,\n  findProp,\n  isCoreComponent,\n  isStaticArgOf,\n  findDir,\n  isStaticExp\n} from '../utils'\nimport { buildSlots } from './vSlot'\nimport { getConstantType } from './hoistStatic'\nimport { BindingTypes } from '../options'\nimport {\n  checkCompatEnabled,\n  CompilerDeprecationTypes,\n  isCompatEnabled\n} from '../compat/compatConfig'\n\n// some directive transforms (e.g. v-model) may return a symbol for runtime\n// import, which should be used instead of a resolveDirective call.\nconst directiveImportMap = new WeakMap<DirectiveNode, symbol>()\n\n// generate a JavaScript AST for this element's codegen\nexport const transformElement: NodeTransform = (node, context) => {\n  // perform the work on exit, after all child expressions have been\n  // processed and merged.\n  return function postTransformElement() {\n    node = context.currentNode!\n\n    if (\n      !(\n        node.type === NodeTypes.ELEMENT &&\n        (node.tagType === ElementTypes.ELEMENT ||\n          node.tagType === ElementTypes.COMPONENT)\n      )\n    ) {\n      return\n    }\n\n    const { tag, props } = node\n    const isComponent = node.tagType === ElementTypes.COMPONENT\n\n    // The goal of the transform is to create a codegenNode implementing the\n    // VNodeCall interface.\n    let vnodeTag = isComponent\n      ? resolveComponentType(node as ComponentNode, context)\n      : `\"${tag}\"`\n\n    const isDynamicComponent =\n      isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT\n\n    let vnodeProps: VNodeCall['props']\n    let vnodeChildren: VNodeCall['children']\n    let vnodePatchFlag: VNodeCall['patchFlag']\n    let patchFlag: number = 0\n    let vnodeDynamicProps: VNodeCall['dynamicProps']\n    let dynamicPropNames: string[] | undefined\n    let vnodeDirectives: VNodeCall['directives']\n\n    let shouldUseBlock =\n      // dynamic component may resolve to plain elements\n      isDynamicComponent ||\n      vnodeTag === TELEPORT ||\n      vnodeTag === SUSPENSE ||\n      (!isComponent &&\n        // <svg> and <foreignObject> must be forced into blocks so that block\n        // updates inside get proper isSVG flag at runtime. (#639, #643)\n        // This is technically web-specific, but splitting the logic out of core\n        // leads to too much unnecessary complexity.\n        (tag === 'svg' || tag === 'foreignObject'))\n\n    // props\n    if (props.length > 0) {\n      const propsBuildResult = buildProps(node, context)\n      vnodeProps = propsBuildResult.props\n      patchFlag = propsBuildResult.patchFlag\n      dynamicPropNames = propsBuildResult.dynamicPropNames\n      const directives = propsBuildResult.directives\n      vnodeDirectives =\n        directives && directives.length\n          ? (createArrayExpression(\n              directives.map(dir => buildDirectiveArgs(dir, context))\n            ) as DirectiveArguments)\n          : undefined\n\n      if (propsBuildResult.shouldUseBlock) {\n        shouldUseBlock = true\n      }\n    }\n\n    // children\n    if (node.children.length > 0) {\n      if (vnodeTag === KEEP_ALIVE) {\n        // Although a built-in component, we compile KeepAlive with raw children\n        // instead of slot functions so that it can be used inside Transition\n        // or other Transition-wrapping HOCs.\n        // To ensure correct updates with block optimizations, we need to:\n        // 1. Force keep-alive into a block. This avoids its children being\n        //    collected by a parent block.\n        shouldUseBlock = true\n        // 2. Force keep-alive to always be updated, since it uses raw children.\n        patchFlag |= PatchFlags.DYNAMIC_SLOTS\n        if (__DEV__ && node.children.length > 1) {\n          context.onError(\n            createCompilerError(ErrorCodes.X_KEEP_ALIVE_INVALID_CHILDREN, {\n              start: node.children[0].loc.start,\n              end: node.children[node.children.length - 1].loc.end,\n              source: ''\n            })\n          )\n        }\n      }\n\n      const shouldBuildAsSlots =\n        isComponent &&\n        // Teleport is not a real component and has dedicated runtime handling\n        vnodeTag !== TELEPORT &&\n        // explained above.\n        vnodeTag !== KEEP_ALIVE\n\n      if (shouldBuildAsSlots) {\n        const { slots, hasDynamicSlots } = buildSlots(node, context)\n        vnodeChildren = slots\n        if (hasDynamicSlots) {\n          patchFlag |= PatchFlags.DYNAMIC_SLOTS\n        }\n      } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {\n        const child = node.children[0]\n        const type = child.type\n        // check for dynamic text children\n        const hasDynamicTextChild =\n          type === NodeTypes.INTERPOLATION ||\n          type === NodeTypes.COMPOUND_EXPRESSION\n        if (\n          hasDynamicTextChild &&\n          getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\n        ) {\n          patchFlag |= PatchFlags.TEXT\n        }\n        // pass directly if the only child is a text node\n        // (plain / interpolation / expression)\n        if (hasDynamicTextChild || type === NodeTypes.TEXT) {\n          vnodeChildren = child as TemplateTextChildNode\n        } else {\n          vnodeChildren = node.children\n        }\n      } else {\n        vnodeChildren = node.children\n      }\n    }\n\n    // patchFlag & dynamicPropNames\n    if (patchFlag !== 0) {\n      if (__DEV__) {\n        if (patchFlag < 0) {\n          // special flags (negative and mutually exclusive)\n          vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`\n        } else {\n          // bitwise flags\n          const flagNames = Object.keys(PatchFlagNames)\n            .map(Number)\n            .filter(n => n > 0 && patchFlag & n)\n            .map(n => PatchFlagNames[n])\n            .join(`, `)\n          vnodePatchFlag = patchFlag + ` /* ${flagNames} */`\n        }\n      } else {\n        vnodePatchFlag = String(patchFlag)\n      }\n      if (dynamicPropNames && dynamicPropNames.length) {\n        vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames)\n      }\n    }\n\n    node.codegenNode = createVNodeCall(\n      context,\n      vnodeTag,\n      vnodeProps,\n      vnodeChildren,\n      vnodePatchFlag,\n      vnodeDynamicProps,\n      vnodeDirectives,\n      !!shouldUseBlock,\n      false /* disableTracking */,\n      isComponent,\n      node.loc\n    )\n  }\n}\n\nexport function resolveComponentType(\n  node: ComponentNode,\n  context: TransformContext,\n  ssr = false\n) {\n  let { tag } = node\n\n  // 1. dynamic component\n  const isExplicitDynamic = isComponentTag(tag)\n  const isProp = findProp(node, 'is')\n  if (isProp) {\n    if (\n      isExplicitDynamic ||\n      (__COMPAT__ &&\n        isCompatEnabled(\n          CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n          context\n        ))\n    ) {\n      const exp =\n        isProp.type === NodeTypes.ATTRIBUTE\n          ? isProp.value && createSimpleExpression(isProp.value.content, true)\n          : isProp.exp\n      if (exp) {\n        return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n          exp\n        ])\n      }\n    } else if (\n      isProp.type === NodeTypes.ATTRIBUTE &&\n      isProp.value!.content.startsWith('vue:')\n    ) {\n      // <button is=\"vue:xxx\">\n      // if not <component>, only is value that starts with \"vue:\" will be\n      // treated as component by the parse phase and reach here, unless it's\n      // compat mode where all is values are considered components\n      tag = isProp.value!.content.slice(4)\n    }\n  }\n\n  // 1.5 v-is (TODO: Deprecate)\n  const isDir = !isExplicitDynamic && findDir(node, 'is')\n  if (isDir && isDir.exp) {\n    return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [\n      isDir.exp\n    ])\n  }\n\n  // 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)\n  const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag)\n  if (builtIn) {\n    // built-ins are simply fallthroughs / have special handling during ssr\n    // so we don't need to import their runtime equivalents\n    if (!ssr) context.helper(builtIn)\n    return builtIn\n  }\n\n  // 3. user component (from setup bindings)\n  // this is skipped in browser build since browser builds do not perform\n  // binding analysis.\n  if (!__BROWSER__) {\n    const fromSetup = resolveSetupReference(tag, context)\n    if (fromSetup) {\n      return fromSetup\n    }\n    const dotIndex = tag.indexOf('.')\n    if (dotIndex > 0) {\n      const ns = resolveSetupReference(tag.slice(0, dotIndex), context)\n      if (ns) {\n        return ns + tag.slice(dotIndex)\n      }\n    }\n  }\n\n  // 4. Self referencing component (inferred from filename)\n  if (\n    !__BROWSER__ &&\n    context.selfName &&\n    capitalize(camelize(tag)) === context.selfName\n  ) {\n    context.helper(RESOLVE_COMPONENT)\n    // codegen.ts has special check for __self postfix when generating\n    // component imports, which will pass additional `maybeSelfReference` flag\n    // to `resolveComponent`.\n    context.components.add(tag + `__self`)\n    return toValidAssetId(tag, `component`)\n  }\n\n  // 5. user component (resolve)\n  context.helper(RESOLVE_COMPONENT)\n  context.components.add(tag)\n  return toValidAssetId(tag, `component`)\n}\n\nfunction resolveSetupReference(name: string, context: TransformContext) {\n  const bindings = context.bindingMetadata\n  if (!bindings || bindings.__isScriptSetup === false) {\n    return\n  }\n\n  const camelName = camelize(name)\n  const PascalName = capitalize(camelName)\n  const checkType = (type: BindingTypes) => {\n    if (bindings[name] === type) {\n      return name\n    }\n    if (bindings[camelName] === type) {\n      return camelName\n    }\n    if (bindings[PascalName] === type) {\n      return PascalName\n    }\n  }\n\n  const fromConst = checkType(BindingTypes.SETUP_CONST)\n  if (fromConst) {\n    return context.inline\n      ? // in inline mode, const setup bindings (e.g. imports) can be used as-is\n        fromConst\n      : `$setup[${JSON.stringify(fromConst)}]`\n  }\n\n  const fromMaybeRef =\n    checkType(BindingTypes.SETUP_LET) ||\n    checkType(BindingTypes.SETUP_REF) ||\n    checkType(BindingTypes.SETUP_MAYBE_REF)\n  if (fromMaybeRef) {\n    return context.inline\n      ? // setup scope bindings that may be refs need to be unrefed\n        `${context.helperString(UNREF)}(${fromMaybeRef})`\n      : `$setup[${JSON.stringify(fromMaybeRef)}]`\n  }\n}\n\nexport type PropsExpression = ObjectExpression | CallExpression | ExpressionNode\n\nexport function buildProps(\n  node: ElementNode,\n  context: TransformContext,\n  props: ElementNode['props'] = node.props,\n  ssr = false\n): {\n  props: PropsExpression | undefined\n  directives: DirectiveNode[]\n  patchFlag: number\n  dynamicPropNames: string[]\n  shouldUseBlock: boolean\n} {\n  const { tag, loc: elementLoc, children } = node\n  const isComponent = node.tagType === ElementTypes.COMPONENT\n  let properties: ObjectExpression['properties'] = []\n  const mergeArgs: PropsExpression[] = []\n  const runtimeDirectives: DirectiveNode[] = []\n  const hasChildren = children.length > 0\n  let shouldUseBlock = false\n\n  // patchFlag analysis\n  let patchFlag = 0\n  let hasRef = false\n  let hasClassBinding = false\n  let hasStyleBinding = false\n  let hasHydrationEventBinding = false\n  let hasDynamicKeys = false\n  let hasVnodeHook = false\n  const dynamicPropNames: string[] = []\n\n  const analyzePatchFlag = ({ key, value }: Property) => {\n    if (isStaticExp(key)) {\n      const name = key.content\n      const isEventHandler = isOn(name)\n      if (\n        !isComponent &&\n        isEventHandler &&\n        // omit the flag for click handlers because hydration gives click\n        // dedicated fast path.\n        name.toLowerCase() !== 'onclick' &&\n        // omit v-model handlers\n        name !== 'onUpdate:modelValue' &&\n        // omit onVnodeXXX hooks\n        !isReservedProp(name)\n      ) {\n        hasHydrationEventBinding = true\n      }\n\n      if (isEventHandler && isReservedProp(name)) {\n        hasVnodeHook = true\n      }\n\n      if (\n        value.type === NodeTypes.JS_CACHE_EXPRESSION ||\n        ((value.type === NodeTypes.SIMPLE_EXPRESSION ||\n          value.type === NodeTypes.COMPOUND_EXPRESSION) &&\n          getConstantType(value, context) > 0)\n      ) {\n        // skip if the prop is a cached handler or has constant value\n        return\n      }\n\n      if (name === 'ref') {\n        hasRef = true\n      } else if (name === 'class') {\n        hasClassBinding = true\n      } else if (name === 'style') {\n        hasStyleBinding = true\n      } else if (name !== 'key' && !dynamicPropNames.includes(name)) {\n        dynamicPropNames.push(name)\n      }\n\n      // treat the dynamic class and style binding of the component as dynamic props\n      if (\n        isComponent &&\n        (name === 'class' || name === 'style') &&\n        !dynamicPropNames.includes(name)\n      ) {\n        dynamicPropNames.push(name)\n      }\n    } else {\n      hasDynamicKeys = true\n    }\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    // static attribute\n    const prop = props[i]\n    if (prop.type === NodeTypes.ATTRIBUTE) {\n      const { loc, name, value } = prop\n      let isStatic = true\n      if (name === 'ref') {\n        hasRef = true\n        if (context.scopes.vFor > 0) {\n          properties.push(\n            createObjectProperty(\n              createSimpleExpression('ref_for', true),\n              createSimpleExpression('true')\n            )\n          )\n        }\n        // in inline mode there is no setupState object, so we can't use string\n        // keys to set the ref. Instead, we need to transform it to pass the\n        // actual ref instead.\n        if (\n          !__BROWSER__ &&\n          value &&\n          context.inline &&\n          context.bindingMetadata[value.content]\n        ) {\n          isStatic = false\n          properties.push(\n            createObjectProperty(\n              createSimpleExpression('ref_key', true),\n              createSimpleExpression(value.content, true, value.loc)\n            )\n          )\n        }\n      }\n      // skip is on <component>, or is=\"vue:xxx\"\n      if (\n        name === 'is' &&\n        (isComponentTag(tag) ||\n          (value && value.content.startsWith('vue:')) ||\n          (__COMPAT__ &&\n            isCompatEnabled(\n              CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n              context\n            )))\n      ) {\n        continue\n      }\n      properties.push(\n        createObjectProperty(\n          createSimpleExpression(\n            name,\n            true,\n            getInnerRange(loc, 0, name.length)\n          ),\n          createSimpleExpression(\n            value ? value.content : '',\n            isStatic,\n            value ? value.loc : loc\n          )\n        )\n      )\n    } else {\n      // directives\n      const { name, arg, exp, loc } = prop\n      const isVBind = name === 'bind'\n      const isVOn = name === 'on'\n\n      // skip v-slot - it is handled by its dedicated transform.\n      if (name === 'slot') {\n        if (!isComponent) {\n          context.onError(\n            createCompilerError(ErrorCodes.X_V_SLOT_MISPLACED, loc)\n          )\n        }\n        continue\n      }\n      // skip v-once/v-memo - they are handled by dedicated transforms.\n      if (name === 'once' || name === 'memo') {\n        continue\n      }\n      // skip v-is and :is on <component>\n      if (\n        name === 'is' ||\n        (isVBind &&\n          isStaticArgOf(arg, 'is') &&\n          (isComponentTag(tag) ||\n            (__COMPAT__ &&\n              isCompatEnabled(\n                CompilerDeprecationTypes.COMPILER_IS_ON_ELEMENT,\n                context\n              ))))\n      ) {\n        continue\n      }\n      // skip v-on in SSR compilation\n      if (isVOn && ssr) {\n        continue\n      }\n\n      if (\n        // #938: elements with dynamic keys should be forced into blocks\n        (isVBind && isStaticArgOf(arg, 'key')) ||\n        // inline before-update hooks need to force block so that it is invoked\n        // before children\n        (isVOn && hasChildren && isStaticArgOf(arg, 'vue:before-update'))\n      ) {\n        shouldUseBlock = true\n      }\n\n      if (isVBind && isStaticArgOf(arg, 'ref') && context.scopes.vFor > 0) {\n        properties.push(\n          createObjectProperty(\n            createSimpleExpression('ref_for', true),\n            createSimpleExpression('true')\n          )\n        )\n      }\n\n      // special case for v-bind and v-on with no argument\n      if (!arg && (isVBind || isVOn)) {\n        hasDynamicKeys = true\n        if (exp) {\n          if (properties.length) {\n            mergeArgs.push(\n              createObjectExpression(dedupeProperties(properties), elementLoc)\n            )\n            properties = []\n          }\n          if (isVBind) {\n            if (__COMPAT__) {\n              // 2.x v-bind object order compat\n              if (__DEV__) {\n                const hasOverridableKeys = mergeArgs.some(arg => {\n                  if (arg.type === NodeTypes.JS_OBJECT_EXPRESSION) {\n                    return arg.properties.some(({ key }) => {\n                      if (\n                        key.type !== NodeTypes.SIMPLE_EXPRESSION ||\n                        !key.isStatic\n                      ) {\n                        return true\n                      }\n                      return (\n                        key.content !== 'class' &&\n                        key.content !== 'style' &&\n                        !isOn(key.content)\n                      )\n                    })\n                  } else {\n                    // dynamic expression\n                    return true\n                  }\n                })\n                if (hasOverridableKeys) {\n                  checkCompatEnabled(\n                    CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\n                    context,\n                    loc\n                  )\n                }\n              }\n\n              if (\n                isCompatEnabled(\n                  CompilerDeprecationTypes.COMPILER_V_BIND_OBJECT_ORDER,\n                  context\n                )\n              ) {\n                mergeArgs.unshift(exp)\n                continue\n              }\n            }\n\n            mergeArgs.push(exp)\n          } else {\n            // v-on=\"obj\" -> toHandlers(obj)\n            mergeArgs.push({\n              type: NodeTypes.JS_CALL_EXPRESSION,\n              loc,\n              callee: context.helper(TO_HANDLERS),\n              arguments: [exp]\n            })\n          }\n        } else {\n          context.onError(\n            createCompilerError(\n              isVBind\n                ? ErrorCodes.X_V_BIND_NO_EXPRESSION\n                : ErrorCodes.X_V_ON_NO_EXPRESSION,\n              loc\n            )\n          )\n        }\n        continue\n      }\n\n      const directiveTransform = context.directiveTransforms[name]\n      if (directiveTransform) {\n        // has built-in directive transform.\n        const { props, needRuntime } = directiveTransform(prop, node, context)\n        !ssr && props.forEach(analyzePatchFlag)\n        properties.push(...props)\n        if (needRuntime) {\n          runtimeDirectives.push(prop)\n          if (isSymbol(needRuntime)) {\n            directiveImportMap.set(prop, needRuntime)\n          }\n        }\n      } else if (!isBuiltInDirective(name)) {\n        // no built-in transform, this is a user custom directive.\n        runtimeDirectives.push(prop)\n        // custom dirs may use beforeUpdate so they need to force blocks\n        // to ensure before-update gets called before children update\n        if (hasChildren) {\n          shouldUseBlock = true\n        }\n      }\n    }\n  }\n\n  let propsExpression: PropsExpression | undefined = undefined\n\n  // has v-bind=\"object\" or v-on=\"object\", wrap with mergeProps\n  if (mergeArgs.length) {\n    if (properties.length) {\n      mergeArgs.push(\n        createObjectExpression(dedupeProperties(properties), elementLoc)\n      )\n    }\n    if (mergeArgs.length > 1) {\n      propsExpression = createCallExpression(\n        context.helper(MERGE_PROPS),\n        mergeArgs,\n        elementLoc\n      )\n    } else {\n      // single v-bind with nothing else - no need for a mergeProps call\n      propsExpression = mergeArgs[0]\n    }\n  } else if (properties.length) {\n    propsExpression = createObjectExpression(\n      dedupeProperties(properties),\n      elementLoc\n    )\n  }\n\n  // patchFlag analysis\n  if (hasDynamicKeys) {\n    patchFlag |= PatchFlags.FULL_PROPS\n  } else {\n    if (hasClassBinding && !isComponent) {\n      patchFlag |= PatchFlags.CLASS\n    }\n    if (hasStyleBinding && !isComponent) {\n      patchFlag |= PatchFlags.STYLE\n    }\n    if (dynamicPropNames.length) {\n      patchFlag |= PatchFlags.PROPS\n    }\n    if (hasHydrationEventBinding) {\n      patchFlag |= PatchFlags.HYDRATE_EVENTS\n    }\n  }\n  if (\n    !shouldUseBlock &&\n    (patchFlag === 0 || patchFlag === PatchFlags.HYDRATE_EVENTS) &&\n    (hasRef || hasVnodeHook || runtimeDirectives.length > 0)\n  ) {\n    patchFlag |= PatchFlags.NEED_PATCH\n  }\n\n  // pre-normalize props, SSR is skipped for now\n  if (!context.inSSR && propsExpression) {\n    switch (propsExpression.type) {\n      case NodeTypes.JS_OBJECT_EXPRESSION:\n        // means that there is no v-bind,\n        // but still need to deal with dynamic key binding\n        let classKeyIndex = -1\n        let styleKeyIndex = -1\n        let hasDynamicKey = false\n\n        for (let i = 0; i < propsExpression.properties.length; i++) {\n          const key = propsExpression.properties[i].key\n          if (isStaticExp(key)) {\n            if (key.content === 'class') {\n              classKeyIndex = i\n            } else if (key.content === 'style') {\n              styleKeyIndex = i\n            }\n          } else if (!key.isHandlerKey) {\n            hasDynamicKey = true\n          }\n        }\n\n        const classProp = propsExpression.properties[classKeyIndex]\n        const styleProp = propsExpression.properties[styleKeyIndex]\n\n        // no dynamic key\n        if (!hasDynamicKey) {\n          if (classProp && !isStaticExp(classProp.value)) {\n            classProp.value = createCallExpression(\n              context.helper(NORMALIZE_CLASS),\n              [classProp.value]\n            )\n          }\n          if (\n            styleProp &&\n            !isStaticExp(styleProp.value) &&\n            // the static style is compiled into an object,\n            // so use `hasStyleBinding` to ensure that it is a dynamic style binding\n            (hasStyleBinding ||\n              // v-bind:style and style both exist,\n              // v-bind:style with static literal object\n              styleProp.value.type === NodeTypes.JS_ARRAY_EXPRESSION)\n          ) {\n            styleProp.value = createCallExpression(\n              context.helper(NORMALIZE_STYLE),\n              [styleProp.value]\n            )\n          }\n        } else {\n          // dynamic key binding, wrap with `normalizeProps`\n          propsExpression = createCallExpression(\n            context.helper(NORMALIZE_PROPS),\n            [propsExpression]\n          )\n        }\n        break\n      case NodeTypes.JS_CALL_EXPRESSION:\n        // mergeProps call, do nothing\n        break\n      default:\n        // single v-bind\n        propsExpression = createCallExpression(\n          context.helper(NORMALIZE_PROPS),\n          [\n            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [\n              propsExpression\n            ])\n          ]\n        )\n        break\n    }\n  }\n\n  return {\n    props: propsExpression,\n    directives: runtimeDirectives,\n    patchFlag,\n    dynamicPropNames,\n    shouldUseBlock\n  }\n}\n\n// Dedupe props in an object literal.\n// Literal duplicated attributes would have been warned during the parse phase,\n// however, it's possible to encounter duplicated `onXXX` handlers with different\n// modifiers. We also need to merge static and dynamic class / style attributes.\n// - onXXX handlers / style: merge into array\n// - class: merge into single expression with concatenation\nfunction dedupeProperties(properties: Property[]): Property[] {\n  const knownProps: Map<string, Property> = new Map()\n  const deduped: Property[] = []\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i]\n    // dynamic keys are always allowed\n    if (prop.key.type === NodeTypes.COMPOUND_EXPRESSION || !prop.key.isStatic) {\n      deduped.push(prop)\n      continue\n    }\n    const name = prop.key.content\n    const existing = knownProps.get(name)\n    if (existing) {\n      if (name === 'style' || name === 'class' || isOn(name)) {\n        mergeAsArray(existing, prop)\n      }\n      // unexpected duplicate, should have emitted error during parse\n    } else {\n      knownProps.set(name, prop)\n      deduped.push(prop)\n    }\n  }\n  return deduped\n}\n\nfunction mergeAsArray(existing: Property, incoming: Property) {\n  if (existing.value.type === NodeTypes.JS_ARRAY_EXPRESSION) {\n    existing.value.elements.push(incoming.value)\n  } else {\n    existing.value = createArrayExpression(\n      [existing.value, incoming.value],\n      existing.loc\n    )\n  }\n}\n\nexport function buildDirectiveArgs(\n  dir: DirectiveNode,\n  context: TransformContext\n): ArrayExpression {\n  const dirArgs: ArrayExpression['elements'] = []\n  const runtime = directiveImportMap.get(dir)\n  if (runtime) {\n    // built-in directive with runtime\n    dirArgs.push(context.helperString(runtime))\n  } else {\n    // user directive.\n    // see if we have directives exposed via <script setup>\n    const fromSetup =\n      !__BROWSER__ && resolveSetupReference('v-' + dir.name, context)\n    if (fromSetup) {\n      dirArgs.push(fromSetup)\n    } else {\n      // inject statement for resolving directive\n      context.helper(RESOLVE_DIRECTIVE)\n      context.directives.add(dir.name)\n      dirArgs.push(toValidAssetId(dir.name, `directive`))\n    }\n  }\n  const { loc } = dir\n  if (dir.exp) dirArgs.push(dir.exp)\n  if (dir.arg) {\n    if (!dir.exp) {\n      dirArgs.push(`void 0`)\n    }\n    dirArgs.push(dir.arg)\n  }\n  if (Object.keys(dir.modifiers).length) {\n    if (!dir.arg) {\n      if (!dir.exp) {\n        dirArgs.push(`void 0`)\n      }\n      dirArgs.push(`void 0`)\n    }\n    const trueExpression = createSimpleExpression(`true`, false, loc)\n    dirArgs.push(\n      createObjectExpression(\n        dir.modifiers.map(modifier =>\n          createObjectProperty(modifier, trueExpression)\n        ),\n        loc\n      )\n    )\n  }\n  return createArrayExpression(dirArgs, dir.loc)\n}\n\nfunction stringifyDynamicPropNames(props: string[]): string {\n  let propsNamesString = `[`\n  for (let i = 0, l = props.length; i < l; i++) {\n    propsNamesString += JSON.stringify(props[i])\n    if (i < l - 1) propsNamesString += ', '\n  }\n  return propsNamesString + `]`\n}\n\nfunction isComponentTag(tag: string) {\n  return tag === 'component' || tag === 'Component'\n}\n", "import { NodeTransform, TransformContext } from '../transform'\nimport {\n  NodeTypes,\n  CallExpression,\n  createCallExpression,\n  ExpressionNode,\n  SlotOutletNode,\n  createFunctionExpression\n} from '../ast'\nimport { isSlotOutlet, isStaticArgOf, isStaticExp } from '../utils'\nimport { buildProps, PropsExpression } from './transformElement'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { RENDER_SLOT } from '../runtimeHelpers'\nimport { camelize } from '@vue/shared/'\n\nexport const transformSlotOutlet: NodeTransform = (node, context) => {\n  if (isSlotOutlet(node)) {\n    const { children, loc } = node\n    const { slotName, slotProps } = processSlotOutlet(node, context)\n\n    const slotArgs: CallExpression['arguments'] = [\n      context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,\n      slotName,\n      '{}',\n      'undefined',\n      'true'\n    ]\n    let expectedLen = 2\n\n    if (slotProps) {\n      slotArgs[2] = slotProps\n      expectedLen = 3\n    }\n\n    if (children.length) {\n      slotArgs[3] = createFunctionExpression([], children, false, false, loc)\n      expectedLen = 4\n    }\n\n    if (context.scopeId && !context.slotted) {\n      expectedLen = 5\n    }\n    slotArgs.splice(expectedLen) // remove unused arguments\n\n    node.codegenNode = createCallExpression(\n      context.helper(RENDER_SLOT),\n      slotArgs,\n      loc\n    )\n  }\n}\n\ninterface SlotOutletProcessResult {\n  slotName: string | ExpressionNode\n  slotProps: PropsExpression | undefined\n}\n\nexport function processSlotOutlet(\n  node: SlotOutletNode,\n  context: TransformContext\n): SlotOutletProcessResult {\n  let slotName: string | ExpressionNode = `\"default\"`\n  let slotProps: PropsExpression | undefined = undefined\n\n  const nonNameProps = []\n  for (let i = 0; i < node.props.length; i++) {\n    const p = node.props[i]\n    if (p.type === NodeTypes.ATTRIBUTE) {\n      if (p.value) {\n        if (p.name === 'name') {\n          slotName = JSON.stringify(p.value.content)\n        } else {\n          p.name = camelize(p.name)\n          nonNameProps.push(p)\n        }\n      }\n    } else {\n      if (p.name === 'bind' && isStaticArgOf(p.arg, 'name')) {\n        if (p.exp) slotName = p.exp\n      } else {\n        if (p.name === 'bind' && p.arg && isStaticExp(p.arg)) {\n          p.arg.content = camelize(p.arg.content)\n        }\n        nonNameProps.push(p)\n      }\n    }\n  }\n\n  if (nonNameProps.length > 0) {\n    const { props, directives } = buildProps(node, context, nonNameProps)\n    slotProps = props\n\n    if (directives.length) {\n      context.onError(\n        createCompilerError(\n          ErrorCodes.X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET,\n          directives[0].loc\n        )\n      )\n    }\n  }\n\n  return {\n    slotName,\n    slotProps\n  }\n}\n", "import { DirectiveTransform, DirectiveTransformResult } from '../transform'\nimport {\n  createCompoundExpression,\n  createObjectProperty,\n  createSimpleExpression,\n  DirectiveNode,\n  ElementTypes,\n  ExpressionNode,\n  NodeTypes,\n  SimpleExpressionNode\n} from '../ast'\nimport { camelize, toHandlerKey } from '@vue/shared'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { processExpression } from './transformExpression'\nimport { validateBrowserExpression } from '../validateExpression'\nimport { hasScopeRef, isMemberExpression } from '../utils'\nimport { TO_HANDLER_KEY } from '../runtimeHelpers'\n\nconst fnExpRE =\n  /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/\n\nexport interface VOnDirectiveNode extends DirectiveNode {\n  // v-on without arg is handled directly in ./transformElements.ts due to it affecting\n  // codegen for the entire props object. This transform here is only for v-on\n  // *with* args.\n  arg: ExpressionNode\n  // exp is guaranteed to be a simple expression here because v-on w/ arg is\n  // skipped by transformExpression as a special case.\n  exp: SimpleExpressionNode | undefined\n}\n\nexport const transformOn: DirectiveTransform = (\n  dir,\n  node,\n  context,\n  augmentor\n) => {\n  const { loc, modifiers, arg } = dir as VOnDirectiveNode\n  if (!dir.exp && !modifiers.length) {\n    context.onError(createCompilerError(ErrorCodes.X_V_ON_NO_EXPRESSION, loc))\n  }\n  let eventName: ExpressionNode\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n    if (arg.isStatic) {\n      let rawName = arg.content\n      // TODO deprecate @vnodeXXX usage\n      if (rawName.startsWith('vue:')) {\n        rawName = `vnode-${rawName.slice(4)}`\n      }\n      // for all event listeners, auto convert it to camelCase. See issue #2249\n      eventName = createSimpleExpression(\n        toHandlerKey(camelize(rawName)),\n        true,\n        arg.loc\n      )\n    } else {\n      // #2388\n      eventName = createCompoundExpression([\n        `${context.helperString(TO_HANDLER_KEY)}(`,\n        arg,\n        `)`\n      ])\n    }\n  } else {\n    // already a compound expression.\n    eventName = arg\n    eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`)\n    eventName.children.push(`)`)\n  }\n\n  // handler processing\n  let exp: ExpressionNode | undefined = dir.exp as\n    | SimpleExpressionNode\n    | undefined\n  if (exp && !exp.content.trim()) {\n    exp = undefined\n  }\n  let shouldCache: boolean = context.cacheHandlers && !exp && !context.inVOnce\n  if (exp) {\n    const isMemberExp = isMemberExpression(exp.content, context)\n    const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content))\n    const hasMultipleStatements = exp.content.includes(`;`)\n\n    // process the expression since it's been skipped\n    if (!__BROWSER__ && context.prefixIdentifiers) {\n      isInlineStatement && context.addIdentifiers(`$event`)\n      exp = dir.exp = processExpression(\n        exp,\n        context,\n        false,\n        hasMultipleStatements\n      )\n      isInlineStatement && context.removeIdentifiers(`$event`)\n      // with scope analysis, the function is hoistable if it has no reference\n      // to scope variables.\n      shouldCache =\n        context.cacheHandlers &&\n        // unnecessary to cache inside v-once\n        !context.inVOnce &&\n        // runtime constants don't need to be cached\n        // (this is analyzed by compileScript in SFC <script setup>)\n        !(exp.type === NodeTypes.SIMPLE_EXPRESSION && exp.constType > 0) &&\n        // #1541 bail if this is a member exp handler passed to a component -\n        // we need to use the original function to preserve arity,\n        // e.g. <transition> relies on checking cb.length to determine\n        // transition end handling. Inline function is ok since its arity\n        // is preserved even when cached.\n        !(isMemberExp && node.tagType === ElementTypes.COMPONENT) &&\n        // bail if the function references closure variables (v-for, v-slot)\n        // it must be passed fresh to avoid stale values.\n        !hasScopeRef(exp, context.identifiers)\n      // If the expression is optimizable and is a member expression pointing\n      // to a function, turn it into invocation (and wrap in an arrow function\n      // below) so that it always accesses the latest value when called - thus\n      // avoiding the need to be patched.\n      if (shouldCache && isMemberExp) {\n        if (exp.type === NodeTypes.SIMPLE_EXPRESSION) {\n          exp.content = `${exp.content} && ${exp.content}(...args)`\n        } else {\n          exp.children = [...exp.children, ` && `, ...exp.children, `(...args)`]\n        }\n      }\n    }\n\n    if (__DEV__ && __BROWSER__) {\n      validateBrowserExpression(\n        exp as SimpleExpressionNode,\n        context,\n        false,\n        hasMultipleStatements\n      )\n    }\n\n    if (isInlineStatement || (shouldCache && isMemberExp)) {\n      // wrap inline statement in a function expression\n      exp = createCompoundExpression([\n        `${\n          isInlineStatement\n            ? !__BROWSER__ && context.isTS\n              ? `($event: any)`\n              : `$event`\n            : `${\n                !__BROWSER__ && context.isTS ? `\\n//@ts-ignore\\n` : ``\n              }(...args)`\n        } => ${hasMultipleStatements ? `{` : `(`}`,\n        exp,\n        hasMultipleStatements ? `}` : `)`\n      ])\n    }\n  }\n\n  let ret: DirectiveTransformResult = {\n    props: [\n      createObjectProperty(\n        eventName,\n        exp || createSimpleExpression(`() => {}`, false, loc)\n      )\n    ]\n  }\n\n  // apply extended compiler augmentor\n  if (augmentor) {\n    ret = augmentor(ret)\n  }\n\n  if (shouldCache) {\n    // cache handlers so that it's always the same handler being passed down.\n    // this avoids unnecessary re-renders when users use inline handlers on\n    // components.\n    ret.props[0].value = context.cache(ret.props[0].value)\n  }\n\n  // mark the key as handler for props normalization check\n  ret.props.forEach(p => (p.key.isHandlerKey = true))\n  return ret\n}\n", "import { DirectiveTransform } from '../transform'\nimport {\n  createObjectProperty,\n  createSimpleExpression,\n  ExpressionNode,\n  NodeTypes\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport { camelize } from '@vue/shared'\nimport { CAMELIZE } from '../runtimeHelpers'\n\n// v-bind without arg is handled directly in ./transformElements.ts due to it affecting\n// codegen for the entire props object. This transform here is only for v-bind\n// *with* args.\nexport const transformBind: DirectiveTransform = (dir, _node, context) => {\n  const { exp, modifiers, loc } = dir\n  const arg = dir.arg!\n\n  if (arg.type !== NodeTypes.SIMPLE_EXPRESSION) {\n    arg.children.unshift(`(`)\n    arg.children.push(`) || \"\"`)\n  } else if (!arg.isStatic) {\n    arg.content = `${arg.content} || \"\"`\n  }\n\n  // .sync is replaced by v-model:arg\n  if (modifiers.includes('camel')) {\n    if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n      if (arg.isStatic) {\n        arg.content = camelize(arg.content)\n      } else {\n        arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`\n      }\n    } else {\n      arg.children.unshift(`${context.helperString(CAMELIZE)}(`)\n      arg.children.push(`)`)\n    }\n  }\n\n  if (!context.inSSR) {\n    if (modifiers.includes('prop')) {\n      injectPrefix(arg, '.')\n    }\n    if (modifiers.includes('attr')) {\n      injectPrefix(arg, '^')\n    }\n  }\n\n  if (\n    !exp ||\n    (exp.type === NodeTypes.SIMPLE_EXPRESSION && !exp.content.trim())\n  ) {\n    context.onError(createCompilerError(ErrorCodes.X_V_BIND_NO_EXPRESSION, loc))\n    return {\n      props: [createObjectProperty(arg, createSimpleExpression('', true, loc))]\n    }\n  }\n\n  return {\n    props: [createObjectProperty(arg, exp)]\n  }\n}\n\nconst injectPrefix = (arg: ExpressionNode, prefix: string) => {\n  if (arg.type === NodeTypes.SIMPLE_EXPRESSION) {\n    if (arg.isStatic) {\n      arg.content = prefix + arg.content\n    } else {\n      arg.content = `\\`${prefix}\\${${arg.content}}\\``\n    }\n  } else {\n    arg.children.unshift(`'${prefix}' + (`)\n    arg.children.push(`)`)\n  }\n}\n", "import { NodeTransform } from '../transform'\nimport {\n  NodeTypes,\n  CompoundExpressionNode,\n  createCallExpression,\n  CallExpression,\n  ElementTypes,\n  ConstantTypes\n} from '../ast'\nimport { isText } from '../utils'\nimport { CREATE_TEXT } from '../runtimeHelpers'\nimport { PatchFlags, PatchFlagNames } from '@vue/shared'\nimport { getConstantType } from './hoistStatic'\n\n// Merge adjacent text nodes and expressions into a single expression\n// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.\nexport const transformText: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ROOT ||\n    node.type === NodeTypes.ELEMENT ||\n    node.type === NodeTypes.FOR ||\n    node.type === NodeTypes.IF_BRANCH\n  ) {\n    // perform the transform on node exit so that all expressions have already\n    // been processed.\n    return () => {\n      const children = node.children\n      let currentContainer: CompoundExpressionNode | undefined = undefined\n      let hasText = false\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n        if (isText(child)) {\n          hasText = true\n          for (let j = i + 1; j < children.length; j++) {\n            const next = children[j]\n            if (isText(next)) {\n              if (!currentContainer) {\n                currentContainer = children[i] = {\n                  type: NodeTypes.COMPOUND_EXPRESSION,\n                  loc: child.loc,\n                  children: [child]\n                }\n              }\n              // merge adjacent text node into current\n              currentContainer.children.push(` + `, next)\n              children.splice(j, 1)\n              j--\n            } else {\n              currentContainer = undefined\n              break\n            }\n          }\n        }\n      }\n\n      if (\n        !hasText ||\n        // if this is a plain element with a single text child, leave it\n        // as-is since the runtime has dedicated fast path for this by directly\n        // setting textContent of the element.\n        // for component root it's always normalized anyway.\n        (children.length === 1 &&\n          (node.type === NodeTypes.ROOT ||\n            (node.type === NodeTypes.ELEMENT &&\n              node.tagType === ElementTypes.ELEMENT &&\n              // #3756\n              // custom directives can potentially add DOM elements arbitrarily,\n              // we need to avoid setting textContent of the element at runtime\n              // to avoid accidentally overwriting the DOM elements added\n              // by the user through custom directives.\n              !node.props.find(\n                p =>\n                  p.type === NodeTypes.DIRECTIVE &&\n                  !context.directiveTransforms[p.name]\n              ) &&\n              // in compat mode, <template> tags with no special directives\n              // will be rendered as a fragment so its children must be\n              // converted into vnodes.\n              !(__COMPAT__ && node.tag === 'template'))))\n      ) {\n        return\n      }\n\n      // pre-convert text nodes into createTextVNode(text) calls to avoid\n      // runtime normalization.\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i]\n        if (isText(child) || child.type === NodeTypes.COMPOUND_EXPRESSION) {\n          const callArgs: CallExpression['arguments'] = []\n          // createTextVNode defaults to single whitespace, so if it is a\n          // single space the code could be an empty call to save bytes.\n          if (child.type !== NodeTypes.TEXT || child.content !== ' ') {\n            callArgs.push(child)\n          }\n          // mark dynamic text with flag so it gets patched inside a block\n          if (\n            !context.ssr &&\n            getConstantType(child, context) === ConstantTypes.NOT_CONSTANT\n          ) {\n            callArgs.push(\n              PatchFlags.TEXT +\n                (__DEV__ ? ` /* ${PatchFlagNames[PatchFlags.TEXT]} */` : ``)\n            )\n          }\n          children[i] = {\n            type: NodeTypes.TEXT_CALL,\n            content: child,\n            loc: child.loc,\n            codegenNode: createCallExpression(\n              context.helper(CREATE_TEXT),\n              callArgs\n            )\n          }\n        }\n      }\n    }\n  }\n}\n", "import { NodeTransform } from '../transform'\nimport { findDir } from '../utils'\nimport { ElementNode, ForNode, IfNode, NodeTypes } from '../ast'\nimport { SET_BLOCK_TRACKING } from '../runtimeHelpers'\n\nconst seen = new WeakSet()\n\nexport const transformOnce: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.ELEMENT && findDir(node, 'once', true)) {\n    if (seen.has(node) || context.inVOnce) {\n      return\n    }\n    seen.add(node)\n    context.inVOnce = true\n    context.helper(SET_BLOCK_TRACKING)\n    return () => {\n      context.inVOnce = false\n      const cur = context.currentNode as ElementNode | IfNode | ForNode\n      if (cur.codegenNode) {\n        cur.codegenNode = context.cache(cur.codegenNode, true /* isVNode */)\n      }\n    }\n  }\n}\n", "import { DirectiveTransform } from '../transform'\nimport {\n  createSimpleExpression,\n  createObjectProperty,\n  createCompoundExpression,\n  NodeTypes,\n  Property,\n  ElementTypes,\n  ExpressionNode,\n  ConstantTypes\n} from '../ast'\nimport { createCompilerError, ErrorCodes } from '../errors'\nimport {\n  isMemberExpression,\n  isSimpleIdentifier,\n  hasScopeRef,\n  isStaticExp\n} from '../utils'\nimport { IS_REF } from '../runtimeHelpers'\nimport { BindingTypes } from '../options'\n\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\n  const { exp, arg } = dir\n  if (!exp) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_NO_EXPRESSION, dir.loc)\n    )\n    return createTransformProps()\n  }\n\n  const rawExp = exp.loc.source\n  const expString =\n    exp.type === NodeTypes.SIMPLE_EXPRESSION ? exp.content : rawExp\n\n  // im SFC <script setup> inline mode, the exp may have been transformed into\n  // _unref(exp)\n  const bindingType = context.bindingMetadata[rawExp]\n  const maybeRef =\n    !__BROWSER__ &&\n    context.inline &&\n    bindingType &&\n    bindingType !== BindingTypes.SETUP_CONST\n\n  if (\n    !expString.trim() ||\n    (!isMemberExpression(expString, context) && !maybeRef)\n  ) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_MALFORMED_EXPRESSION, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    isSimpleIdentifier(expString) &&\n    context.identifiers[expString]\n  ) {\n    context.onError(\n      createCompilerError(ErrorCodes.X_V_MODEL_ON_SCOPE_VARIABLE, exp.loc)\n    )\n    return createTransformProps()\n  }\n\n  const propName = arg ? arg : createSimpleExpression('modelValue', true)\n  const eventName = arg\n    ? isStaticExp(arg)\n      ? `onUpdate:${arg.content}`\n      : createCompoundExpression(['\"onUpdate:\" + ', arg])\n    : `onUpdate:modelValue`\n\n  let assignmentExp: ExpressionNode\n  const eventArg = context.isTS ? `($event: any)` : `$event`\n  if (maybeRef) {\n    if (bindingType === BindingTypes.SETUP_REF) {\n      // v-model used on known ref.\n      assignmentExp = createCompoundExpression([\n        `${eventArg} => ((`,\n        createSimpleExpression(rawExp, false, exp.loc),\n        `).value = $event)`\n      ])\n    } else {\n      // v-model used on a potentially ref binding in <script setup> inline mode.\n      // the assignment needs to check whether the binding is actually a ref.\n      const altAssignment =\n        bindingType === BindingTypes.SETUP_LET ? `${rawExp} = $event` : `null`\n      assignmentExp = createCompoundExpression([\n        `${eventArg} => (${context.helperString(IS_REF)}(${rawExp}) ? (`,\n        createSimpleExpression(rawExp, false, exp.loc),\n        `).value = $event : ${altAssignment})`\n      ])\n    }\n  } else {\n    assignmentExp = createCompoundExpression([\n      `${eventArg} => ((`,\n      exp,\n      `) = $event)`\n    ])\n  }\n\n  const props = [\n    // modelValue: foo\n    createObjectProperty(propName, dir.exp!),\n    // \"onUpdate:modelValue\": $event => (foo = $event)\n    createObjectProperty(eventName, assignmentExp)\n  ]\n\n  // cache v-model handler if applicable (when it doesn't refer any scope vars)\n  if (\n    !__BROWSER__ &&\n    context.prefixIdentifiers &&\n    !context.inVOnce &&\n    context.cacheHandlers &&\n    !hasScopeRef(exp, context.identifiers)\n  ) {\n    props[1].value = context.cache(props[1].value)\n  }\n\n  // modelModifiers: { foo: true, \"bar-baz\": true }\n  if (dir.modifiers.length && node.tagType === ElementTypes.COMPONENT) {\n    const modifiers = dir.modifiers\n      .map(m => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`)\n      .join(`, `)\n    const modifiersKey = arg\n      ? isStaticExp(arg)\n        ? `${arg.content}Modifiers`\n        : createCompoundExpression([arg, ' + \"Modifiers\"'])\n      : `modelModifiers`\n    props.push(\n      createObjectProperty(\n        modifiersKey,\n        createSimpleExpression(\n          `{ ${modifiers} }`,\n          false,\n          dir.loc,\n          ConstantTypes.CAN_HOIST\n        )\n      )\n    )\n  }\n\n  return createTransformProps(props)\n}\n\nfunction createTransformProps(props: Property[] = []) {\n  return { props }\n}\n", "import { NodeTransform } from '../transform'\nimport { findDir, makeBlock } from '../utils'\nimport {\n  createCallExpression,\n  createFunctionExpression,\n  ElementTypes,\n  MemoExpression,\n  NodeTypes,\n  PlainElementNode\n} from '../ast'\nimport { WITH_MEMO } from '../runtimeHelpers'\n\nconst seen = new WeakSet()\n\nexport const transformMemo: NodeTransform = (node, context) => {\n  if (node.type === NodeTypes.ELEMENT) {\n    const dir = findDir(node, 'memo')\n    if (!dir || seen.has(node)) {\n      return\n    }\n    seen.add(node)\n    return () => {\n      const codegenNode =\n        node.codegenNode ||\n        (context.currentNode as PlainElementNode).codegenNode\n      if (codegenNode && codegenNode.type === NodeTypes.VNODE_CALL) {\n        // non-component sub tree should be turned into a block\n        if (node.tagType !== ElementTypes.COMPONENT) {\n          makeBlock(codegenNode, context)\n        }\n        node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [\n          dir.exp!,\n          createFunctionExpression(undefined, codegenNode),\n          `_cache`,\n          String(context.cached++)\n        ]) as MemoExpression\n      }\n    }\n  }\n}\n", "import { CompilerOptions } from './options'\nimport { baseParse } from './parse'\nimport { transform, NodeTransform, DirectiveTransform } from './transform'\nimport { generate, CodegenResult } from './codegen'\nimport { RootNode } from './ast'\nimport { isString, extend } from '@vue/shared'\nimport { transformIf } from './transforms/vIf'\nimport { transformFor } from './transforms/vFor'\nimport { transformExpression } from './transforms/transformExpression'\nimport { transformSlotOutlet } from './transforms/transformSlotOutlet'\nimport { transformElement } from './transforms/transformElement'\nimport { transformOn } from './transforms/vOn'\nimport { transformBind } from './transforms/vBind'\nimport { trackSlotScopes, trackVForSlotScopes } from './transforms/vSlot'\nimport { transformText } from './transforms/transformText'\nimport { transformOnce } from './transforms/vOnce'\nimport { transformModel } from './transforms/vModel'\nimport { transformFilter } from './compat/transformFilter'\nimport { defaultOnError, createCompilerError, ErrorCodes } from './errors'\nimport { transformMemo } from './transforms/vMemo'\n\nexport type TransformPreset = [\n  NodeTransform[],\n  Record<string, DirectiveTransform>\n]\n\nexport function getBaseTransformPreset(\n  prefixIdentifiers?: boolean\n): TransformPreset {\n  return [\n    [\n      transformOnce,\n      transformIf,\n      transformMemo,\n      transformFor,\n      ...(__COMPAT__ ? [transformFilter] : []),\n      ...(!__BROWSER__ && prefixIdentifiers\n        ? [\n            // order is important\n            trackVForSlotScopes,\n            transformExpression\n          ]\n        : __BROWSER__ && __DEV__\n        ? [transformExpression]\n        : []),\n      transformSlotOutlet,\n      transformElement,\n      trackSlotScopes,\n      transformText\n    ],\n    {\n      on: transformOn,\n      bind: transformBind,\n      model: transformModel\n    }\n  ]\n}\n\n// we name it `baseCompile` so that higher order compilers like\n// @vue/compiler-dom can export `compile` while re-exporting everything else.\nexport function baseCompile(\n  template: string | RootNode,\n  options: CompilerOptions = {}\n): CodegenResult {\n  const onError = options.onError || defaultOnError\n  const isModuleMode = options.mode === 'module'\n  /* istanbul ignore if */\n  if (__BROWSER__) {\n    if (options.prefixIdentifiers === true) {\n      onError(createCompilerError(ErrorCodes.X_PREFIX_ID_NOT_SUPPORTED))\n    } else if (isModuleMode) {\n      onError(createCompilerError(ErrorCodes.X_MODULE_MODE_NOT_SUPPORTED))\n    }\n  }\n\n  const prefixIdentifiers =\n    !__BROWSER__ && (options.prefixIdentifiers === true || isModuleMode)\n  if (!prefixIdentifiers && options.cacheHandlers) {\n    onError(createCompilerError(ErrorCodes.X_CACHE_HANDLER_NOT_SUPPORTED))\n  }\n  if (options.scopeId && !isModuleMode) {\n    onError(createCompilerError(ErrorCodes.X_SCOPE_ID_NOT_SUPPORTED))\n  }\n\n  const ast = isString(template) ? baseParse(template, options) : template\n  const [nodeTransforms, directiveTransforms] =\n    getBaseTransformPreset(prefixIdentifiers)\n\n  if (!__BROWSER__ && options.isTS) {\n    const { expressionPlugins } = options\n    if (!expressionPlugins || !expressionPlugins.includes('typescript')) {\n      options.expressionPlugins = [...(expressionPlugins || []), 'typescript']\n    }\n  }\n\n  transform(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers,\n      nodeTransforms: [\n        ...nodeTransforms,\n        ...(options.nodeTransforms || []) // user transforms\n      ],\n      directiveTransforms: extend(\n        {},\n        directiveTransforms,\n        options.directiveTransforms || {} // user transforms\n      )\n    })\n  )\n\n  return generate(\n    ast,\n    extend({}, options, {\n      prefixIdentifiers\n    })\n  )\n}\n", "import { DirectiveTransform } from '../transform'\n\nexport const noopDirectiveTransform: DirectiveTransform = () => ({ props: [] })\n", "import { registerRuntimeHelpers } from '@vue/compiler-core'\n\nexport const V_MODEL_RADIO = Symbol(__DEV__ ? `vModelRadio` : ``)\nexport const V_MODEL_CHECKBOX = Symbol(__DEV__ ? `vModelCheckbox` : ``)\nexport const V_MODEL_TEXT = Symbol(__DEV__ ? `vModelText` : ``)\nexport const V_MODEL_SELECT = Symbol(__DEV__ ? `vModelSelect` : ``)\nexport const V_MODEL_DYNAMIC = Symbol(__DEV__ ? `vModelDynamic` : ``)\n\nexport const V_ON_WITH_MODIFIERS = Symbol(__DEV__ ? `vOnModifiersGuard` : ``)\nexport const V_ON_WITH_KEYS = Symbol(__DEV__ ? `vOnKeysGuard` : ``)\n\nexport const V_SHOW = Symbol(__DEV__ ? `vShow` : ``)\n\nexport const TRANSITION = Symbol(__DEV__ ? `Transition` : ``)\nexport const TRANSITION_GROUP = Symbol(__DEV__ ? `TransitionGroup` : ``)\n\nregisterRuntimeHelpers({\n  [V_MODEL_RADIO]: `vModelRadio`,\n  [V_MODEL_CHECKBOX]: `vModelCheckbox`,\n  [V_MODEL_TEXT]: `vModelText`,\n  [V_MODEL_SELECT]: `vModelSelect`,\n  [V_MODEL_DYNAMIC]: `vModelDynamic`,\n  [V_ON_WITH_MODIFIERS]: `withModifiers`,\n  [V_ON_WITH_KEYS]: `withKeys`,\n  [V_SHOW]: `vShow`,\n  [TRANSITION]: `Transition`,\n  [TRANSITION_GROUP]: `TransitionGroup`\n})\n", "/* eslint-disable no-restricted-globals */\n\nlet decoder: HTMLDivElement\n\nexport function decodeHtmlBrowser(raw: string, asAttr = false): string {\n  if (!decoder) {\n    decoder = document.createElement('div')\n  }\n  if (asAttr) {\n    decoder.innerHTML = `<div foo=\"${raw.replace(/\"/g, '&quot;')}\">`\n    return decoder.children[0].getAttribute('foo') as string\n  } else {\n    decoder.innerHTML = raw\n    return decoder.textContent as string\n  }\n}\n", "import {\n  TextModes,\n  ParserOptions,\n  ElementNode,\n  Namespaces,\n  NodeTypes,\n  isBuiltInType\n} from '@vue/compiler-core'\nimport { makeMap, isVoidTag, isHTMLTag, isSVGTag } from '@vue/shared'\nimport { TRANSITION, TRANSITION_GROUP } from './runtimeHelpers'\nimport { decodeHtml } from './decodeHtml'\nimport { decodeHtmlBrowser } from './decodeHtmlBrowser'\n\nconst isRawTextContainer = /*#__PURE__*/ makeMap(\n  'style,iframe,script,noscript',\n  true\n)\n\nexport const enum DOMNamespaces {\n  HTML = Namespaces.HTML,\n  SVG,\n  MATH_ML\n}\n\nexport const parserOptions: ParserOptions = {\n  isVoidTag,\n  isNativeTag: tag => isHTMLTag(tag) || isSVGTag(tag),\n  isPreTag: tag => tag === 'pre',\n  decodeEntities: __BROWSER__ ? decodeHtmlBrowser : decodeHtml,\n\n  isBuiltInComponent: (tag: string): symbol | undefined => {\n    if (isBuiltInType(tag, `Transition`)) {\n      return TRANSITION\n    } else if (isBuiltInType(tag, `TransitionGroup`)) {\n      return TRANSITION_GROUP\n    }\n  },\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(tag: string, parent: ElementNode | undefined): DOMNamespaces {\n    let ns = parent ? parent.ns : DOMNamespaces.HTML\n\n    if (parent && ns === DOMNamespaces.MATH_ML) {\n      if (parent.tag === 'annotation-xml') {\n        if (tag === 'svg') {\n          return DOMNamespaces.SVG\n        }\n        if (\n          parent.props.some(\n            a =>\n              a.type === NodeTypes.ATTRIBUTE &&\n              a.name === 'encoding' &&\n              a.value != null &&\n              (a.value.content === 'text/html' ||\n                a.value.content === 'application/xhtml+xml')\n          )\n        ) {\n          ns = DOMNamespaces.HTML\n        }\n      } else if (\n        /^m(?:[ions]|text)$/.test(parent.tag) &&\n        tag !== 'mglyph' &&\n        tag !== 'malignmark'\n      ) {\n        ns = DOMNamespaces.HTML\n      }\n    } else if (parent && ns === DOMNamespaces.SVG) {\n      if (\n        parent.tag === 'foreignObject' ||\n        parent.tag === 'desc' ||\n        parent.tag === 'title'\n      ) {\n        ns = DOMNamespaces.HTML\n      }\n    }\n\n    if (ns === DOMNamespaces.HTML) {\n      if (tag === 'svg') {\n        return DOMNamespaces.SVG\n      }\n      if (tag === 'math') {\n        return DOMNamespaces.MATH_ML\n      }\n    }\n    return ns\n  },\n\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n  getTextMode({ tag, ns }: ElementNode): TextModes {\n    if (ns === DOMNamespaces.HTML) {\n      if (tag === 'textarea' || tag === 'title') {\n        return TextModes.RCDATA\n      }\n      if (isRawTextContainer(tag)) {\n        return TextModes.RAWTEXT\n      }\n    }\n    return TextModes.DATA\n  }\n}\n", "import {\n  NodeTransform,\n  NodeTypes,\n  createSimpleExpression,\n  SimpleExpressionNode,\n  SourceLocation,\n  ConstantTypes\n} from '@vue/compiler-core'\nimport { parseStringStyle } from '@vue/shared'\n\n// Parse inline CSS strings for static style attributes into an object.\n// This is a NodeTransform since it works on the static `style` attribute and\n// converts it into a dynamic equivalent:\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\n// It is then processed by `transformElement` and included in the generated\n// props.\nexport const transformStyle: NodeTransform = node => {\n  if (node.type === NodeTypes.ELEMENT) {\n    node.props.forEach((p, i) => {\n      if (p.type === NodeTypes.ATTRIBUTE && p.name === 'style' && p.value) {\n        // replace p with an expression node\n        node.props[i] = {\n          type: NodeTypes.DIRECTIVE,\n          name: `bind`,\n          arg: createSimpleExpression(`style`, true, p.loc),\n          exp: parseInlineCSS(p.value.content, p.loc),\n          modifiers: [],\n          loc: p.loc\n        }\n      }\n    })\n  }\n}\n\nconst parseInlineCSS = (\n  cssText: string,\n  loc: SourceLocation\n): SimpleExpressionNode => {\n  const normalized = parseStringStyle(cssText)\n  return createSimpleExpression(\n    JSON.stringify(normalized),\n    false,\n    loc,\n    ConstantTypes.CAN_STRINGIFY\n  )\n}\n", "import {\n  SourceLocation,\n  CompilerError,\n  createCompilerError,\n  ErrorCodes\n} from '@vue/compiler-core'\n\nexport interface DOMCompilerError extends CompilerError {\n  code: DOMErrorCodes\n}\n\nexport function createDOMCompilerError(\n  code: DOMErrorCodes,\n  loc?: SourceLocation\n) {\n  return createCompilerError(\n    code,\n    loc,\n    __DEV__ || !__BROWSER__ ? DOMErrorMessages : undefined\n  ) as DOMCompilerError\n}\n\nexport const enum DOMErrorCodes {\n  X_V_HTML_NO_EXPRESSION = ErrorCodes.__EXTEND_POINT__,\n  X_V_HTML_WITH_CHILDREN,\n  X_V_TEXT_NO_EXPRESSION,\n  X_V_TEXT_WITH_CHILDREN,\n  X_V_MODEL_ON_INVALID_ELEMENT,\n  X_V_MODEL_ARG_ON_ELEMENT,\n  X_V_MODEL_ON_FILE_INPUT_ELEMENT,\n  X_V_MODEL_UNNECESSARY_VALUE,\n  X_V_SHOW_NO_EXPRESSION,\n  X_TRANSITION_INVALID_CHILDREN,\n  X_IGNORED_SIDE_EFFECT_TAG,\n  __EXTEND_POINT__\n}\n\nexport const DOMErrorMessages: { [code: number]: string } = {\n  [DOMErrorCodes.X_V_HTML_NO_EXPRESSION]: `v-html is missing expression.`,\n  [DOMErrorCodes.X_V_HTML_WITH_CHILDREN]: `v-html will override element children.`,\n  [DOMErrorCodes.X_V_TEXT_NO_EXPRESSION]: `v-text is missing expression.`,\n  [DOMErrorCodes.X_V_TEXT_WITH_CHILDREN]: `v-text will override element children.`,\n  [DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT]: `v-model can only be used on <input>, <textarea> and <select> elements.`,\n  [DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT]: `v-model argument is not supported on plain elements.`,\n  [DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,\n  [DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,\n  [DOMErrorCodes.X_V_SHOW_NO_EXPRESSION]: `v-show is missing expression.`,\n  [DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN]: `<Transition> expects exactly one child element or component.`,\n  [DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`\n}\n", "import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const transformVHtml: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_NO_EXPRESSION, loc)\n    )\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_HTML_WITH_CHILDREN, loc)\n    )\n    node.children.length = 0\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`innerHTML`, true, loc),\n        exp || createSimpleExpression('', true)\n      )\n    ]\n  }\n}\n", "import {\n  DirectiveTransform,\n  createObjectProperty,\n  createSimpleExpression,\n  TO_DISPLAY_STRING,\n  createCallExpression\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const transformVText: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_NO_EXPRESSION, loc)\n    )\n  }\n  if (node.children.length) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_TEXT_WITH_CHILDREN, loc)\n    )\n    node.children.length = 0\n  }\n  return {\n    props: [\n      createObjectProperty(\n        createSimpleExpression(`textContent`, true),\n        exp\n          ? createCallExpression(\n              context.helperString(TO_DISPLAY_STRING),\n              [exp],\n              loc\n            )\n          : createSimpleExpression('', true)\n      )\n    ]\n  }\n}\n", "import {\n  transformModel as baseTransform,\n  DirectiveTransform,\n  ElementTypes,\n  findProp,\n  NodeTypes,\n  hasDynamicKeyVBind\n} from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\nimport {\n  V_MODEL_CHECKBOX,\n  V_MODEL_RADIO,\n  V_MODEL_SELECT,\n  V_MODEL_TEXT,\n  V_MODEL_DYNAMIC\n} from '../runtimeHelpers'\n\nexport const transformModel: DirectiveTransform = (dir, node, context) => {\n  const baseResult = baseTransform(dir, node, context)\n  // base transform has errors OR component v-model (only need props)\n  if (!baseResult.props.length || node.tagType === ElementTypes.COMPONENT) {\n    return baseResult\n  }\n\n  if (dir.arg) {\n    context.onError(\n      createDOMCompilerError(\n        DOMErrorCodes.X_V_MODEL_ARG_ON_ELEMENT,\n        dir.arg.loc\n      )\n    )\n  }\n\n  function checkDuplicatedValue() {\n    const value = findProp(node, 'value')\n    if (value) {\n      context.onError(\n        createDOMCompilerError(\n          DOMErrorCodes.X_V_MODEL_UNNECESSARY_VALUE,\n          value.loc\n        )\n      )\n    }\n  }\n\n  const { tag } = node\n  const isCustomElement = context.isCustomElement(tag)\n  if (\n    tag === 'input' ||\n    tag === 'textarea' ||\n    tag === 'select' ||\n    isCustomElement\n  ) {\n    let directiveToUse = V_MODEL_TEXT\n    let isInvalidType = false\n    if (tag === 'input' || isCustomElement) {\n      const type = findProp(node, `type`)\n      if (type) {\n        if (type.type === NodeTypes.DIRECTIVE) {\n          // :type=\"foo\"\n          directiveToUse = V_MODEL_DYNAMIC\n        } else if (type.value) {\n          switch (type.value.content) {\n            case 'radio':\n              directiveToUse = V_MODEL_RADIO\n              break\n            case 'checkbox':\n              directiveToUse = V_MODEL_CHECKBOX\n              break\n            case 'file':\n              isInvalidType = true\n              context.onError(\n                createDOMCompilerError(\n                  DOMErrorCodes.X_V_MODEL_ON_FILE_INPUT_ELEMENT,\n                  dir.loc\n                )\n              )\n              break\n            default:\n              // text type\n              __DEV__ && checkDuplicatedValue()\n              break\n          }\n        }\n      } else if (hasDynamicKeyVBind(node)) {\n        // element has bindings with dynamic keys, which can possibly contain\n        // \"type\".\n        directiveToUse = V_MODEL_DYNAMIC\n      } else {\n        // text type\n        __DEV__ && checkDuplicatedValue()\n      }\n    } else if (tag === 'select') {\n      directiveToUse = V_MODEL_SELECT\n    } else {\n      // textarea\n      __DEV__ && checkDuplicatedValue()\n    }\n    // inject runtime directive\n    // by returning the helper symbol via needRuntime\n    // the import will replaced a resolveDirective call.\n    if (!isInvalidType) {\n      baseResult.needRuntime = context.helper(directiveToUse)\n    }\n  } else {\n    context.onError(\n      createDOMCompilerError(\n        DOMErrorCodes.X_V_MODEL_ON_INVALID_ELEMENT,\n        dir.loc\n      )\n    )\n  }\n\n  // native vmodel doesn't need the `modelValue` props since they are also\n  // passed to the runtime as `binding.value`. removing it reduces code size.\n  baseResult.props = baseResult.props.filter(\n    p =>\n      !(\n        p.key.type === NodeTypes.SIMPLE_EXPRESSION &&\n        p.key.content === 'modelValue'\n      )\n  )\n\n  return baseResult\n}\n", "import {\n  transformOn as baseTransform,\n  DirectiveTransform,\n  createObjectProperty,\n  createCallExpression,\n  createSimpleExpression,\n  NodeTypes,\n  createCompoundExpression,\n  ExpressionNode,\n  SimpleExpressionNode,\n  isStaticExp,\n  CompilerDeprecationTypes,\n  TransformContext,\n  SourceLocation,\n  checkCompatEnabled\n} from '@vue/compiler-core'\nimport { V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS } from '../runtimeHelpers'\nimport { makeMap, capitalize } from '@vue/shared'\n\nconst isEventOptionModifier = /*#__PURE__*/ makeMap(`passive,once,capture`)\nconst isNonKeyModifier = /*#__PURE__*/ makeMap(\n  // event propagation management\n  `stop,prevent,self,` +\n    // system modifiers + exact\n    `ctrl,shift,alt,meta,exact,` +\n    // mouse\n    `middle`\n)\n// left & right could be mouse or key modifiers based on event type\nconst maybeKeyModifier = /*#__PURE__*/ makeMap('left,right')\nconst isKeyboardEvent = /*#__PURE__*/ makeMap(\n  `onkeyup,onkeydown,onkeypress`,\n  true\n)\n\nconst resolveModifiers = (\n  key: ExpressionNode,\n  modifiers: string[],\n  context: TransformContext,\n  loc: SourceLocation\n) => {\n  const keyModifiers = []\n  const nonKeyModifiers = []\n  const eventOptionModifiers = []\n\n  for (let i = 0; i < modifiers.length; i++) {\n    const modifier = modifiers[i]\n\n    if (\n      __COMPAT__ &&\n      modifier === 'native' &&\n      checkCompatEnabled(\n        CompilerDeprecationTypes.COMPILER_V_ON_NATIVE,\n        context,\n        loc\n      )\n    ) {\n      eventOptionModifiers.push(modifier)\n    } else if (isEventOptionModifier(modifier)) {\n      // eventOptionModifiers: modifiers for addEventListener() options,\n      // e.g. .passive & .capture\n      eventOptionModifiers.push(modifier)\n    } else {\n      // runtimeModifiers: modifiers that needs runtime guards\n      if (maybeKeyModifier(modifier)) {\n        if (isStaticExp(key)) {\n          if (isKeyboardEvent((key as SimpleExpressionNode).content)) {\n            keyModifiers.push(modifier)\n          } else {\n            nonKeyModifiers.push(modifier)\n          }\n        } else {\n          keyModifiers.push(modifier)\n          nonKeyModifiers.push(modifier)\n        }\n      } else {\n        if (isNonKeyModifier(modifier)) {\n          nonKeyModifiers.push(modifier)\n        } else {\n          keyModifiers.push(modifier)\n        }\n      }\n    }\n  }\n\n  return {\n    keyModifiers,\n    nonKeyModifiers,\n    eventOptionModifiers\n  }\n}\n\nconst transformClick = (key: ExpressionNode, event: string) => {\n  const isStaticClick =\n    isStaticExp(key) && key.content.toLowerCase() === 'onclick'\n  return isStaticClick\n    ? createSimpleExpression(event, true)\n    : key.type !== NodeTypes.SIMPLE_EXPRESSION\n    ? createCompoundExpression([\n        `(`,\n        key,\n        `) === \"onClick\" ? \"${event}\" : (`,\n        key,\n        `)`\n      ])\n    : key\n}\n\nexport const transformOn: DirectiveTransform = (dir, node, context) => {\n  return baseTransform(dir, node, context, baseResult => {\n    const { modifiers } = dir\n    if (!modifiers.length) return baseResult\n\n    let { key, value: handlerExp } = baseResult.props[0]\n    const { keyModifiers, nonKeyModifiers, eventOptionModifiers } =\n      resolveModifiers(key, modifiers, context, dir.loc)\n\n    // normalize click.right and click.middle since they don't actually fire\n    if (nonKeyModifiers.includes('right')) {\n      key = transformClick(key, `onContextmenu`)\n    }\n    if (nonKeyModifiers.includes('middle')) {\n      key = transformClick(key, `onMouseup`)\n    }\n\n    if (nonKeyModifiers.length) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [\n        handlerExp,\n        JSON.stringify(nonKeyModifiers)\n      ])\n    }\n\n    if (\n      keyModifiers.length &&\n      // if event name is dynamic, always wrap with keys guard\n      (!isStaticExp(key) || isKeyboardEvent(key.content))\n    ) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [\n        handlerExp,\n        JSON.stringify(keyModifiers)\n      ])\n    }\n\n    if (eventOptionModifiers.length) {\n      const modifierPostfix = eventOptionModifiers.map(capitalize).join('')\n      key = isStaticExp(key)\n        ? createSimpleExpression(`${key.content}${modifierPostfix}`, true)\n        : createCompoundExpression([`(`, key, `) + \"${modifierPostfix}\"`])\n    }\n\n    return {\n      props: [createObjectProperty(key, handlerExp)]\n    }\n  })\n}\n", "import { DirectiveTransform } from '@vue/compiler-core'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\nimport { V_SHOW } from '../runtimeHelpers'\n\nexport const transformShow: DirectiveTransform = (dir, node, context) => {\n  const { exp, loc } = dir\n  if (!exp) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_V_SHOW_NO_EXPRESSION, loc)\n    )\n  }\n\n  return {\n    props: [],\n    needRuntime: context.helper(V_SHOW)\n  }\n}\n", "import {\n  NodeTransform,\n  NodeTypes,\n  ElementTypes,\n  ComponentNode,\n  IfBranchNode\n} from '@vue/compiler-core'\nimport { TRANSITION } from '../runtimeHelpers'\nimport { createDOMCompilerError, DOMErrorCodes } from '../errors'\n\nexport const warnTransitionChildren: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    node.tagType === ElementTypes.COMPONENT\n  ) {\n    const component = context.isBuiltInComponent(node.tag)\n    if (component === TRANSITION) {\n      return () => {\n        if (node.children.length && hasMultipleChildren(node)) {\n          context.onError(\n            createDOMCompilerError(\n              DOMErrorCodes.X_TRANSITION_INVALID_CHILDREN,\n              {\n                start: node.children[0].loc.start,\n                end: node.children[node.children.length - 1].loc.end,\n                source: ''\n              }\n            )\n          )\n        }\n      }\n    }\n  }\n}\n\nfunction hasMultipleChildren(node: ComponentNode | IfBranchNode): boolean {\n  // #1352 filter out potential comment nodes.\n  const children = (node.children = node.children.filter(\n    c =>\n      c.type !== NodeTypes.COMMENT &&\n      !(c.type === NodeTypes.TEXT && !c.content.trim())\n  ))\n  const child = children[0]\n  return (\n    children.length !== 1 ||\n    child.type === NodeTypes.FOR ||\n    (child.type === NodeTypes.IF && child.branches.some(hasMultipleChildren))\n  )\n}\n", "import { NodeTransform, NodeTypes, ElementTypes } from '@vue/compiler-core'\nimport { DOMErrorCodes, createDOMCompilerError } from '../errors'\n\nexport const ignoreSideEffectTags: NodeTransform = (node, context) => {\n  if (\n    node.type === NodeTypes.ELEMENT &&\n    node.tagType === ElementTypes.ELEMENT &&\n    (node.tag === 'script' || node.tag === 'style')\n  ) {\n    context.onError(\n      createDOMCompilerError(DOMErrorCodes.X_IGNORED_SIDE_EFFECT_TAG, node.loc)\n    )\n    context.removeNode()\n  }\n}\n", "import {\n  baseCompile,\n  baseParse,\n  CompilerOptions,\n  CodegenResult,\n  ParserOptions,\n  RootNode,\n  noopDirectiveTransform,\n  NodeTransform,\n  DirectiveTransform\n} from '@vue/compiler-core'\nimport { parserOptions } from './parserOptions'\nimport { transformStyle } from './transforms/transformStyle'\nimport { transformVHtml } from './transforms/vHtml'\nimport { transformVText } from './transforms/vText'\nimport { transformModel } from './transforms/vModel'\nimport { transformOn } from './transforms/vOn'\nimport { transformShow } from './transforms/vShow'\nimport { warnTransitionChildren } from './transforms/warnTransitionChildren'\nimport { stringifyStatic } from './transforms/stringifyStatic'\nimport { ignoreSideEffectTags } from './transforms/ignoreSideEffectTags'\nimport { extend } from '@vue/shared'\n\nexport { parserOptions }\n\nexport const DOMNodeTransforms: NodeTransform[] = [\n  transformStyle,\n  ...(__DEV__ ? [warnTransitionChildren] : [])\n]\n\nexport const DOMDirectiveTransforms: Record<string, DirectiveTransform> = {\n  cloak: noopDirectiveTransform,\n  html: transformVHtml,\n  text: transformVText,\n  model: transformModel, // override compiler-core\n  on: transformOn, // override compiler-core\n  show: transformShow\n}\n\nexport function compile(\n  template: string,\n  options: CompilerOptions = {}\n): CodegenResult {\n  return baseCompile(\n    template,\n    extend({}, parserOptions, options, {\n      nodeTransforms: [\n        // ignore <script> and <tag>\n        // this is not put inside DOMNodeTransforms because that list is used\n        // by compiler-ssr to generate vnode fallback branches\n        ignoreSideEffectTags,\n        ...DOMNodeTransforms,\n        ...(options.nodeTransforms || [])\n      ],\n      directiveTransforms: extend(\n        {},\n        DOMDirectiveTransforms,\n        options.directiveTransforms || {}\n      ),\n      transformHoist: __BROWSER__ ? null : stringifyStatic\n    })\n  )\n}\n\nexport function parse(template: string, options: ParserOptions = {}): RootNode {\n  return baseParse(template, extend({}, parserOptions, options))\n}\n\nexport * from './runtimeHelpers'\nexport { transformStyle } from './transforms/transformStyle'\nexport { createDOMCompilerError, DOMErrorCodes } from './errors'\nexport * from '@vue/compiler-core'\n"],
  "mappings": "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,uBACE;QACF,sBACE;QACF,sBACE;QACF,oBAAoB;QACpB,sBAAsB;QACtB,oBAAoB;QACpB,wBACE;QACF,sBAAsB;QACtB,wBAAwB;QACxB,iBACE;QACF,gBAAgB;QAChB,sBAAsB;QACtB,kBAAkB;QAClB,4BAA4B;QAC5B,uBACE;QACF,+BACE;QACF,wBACE;QACF,YAAY;QACZ,UAAU;QACV,mCACE;QACF,sBAAsB;QACtB,8BACE;QACF,eAAe;QACf,uBACE;QACF,iCACE;QACF,iBAAiB;QACjB,4BAA4B;QAC5B,0BAA0B;QAC1B,sBAAsB;QACtB,kBAAkB;QAClB,gBAAgB;QAChB,cAAc;QACd,uBAAuB;QACvB,+BAA+B;QAC/B,4BAA4B;QAC5B,mBAAmB;QACnB,YAAY;QACZ,mBAAmB;QACnB,eAAe;QACf,0BACE;QACF,0BAA0B;QAC1B,gCAAgC;QAChC,+BAA+B;QAC/B,+BAA+B;QAC/B,uBACE;QACF,8BAA8B;QAC9B,oBAAoB;QACpB,qBACE;QACF,2BAA2B;QAC3B,sBAAsB;QACtB,kBAAkB;QAClB,uBACE;QACF,kBAAkB;QAClB,sBAAsB;QACtB,2BACE;QACF,kCACE;QACF,6BACE;QACF,mCACE;QACF,kCACE;QACF,uBAAuB;QACvB,0BAA0B;QAC1B,mBAAmB;QACnB,kBAAkB;QAClB,kBAAkB;QAClB,kCACE;QACF,mBACE;QACF,uBACE;QACF,4BACE;QACF,uBACE;QACF,WAAW;QACX,oBAAoB;QACpB,kBAAkB;QAElB,mBACE;QACF,4BACE;QACF,kBACE;QACF,4BACE;QACF,iBACE;QACF,yBACE;QAMF,qBACE;QACF,gCACE;QACF,gCACE;QACF,qBACE;QACF,wBACE;QACF,mCACE;QAEF,qBACE;QACF,0BAA0B;QAC1B,2CACE;QACF,6CACE;QACF,8CACE;QACF,eAAe;QACf,mBAAmB;QACnB,gBACE;QACF,iBAAiB;QACjB,cAAc;QACd,qBAAqB;QACrB,4BAA4B;QAC5B,gBACE;QACF,qBACE;QACF,oBAAoB;QACpB,YAAY;QACZ,iBACE;QACF,mBAAmB;Q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,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,KAAI,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,IAAG,KAAI,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,IAAG,KAAI,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,KAAI,IAAG,KAAI,GAAE,IAAG,KAAI,KAAI,KAAI,IAAG,KAAI,MAAK,IAAG,IAAG,MAAK,MAAK,KAAI,MAAK,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,IAAG,KAAI,IAAG,KAAI,IAAG,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,MAAK,GAAE,MAAK,IAAG,GAAE,MAAK,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,KAAI,IAAG,GAAE,IAAG,GAAE,GAAE,KAAI,MAAK,KAAI,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,MAAK,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,KAAI,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,MAAK,IAAG,KAAI,IAAG,IAAG,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,IAAG,MAAK,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,KAAI,IAAG,IAAG,GAAE,GAAE,MAAK,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,MAAK,OAAM,IAAG,MAAK,GAAE,KAAI,GAAE,MAAK,IAAG,MAAK,MAAK,KAAI,MAAK;AAEl6C,UAAM,wBAAwB,CAAC,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,KAAI,GAAE,MAAK,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,GAAE,GAAE,GAAE,KAAI,GAAE,KAAI,IAAG,IAAG,GAAE,KAAI,GAAE,IAAG,IAAG,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,GAAE,GAAE,GAAE,GAAE,GAAE,KAAI,IAAG,IAAG,GAAE,GAAE,GAAE,IAAG,IAAG,IAAG,GAAE,KAAI,GAAE,GAAE,GAAE,IAAG,GAAE,IAAG,IAAG,IAAG,GAAE,IAAG,IAAG,GAAE,GAAE,IAAG,IAAG,GAAE,GAAE,KAAI,IAAG,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AQ,iBAAK,MAAM,KAAK;;QAG3C,iBACE,MACA,MAAe,KAAK,MAAM,YAC1B,SAAoB,KAAK,MAAM,eACzB;AACN,eAAK,MAAM;AACX,eAAK,IAAI,MAAM;AACf,cAAI,KAAK,QAAQ;AAAQ,iBAAK,MAAM,KAAK;;QAM3C,2BAA2B,MAAgB,cAA8B;AACvE,eAAK,mBAAmB,MAAM,aAAa,OAAO,aAAa,IAAI;;;AC1HvE,UAAM,gBAAgB,oBAAI,IAAI,CAC5B,KACA,OACA,QACA,WACA,SACA,WACA,SACA,aACA,SACA,QACA,UACA,UACA,UACA,QACA,UACA;AAKF,UAAM,aAAa,mBACjB;QACE,2BACE;QACF,4BACE;QACF,oBAAoB;QACpB,qBACE;QACF,8BACE;QACF,+BACE;QACF,iCACE;QACF,yBACE;QACF,8BACE;QACF,yBACE;QACF,wCACE;QACF,yCACE;QACF,wCACE;QACF,yCACE;QACF,uBACE;QACF,gCACE;QACF,2CACE;QACF,2BAA2B;QAC3B,qCACE;QACF,oBACE;QACF,wBACE;QACF,iBAAiB;QACjB,qCACE;QACF,yBACE;QACF,qBACE;QACF,mBACE;QACF,mBACE;QACF,2BAA2B;QAC3B,gBAAgB;QAChB,6BACE;QACF,8BACE;QACF,2BAA2B;QAC3B,sBACE;QACF,oBAAoB;QACpB,uBACE;QACF,mBACE;QACF,mCACE;QACF,wBAAwB;QACxB,8BACE;QACF,oCACE;QACF,sBACE;QACF,8BACE;QACF,mCACE;QACF,iDACE;QACF,8BACE;QACF,qCACE;QACF,yBAAyB;SAEhB,YAAW,aACH;AAIrB,8BAAwB,aAA8B;AACpD,eACE,YAAY,SAAS,iCACpB,YAAY,SAAS,8BACnB,EAAC,YAAY,eACX,YAAY,YAAY,SAAS,eAChC,YAAY,YAAY,SAAS;;AAI3C,iCAA2B,MAAuB;AAChD,eAAO,KAAK,eAAe,UAAU,KAAK,eAAe;;AAG3D,oCAA8B,MAA0B;AACtD,eAAO,2BAA2B,SAAS,SAAI;;AAGjD,UAAM,oBAAoB;QACxB,OAAO;QACP,KAAK;QACL,MAAM;QACN,WAAW;;AAIb,yBACE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",
  "names": []
}
